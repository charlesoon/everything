# Everything 최적화 방안 총정리

현재 코드베이스(`main.rs`, `fd_search.rs`, `query.rs`, `App.svelte`) 분석을 바탕으로 인덱싱 속도, 검색 응답, DB 처리량, 프론트엔드 렌더링 전반의 최적화 기회를 정리한다.

---

## 1. 인덱싱 속도

### 1-1. 병렬 디렉터리 순회 (jwalk 활용)

| 항목 | 내용 |
|------|------|
| 현재 | `WalkDir::new(root)` 단일 스레드 순회 (`main.rs:1541`) |
| 문제 | $HOME 아래 수십만 파일을 한 스레드로 처리 |
| 방안 | `fd_search.rs`에서 이미 사용 중인 `jwalk::WalkDir`를 인덱싱에도 적용. `num_threads(4)` + `rayon` 채널로 행을 수집하고, 메인 스레드에서 배치 upsert |
| 기대 효과 | 3-5x (멀티코어 활용) |
| 복잡도 | 중 |

### 1-2. BATCH_SIZE 증가

| 항목 | 내용 |
|------|------|
| 현재 | `BATCH_SIZE = 4_000` (`main.rs:36`) |
| 문제 | 트랜잭션 커밋 횟수가 많아 I/O 오버헤드 발생 |
| 방안 | 8,000-16,000으로 증가. 메모리 부담 미미 (IndexRow ~300B × 16K ≈ 5MB) |
| 기대 효과 | 10-20% |
| 복잡도 | 하 |

### 1-3. metadata 이중 호출 제거

| 항목 | 내용 |
|------|------|
| 현재 | `index_row_from_path()`가 `fs::symlink_metadata()` 재호출 (`main.rs:724`) |
| 문제 | WalkDir는 이미 DirEntry에 metadata를 갖고 있음. 같은 파일에 syscall 2회 |
| 방안 | `index_row_from_entry(entry: &walkdir::DirEntry)` 오버로드 추가, `entry.metadata()` 사용 |
| 기대 효과 | 15-25% (syscall 절반 감소) |
| 복잡도 | 중 |

### 1-4. 인덱싱 중 FTS5 트리거 비활성화

| 항목 | 내용 |
|------|------|
| 현재 | INSERT마다 `entries_ai` 트리거가 FTS5에 동기 삽입 (`main.rs:253-255`) |
| 문제 | 트리거 오버헤드가 전체 upsert 시간의 40-60%를 차지할 수 있음 |
| 방안 | full index 시 트리거 DROP → 배치 완료 후 `INSERT INTO entries_fts(entries_fts) VALUES('rebuild')` → 트리거 재생성 |
| 기대 효과 | 30-50% (bulk insert 기준) |
| 복잡도 | 중 |

### 1-5. 점진적(incremental) 인덱싱

| 항목 | 내용 |
|------|------|
| 현재 | `DELETE FROM entries` 후 전체 재스캔 (`main.rs:1487`) |
| 문제 | 앱 재시작마다 0부터 시작. 100만 파일 기준 수분 소요 |
| 방안 | `indexed_at` 타임스탬프 비교: 스캔 시작 시각 기록 → 이미 존재하는 row는 mtime 비교 후 skip → 스캔 종료 후 `indexed_at < start_ts` 행만 DELETE (삭제된 파일) |
| 기대 효과 | 극대 — 재시작 시 수초 내 Ready 전환 |
| 복잡도 | 상 |

---

## 2. SQLite 튜닝

### 2-1. cache_size 확대

| 항목 | 내용 |
|------|------|
| 현재 | 기본값 (≈2MB) (`main.rs:193-201`) |
| 방안 | 인덱싱 시 `PRAGMA cache_size = -65536` (64MB), 검색 시 `-16384` (16MB) |
| 기대 효과 | 20-30% 쓰기, 10-15% 읽기 |
| 복잡도 | 하 |

### 2-2. WAL autocheckpoint 제어

| 항목 | 내용 |
|------|------|
| 현재 | WAL 기본 autocheckpoint (1000 페이지) |
| 방안 | 인덱싱 중 `PRAGMA wal_autocheckpoint = 0` → 완료 후 수동 `PRAGMA wal_checkpoint(TRUNCATE)` |
| 기대 효과 | 10-20% 쓰기 (checkpoint I/O 제거) |
| 복잡도 | 하 |

### 2-3. page_size 확대

| 항목 | 내용 |
|------|------|
| 현재 | 기본 4096B |
| 방안 | DB 생성 시 `PRAGMA page_size = 8192` (path 평균 길이 고려) |
| 기대 효과 | 15-25% I/O 감소 |
| 복잡도 | 중 (DB 버전 범프 필요) |

### 2-4. 복합 인덱스 추가

| 항목 | 내용 |
|------|------|
| 현재 | `idx_entries_dir`, `idx_entries_name` 개별 인덱스 (`main.rs:240-241`) |
| 문제 | `PathSearch`에서 `dir LIKE AND name LIKE` 조합 시 인덱스 교차 비효율 |
| 방안 | `CREATE INDEX idx_entries_dir_name ON entries(dir, name)` |
| 기대 효과 | PathSearch 20-40% 개선 |
| 복잡도 | 하 |

### 2-5. FTS5 prefix 축소

| 항목 | 내용 |
|------|------|
| 현재 | `prefix='2 3 4 5 6'` (`main.rs:250`) |
| 문제 | prefix 인덱스 5개 → FTS 빌드 시간 + 디스크 사용량 증가 |
| 방안 | `prefix='2 3'`으로 축소. 4+ 글자 쿼리는 접두사 스캔으로 충분 |
| 기대 효과 | FTS 인덱스 크기 30-40% 감소, 빌드 15-20% 빠름 |
| 복잡도 | 하 (DB 버전 범프) |

---

## 3. 검색 응답 최적화

### 3-1. 사용자 검색어 기반 우선 인덱싱 (검색 이력 활용)

| 항목 | 내용 |
|------|------|
| 현재 | 검색 이력을 로그에만 기록 (`log_search`) |
| 방안 | 최근 검색어 상위 N개를 `frequent_queries` 테이블에 유지. 인덱싱 시 해당 쿼리에 매치되는 디렉터리를 priority_roots 앞에 배치 |
| 기대 효과 | 사용자 체감 검색 가용성 대폭 향상 |
| 복잡도 | 중 |

### 3-2. 쿼리별 결과 캐시 (인메모리)

| 항목 | 내용 |
|------|------|
| 현재 | 매 검색마다 SQL 실행 |
| 방안 | LRU 캐시(크기 100, TTL 5초)에 `(query, sort, offset) → Vec<EntryDto>` 저장. `index_updated` 이벤트 시 무효화 |
| 기대 효과 | 동일 쿼리 반복 시 0ms 응답 |
| 복잡도 | 중 |

### 3-3. filter_ignored_entries를 WHERE절로 이동

| 항목 | 내용 |
|------|------|
| 현재 | SQL 결과를 받은 후 Rust에서 필터링 (`main.rs:2147-2148`) |
| 문제 | 쿼리가 LIMIT만큼 반환해도 필터링 후 결과가 줄어듦 |
| 방안 | ignore 패턴을 SQL WHERE 조건(NOT LIKE / NOT IN)으로 변환하여 DB 레벨에서 배제 |
| 기대 효과 | 결과 정확성 + 20-40% 성능 (ignore 항목이 많을수록 효과 큼) |
| 복잡도 | 중 |

### 3-4. OFFSET → keyset 페이지네이션

| 항목 | 내용 |
|------|------|
| 현재 | `LIMIT ?1 OFFSET ?2` (`main.rs:2046, 2073, 2096, 2118`) |
| 문제 | OFFSET은 건너뛸 행을 모두 스캔 (O(n)) |
| 방안 | 이전 페이지 마지막 행의 `(sort_key, id)`를 기준으로 `WHERE (sort_key, id) > (?, ?)` |
| 기대 효과 | 5페이지 이후 50-80% 빠름 |
| 복잡도 | 중 |

### 3-5. NameSearch 랭킹 SQL 개선

| 항목 | 내용 |
|------|------|
| 현재 | CASE WHEN 3단계 rank 계산 (`main.rs:2064-2069`) |
| 방안 | 완전일치(rank 0)를 별도 쿼리로 분리 → UNION ALL → 전체 LIKE 스캔 감소. 또는 name 컬럼에 COLLATE NOCASE 인덱스 추가 |
| 기대 효과 | 완전일치 시 즉시 반환 |
| 복잡도 | 중 |

### 3-6. 정렬 결과 클라이언트 캐싱

| 항목 | 내용 |
|------|------|
| 현재 | 정렬 변경 시 서버 재쿼리 (`App.svelte:560-572`) |
| 방안 | 결과 500건 이하면 프론트엔드에서 인메모리 정렬. 서버 왕복 제거 |
| 기대 효과 | 정렬 전환 50-100ms → 즉시 |
| 복잡도 | 중 |

---

## 4. 아이콘 로딩

### 4-1. Swift 서브프로세스 → 상주 데몬

| 항목 | 내용 |
|------|------|
| 현재 | 확장자별 `swift -e ...` 프로세스 생성 (`main.rs:1878`) |
| 문제 | 프로세스 스폰 오버헤드 ~50-100ms/회 |
| 방안 | Swift CLI 바이너리 하나를 stdin/stdout 통신으로 상주시키거나, `objc` 크레이트로 NSWorkspace 직접 호출 |
| 기대 효과 | 5-10x 아이콘 로드 속도 |
| 복잡도 | 상 |

### 4-2. 공통 확장자 프리로드

| 항목 | 내용 |
|------|------|
| 현재 | 최초 요청 시 로드 |
| 방안 | 앱 시작 시 상위 20개 확장자(`txt`, `pdf`, `png`, `jpg`, `md`, `json`, `swift`, `rs`, `js`, `ts`, `html`, `css`, `py`, `zip`, `dmg`, `app`, `doc`, `xls`, `ppt`, `mov`)를 백그라운드에서 일괄 로드 |
| 기대 효과 | 첫 검색 결과 표시 시 아이콘 즉시 렌더 |
| 복잡도 | 하 |

### 4-3. 병렬 아이콘 요청

| 항목 | 내용 |
|------|------|
| 현재 | 보이는 행마다 순차 `get_file_icon` 호출 (`App.svelte:112`) |
| 방안 | 미캐시 확장자를 모아서 `Promise.all` 또는 Rust 측 배치 API로 일괄 처리 |
| 기대 효과 | 30-50% 초기 렌더 아이콘 로드 시간 단축 |
| 복잡도 | 중 |

---

## 5. 프론트엔드 렌더링

### 5-1. highlight 세그먼트 메모이제이션

| 항목 | 내용 |
|------|------|
| 현재 | `highlightSegments()` 매 렌더 시 재계산 (`App.svelte:134-163`) |
| 문제 | 스크롤 시 동일 entry에 대해 반복 계산 |
| 방안 | `Map<string, Segment[]>` 캐시. 쿼리 변경 시 초기화 |
| 기대 효과 | 스크롤 성능 30-50% 개선 |
| 복잡도 | 하 |

### 5-2. 가상 스크롤 버퍼 확대

| 항목 | 내용 |
|------|------|
| 현재 | 상하 6행 버퍼 (`App.svelte:102-104`) |
| 방안 | 10-12행으로 증가. 빠른 스크롤 시 깜빡임 감소 |
| 기대 효과 | 체감 스크롤 부드러움 향상 |
| 복잡도 | 하 |

### 5-3. 디바운스 간격 최적화

| 항목 | 내용 |
|------|------|
| 현재 | 프론트엔드 검색 디바운스 (존재한다면) |
| 방안 | 150ms 디바운스 + 첫 글자 즉시 전송 (leading edge). 타이핑 중 불필요한 중간 쿼리 제거 |
| 기대 효과 | 백엔드 부하 40-60% 감소 |
| 복잡도 | 하 |

---

## 6. 파일 감시 (FSEvents watcher)

### 6-1. 디바운스 축소

| 항목 | 내용 |
|------|------|
| 현재 | `WATCH_DEBOUNCE = 500ms` (`main.rs:38`) |
| 방안 | 200-300ms로 축소. 파일 저장 후 검색 반영까지 체감 지연 감소 |
| 기대 효과 | 사용자 체감 반응성 향상 |
| 복잡도 | 하 |

### 6-2. pending_paths 중복 제거

| 항목 | 내용 |
|------|------|
| 현재 | 파일 + 부모를 Vec에 push (`main.rs:1789-1793`) |
| 문제 | 같은 디렉터리에서 다수 변경 시 중복 처리 |
| 방안 | `HashSet<PathBuf>`로 변경. 디바운스 윈도우 내 중복 경로 자동 제거 |
| 기대 효과 | 대량 변경 시 10-20% 처리량 감소 |
| 복잡도 | 하 |

---

## 7. 라이브 서치 (fd_search)

### 7-1. 타임아웃 축소

| 항목 | 내용 |
|------|------|
| 현재 | `SEARCH_TIMEOUT = 10s` (`fd_search.rs:33`) |
| 방안 | 3초로 축소. 대부분의 유효 결과는 1초 내 수집됨 |
| 기대 효과 | 최악 케이스 대기 시간 70% 감소 |
| 복잡도 | 하 |

### 7-2. 깊이 제한 확대

| 항목 | 내용 |
|------|------|
| 현재 | `MAX_DEPTH = 10` (`fd_search.rs:32`) |
| 방안 | 15-20으로 증가. node_modules 등은 이미 should_skip_path로 제외됨 |
| 기대 효과 | 깊은 프로젝트 구조에서 결과 누락 감소 |
| 복잡도 | 하 |

### 7-3. 중복 정렬 제거

| 항목 | 내용 |
|------|------|
| 현재 | `run_fd_search()` 내 정렬 후 `search` 커맨드에서 재정렬 |
| 방안 | 라이브 서치 결과에 이미 정렬 적용됨을 표시하여 재정렬 스킵 |
| 기대 효과 | 10-15% |
| 복잡도 | 하 |

---

## 8. 메모리 관리

### 8-1. 아이콘 캐시 크기 제한

| 항목 | 내용 |
|------|------|
| 현재 | `HashMap<String, Vec<u8>>` 무한 성장 (`main.rs:165`) |
| 방안 | LRU 캐시 (최대 200 엔트리 또는 50MB) |
| 기대 효과 | 메모리 사용량 상한 보장 |
| 복잡도 | 하 |

### 8-2. 라이브 서치 캐시 크기 조정

| 항목 | 내용 |
|------|------|
| 현재 | 120 쿼리 캐시 (`main.rs:1266`) |
| 방안 | 50으로 축소. 오래된 쿼리 캐시가 메모리만 차지 |
| 기대 효과 | 메모리 30-50% 절감 (캐시 부분) |
| 복잡도 | 하 |

---

## 우선순위 매트릭스

### 즉시 적용 (하루 이내, 효과 큼)

| # | 항목 | 기대 효과 |
|---|------|-----------|
| 2-1 | SQLite cache_size 확대 | 쓰기 20-30% |
| 2-2 | WAL autocheckpoint 제어 | 쓰기 10-20% |
| 2-5 | FTS5 prefix 축소 | 빌드 15-20% |
| 2-4 | 복합 인덱스 dir+name | PathSearch 20-40% |
| 1-2 | BATCH_SIZE 증가 | 인덱싱 10-20% |
| 4-2 | 공통 확장자 프리로드 | 첫 검색 체감 |

### 단기 (1주 이내)

| # | 항목 | 기대 효과 |
|---|------|-----------|
| 1-4 | 인덱싱 중 FTS5 트리거 비활성화 | 인덱싱 30-50% |
| 1-3 | metadata 이중 호출 제거 | 인덱싱 15-25% |
| 3-3 | filter_ignored를 WHERE절로 | 검색 20-40% |
| 3-1 | 검색어 기반 우선 인덱싱 | 체감 가용성 |
| 5-1 | highlight 메모이제이션 | 스크롤 30-50% |

### 중기 (1개월 이내)

| # | 항목 | 기대 효과 |
|---|------|-----------|
| 1-1 | jwalk 병렬 순회 | 인덱싱 3-5x |
| 1-5 | 점진적 인덱싱 | 재시작 수초 |
| 3-4 | keyset 페이지네이션 | 깊은 페이지 50-80% |
| 4-1 | Swift 데몬 / objc 직접 호출 | 아이콘 5-10x |
| 3-2 | 쿼리 결과 인메모리 캐시 | 반복 쿼리 0ms |
