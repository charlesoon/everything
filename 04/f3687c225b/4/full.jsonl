{"type":"file-history-snapshot","messageId":"e434e1c3-80d1-4915-b98d-97d59bc63d17","snapshot":{"messageId":"e434e1c3-80d1-4915-b98d-97d59bc63d17","trackedFileBackups":{},"timestamp":"2026-02-21T14:32:12.415Z"},"isSnapshotUpdate":false}
{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","type":"progress","data":{"type":"hook_progress","hookEvent":"SessionStart","hookName":"SessionStart:clear","command":"entire hooks claude-code session-start"},"parentToolUseID":"9179d9cd-7031-4cdc-9f1e-3019f7ddbc9c","toolUseID":"9179d9cd-7031-4cdc-9f1e-3019f7ddbc9c","timestamp":"2026-02-21T14:32:10.933Z","uuid":"32ee0e84-67f7-4631-8b87-0e6dcc734142"}
{"parentUuid":"32ee0e84-67f7-4631-8b87-0e6dcc734142","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","type":"user","message":{"role":"user","content":"<local-command-caveat>Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to.</local-command-caveat>"},"isMeta":true,"uuid":"e63ecf4c-5fb1-43d6-a8b5-5e853038b048","timestamp":"2026-02-21T14:32:12.415Z"}
{"parentUuid":"e63ecf4c-5fb1-43d6-a8b5-5e853038b048","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","type":"user","message":{"role":"user","content":"<command-name>/clear</command-name>\n            <command-message>clear</command-message>\n            <command-args></command-args>"},"uuid":"e434e1c3-80d1-4915-b98d-97d59bc63d17","timestamp":"2026-02-21T14:32:10.587Z"}
{"parentUuid":"e434e1c3-80d1-4915-b98d-97d59bc63d17","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","type":"user","message":{"role":"user","content":"<local-command-stdout></local-command-stdout>"},"uuid":"0828c27a-4287-4054-9540-faa9f74d3a36","timestamp":"2026-02-21T14:32:12.415Z"}
{"type":"file-history-snapshot","messageId":"475eedbe-041a-4296-9cbb-7313506e184a","snapshot":{"messageId":"475eedbe-041a-4296-9cbb-7313506e184a","trackedFileBackups":{},"timestamp":"2026-02-21T14:32:16.817Z"},"isSnapshotUpdate":false}
{"parentUuid":"0828c27a-4287-4054-9540-faa9f74d3a36","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","type":"user","message":{"role":"user","content":"<command-message>ln:codereview</command-message>\n<command-name>/ln:codereview</command-name>"},"uuid":"475eedbe-041a-4296-9cbb-7313506e184a","timestamp":"2026-02-21T14:32:14.269Z"}
{"parentUuid":"475eedbe-041a-4296-9cbb-7313506e184a","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","type":"user","message":{"role":"user","content":[{"type":"text","text":"Conduct a thorough, line-by-line code review with a critical perspective.\n\n**Usage:**\n```bash\n/ln:codereview           # Review all uncommitted changes (default)\n/ln:codereview all       # Review all uncommitted changes (staged + unstaged)\n/ln:codereview unstaged  # Review only unstaged changes\n```\n\n## Review Scope\n\n**Mode 1: All uncommitted changes (default)**\n- Command: `git diff HEAD` (staged + unstaged)\n- Reviews everything not yet committed\n\n**Mode 2: Unstaged only**\n- Command: `git diff` (working directory changes only)\n- Reviews only files not yet staged\n\nAll modes include:\n1. **Critical examination**: Line-by-line inspection with skeptical mindset\n2. **Pattern validation**: Verify adherence to project conventions and guides\n\n## Review Categories\n\n### Code Quality\n- **Clean code**: No TODO comments, no unused code\n- **Naming conventions**: Consistent with project standards\n- **File organization**: Proper separation of concerns\n- **Documentation**: Adequate comments where necessary\n\n### Technical Validation\n- **Build verification**: Zero warnings, all tests pass\n- **Type safety**: No type errors or unsafe operations\n- **Performance**: No memory leaks, efficient algorithms\n- **Security**: No hardcoded secrets or vulnerabilities\n\n### Architecture Review\n- **Design patterns**: Appropriate use of patterns\n- **Dependency management**: Minimal coupling\n- **Error handling**: Comprehensive error coverage\n- **Concurrency**: Thread safety and race conditions\n\n### Design Principles (OCP/SRP)\n\n**OCP (Open-Closed Principle) violations to catch:**\n- Adding `else if` / `switch case` to extend existing behavior\n- Modifying stable code instead of creating new modules\n- Missing extension points (strategy, registry, plugin patterns)\n\n**SRP (Single Responsibility Principle) violations to catch:**\n- One file handling multiple unrelated concerns\n- Functions/classes that change for multiple reasons\n- God objects or utility dumps\n\n**When found, suggest:**\n- Extract new behavior into separate file/class\n- Use strategy/registry pattern for extensibility\n- Split multi-responsibility files into focused modules\n\n## Review Process\n\n### Step 0: Understand Project Context (MANDATORY)\n\nBefore reviewing any code, you MUST understand the project environment:\n\n1. **Read CLAUDE.md** - Check project root and user's `~/.claude/CLAUDE.md` for project-specific conventions\n2. **Identify app type** - Read entry points, config files, or main modules to determine:\n   - **Platform**: Desktop (Electron) / Mobile (React Native, Flutter, iOS, Android) / Web server / CLI / Library\n   - **User model**: Single-user vs Multi-user\n   - **Network exposure**: Local-only vs Network-exposed API\n3. **Understand architecture** - Scan key files to grasp the overall structure\n\n**Why this matters:**\n- Security concerns differ drastically between local desktop app and public API server\n- \"Memory leak\" in a short-lived CLI is irrelevant; in a long-running server it's critical\n- Path traversal in local-only app with file dialog is low-risk; in server accepting arbitrary input it's critical\n\n**DO NOT skip this step.** Reviewing without context leads to false positives and wastes everyone's time.\n\n### Step 1: Analyze Changes\n\nDetermine review mode from command argument (default: `all`):\n\n**Mode: all (default)**\n```bash\ngit diff HEAD  # All uncommitted changes (staged + unstaged)\n```\n\n**Mode: unstaged**\n```bash\ngit diff  # Only unstaged changes\n```\n\n### Step 2: Validate Build\n- TypeScript: `npx tsc --noEmit`\n- Linting: `npm run lint`\n- Testing: `npm run test`\n- Language-specific checks per development guides\n\n### Step 3: Generate Report\n\nI will provide a structured report with:\n\n#### Critical Issues ðŸš¨\n- **ONLY** issues that will cause runtime crashes, data loss, or security breaches\n- Must be reproducible with concrete steps\n- Example: SQL injection, unhandled null causing crash, infinite loop\n\n#### Major Issues âš ï¸\n- Issues that cause incorrect behavior users will notice\n- Must demonstrate actual failure scenario\n- Example: Wrong calculation result, UI not updating, API returning wrong data\n\n#### Minor Issues ðŸ’¡\n- Style violations or optimization opportunities\n- Suggestions for improvement\n- Example: Inconsistent naming, missing error message\n\n**DO NOT mark as Critical/Major:**\n- Theoretical concerns without concrete failure scenario\n- \"Could potentially cause...\" without proof\n- Design preferences or \"I would do it differently\"\n\n#### Positive Highlights âœ…\n- Well-implemented patterns\n- Good practices observed\n\n## Review Principles\n\n- **No temporary solutions**: Reject workarounds or hacks\n- **Complete implementation**: No partial features with TODOs\n- **Performance first**: Consider memory, CPU, and I/O impact\n- **Build cleanliness**: Zero warnings tolerance\n- **Guide compliance**: Follow all development guides in docs/\n\n## â›” Anti-Hallucination Rules\n\nBefore reporting ANY issue, you MUST:\n\n1. **READ the actual code** - Don't guess based on patterns. Read the exact lines.\n2. **TRACE the execution flow** - Follow the code path. If you claim race condition, prove it step by step.\n3. **VERIFY the issue exists** - Can you reproduce it? Show concrete scenario.\n4. **CHECK context** - What's the runtime environment? Desktop vs server, single-user vs multi-user?\n5. **CONFIRM it's not intentional** - fire-and-forget, placeholder values updated later, etc. may be by design.\n\n### Issue Validation Checklist\n\nFor each issue you want to report, answer:\n1. Did I read the ACTUAL code, not just the diff snippet?\n2. Can I show the EXACT line numbers where this fails?\n3. Is this a REAL bug or theoretical concern that can't happen in practice?\n4. Does the surrounding code already handle this case?\n\n### What NOT to report as issues:\n- Singleton with placeholder that gets updated in init/start method\n- \"Memory leak\" in single-user desktop app with bounded data\n- \"Race condition\" when there's already a guard (e.g., `if (this.running) return`)\n- Intentional fire-and-forget patterns with error logging\n- \"Missing cleanup\" when cleanup exists in useEffect return or stop() method\n\n## Exclusions (Do NOT Review)\n\n- **Git submodule reference changes only**: Skip dirty submodule states, submodule commit hash changes in the main repo. Source code inside submodules CAN and SHOULD be reviewed when requested.\n\n## Output Format\n\nThe review will be delivered as a comprehensive report with:\n- Severity-based issue categorization\n- Specific line references for each issue\n- Concrete suggestions for fixes\n- Overall code health assessment"}]},"isMeta":true,"uuid":"97f10781-6d88-442a-92ab-8500ea9f9237","timestamp":"2026-02-21T14:32:14.269Z"}
{"parentUuid":"97f10781-6d88-442a-92ab-8500ea9f9237","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","message":{"model":"claude-sonnet-4-6","id":"msg_01B8qy9duquCpwgBowqPrHap","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user has invoked the `ln:codereview` skill. Let me follow the skill's instructions to conduct a thorough code review of all uncommitted changes.\n\nFirst, I need to:\n1. Understand the project context (read CLAUDE.md - already done via system context)\n2. Analyze changes using `git diff HEAD`\n3. Validate build\n4. Generate report\n\nFrom the system context, I can see:\n- The project is a macOS Tauri v2 + Rust + Svelte 4 + SQLite app\n- There's one modified file: `src/App.svelte`\n- Some untracked files: `doc/app_v2.pen`, `doc/image.png`, `doc/images/`, `doc/untitled.pen`\n\n\nNow I'll pull the diff to see what's changed in the App.svelte file and examine any other uncommitted modifications.","signature":"EqIGCkYICxgCKkBNDHraPDD7ArwRIaAc/ISoWbS+g5BEh8VOiGHCLiFIztAGztj/LaZ6s3yD+DrgQVA1SYKSJ85RrG8aQmLHfKNFEgyM8fzvZYAUYJm5QnEaDG91BdETSdCXk5CSySIwRjUAptq4CLSGzvRtWkRxSI8QQzYcDqoDv2uh9ZsbP2NTmXr5t65Eh02NrKtGqqpTKokFvf8EeviqM0Q6UsIee3g1kwBHNMFyTzTuUmFzMWUp3f15Oc+fSagh8jR1NzIBTPjUT4iGG2Vzl5lpqcpkP888VE5ShcAa4aRF5iLFZKD5L+yez+2Cz1NHbVBidDaKQTMTuair590+ftgoOK5WOljPhhpYNKTd6saJTMCm1TqxfAQ+g574XjKfd8zM+NEnouDDsGwZyXXeeebLvhjf6eBKrQ941F//Q1G14vdvaqLNhAbVG0hhylcfqQcGWyUNbImZ6PWK5vhY6MnZxVdVoscX/t/xaM5VQfEkz729gHN2WIkvcqdV7GvpTc8R/I4jyhPyYqQ6m91RfhP8nAqKepwJpf3XksjF5OCBFkLbSmh0uQWCLCgJStTDdF3/xEl5iDK4bwUxg4MN3Zvr9sab+F/7KaRRbGjFmZNGT++BQ3ooHCuFUo3VU51VAwH5FoHIhUyk8z+ZNVW/oG0jL1twvfW2jFesoZYAkWcEhfItUOtKWiPHFlX94Nmj/5g7jbTkSRbYg0b3mz5YyRjvjOlWpHOoGYLNuye6Z0BzvgLBaT3bnAhvIeML0B421Z6fo+x2x+WgH/E29KR2BBbKKNAGvTqxHhLzyfQ5qvEyau/ubS6hYwmHLfO3h3dJiP+7yJtwpaYIKgdWEZQcPzlnBEbTXfjJdKaK+fDMm6moYhLjbaEgdUyh4GUP+RaiyWRIKk2fzm8yjOguwxrD5p1SGbHVzZGKxF9wurV3rGB+6LmA7YE44uVUrckv7Of25AKMMgQetjU11XmLE0OT4+y6HDxcW5cBT0C55Gvn8Ao37GNAo7kbtcdL0n74SoHWgA7qRzl4jXD/pEC/PreR70AZnf5HbGIi8eMXeO5q6SManhgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":9582,"cache_read_input_tokens":25541,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":9582},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMNpq2AnZgb5UHWqktTM","type":"assistant","uuid":"44e7ef18-19f9-464e-872e-5f9a8fd8462b","timestamp":"2026-02-21T14:32:22.711Z"}
{"parentUuid":"44e7ef18-19f9-464e-872e-5f9a8fd8462b","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","message":{"model":"claude-sonnet-4-6","id":"msg_01B8qy9duquCpwgBowqPrHap","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016zvqi7c6x9qLRy4LCdKDmC","name":"Bash","input":{"command":"git diff HEAD","description":"Get all uncommitted changes"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":9582,"cache_read_input_tokens":25541,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":9582},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMNpq2AnZgb5UHWqktTM","type":"assistant","uuid":"30124323-4ff4-4393-98f1-977724da9b72","timestamp":"2026-02-21T14:32:22.807Z"}
{"parentUuid":"30124323-4ff4-4393-98f1-977724da9b72","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016zvqi7c6x9qLRy4LCdKDmC","type":"tool_result","content":"diff --git a/src/App.svelte b/src/App.svelte\nindex db9259a..86159ae 100644\n--- a/src/App.svelte\n+++ b/src/App.svelte\n@@ -5,16 +5,17 @@\n   import { getCurrentWindow } from '@tauri-apps/api/window';\n   import { startDrag } from '@crabnebula/tauri-plugin-drag';\n \n-  const rowHeight = 28;\n+  const rowHeight = 30;\n   const PAGE_SIZE = 500;\n   let homePrefix = '';\n   const COL_WIDTHS_KEY = 'REDACTED';\n+  const THEME_KEY = 'everything-theme';\n   const columnKeys = ['name', 'path', 'size', 'modified'];\n   const minColumnWidth = {\n     name: 180,\n     path: 240,\n     size: 75,\n-    modified: 120\n+    modified: 150\n   };\n   const defaultColumnRatios = {\n     name: 0.3,\n@@ -22,6 +23,12 @@\n     size: 0.1\n   };\n \n+  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || 'dark'; } catch { return 'dark'; } })();\n+  function cycleTheme() {\n+    theme = theme === 'dark' ? 'light' : 'dark';\n+    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n+  }\n+\n   let query = '';\n   let results = [];\n   let totalResults = 0;\n@@ -40,6 +47,8 @@\n     draftName: ''\n   };\n \n+  let renameOverlay = { top: 0, left: 0, width: 0 };\n+\n   let indexStatus = {\n     state: 'Indexing',\n     entriesCount: 0,\n@@ -61,13 +70,13 @@\n   let searchGeneration = 0;\n \n   let scanned = 0;\n-  let indexed = 0;\n-  let currentPath = '';\n \n   let searchInputEl;\n   let renameInputEl;\n   let tableAreaEl;\n   let tableContainer;\n+  let tableResizeObserver = null;\n+  let viewportResizeRaf = null;\n   let scrollTop = 0;\n   let headerScrollLeft = 0;\n   let viewportHeight = 520;\n@@ -78,7 +87,7 @@\n     name: 250,\n     path: 350,\n     size: 75,\n-    modified: 120\n+    modified: 150\n   };\n \n   let contextMenu = {\n@@ -295,6 +304,16 @@\n     syncColumnWidthsToContainer();\n   }\n \n+  function scheduleViewportHeightUpdate() {\n+    if (viewportResizeRaf !== null) {\n+      return;\n+    }\n+    viewportResizeRaf = requestAnimationFrame(() => {\n+      viewportResizeRaf = null;\n+      updateViewportHeight();\n+    });\n+  }\n+\n   function startColumnResize(event, leftKey) {\n     event.preventDefault();\n     event.stopPropagation();\n@@ -420,12 +439,6 @@\n       if (typeof status.scanned === 'number') {\n         scanned = status.scanned;\n       }\n-      if (typeof status.indexed === 'number') {\n-        indexed = status.indexed;\n-      }\n-      if (typeof status.currentPath === 'string') {\n-        currentPath = status.currentPath;\n-      }\n       if (status.state === 'Ready' && prevState !== 'Ready') {\n         scheduleSearch();\n       }\n@@ -900,8 +913,6 @@\n     totalResultsKnown = false;\n     clearSelection();\n     scanned = 0;\n-    indexed = 0;\n-    currentPath = '';\n     dbLatencyMs = null;\n     dbLastQuery = '';\n     indexStatus = { ...indexStatus, state: 'Indexing', entriesCount: 0, message: null };\n@@ -921,6 +932,12 @@\n     return selectedIndices.size > 1;\n   }\n \n+  function autoResizeRenameInput() {\n+    if (!renameInputEl) return;\n+    renameInputEl.style.height = '0';\n+    renameInputEl.style.height = renameInputEl.scrollHeight + 'px';\n+  }\n+\n   async function startRename() {\n     if (isMultiSelected()) {\n       return;\n@@ -932,6 +949,23 @@\n     }\n \n     const entry = results[idx];\n+\n+    // Calculate overlay position mathematically.\n+    // Name cell text starts at: padding-left(16) + icon(16) + gap(6) = 38px from cell left.\n+    // Textarea has padding-left: 0 and border: 1.5px, so text starts ~2px from overlay left.\n+    if (tableContainer) {\n+      const rect = tableContainer.getBoundingClientRect();\n+      const cellLeft = rect.left - tableContainer.scrollLeft;\n+      const textLeft = cellLeft + 38;\n+      const cellRight = cellLeft + colWidths.name;\n+      const rowTop = rect.top + idx * rowHeight - tableContainer.scrollTop;\n+      renameOverlay = {\n+        top: rowTop,\n+        left: textLeft - 2,\n+        width: cellRight - textLeft + 2 - 4\n+      };\n+    }\n+\n     editing = {\n       active: true,\n       path: entry.path,\n@@ -942,6 +976,7 @@\n     await tick();\n \n     if (renameInputEl) {\n+      autoResizeRenameInput();\n       renameInputEl.focus();\n       const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n       const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n@@ -984,6 +1019,17 @@\n     closeContextMenu();\n   }\n \n+  function onTitleBarMouseDown(event) {\n+    if (event.button !== 0) {\n+      return;\n+    }\n+\n+    const activeElement = document.activeElement;\n+    if (activeElement instanceof HTMLElement && isTextInputTarget(activeElement)) {\n+      activeElement.blur();\n+    }\n+  }\n+\n   async function focusSearch() {\n     await getCurrentWindow().show();\n     await getCurrentWindow().setFocus();\n@@ -1029,6 +1075,7 @@\n       if (event.key === 'Escape') {\n         event.preventDefault();\n         cancelRename();\n+        searchInputEl?.focus();\n         return;\n       }\n       return;\n@@ -1227,8 +1274,6 @@\n \n     const unlistenProgress = await listen('index_progress', (event) => {\n       scanned = event.payload.scanned;\n-      indexed = event.payload.indexed;\n-      currentPath = event.payload.currentPath;\n       if (indexStatus.state !== 'Indexing') {\n         indexStatus = {\n           ...indexStatus,\n@@ -1325,7 +1370,18 @@\n     await runSearch();\n     flog(`[startup/fe] +${ms()}ms runSearch done`);\n \n-    window.addEventListener('resize', updateViewportHeight);\n+    if (typeof ResizeObserver !== 'undefined') {\n+      tableResizeObserver = new ResizeObserver(() => {\n+        scheduleViewportHeightUpdate();\n+      });\n+      if (tableContainer) {\n+        tableResizeObserver.observe(tableContainer);\n+      } else if (tableAreaEl) {\n+        tableResizeObserver.observe(tableAreaEl);\n+      }\n+    }\n+\n+    window.addEventListener('resize', scheduleViewportHeightUpdate);\n     window.addEventListener('click', onGlobalClick);\n     statusRefreshTimer = setInterval(() => {\n       if (indexStatus.state === 'Indexing') {\n@@ -1346,14 +1402,31 @@\n       unlisten();\n     }\n \n-    window.removeEventListener('resize', updateViewportHeight);\n+    tableResizeObserver?.disconnect();\n+    tableResizeObserver = null;\n+    if (viewportResizeRaf !== null) {\n+      cancelAnimationFrame(viewportResizeRaf);\n+      viewportResizeRaf = null;\n+    }\n+    window.removeEventListener('resize', scheduleViewportHeightUpdate);\n     window.removeEventListener('click', onGlobalClick);\n   });\n </script>\n \n <svelte:window on:keydown={handleKeydown} />\n \n-<div class=\"app-shell\">\n+<div class=\"app-shell\" data-theme={theme}>\n+  <div class=\"title-bar\" role=\"presentation\" data-tauri-drag-region on:mousedown={onTitleBarMouseDown}>\n+    <div class=\"title-left\"></div>\n+    <div class=\"title-center\">\n+      <svg class=\"title-icon\" viewBox=\"0 0 215 205\" fill-rule=\"evenodd\" aria-hidden=\"true\">\n+        <path d=\"M85 0c46.9 0 85 38.1 85 85 0 20.1-7.2 38.5-19.2 52.7l40.7 40.8c5.8 5.8 5.8 15.2 0 21-5.8 5.8-15.2 5.8-21 0l-40.7-40.7c-13.6 9.7-30.4 15.2-44.8 15.2-46.9 0-85-42.1-85-89 0-46.9 38.1-85 85-85z m0 32c-29.3 0-53 23.7-53 53 0 29.3 23.7 53 53 53 29.3 0 53-23.7 53-53 0-29.3-23.7-53-53-53z\"/>\n+      </svg>\n+      <span class=\"title-text\">Everything</span>\n+    </div>\n+    <div class=\"title-right\"></div>\n+  </div>\n+\n   <header class=\"search-bar\">\n     <input\n       bind:this={searchInputEl}\n@@ -1373,7 +1446,7 @@\n       <div class=\"table-header-track\">\n         <div class=\"col name\">\n           <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('name')}>\n-            Name{#if sortBy === 'name'}{sortDir === 'asc' ? ' â–²' : ' â–¼'}{/if}\n+            Name{#if sortBy === 'name'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n           </button>\n           <button\n             type=\"button\"\n@@ -1386,7 +1459,7 @@\n \n         <div class=\"col path\">\n           <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('dir')}>\n-            Path{#if sortBy === 'dir'}{sortDir === 'asc' ? ' â–²' : ' â–¼'}{/if}\n+            Path{#if sortBy === 'dir'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n           </button>\n           <button\n             type=\"button\"\n@@ -1399,13 +1472,13 @@\n \n         <div class=\"col size\">\n           <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('size')}>\n-            Size{#if sortBy === 'size'}{sortDir === 'asc' ? ' â–²' : ' â–¼'}{/if}\n+            Size{#if sortBy === 'size'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n           </button>\n         </div>\n \n         <div class=\"col modified\">\n           <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('mtime')}>\n-            Modified{#if sortBy === 'mtime'}{sortDir === 'asc' ? ' â–²' : ' â–¼'}{/if}\n+            Modified{#if sortBy === 'mtime'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n           </button>\n         </div>\n       </div>\n@@ -1417,6 +1490,7 @@\n       on:scroll={() => {\n         scrollTop = tableContainer.scrollTop;\n         headerScrollLeft = tableContainer.scrollLeft;\n+        if (editing.active) cancelRename();\n         const scrollBottom = scrollTop + tableContainer.clientHeight;\n         if (scrollBottom >= totalHeight - rowHeight * 10) {\n           void loadMore();\n@@ -1439,17 +1513,7 @@\n             >\n               <div class=\"cell name\">\n                 <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n-\n-                {#if editing.active && editing.index === index}\n-                  <input\n-                    bind:this={renameInputEl}\n-                    class=\"rename-input\"\n-                    bind:value={editing.draftName}\n-                    on:click|stopPropagation\n-                  />\n-                {:else}\n-                  <span class=\"ellipsis\">{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n-                {/if}\n+                <span class=\"ellipsis\" class:name-editing={editing.active && editing.index === index}>{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n               </div>\n               <div class=\"cell path\"><span class=\"ellipsis\">{displayPath(entry.dir)}</span></div>\n               <div class=\"cell size\">{formatSize(entry)}</div>\n@@ -1462,45 +1526,71 @@\n   </section>\n \n   <footer class=\"status-bar\">\n-    {#if indexStatus.state === 'Indexing'}\n-        {#if indexStatus.entriesCount > 0}\n-          <span>Indexing{#if lastReadyCount > 0} ({Math.min(99, Math.round((scanned / lastReadyCount) * 100))}%){/if}{#if indexingElapsed} Â· {indexingElapsed}{/if} Â· {indexStatus.entriesCount.toLocaleString()} entries</span>\n+    <div class=\"status-left\">\n+      <span class=\"status-state\">\n+        <span class=\"state-dot {indexStatus.state === 'Indexing' ? 'indexing' : indexStatus.state === 'Error' ? 'error' : 'ready'}\"></span>\n+        {#if indexStatus.state === 'Indexing'}\n+          Indexing{#if lastReadyCount > 0} ({Math.min(99, Math.round((scanned / lastReadyCount) * 100))}%){/if}{#if indexingElapsed} Â· {indexingElapsed}{/if}\n+          {#if !indexStatus.isCatchup}\n+            Â· {scanned.toLocaleString()} scanned\n+          {/if}\n         {:else}\n-          <span>Starting indexing...{#if indexingElapsed} ({indexingElapsed}){/if}</span>\n-        {/if}\n-      {:else}\n-        <span>Index: {indexStatus.state}</span>\n-        <span>Entries: {indexStatus.entriesCount.toLocaleString()}</span>\n-        {#if indexingFinishedAt}\n-          <span>Indexed in {indexingFinishedAt}</span>\n+          Index: {indexStatus.state}\n         {/if}\n+      </span>\n+      <span>{indexStatus.entriesCount.toLocaleString()} entries</span>\n+      {#if indexingFinishedAt && indexStatus.state !== 'Indexing'}\n+        <span>in {indexingFinishedAt}</span>\n+      {/if}\n+      {#if dbLatencyMs !== null && dbLastQuery}\n+        <span>\"{dbLastQuery}\" {dbLatencyMs}ms Â· {totalResults} results</span>\n       {/if}\n       {#if searchModeLabel === 'spotlight' || searchModeLabel === 'spotlight_timeout'}\n-        <span class=\"status-spotlight\">Spotlight fallback{#if searchModeLabel === 'spotlight_timeout'} (partial results){/if}</span>\n+        <span class=\"status-spotlight\">Spotlight fallback{#if searchModeLabel === 'spotlight_timeout'} (partial){/if}</span>\n       {/if}\n-      {#if dbLatencyMs !== null && dbLastQuery}\n-        <span>\"{dbLastQuery}\" {dbLatencyMs} ms Â· {totalResults} results</span>\n+      {#if indexStatus.permissionErrors > 0}\n+        <span class=\"status-warning\">{indexStatus.permissionErrors.toLocaleString()} permission errors</span>\n       {/if}\n-    <button\n-      class=\"status-btn\"\n-      on:click={resetIndex}\n-      disabled={indexStatus.state === 'Indexing'}\n-      title={indexStatus.state === 'Indexing' ? 'Cannot reset while indexing is in progress.' : 'Reset and rebuild the index.'}\n-    >\n-      Reset Index\n-    </button>\n-    {#if indexStatus.state === 'Indexing' && !indexStatus.isCatchup}\n-      <span class=\"index-progress\">Scanned {scanned.toLocaleString()} / Indexed {indexed.toLocaleString()}</span>\n-      <span class=\"path-preview\">{displayPath(currentPath)}</span>\n-    {/if}\n-    {#if indexStatus.permissionErrors > 0}\n-      <span class=\"status-warning\">Permission errors: {indexStatus.permissionErrors.toLocaleString()}</span>\n-    {/if}\n-    {#if indexStatus.message}\n-      <span class={indexStatus.isCatchup ? 'index-progress' : 'status-error'}>{indexStatus.message}</span>\n-    {/if}\n+      {#if indexStatus.message}\n+        <span class={indexStatus.isCatchup ? 'index-progress' : 'status-error'}>{indexStatus.message}</span>\n+      {/if}\n+    </div>\n+    <div class=\"status-right\">\n+      <button class=\"status-btn theme-btn\" on:click={cycleTheme} title=\"Switch theme\">\n+        {theme === 'dark' ? 'â˜€ Light' : 'â—‘ Dark'}\n+      </button>\n+      <button\n+        class=\"status-btn rebuild-btn\"\n+        on:click={resetIndex}\n+        disabled={indexStatus.state === 'Indexing'}\n+        title={indexStatus.state === 'Indexing' ? 'Cannot reset while indexing is in progress.' : 'Reset and rebuild the index.'}\n+      >\n+        <svg class=\"rebuild-icon\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n+          <path d=\"M23 4v6h-6\"/><path d=\"M20.49 15a9 9 0 1 1-2.12-9.36L23 10\"/>\n+        </svg>\n+        Rebuild Index\n+      </button>\n+    </div>\n   </footer>\n \n+  {#if editing.active}\n+    <div\n+      class=\"rename-overlay\"\n+      style=\"top:{renameOverlay.top}px; left:{renameOverlay.left}px; width:{renameOverlay.width}px;\"\n+      role=\"presentation\"\n+      on:mousedown|stopPropagation\n+    >\n+      <textarea\n+        bind:this={renameInputEl}\n+        class=\"rename-textarea\"\n+        bind:value={editing.draftName}\n+        on:input={autoResizeRenameInput}\n+        on:click|stopPropagation\n+        on:blur={commitRename}\n+      />\n+    </div>\n+  {/if}\n+\n   {#if contextMenu.visible}\n     <div class=\"context-menu\" style={`left:${contextMenu.x}px;top:${contextMenu.y}px;`}>\n       <button on:click={() => (closeContextMenu(), openSelected())}>Open</button>\n@@ -1578,6 +1668,144 @@\n     }\n   }\n \n+  /* â”€â”€ Theme: Dark â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n+  :global([data-theme=\"dark\"]) {\n+    color-scheme: dark;\n+    --bg-app: #1E1E21;\n+    --text-primary: #E2E8F0;\n+    --text-muted: #94A3B8;\n+    --bar-grad-top: #1E1E21;\n+    --bar-grad-bottom: #1E1E21;\n+    --surface-header: #1E1E21;\n+    --surface: #1E1E21;\n+    --bg-input: #161618;\n+    --border-soft: #2A2A2D;\n+    --border-input: rgba(255, 255, 255, 0.06);\n+    --focus-ring: #4DA8FF;\n+    --accent: #4DA8FF;\n+    --row-border: rgba(255, 255, 255, 0.02);\n+    --row-hover: #282828;\n+    --row-selected: rgba(77, 168, 255, 0.10);\n+    --button-bg: rgba(255, 255, 255, 0.05);\n+    --button-border: #2A2A2D;\n+    --button-text: #94A3B8;\n+    --menu-bg: #252528;\n+    --menu-border: #2A2A2D;\n+    --menu-hover: rgba(255, 255, 255, 0.04);\n+    --menu-text: #E2E8F0;\n+    --error-text: #ff9d9d;\n+    --warning-text: #e0c670;\n+    --toast-bg: rgba(10, 10, 16, 0.93);\n+    --toast-text: #f2f2f6;\n+  }\n+\n+  /* â”€â”€ Theme: Light â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n+  :global([data-theme=\"light\"]) {\n+    color-scheme: light;\n+    --bg-app: #F5F5F7;\n+    --text-primary: #1C1C1E;\n+    --text-muted: #6E6E7A;\n+    --bar-grad-top: #F5F5F7;\n+    --bar-grad-bottom: #F5F5F7;\n+    --surface-header: #F5F5F7;\n+    --surface: #F5F5F7;\n+    --bg-input: #FFFFFF;\n+    --border-soft: #D1D1D6;\n+    --border-input: rgba(0, 0, 0, 0.10);\n+    --focus-ring: #3A8BF5;\n+    --accent: #3A8BF5;\n+    --row-border: rgba(0, 0, 0, 0.04);\n+    --row-hover: rgba(0, 0, 0, 0.04);\n+    --row-selected: rgba(58, 139, 245, 0.10);\n+    --button-bg: #FFFFFF;\n+    --button-border: #D1D1D6;\n+    --button-text: #3C3C43;\n+    --menu-bg: #FFFFFF;\n+    --menu-border: #D1D1D6;\n+    --menu-hover: rgba(0, 0, 0, 0.05);\n+    --menu-text: #1C1C1E;\n+    --error-text: #D93025;\n+    --warning-text: #B45309;\n+    --toast-bg: rgba(255, 255, 255, 0.95);\n+    --toast-text: #1C1C1E;\n+  }\n+\n+  /* â”€â”€ Themed element overrides â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n+  :global([data-theme]) {\n+    background: var(--bg-app);\n+  }\n+\n+  /* Search bar: flat, no gradient, no separator */\n+  :global([data-theme]) .search-bar {\n+    height: 44px;\n+    padding: 0 16px;\n+    background: var(--bg-app);\n+    border-bottom: none;\n+  }\n+\n+  :global([data-theme]) .search-input {\n+    backdrop-filter: none;\n+    -webkit-backdrop-filter: none;\n+    font-family: 'JetBrains Mono', 'SF Mono', monospace;\n+    font-size: 12px;\n+    height: 34px;\n+    border-radius: 8px;\n+  }\n+\n+  /* Table header: flat bg, 16px edge padding */\n+  :global([data-theme]) .table-header {\n+    background: var(--bg-app);\n+  }\n+\n+  :global([data-theme]) .col-button {\n+    padding: 0 8px;\n+  }\n+\n+  :global([data-theme]) .col.name .col-button {\n+    padding-left: 16px;\n+  }\n+\n+  /* Row cells: JetBrains Mono, 16px outer edges */\n+  :global([data-theme]) .cell {\n+    font-family: 'JetBrains Mono', monospace;\n+  }\n+\n+  :global([data-theme]) .cell.name {\n+    font-family: Inter, 'SF Pro Text', sans-serif;\n+    padding-left: 16px;\n+    font-size: 12px;\n+    color: var(--text-primary);\n+  }\n+\n+  :global([data-theme]) .cell.path {\n+    font-size: 11px;\n+  }\n+\n+  :global([data-theme]) .cell.size {\n+    font-size: 11px;\n+  }\n+\n+  :global([data-theme]) .cell.modified {\n+    padding-right: 16px;\n+    font-size: 11px;\n+    white-space: nowrap;\n+  }\n+\n+  :global([data-theme]) .row.selected {\n+    box-shadow: inset 3px 0 0 var(--accent);\n+  }\n+\n+  /* Dim path/size/date cells in themed mode */\n+  :global([data-theme]) .cell.path,\n+  :global([data-theme]) .cell.size,\n+  :global([data-theme]) .cell.modified {\n+    color: var(--text-muted);\n+  }\n+\n+  :global(:root) {\n+    background: transparent;\n+  }\n+\n   :global(html, body) {\n     margin: 0;\n     width: 100%;\n@@ -1585,7 +1813,7 @@\n     overflow: hidden;\n     background: transparent;\n     color: var(--text-primary);\n-    font-family: 'SF Pro Text', 'Segoe UI', Helvetica, Arial, sans-serif;\n+    font-family: Inter, 'SF Pro Text', 'Segoe UI', Helvetica, Arial, sans-serif;\n   }\n \n   :global(#app) {\n@@ -1595,11 +1823,62 @@\n \n   .app-shell {\n     display: grid;\n-    grid-template-rows: auto 1fr auto;\n+    grid-template-rows: auto auto 1fr auto;\n     height: 100%;\n     min-width: 0;\n   }\n \n+  .title-bar {\n+    display: flex;\n+    align-items: center;\n+    justify-content: space-between;\n+    height: 44px;\n+    padding: 0 16px;\n+    background: var(--surface-header);\n+    cursor: default;\n+    flex-shrink: 0;\n+    user-select: none;\n+    -webkit-user-select: none;\n+  }\n+\n+  .title-left {\n+    width: 72px;\n+    pointer-events: none;\n+    user-select: none;\n+    -webkit-user-select: none;\n+  }\n+\n+  .title-center {\n+    display: flex;\n+    align-items: center;\n+    gap: 8px;\n+    pointer-events: none;\n+    user-select: none;\n+    -webkit-user-select: none;\n+  }\n+\n+  .title-right {\n+    width: 72px;\n+    pointer-events: none;\n+    user-select: none;\n+    -webkit-user-select: none;\n+  }\n+\n+  .title-icon {\n+    width: 14px;\n+    height: 14px;\n+    fill: var(--accent);\n+    flex-shrink: 0;\n+  }\n+\n+  .title-text {\n+    font-family: Inter, 'SF Pro Text', sans-serif;\n+    font-size: 13px;\n+    font-weight: 500;\n+    color: var(--text-primary);\n+    letter-spacing: -0.01em;\n+  }\n+\n   .search-bar {\n     display: flex;\n     align-items: center;\n@@ -1608,6 +1887,7 @@\n     background: linear-gradient(180deg, var(--bar-grad-top) 0%, var(--bar-grad-bottom) 100%);\n     border-bottom: 1px solid var(--border-soft);\n     min-width: 0;\n+    flex-shrink: 0;\n   }\n \n   .search-input {\n@@ -1616,12 +1896,12 @@\n     width: 100%;\n     min-width: 0;\n     flex: 1 1 auto;\n-    height: 32px;\n+    height: 36px;\n     border: 1px solid var(--border-input);\n-    border-radius: 8px;\n+    border-radius: 14px;\n     padding: 0 10px;\n     font-size: 14px;\n-    background: var(--surface);\n+    background: var(--bg-input, var(--surface));\n     color: var(--text-primary);\n     backdrop-filter: blur(12px) saturate(160%);\n     -webkit-backdrop-filter: blur(12px) saturate(160%);\n@@ -1655,11 +1935,12 @@\n   }\n \n   .table-header {\n-    height: 30px;\n+    height: 32px;\n     border-bottom: 1px solid var(--border-soft);\n     background: var(--surface-header);\n     user-select: none;\n     overflow: hidden;\n+    flex-shrink: 0;\n   }\n \n   .table-header-track {\n@@ -1680,9 +1961,11 @@\n     display: flex;\n     align-items: center;\n     justify-content: flex-start;\n+    gap: 4px;\n     box-sizing: border-box;\n     padding: 0 8px;\n-    font-size: 12px;\n+    font-family: Inter, 'SF Pro Text', sans-serif;\n+    font-size: 11px;\n     font-weight: 600;\n     line-height: 1;\n     color: var(--text-muted);\n@@ -1693,6 +1976,13 @@\n     cursor: pointer;\n   }\n \n+  .sort-icon {\n+    width: 10px;\n+    height: 10px;\n+    flex-shrink: 0;\n+    color: var(--accent);\n+  }\n+\n   .col-resizer {\n     position: absolute;\n     top: 0;\n@@ -1744,7 +2034,7 @@\n   }\n \n   .row {\n-    height: 28px;\n+    height: 30px;\n     border-bottom: 1px solid var(--row-border);\n     cursor: default;\n     -webkit-user-select: none;\n@@ -1766,21 +2056,11 @@\n     display: flex;\n     align-items: center;\n     gap: 6px;\n-  }\n-\n-  .cell.name {\n-    min-width: 0;\n-  }\n-\n-  .cell.path,\n-  .cell.size,\n-  .cell.modified {\n     min-width: 0;\n   }\n \n   .cell.size {\n     text-align: right;\n-    padding-right: 8px;\n     font-variant-numeric: tabular-nums;\n   }\n \n@@ -1802,29 +2082,64 @@\n     flex: 0 0 auto;\n   }\n \n-  .rename-input {\n+  .name-editing {\n+    opacity: 0.25;\n+  }\n+\n+  .rename-overlay {\n+    position: fixed;\n+    z-index: 100;\n+    min-width: 120px;\n+  }\n+\n+  .rename-textarea {\n+    display: block;\n     width: 100%;\n-    height: 20px;\n+    box-sizing: border-box;\n+    font-family: Inter, 'SF Pro Text', sans-serif;\n     font-size: 12px;\n-    border: 1px solid var(--focus-ring);\n+    line-height: 18px;\n+    padding: 5px 4px 5px 0;\n+    border: 1.5px solid var(--focus-ring);\n     border-radius: 4px;\n-    padding: 0 4px;\n-    background: var(--surface);\n+    background: var(--bg-input, var(--surface));\n     color: var(--text-primary);\n+    outline: none;\n+    resize: none;\n+    overflow: hidden;\n+    box-shadow: 0 2px 14px rgba(0, 0, 0, 0.22), 0 0 0 3px rgba(77, 168, 255, 0.13);\n   }\n \n   .status-bar {\n     display: flex;\n     align-items: center;\n-    gap: 14px;\n-    padding: 6px 8px;\n+    justify-content: space-between;\n+    height: 32px;\n+    padding: 0 16px;\n     background: var(--surface-header);\n     border-top: 1px solid var(--border-soft);\n+    font-family: 'JetBrains Mono', monospace;\n     font-size: 11px;\n     color: var(--text-muted);\n     white-space: nowrap;\n     overflow: hidden;\n     min-width: 0;\n+    flex-shrink: 0;\n+  }\n+\n+  .status-left {\n+    display: flex;\n+    align-items: center;\n+    gap: 16px;\n+    overflow: hidden;\n+    min-width: 0;\n+  }\n+\n+  .status-right {\n+    display: flex;\n+    align-items: center;\n+    gap: 8px;\n+    flex-shrink: 0;\n   }\n \n   .status-btn {\n@@ -1848,9 +2163,54 @@\n     filter: none;\n   }\n \n-  .path-preview {\n-    overflow: hidden;\n-    text-overflow: ellipsis;\n+  .status-state {\n+    display: flex;\n+    align-items: center;\n+    gap: 6px;\n+  }\n+\n+  .state-dot {\n+    width: 6px;\n+    height: 6px;\n+    border-radius: 50%;\n+    flex-shrink: 0;\n+  }\n+\n+  .state-dot.ready { background: #28C840; }\n+  .state-dot.indexing { background: #FEBC2E; }\n+  .state-dot.error { background: #FF5F57; }\n+\n+  .rebuild-btn {\n+    display: flex;\n+    align-items: center;\n+    gap: 6px;\n+    font-family: Inter, 'SF Pro Text', sans-serif;\n+    font-size: 10px;\n+    font-weight: 500;\n+    background: var(--button-bg);\n+    border: 1px solid var(--button-border);\n+    border-radius: 4px;\n+    color: var(--button-text);\n+    height: 22px;\n+    padding: 0 10px;\n+    cursor: pointer;\n+  }\n+\n+  .rebuild-btn:hover {\n+    filter: brightness(1.1);\n+  }\n+\n+  .rebuild-btn:disabled {\n+    opacity: 0.5;\n+    cursor: not-allowed;\n+    filter: none;\n+  }\n+\n+  .rebuild-icon {\n+    width: 11px;\n+    height: 11px;\n+    color: var(--accent);\n+    flex-shrink: 0;\n   }\n \n   .status-error {","is_error":false}]},"uuid":"bf8b4c47-975f-4c23-9a9e-905be5fc1178","timestamp":"2026-02-21T14:32:22.931Z","toolUseResult":{"stdout":"diff --git a/src/App.svelte b/src/App.svelte\nindex db9259a..86159ae 100644\n--- a/src/App.svelte\n+++ b/src/App.svelte\n@@ -5,16 +5,17 @@\n   import { getCurrentWindow } from '@tauri-apps/api/window';\n   import { startDrag } from '@crabnebula/tauri-plugin-drag';\n \n-  const rowHeight = 28;\n+  const rowHeight = 30;\n   const PAGE_SIZE = 500;\n   let homePrefix = '';\n   const COL_WIDTHS_KEY = 'REDACTED';\n+  const THEME_KEY = 'everything-theme';\n   const columnKeys = ['name', 'path', 'size', 'modified'];\n   const minColumnWidth = {\n     name: 180,\n     path: 240,\n     size: 75,\n-    modified: 120\n+    modified: 150\n   };\n   const defaultColumnRatios = {\n     name: 0.3,\n@@ -22,6 +23,12 @@\n     size: 0.1\n   };\n \n+  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || 'dark'; } catch { return 'dark'; } })();\n+  function cycleTheme() {\n+    theme = theme === 'dark' ? 'light' : 'dark';\n+    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n+  }\n+\n   let query = '';\n   let results = [];\n   let totalResults = 0;\n@@ -40,6 +47,8 @@\n     draftName: ''\n   };\n \n+  let renameOverlay = { top: 0, left: 0, width: 0 };\n+\n   let indexStatus = {\n     state: 'Indexing',\n     entriesCount: 0,\n@@ -61,13 +70,13 @@\n   let searchGeneration = 0;\n \n   let scanned = 0;\n-  let indexed = 0;\n-  let currentPath = '';\n \n   let searchInputEl;\n   let renameInputEl;\n   let tableAreaEl;\n   let tableContainer;\n+  let tableResizeObserver = null;\n+  let viewportResizeRaf = null;\n   let scrollTop = 0;\n   let headerScrollLeft = 0;\n   let viewportHeight = 520;\n@@ -78,7 +87,7 @@\n     name: 250,\n     path: 350,\n     size: 75,\n-    modified: 120\n+    modified: 150\n   };\n \n   let contextMenu = {\n@@ -295,6 +304,16 @@\n     syncColumnWidthsToContainer();\n   }\n \n+  function scheduleViewportHeightUpdate() {\n+    if (viewportResizeRaf !== null) {\n+      return;\n+    }\n+    viewportResizeRaf = requestAnimationFrame(() => {\n+      viewportResizeRaf = null;\n+      updateViewportHeight();\n+    });\n+  }\n+\n   function startColumnResize(event, leftKey) {\n     event.preventDefault();\n     event.stopPropagation();\n@@ -420,12 +439,6 @@\n       if (typeof status.scanned === 'number') {\n         scanned = status.scanned;\n       }\n-      if (typeof status.indexed === 'number') {\n-        indexed = status.indexed;\n-      }\n-      if (typeof status.currentPath === 'string') {\n-        currentPath = status.currentPath;\n-      }\n       if (status.state === 'Ready' && prevState !== 'Ready') {\n         scheduleSearch();\n       }\n@@ -900,8 +913,6 @@\n     totalResultsKnown = false;\n     clearSelection();\n     scanned = 0;\n-    indexed = 0;\n-    currentPath = '';\n     dbLatencyMs = null;\n     dbLastQuery = '';\n     indexStatus = { ...indexStatus, state: 'Indexing', entriesCount: 0, message: null };\n@@ -921,6 +932,12 @@\n     return selectedIndices.size > 1;\n   }\n \n+  function autoResizeRenameInput() {\n+    if (!renameInputEl) return;\n+    renameInputEl.style.height = '0';\n+    renameInputEl.style.height = renameInputEl.scrollHeight + 'px';\n+  }\n+\n   async function startRename() {\n     if (isMultiSelected()) {\n       return;\n@@ -932,6 +949,23 @@\n     }\n \n     const entry = results[idx];\n+\n+    // Calculate overlay position mathematically.\n+    // Name cell text starts at: padding-left(16) + icon(16) + gap(6) = 38px from cell left.\n+    // Textarea has padding-left: 0 and border: 1.5px, so text starts ~2px from overlay left.\n+    if (tableContainer) {\n+      const rect = tableContainer.getBoundingClientRect();\n+      const cellLeft = rect.left - tableContainer.scrollLeft;\n+      const textLeft = cellLeft + 38;\n+      const cellRight = cellLeft + colWidths.name;\n+      const rowTop = rect.top + idx * rowHeight - tableContainer.scrollTop;\n+      renameOverlay = {\n+        top: rowTop,\n+        left: textLeft - 2,\n+        width: cellRight - textLeft + 2 - 4\n+      };\n+    }\n+\n     editing = {\n       active: true,\n       path: entry.path,\n@@ -942,6 +976,7 @@\n     await tick();\n \n     if (renameInputEl) {\n+      autoResizeRenameInput();\n       renameInputEl.focus();\n       const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n       const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n@@ -984,6 +1019,17 @@\n     closeContextMenu();\n   }\n \n+  function onTitleBarMouseDown(event) {\n+    if (event.button !== 0) {\n+      return;\n+    }\n+\n+    const activeElement = document.activeElement;\n+    if (activeElement instanceof HTMLElement && isTextInputTarget(activeElement)) {\n+      activeElement.blur();\n+    }\n+  }\n+\n   async function focusSearch() {\n     await getCurrentWindow().show();\n     await getCurrentWindow().setFocus();\n@@ -1029,6 +1075,7 @@\n       if (event.key === 'Escape') {\n         event.preventDefault();\n         cancelRename();\n+        searchInputEl?.focus();\n         return;\n       }\n       return;\n@@ -1227,8 +1274,6 @@\n \n     const unlistenProgress = await listen('index_progress', (event) => {\n       scanned = event.payload.scanned;\n-      indexed = event.payload.indexed;\n-      currentPath = event.payload.currentPath;\n       if (indexStatus.state !== 'Indexing') {\n         indexStatus = {\n           ...indexStatus,\n@@ -1325,7 +1370,18 @@\n     await runSearch();\n     flog(`[startup/fe] +${ms()}ms runSearch done`);\n \n-    window.addEventListener('resize', updateViewportHeight);\n+    if (typeof ResizeObserver !== 'undefined') {\n+      tableResizeObserver = new ResizeObserver(() => {\n+        scheduleViewportHeightUpdate();\n+      });\n+      if (tableContainer) {\n+        tableResizeObserver.observe(tableContainer);\n+      } else if (tableAreaEl) {\n+        tableResizeObserver.observe(tableAreaEl);\n+      }\n+    }\n+\n+    window.addEventListener('resize', scheduleViewportHeightUpdate);\n     window.addEventListener('click', onGlobalClick);\n     statusRefreshTimer = setInterval(() => {\n       if (indexStatus.state === 'Indexing') {\n@@ -1346,14 +1402,31 @@\n       unlisten();\n     }\n \n-    window.removeEventListener('resize', updateViewportHeight);\n+    tableResizeObserver?.disconnect();\n+    tableResizeObserver = null;\n+    if (viewportResizeRaf !== null) {\n+      cancelAnimationFrame(viewportResizeRaf);\n+      viewportResizeRaf = null;\n+    }\n+    window.removeEventListener('resize', scheduleViewportHeightUpdate);\n     window.removeEventListener('click', onGlobalClick);\n   });\n </script>\n \n <svelte:window on:keydown={handleKeydown} />\n \n-<div class=\"app-shell\">\n+<div class=\"app-shell\" data-theme={theme}>\n+  <div class=\"title-bar\" role=\"presentation\" data-tauri-drag-region on:mousedown={onTitleBarMouseDown}>\n+    <div class=\"title-left\"></div>\n+    <div class=\"title-center\">\n+      <svg class=\"title-icon\" viewBox=\"0 0 215 205\" fill-rule=\"evenodd\" aria-hidden=\"true\">\n+        <path d=\"M85 0c46.9 0 85 38.1 85 85 0 20.1-7.2 38.5-19.2 52.7l40.7 40.8c5.8 5.8 5.8 15.2 0 21-5.8 5.8-15.2 5.8-21 0l-40.7-40.7c-13.6 9.7-30.4 15.2-44.8 15.2-46.9 0-85-42.1-85-89 0-46.9 38.1-85 85-85z m0 32c-29.3 0-53 23.7-53 53 0 29.3 23.7 53 53 53 29.3 0 53-23.7 53-53 0-29.3-23.7-53-53-53z\"/>\n+      </svg>\n+      <span class=\"title-text\">Everything</span>\n+    </div>\n+    <div class=\"title-right\"></div>\n+  </div>\n+\n   <header class=\"search-bar\">\n     <input\n       bind:this={searchInputEl}\n@@ -1373,7 +1446,7 @@\n       <div class=\"table-header-track\">\n         <div class=\"col name\">\n           <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('name')}>\n-            Name{#if sortBy === 'name'}{sortDir === 'asc' ? ' â–²' : ' â–¼'}{/if}\n+            Name{#if sortBy === 'name'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n           </button>\n           <button\n             type=\"button\"\n@@ -1386,7 +1459,7 @@\n \n         <div class=\"col path\">\n           <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('dir')}>\n-            Path{#if sortBy === 'dir'}{sortDir === 'asc' ? ' â–²' : ' â–¼'}{/if}\n+            Path{#if sortBy === 'dir'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n           </button>\n           <button\n             type=\"button\"\n@@ -1399,13 +1472,13 @@\n \n         <div class=\"col size\">\n           <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('size')}>\n-            Size{#if sortBy === 'size'}{sortDir === 'asc' ? ' â–²' : ' â–¼'}{/if}\n+            Size{#if sortBy === 'size'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n           </button>\n         </div>\n \n         <div class=\"col modified\">\n           <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('mtime')}>\n-            Modified{#if sortBy === 'mtime'}{sortDir === 'asc' ? ' â–²' : ' â–¼'}{/if}\n+            Modified{#if sortBy === 'mtime'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n           </button>\n         </div>\n       </div>\n@@ -1417,6 +1490,7 @@\n       on:scroll={() => {\n         scrollTop = tableContainer.scrollTop;\n         headerScrollLeft = tableContainer.scrollLeft;\n+        if (editing.active) cancelRename();\n         const scrollBottom = scrollTop + tableContainer.clientHeight;\n         if (scrollBottom >= totalHeight - rowHeight * 10) {\n           void loadMore();\n@@ -1439,17 +1513,7 @@\n             >\n               <div class=\"cell name\">\n                 <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n-\n-                {#if editing.active && editing.index === index}\n-                  <input\n-                    bind:this={renameInputEl}\n-                    class=\"rename-input\"\n-                    bind:value={editing.draftName}\n-                    on:click|stopPropagation\n-                  />\n-                {:else}\n-                  <span class=\"ellipsis\">{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n-                {/if}\n+                <span class=\"ellipsis\" class:name-editing={editing.active && editing.index === index}>{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n               </div>\n               <div class=\"cell path\"><span class=\"ellipsis\">{displayPath(entry.dir)}</span></div>\n               <div class=\"cell size\">{formatSize(entry)}</div>\n@@ -1462,45 +1526,71 @@\n   </section>\n \n   <footer class=\"status-bar\">\n-    {#if indexStatus.state === 'Indexing'}\n-        {#if indexStatus.entriesCount > 0}\n-          <span>Indexing{#if lastReadyCount > 0} ({Math.min(99, Math.round((scanned / lastReadyCount) * 100))}%){/if}{#if indexingElapsed} Â· {indexingElapsed}{/if} Â· {indexStatus.entriesCount.toLocaleString()} entries</span>\n+    <div class=\"status-left\">\n+      <span class=\"status-state\">\n+        <span class=\"state-dot {indexStatus.state === 'Indexing' ? 'indexing' : indexStatus.state === 'Error' ? 'error' : 'ready'}\"></span>\n+        {#if indexStatus.state === 'Indexing'}\n+          Indexing{#if lastReadyCount > 0} ({Math.min(99, Math.round((scanned / lastReadyCount) * 100))}%){/if}{#if indexingElapsed} Â· {indexingElapsed}{/if}\n+          {#if !indexStatus.isCatchup}\n+            Â· {scanned.toLocaleString()} scanned\n+          {/if}\n         {:else}\n-          <span>Starting indexing...{#if indexingElapsed} ({indexingElapsed}){/if}</span>\n-        {/if}\n-      {:else}\n-        <span>Index: {indexStatus.state}</span>\n-        <span>Entries: {indexStatus.entriesCount.toLocaleString()}</span>\n-        {#if indexingFinishedAt}\n-          <span>Indexed in {indexingFinishedAt}</span>\n+          Index: {indexStatus.state}\n         {/if}\n+      </span>\n+      <span>{indexStatus.entriesCount.toLocaleString()} entries</span>\n+      {#if indexingFinishedAt && indexStatus.state !== 'Indexing'}\n+        <span>in {indexingFinishedAt}</span>\n+      {/if}\n+      {#if dbLatencyMs !== null && dbLastQuery}\n+        <span>\"{dbLastQuery}\" {dbLatencyMs}ms Â· {totalResults} results</span>\n       {/if}\n       {#if searchModeLabel === 'spotlight' || searchModeLabel === 'spotlight_timeout'}\n-        <span class=\"status-spotlight\">Spotlight fallback{#if searchModeLabel === 'spotlight_timeout'} (partial results){/if}</span>\n+        <span class=\"status-spotlight\">Spotlight fallback{#if searchModeLabel === 'spotlight_timeout'} (partial){/if}</span>\n       {/if}\n-      {#if dbLatencyMs !== null && dbLastQuery}\n-        <span>\"{dbLastQuery}\" {dbLatencyMs} ms Â· {totalResults} results</span>\n+      {#if indexStatus.permissionErrors > 0}\n+        <span class=\"status-warning\">{indexStatus.permissionErrors.toLocaleString()} permission errors</span>\n       {/if}\n-    <button\n-      class=\"status-btn\"\n-      on:click={resetIndex}\n-      disabled={indexStatus.state === 'Indexing'}\n-      title={indexStatus.state === 'Indexing' ? 'Cannot reset while indexing is in progress.' : 'Reset and rebuild the index.'}\n-    >\n-      Reset Index\n-    </button>\n-    {#if indexStatus.state === 'Indexing' && !indexStatus.isCatchup}\n-      <span class=\"index-progress\">Scanned {scanned.toLocaleString()} / Indexed {indexed.toLocaleString()}</span>\n-      <span class=\"path-preview\">{displayPath(currentPath)}</span>\n-    {/if}\n-    {#if indexStatus.permissionErrors > 0}\n-      <span class=\"status-warning\">Permission errors: {indexStatus.permissionErrors.toLocaleString()}</span>\n-    {/if}\n-    {#if indexStatus.message}\n-      <span class={indexStatus.isCatchup ? 'index-progress' : 'status-error'}>{indexStatus.message}</span>\n-    {/if}\n+      {#if indexStatus.message}\n+        <span class={indexStatus.isCatchup ? 'index-progress' : 'status-error'}>{indexStatus.message}</span>\n+      {/if}\n+    </div>\n+    <div class=\"status-right\">\n+      <button class=\"status-btn theme-btn\" on:click={cycleTheme} title=\"Switch theme\">\n+        {theme === 'dark' ? 'â˜€ Light' : 'â—‘ Dark'}\n+      </button>\n+      <button\n+        class=\"status-btn rebuild-btn\"\n+        on:click={resetIndex}\n+        disabled={indexStatus.state === 'Indexing'}\n+        title={indexStatus.state === 'Indexing' ? 'Cannot reset while indexing is in progress.' : 'Reset and rebuild the index.'}\n+      >\n+        <svg class=\"rebuild-icon\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n+          <path d=\"M23 4v6h-6\"/><path d=\"M20.49 15a9 9 0 1 1-2.12-9.36L23 10\"/>\n+        </svg>\n+        Rebuild Index\n+      </button>\n+    </div>\n   </footer>\n \n+  {#if editing.active}\n+    <div\n+      class=\"rename-overlay\"\n+      style=\"top:{renameOverlay.top}px; left:{renameOverlay.left}px; width:{renameOverlay.width}px;\"\n+      role=\"presentation\"\n+      on:mousedown|stopPropagation\n+    >\n+      <textarea\n+        bind:this={renameInputEl}\n+        class=\"rename-textarea\"\n+        bind:value={editing.draftName}\n+        on:input={autoResizeRenameInput}\n+        on:click|stopPropagation\n+        on:blur={commitRename}\n+      />\n+    </div>\n+  {/if}\n+\n   {#if contextMenu.visible}\n     <div class=\"context-menu\" style={`left:${contextMenu.x}px;top:${contextMenu.y}px;`}>\n       <button on:click={() => (closeContextMenu(), openSelected())}>Open</button>\n@@ -1578,6 +1668,144 @@\n     }\n   }\n \n+  /* â”€â”€ Theme: Dark â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n+  :global([data-theme=\"dark\"]) {\n+    color-scheme: dark;\n+    --bg-app: #1E1E21;\n+    --text-primary: #E2E8F0;\n+    --text-muted: #94A3B8;\n+    --bar-grad-top: #1E1E21;\n+    --bar-grad-bottom: #1E1E21;\n+    --surface-header: #1E1E21;\n+    --surface: #1E1E21;\n+    --bg-input: #161618;\n+    --border-soft: #2A2A2D;\n+    --border-input: rgba(255, 255, 255, 0.06);\n+    --focus-ring: #4DA8FF;\n+    --accent: #4DA8FF;\n+    --row-border: rgba(255, 255, 255, 0.02);\n+    --row-hover: #282828;\n+    --row-selected: rgba(77, 168, 255, 0.10);\n+    --button-bg: rgba(255, 255, 255, 0.05);\n+    --button-border: #2A2A2D;\n+    --button-text: #94A3B8;\n+    --menu-bg: #252528;\n+    --menu-border: #2A2A2D;\n+    --menu-hover: rgba(255, 255, 255, 0.04);\n+    --menu-text: #E2E8F0;\n+    --error-text: #ff9d9d;\n+    --warning-text: #e0c670;\n+    --toast-bg: rgba(10, 10, 16, 0.93);\n+    --toast-text: #f2f2f6;\n+  }\n+\n+  /* â”€â”€ Theme: Light â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n+  :global([data-theme=\"light\"]) {\n+    color-scheme: light;\n+    --bg-app: #F5F5F7;\n+    --text-primary: #1C1C1E;\n+    --text-muted: #6E6E7A;\n+    --bar-grad-top: #F5F5F7;\n+    --bar-grad-bottom: #F5F5F7;\n+    --surface-header: #F5F5F7;\n+    --surface: #F5F5F7;\n+    --bg-input: #FFFFFF;\n+    --border-soft: #D1D1D6;\n+    --border-input: rgba(0, 0, 0, 0.10);\n+    --focus-ring: #3A8BF5;\n+    --accent: #3A8BF5;\n+    --row-border: rgba(0, 0, 0, 0.04);\n+    --row-hover: rgba(0, 0, 0, 0.04);\n+    --row-selected: rgba(58, 139, 245, 0.10);\n+    --button-bg: #FFFFFF;\n+    --button-border: #D1D1D6;\n+    --button-text: #3C3C43;\n+    --menu-bg: #FFFFFF;\n+    --menu-border: #D1D1D6;\n+    --menu-hover: rgba(0, 0, 0, 0.05);\n+    --menu-text: #1C1C1E;\n+    --error-text: #D93025;\n+    --warning-text: #B45309;\n+    --toast-bg: rgba(255, 255, 255, 0.95);\n+    --toast-text: #1C1C1E;\n+  }\n+\n+  /* â”€â”€ Themed element overrides â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n+  :global([data-theme]) {\n+    background: var(--bg-app);\n+  }\n+\n+  /* Search bar: flat, no gradient, no separator */\n+  :global([data-theme]) .search-bar {\n+    height: 44px;\n+    padding: 0 16px;\n+    background: var(--bg-app);\n+    border-bottom: none;\n+  }\n+\n+  :global([data-theme]) .search-input {\n+    backdrop-filter: none;\n+    -webkit-backdrop-filter: none;\n+    font-family: 'JetBrains Mono', 'SF Mono', monospace;\n+    font-size: 12px;\n+    height: 34px;\n+    border-radius: 8px;\n+  }\n+\n+  /* Table header: flat bg, 16px edge padding */\n+  :global([data-theme]) .table-header {\n+    background: var(--bg-app);\n+  }\n+\n+  :global([data-theme]) .col-button {\n+    padding: 0 8px;\n+  }\n+\n+  :global([data-theme]) .col.name .col-button {\n+    padding-left: 16px;\n+  }\n+\n+  /* Row cells: JetBrains Mono, 16px outer edges */\n+  :global([data-theme]) .cell {\n+    font-family: 'JetBrains Mono', monospace;\n+  }\n+\n+  :global([data-theme]) .cell.name {\n+    font-family: Inter, 'SF Pro Text', sans-serif;\n+    padding-left: 16px;\n+    font-size: 12px;\n+    color: var(--text-primary);\n+  }\n+\n+  :global([data-theme]) .cell.path {\n+    font-size: 11px;\n+  }\n+\n+  :global([data-theme]) .cell.size {\n+    font-size: 11px;\n+  }\n+\n+  :global([data-theme]) .cell.modified {\n+    padding-right: 16px;\n+    font-size: 11px;\n+    white-space: nowrap;\n+  }\n+\n+  :global([data-theme]) .row.selected {\n+    box-shadow: inset 3px 0 0 var(--accent);\n+  }\n+\n+  /* Dim path/size/date cells in themed mode */\n+  :global([data-theme]) .cell.path,\n+  :global([data-theme]) .cell.size,\n+  :global([data-theme]) .cell.modified {\n+    color: var(--text-muted);\n+  }\n+\n+  :global(:root) {\n+    background: transparent;\n+  }\n+\n   :global(html, body) {\n     margin: 0;\n     width: 100%;\n@@ -1585,7 +1813,7 @@\n     overflow: hidden;\n     background: transparent;\n     color: var(--text-primary);\n-    font-family: 'SF Pro Text', 'Segoe UI', Helvetica, Arial, sans-serif;\n+    font-family: Inter, 'SF Pro Text', 'Segoe UI', Helvetica, Arial, sans-serif;\n   }\n \n   :global(#app) {\n@@ -1595,11 +1823,62 @@\n \n   .app-shell {\n     display: grid;\n-    grid-template-rows: auto 1fr auto;\n+    grid-template-rows: auto auto 1fr auto;\n     height: 100%;\n     min-width: 0;\n   }\n \n+  .title-bar {\n+    display: flex;\n+    align-items: center;\n+    justify-content: space-between;\n+    height: 44px;\n+    padding: 0 16px;\n+    background: var(--surface-header);\n+    cursor: default;\n+    flex-shrink: 0;\n+    user-select: none;\n+    -webkit-user-select: none;\n+  }\n+\n+  .title-left {\n+    width: 72px;\n+    pointer-events: none;\n+    user-select: none;\n+    -webkit-user-select: none;\n+  }\n+\n+  .title-center {\n+    display: flex;\n+    align-items: center;\n+    gap: 8px;\n+    pointer-events: none;\n+    user-select: none;\n+    -webkit-user-select: none;\n+  }\n+\n+  .title-right {\n+    width: 72px;\n+    pointer-events: none;\n+    user-select: none;\n+    -webkit-user-select: none;\n+  }\n+\n+  .title-icon {\n+    width: 14px;\n+    height: 14px;\n+    fill: var(--accent);\n+    flex-shrink: 0;\n+  }\n+\n+  .title-text {\n+    font-family: Inter, 'SF Pro Text', sans-serif;\n+    font-size: 13px;\n+    font-weight: 500;\n+    color: var(--text-primary);\n+    letter-spacing: -0.01em;\n+  }\n+\n   .search-bar {\n     display: flex;\n     align-items: center;\n@@ -1608,6 +1887,7 @@\n     background: linear-gradient(180deg, var(--bar-grad-top) 0%, var(--bar-grad-bottom) 100%);\n     border-bottom: 1px solid var(--border-soft);\n     min-width: 0;\n+    flex-shrink: 0;\n   }\n \n   .search-input {\n@@ -1616,12 +1896,12 @@\n     width: 100%;\n     min-width: 0;\n     flex: 1 1 auto;\n-    height: 32px;\n+    height: 36px;\n     border: 1px solid var(--border-input);\n-    border-radius: 8px;\n+    border-radius: 14px;\n     padding: 0 10px;\n     font-size: 14px;\n-    background: var(--surface);\n+    background: var(--bg-input, var(--surface));\n     color: var(--text-primary);\n     backdrop-filter: blur(12px) saturate(160%);\n     -webkit-backdrop-filter: blur(12px) saturate(160%);\n@@ -1655,11 +1935,12 @@\n   }\n \n   .table-header {\n-    height: 30px;\n+    height: 32px;\n     border-bottom: 1px solid var(--border-soft);\n     background: var(--surface-header);\n     user-select: none;\n     overflow: hidden;\n+    flex-shrink: 0;\n   }\n \n   .table-header-track {\n@@ -1680,9 +1961,11 @@\n     display: flex;\n     align-items: center;\n     justify-content: flex-start;\n+    gap: 4px;\n     box-sizing: border-box;\n     padding: 0 8px;\n-    font-size: 12px;\n+    font-family: Inter, 'SF Pro Text', sans-serif;\n+    font-size: 11px;\n     font-weight: 600;\n     line-height: 1;\n     color: var(--text-muted);\n@@ -1693,6 +1976,13 @@\n     cursor: pointer;\n   }\n \n+  .sort-icon {\n+    width: 10px;\n+    height: 10px;\n+    flex-shrink: 0;\n+    color: var(--accent);\n+  }\n+\n   .col-resizer {\n     position: absolute;\n     top: 0;\n@@ -1744,7 +2034,7 @@\n   }\n \n   .row {\n-    height: 28px;\n+    height: 30px;\n     border-bottom: 1px solid var(--row-border);\n     cursor: default;\n     -webkit-user-select: none;\n@@ -1766,21 +2056,11 @@\n     display: flex;\n     align-items: center;\n     gap: 6px;\n-  }\n-\n-  .cell.name {\n-    min-width: 0;\n-  }\n-\n-  .cell.path,\n-  .cell.size,\n-  .cell.modified {\n     min-width: 0;\n   }\n \n   .cell.size {\n     text-align: right;\n-    padding-right: 8px;\n     font-variant-numeric: tabular-nums;\n   }\n \n@@ -1802,29 +2082,64 @@\n     flex: 0 0 auto;\n   }\n \n-  .rename-input {\n+  .name-editing {\n+    opacity: 0.25;\n+  }\n+\n+  .rename-overlay {\n+    position: fixed;\n+    z-index: 100;\n+    min-width: 120px;\n+  }\n+\n+  .rename-textarea {\n+    display: block;\n     width: 100%;\n-    height: 20px;\n+    box-sizing: border-box;\n+    font-family: Inter, 'SF Pro Text', sans-serif;\n     font-size: 12px;\n-    border: 1px solid var(--focus-ring);\n+    line-height: 18px;\n+    padding: 5px 4px 5px 0;\n+    border: 1.5px solid var(--focus-ring);\n     border-radius: 4px;\n-    padding: 0 4px;\n-    background: var(--surface);\n+    background: var(--bg-input, var(--surface));\n     color: var(--text-primary);\n+    outline: none;\n+    resize: none;\n+    overflow: hidden;\n+    box-shadow: 0 2px 14px rgba(0, 0, 0, 0.22), 0 0 0 3px rgba(77, 168, 255, 0.13);\n   }\n \n   .status-bar {\n     display: flex;\n     align-items: center;\n-    gap: 14px;\n-    padding: 6px 8px;\n+    justify-content: space-between;\n+    height: 32px;\n+    padding: 0 16px;\n     background: var(--surface-header);\n     border-top: 1px solid var(--border-soft);\n+    font-family: 'JetBrains Mono', monospace;\n     font-size: 11px;\n     color: var(--text-muted);\n     white-space: nowrap;\n     overflow: hidden;\n     min-width: 0;\n+    flex-shrink: 0;\n+  }\n+\n+  .status-left {\n+    display: flex;\n+    align-items: center;\n+    gap: 16px;\n+    overflow: hidden;\n+    min-width: 0;\n+  }\n+\n+  .status-right {\n+    display: flex;\n+    align-items: center;\n+    gap: 8px;\n+    flex-shrink: 0;\n   }\n \n   .status-btn {\n@@ -1848,9 +2163,54 @@\n     filter: none;\n   }\n \n-  .path-preview {\n-    overflow: hidden;\n-    text-overflow: ellipsis;\n+  .status-state {\n+    display: flex;\n+    align-items: center;\n+    gap: 6px;\n+  }\n+\n+  .state-dot {\n+    width: 6px;\n+    height: 6px;\n+    border-radius: 50%;\n+    flex-shrink: 0;\n+  }\n+\n+  .state-dot.ready { background: #28C840; }\n+  .state-dot.indexing { background: #FEBC2E; }\n+  .state-dot.error { background: #FF5F57; }\n+\n+  .rebuild-btn {\n+    display: flex;\n+    align-items: center;\n+    gap: 6px;\n+    font-family: Inter, 'SF Pro Text', sans-serif;\n+    font-size: 10px;\n+    font-weight: 500;\n+    background: var(--button-bg);\n+    border: 1px solid var(--button-border);\n+    border-radius: 4px;\n+    color: var(--button-text);\n+    height: 22px;\n+    padding: 0 10px;\n+    cursor: pointer;\n+  }\n+\n+  .rebuild-btn:hover {\n+    filter: brightness(1.1);\n+  }\n+\n+  .rebuild-btn:disabled {\n+    opacity: 0.5;\n+    cursor: not-allowed;\n+    filter: none;\n+  }\n+\n+  .rebuild-icon {\n+    width: 11px;\n+    height: 11px;\n+    color: var(--accent);\n+    flex-shrink: 0;\n   }\n \n   .status-error {","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"30124323-4ff4-4393-98f1-977724da9b72"}
{"parentUuid":"bf8b4c47-975f-4c23-9a9e-905be5fc1178","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","message":{"model":"claude-sonnet-4-6","id":"msg_013zGYC2STUHQMucMtXbsj2R","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The diff is quite large. Let me also read the current App.svelte to understand the full context.","signature":"EogCCkYICxgCKkCgBIOkKkhY+6Ija7y63BSrx6YlaJ5ydz1L2gLINNKRCJHYLTrg8MDfVF7pMui68SGcAqC9BRCdhNbflJg3NsR+EgynbFCq6H1iS82QnK8aDIV3hZTOmtggaqO30SIwNXTgLlq4bBCIbABUrc/bwzDA84Y252m5fXg4d+yBzOHspmJASAYpoH8qzCxmaTbtKnDNzqZc0UHRa0fTU/Kf3jEbZib4LGLxbujL21vhDWHLSODAaWoJycWfRw9UiF0d3Lux618JJS7+Wn6JWrjIAb4wv2c/nno92x/6rnZ7pKv2mdlznppzO5uqWK/B6dATO0vT/Oryd51d3T6awCzEzHRbGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":10564,"cache_read_input_tokens":35123,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":10564},"output_tokens":9,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMNqH3LsK82nzAiVjac4","type":"assistant","uuid":"8e717808-4879-4fa6-ba00-1ae2d370e301","timestamp":"2026-02-21T14:32:24.913Z"}
{"parentUuid":"8e717808-4879-4fa6-ba00-1ae2d370e301","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_013zGYC2STUHQMucMtXbsj2R","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Vs9HrM1wv32uxsJo2wbHFH","name":"Read","input":{"file_path":"/Users/al02402336/everything/src/App.svelte"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":10564,"cache_read_input_tokens":35123,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":10564},"output_tokens":9,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMNqH3LsK82nzAiVjac4","type":"assistant","uuid":"9da282ea-e4a9-49c5-8d9d-6c67bb4e3f6a","timestamp":"2026-02-21T14:32:25.719Z"}
{"parentUuid":"9da282ea-e4a9-49c5-8d9d-6c67bb4e3f6a","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01Vs9HrM1wv32uxsJo2wbHFH","toolUseID":"toolu_01Vs9HrM1wv32uxsJo2wbHFH","timestamp":"2026-02-21T14:32:26.032Z","uuid":"ed6cad3a-a6b0-48b7-9f0e-a959c0143470"}
{"parentUuid":"9da282ea-e4a9-49c5-8d9d-6c67bb4e3f6a","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Vs9HrM1wv32uxsJo2wbHFH","type":"tool_result","content":"     1â†’<script>\n     2â†’  import { onDestroy, onMount, tick } from 'svelte';\n     3â†’  import { invoke } from '@tauri-apps/api/core';\n     4â†’  import { listen } from '@tauri-apps/api/event';\n     5â†’  import { getCurrentWindow } from '@tauri-apps/api/window';\n     6â†’  import { startDrag } from '@crabnebula/tauri-plugin-drag';\n     7â†’\n     8â†’  const rowHeight = 30;\n     9â†’  const PAGE_SIZE = 500;\n    10â†’  let homePrefix = '';\n    11â†’  const COL_WIDTHS_KEY = 'REDACTED';\n    12â†’  const THEME_KEY = 'everything-theme';\n    13â†’  const columnKeys = ['name', 'path', 'size', 'modified'];\n    14â†’  const minColumnWidth = {\n    15â†’    name: 180,\n    16â†’    path: 240,\n    17â†’    size: 75,\n    18â†’    modified: 150\n    19â†’  };\n    20â†’  const defaultColumnRatios = {\n    21â†’    name: 0.3,\n    22â†’    path: 0.45,\n    23â†’    size: 0.1\n    24â†’  };\n    25â†’\n    26â†’  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || 'dark'; } catch { return 'dark'; } })();\n    27â†’  function cycleTheme() {\n    28â†’    theme = theme === 'dark' ? 'light' : 'dark';\n    29â†’    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n    30â†’  }\n    31â†’\n    32â†’  let query = '';\n    33â†’  let results = [];\n    34â†’  let totalResults = 0;\n    35â†’  let totalResultsKnown = false;\n    36â†’\n    37â†’  let dbLatencyMs = null;\n    38â†’  let dbLastQuery = '';\n    39â†’  let searchModeLabel = '';\n    40â†’  let selectedIndices = new Set();\n    41â†’  let selectionAnchor = -1;\n    42â†’  let lastSelectedIndex = -1;\n    43â†’  let editing = {\n    44â†’    active: false,\n    45â†’    path: '',\n    46â†’    index: -1,\n    47â†’    draftName: ''\n    48â†’  };\n    49â†’\n    50â†’  let renameOverlay = { top: 0, left: 0, width: 0 };\n    51â†’\n    52â†’  let indexStatus = {\n    53â†’    state: 'Indexing',\n    54â†’    entriesCount: 0,\n    55â†’    lastUpdated: null,\n    56â†’    permissionErrors: 0,\n    57â†’    message: null,\n    58â†’    isCatchup: false\n    59â†’  };\n    60â†’\n    61â†’  let indexingStartTime = null;\n    62â†’  let indexingElapsed = '';\n    63â†’  let indexingFinishedAt = '';\n    64â†’\n    65â†’  let sortBy = 'name';\n    66â†’  let sortDir = 'asc';\n    67â†’\n    68â†’  let hasMore = true;\n    69â†’  let loadingMore = false;\n    70â†’  let searchGeneration = 0;\n    71â†’\n    72â†’  let scanned = 0;\n    73â†’\n    74â†’  let searchInputEl;\n    75â†’  let renameInputEl;\n    76â†’  let tableAreaEl;\n    77â†’  let tableContainer;\n    78â†’  let tableResizeObserver = null;\n    79â†’  let viewportResizeRaf = null;\n    80â†’  let scrollTop = 0;\n    81â†’  let headerScrollLeft = 0;\n    82â†’  let viewportHeight = 520;\n    83â†’  let lastTableWidth = 0;\n    84â†’  let resizingColumn = '';\n    85â†’  let resizeCleanup = null;\n    86â†’  let colWidths = {\n    87â†’    name: 250,\n    88â†’    path: 350,\n    89â†’    size: 75,\n    90â†’    modified: 150\n    91â†’  };\n    92â†’\n    93â†’  let contextMenu = {\n    94â†’    visible: false,\n    95â†’    x: 0,\n    96â†’    y: 0\n    97â†’  };\n    98â†’\n    99â†’  let platform = '';\n   100â†’  let toast = '';\n   101â†’  let searchTimer;\n   102â†’  let lastSearchFiredAt = 0;\n   103â†’  let toastTimer;\n   104â†’  let statusRefreshTimer;\n   105â†’  let elapsedTimer;\n   106â†’  let statusRefreshInFlight = false;\n   107â†’  let lastReadyCount = 0;\n   108â†’\n   109â†’  const iconCache = new Map();\n   110â†’  const iconLoading = new Set();\n   111â†’\n   112â†’  let highlightCache = new Map();\n   113â†’  let highlightCacheQuery = '';\n   114â†’\n   115â†’  const folderFallbackIcon =\n   116â†’    \"data:image/svg+xml;utf8,\" +\n   117â†’    encodeURIComponent(\n   118â†’      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='1' y='4' width='14' height='10' rx='2' fill='#d9b34f'/><rect x='1' y='2' width='6' height='4' rx='1' fill='#e6ca7a'/></svg>`\n   119â†’    );\n   120â†’  const fileFallbackIcon =\n   121â†’    \"data:image/svg+xml;utf8,\" +\n   122â†’    encodeURIComponent(\n   123â†’      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='3' y='1' width='10' height='14' rx='1.5' fill='#b4bec9'/><rect x='5' y='5' width='6' height='1.2' fill='#8d98a5'/><rect x='5' y='8' width='6' height='1.2' fill='#8d98a5'/></svg>`\n   124â†’    );\n   125â†’\n   126â†’  $: totalHeight = results.length * rowHeight;\n   127â†’  $: startIndex = Math.max(0, Math.floor(scrollTop / rowHeight) - 10);\n   128â†’  $: visibleCount = Math.ceil(viewportHeight / rowHeight) + 20;\n   129â†’  $: endIndex = Math.min(results.length, startIndex + visibleCount);\n   130â†’  $: visibleRows = results.slice(startIndex, endIndex);\n   131â†’  $: translateY = startIndex * rowHeight;\n   132â†’  $: tableMinWidth = colWidths.name + colWidths.path + colWidths.size + colWidths.modified;\n   133â†’  $: tableGridStyle = `--col-name:${colWidths.name}px;--col-path:${colWidths.path}px;--col-size:${colWidths.size}px;--col-modified:${colWidths.modified}px;--table-min-width:${tableMinWidth}px;--header-offset:${-headerScrollLeft}px;`;\n   134â†’\n   135â†’  $: {\n   136â†’    for (const entry of visibleRows) {\n   137â†’      void ensureIcon(entry);\n   138â†’    }\n   139â†’  }\n   140â†’\n   141â†’  function showToast(message) {\n   142â†’    toast = message;\n   143â†’    clearTimeout(toastTimer);\n   144â†’    toastTimer = setTimeout(() => {\n   145â†’      toast = '';\n   146â†’    }, 3000);\n   147â†’  }\n   148â†’\n   149â†’  function bytesToBase64(bytes) {\n   150â†’    let binary = '';\n   151â†’    const chunk = 0x8000;\n   152â†’    for (let i = 0; i < bytes.length; i += chunk) {\n   153â†’      const part = bytes.subarray(i, i + chunk);\n   154â†’      binary += String.fromCharCode(...part);\n   155â†’    }\n   156â†’    return btoa(binary);\n   157â†’  }\n   158â†’\n   159â†’  function highlightSegments(name, q) {\n   160â†’    q = (q || '').trim();\n   161â†’    if (!q) return [{ text: name, hl: false }];\n   162â†’\n   163â†’    // Reset cache when query changes\n   164â†’    if (q !== highlightCacheQuery) {\n   165â†’      highlightCache = new Map();\n   166â†’      highlightCacheQuery = q;\n   167â†’    }\n   168â†’\n   169â†’    // Check cache\n   170â†’    const cached = highlightCache.get(name);\n   171â†’    if (cached) return cached;\n   172â†’\n   173â†’    if (q.includes('/')) q = q.slice(q.lastIndexOf('/') + 1);\n   174â†’    q = q.replace(/[*?]/g, '');\n   175â†’    const terms = q.split(/\\s+/).filter(Boolean);\n   176â†’    if (terms.length === 0) return [{ text: name, hl: false }];\n   177â†’\n   178â†’    const lower = name.toLowerCase();\n   179â†’    const marks = new Uint8Array(name.length);\n   180â†’    for (const t of terms) {\n   181â†’      const tl = t.toLowerCase();\n   182â†’      let idx = lower.indexOf(tl);\n   183â†’      while (idx !== -1) {\n   184â†’        for (let i = idx; i < idx + tl.length; i++) marks[i] = 1;\n   185â†’        idx = lower.indexOf(tl, idx + 1);\n   186â†’      }\n   187â†’    }\n   188â†’\n   189â†’    const segs = [];\n   190â†’    let i = 0;\n   191â†’    while (i < name.length) {\n   192â†’      const m = marks[i];\n   193â†’      let j = i + 1;\n   194â†’      while (j < name.length && marks[j] === m) j++;\n   195â†’      segs.push({ text: name.slice(i, j), hl: m === 1 });\n   196â†’      i = j;\n   197â†’    }\n   198â†’\n   199â†’    highlightCache.set(name, segs);\n   200â†’    return segs;\n   201â†’  }\n   202â†’\n   203â†’  const perFileIconExts = new Set(['exe', 'lnk', 'ico', 'url', 'scr', 'appx']);\n   204â†’\n   205â†’  function iconKey(entry) {\n   206â†’    if (entry.isDir) return '__folder__';\n   207â†’    const ext = (entry.ext || '').toLowerCase();\n   208â†’    if (perFileIconExts.has(ext)) return entry.path;\n   209â†’    return ext || '__file__';\n   210â†’  }\n   211â†’\n   212â†’  function iconFor(entry) {\n   213â†’    return iconCache.get(iconKey(entry)) || (entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n   214â†’  }\n   215â†’\n   216â†’  async function ensureIcon(entry) {\n   217â†’    const key = iconKey(entry);\n   218â†’    if (iconCache.has(key) || iconLoading.has(key)) {\n   219â†’      return;\n   220â†’    }\n   221â†’\n   222â†’    iconLoading.add(key);\n   223â†’    try {\n   224â†’      const bytes = await invoke('get_file_icon', {\n   225â†’        path: entry.path,\n   226â†’        ext: entry.isDir ? 'folder' : entry.ext || '',\n   227â†’      });\n   228â†’      if (Array.isArray(bytes) && bytes.length > 0) {\n   229â†’        const image = `data:image/png;base64,${bytesToBase64(Uint8Array.from(bytes))}`;\n   230â†’        iconCache.set(key, image);\n   231â†’      } else {\n   232â†’        iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n   233â†’      }\n   234â†’    } catch {\n   235â†’      iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n   236â†’    } finally {\n   237â†’      iconLoading.delete(key);\n   238â†’    }\n   239â†’  }\n   240â†’\n   241â†’  function syncColumnWidthsToContainer() {\n   242â†’    const width = tableContainer?.clientWidth || tableAreaEl?.clientWidth;\n   243â†’    if (!width || lastTableWidth !== 0) {\n   244â†’      return;\n   245â†’    }\n   246â†’\n   247â†’    const saved = loadColWidths();\n   248â†’    if (saved) {\n   249â†’      const total = columnKeys.reduce((s, k) => s + saved[k], 0);\n   250â†’      if (Math.abs(total - width) > 2) {\n   251â†’        const scale = (width - saved.modified) / (total - saved.modified);\n   252â†’        let scaledName = Math.max(minColumnWidth.name, Math.round(saved.name * scale));\n   253â†’        let scaledSize = Math.max(minColumnWidth.size, Math.round(saved.size * scale));\n   254â†’        let rawPath = width - saved.modified - scaledName - scaledSize;\n   255â†’        if (rawPath < minColumnWidth.path) {\n   256â†’          const shortfall = minColumnWidth.path - rawPath;\n   257â†’          const nameReduction = Math.min(shortfall, scaledName - minColumnWidth.name);\n   258â†’          scaledName -= nameReduction;\n   259â†’          const remaining = shortfall - nameReduction;\n   260â†’          if (remaining > 0) {\n   261â†’            scaledSize -= Math.min(remaining, scaledSize - minColumnWidth.size);\n   262â†’          }\n   263â†’          rawPath = width - saved.modified - scaledName - scaledSize;\n   264â†’        }\n   265â†’        const scaledPath = Math.max(minColumnWidth.path, rawPath);\n   266â†’        colWidths = { name: scaledName, path: scaledPath, size: scaledSize, modified: saved.modified };\n   267â†’      } else {\n   268â†’        colWidths = saved;\n   269â†’      }\n   270â†’    } else {\n   271â†’      const fixedModified = minColumnWidth.modified;\n   272â†’      const rest = width - fixedModified;\n   273â†’      const ratioSum = defaultColumnRatios.name + defaultColumnRatios.path + defaultColumnRatios.size;\n   274â†’      colWidths = {\n   275â†’        name: Math.max(minColumnWidth.name, Math.round(rest * defaultColumnRatios.name / ratioSum)),\n   276â†’        path: Math.max(minColumnWidth.path, Math.round(rest * defaultColumnRatios.path / ratioSum)),\n   277â†’        size: Math.max(minColumnWidth.size, Math.round(rest * defaultColumnRatios.size / ratioSum)),\n   278â†’        modified: fixedModified\n   279â†’      };\n   280â†’    }\n   281â†’    lastTableWidth = width;\n   282â†’  }\n   283â†’\n   284â†’  function loadColWidths() {\n   285â†’    try {\n   286â†’      const raw = localStorage.getItem(COL_WIDTHS_KEY);\n   287â†’      if (!raw) return null;\n   288â†’      const parsed = JSON.parse(raw);\n   289â†’      for (const key of columnKeys) {\n   290â†’        if (typeof parsed[key] !== 'number' || parsed[key] < (minColumnWidth[key] || 0)) return null;\n   291â†’      }\n   292â†’      return parsed;\n   293â†’    } catch {\n   294â†’      return null;\n   295â†’    }\n   296â†’  }\n   297â†’\n   298â†’  function saveColWidths() {\n   299â†’    localStorage.setItem(COL_WIDTHS_KEY, JSON.stringify(colWidths));\n   300â†’  }\n   301â†’\n   302â†’  function updateViewportHeight() {\n   303â†’    viewportHeight = tableContainer?.clientHeight || 520;\n   304â†’    syncColumnWidthsToContainer();\n   305â†’  }\n   306â†’\n   307â†’  function scheduleViewportHeightUpdate() {\n   308â†’    if (viewportResizeRaf !== null) {\n   309â†’      return;\n   310â†’    }\n   311â†’    viewportResizeRaf = requestAnimationFrame(() => {\n   312â†’      viewportResizeRaf = null;\n   313â†’      updateViewportHeight();\n   314â†’    });\n   315â†’  }\n   316â†’\n   317â†’  function startColumnResize(event, leftKey) {\n   318â†’    event.preventDefault();\n   319â†’    event.stopPropagation();\n   320â†’\n   321â†’    const index = columnKeys.indexOf(leftKey);\n   322â†’    if (index < 0 || index >= columnKeys.length - 1) {\n   323â†’      return;\n   324â†’    }\n   325â†’\n   326â†’    const startX = event.clientX;\n   327â†’    const startLeft = colWidths[leftKey];\n   328â†’    const rightKey = columnKeys[index + 1];\n   329â†’    const startRight = colWidths[rightKey];\n   330â†’\n   331â†’    resizeCleanup?.();\n   332â†’    resizingColumn = leftKey;\n   333â†’\n   334â†’    const onMove = (moveEvent) => {\n   335â†’      const delta = Math.round(moveEvent.clientX - startX);\n   336â†’      if (leftKey === 'name') {\n   337â†’        // Two-column trade: name and path swap space, each respects its minimum\n   338â†’        const nextLeft = Math.max(\n   339â†’          minColumnWidth[leftKey],\n   340â†’          Math.min(startLeft + delta, startLeft + startRight - minColumnWidth[rightKey])\n   341â†’        );\n   342â†’        const nextRight = startLeft + startRight - nextLeft;\n   343â†’        colWidths = { ...colWidths, [leftKey]: nextLeft, [rightKey]: nextRight };\n   344â†’      } else {\n   345â†’        // path splitter: path grows unconstrained (allows horizontal scroll on right drag)\n   346â†’        const nextLeft = Math.max(minColumnWidth[leftKey], startLeft + delta);\n   347â†’        colWidths = { ...colWidths, [leftKey]: nextLeft };\n   348â†’      }\n   349â†’    };\n   350â†’\n   351â†’    const onUp = () => {\n   352â†’      cleanup();\n   353â†’    };\n   354â†’\n   355â†’    const cleanup = () => {\n   356â†’      window.removeEventListener('mousemove', onMove);\n   357â†’      window.removeEventListener('mouseup', onUp);\n   358â†’      document.body.style.cursor = '';\n   359â†’      document.body.style.userSelect = '';\n   360â†’      resizingColumn = '';\n   361â†’      saveColWidths();\n   362â†’      if (resizeCleanup === cleanup) {\n   363â†’        resizeCleanup = null;\n   364â†’      }\n   365â†’    };\n   366â†’\n   367â†’    resizeCleanup = cleanup;\n   368â†’    document.body.style.cursor = 'col-resize';\n   369â†’    document.body.style.userSelect = 'none';\n   370â†’    window.addEventListener('mousemove', onMove);\n   371â†’    window.addEventListener('mouseup', onUp);\n   372â†’  }\n   373â†’\n   374â†’  function selectedPaths() {\n   375â†’    const sorted = [...selectedIndices].sort((a, b) => a - b);\n   376â†’    return sorted.map((idx) => results[idx]).filter(Boolean).map((entry) => entry.path);\n   377â†’  }\n   378â†’\n   379â†’  function clearSelection() {\n   380â†’    selectedIndices = new Set();\n   381â†’    selectionAnchor = -1;\n   382â†’    lastSelectedIndex = -1;\n   383â†’  }\n   384â†’\n   385â†’  function selectSingle(index) {\n   386â†’    selectedIndices = new Set([index]);\n   387â†’    selectionAnchor = index;\n   388â†’    lastSelectedIndex = index;\n   389â†’  }\n   390â†’\n   391â†’  function selectToggle(index) {\n   392â†’    const next = new Set(selectedIndices);\n   393â†’    if (next.has(index)) {\n   394â†’      next.delete(index);\n   395â†’    } else {\n   396â†’      next.add(index);\n   397â†’    }\n   398â†’    selectedIndices = next;\n   399â†’    selectionAnchor = index;\n   400â†’    lastSelectedIndex = index;\n   401â†’  }\n   402â†’\n   403â†’  function selectRange(index) {\n   404â†’    const anchor = selectionAnchor >= 0 ? selectionAnchor : index;\n   405â†’    const [from, to] = [Math.min(anchor, index), Math.max(anchor, index)];\n   406â†’    const next = new Set();\n   407â†’    for (let i = from; i <= to; i += 1) {\n   408â†’      next.add(i);\n   409â†’    }\n   410â†’    selectedIndices = next;\n   411â†’    lastSelectedIndex = index;\n   412â†’  }\n   413â†’\n   414â†’  function primaryEntry() {\n   415â†’    const idx = lastSelectedIndex >= 0 ? lastSelectedIndex : -1;\n   416â†’    return idx >= 0 ? results[idx] : null;\n   417â†’  }\n   418â†’\n   419â†’  async function refreshStatus() {\n   420â†’    if (statusRefreshInFlight) {\n   421â†’      return;\n   422â†’    }\n   423â†’    statusRefreshInFlight = true;\n   424â†’    try {\n   425â†’      const status = await invoke('get_index_status');\n   426â†’      const prevState = indexStatus.state;\n   427â†’      indexStatus = {\n   428â†’        state: status.state,\n   429â†’        entriesCount: status.entriesCount,\n   430â†’        lastUpdated: status.lastUpdated,\n   431â†’        permissionErrors: status.permissionErrors ?? 0,\n   432â†’        message: status.message\n   433â†’      };\n   434â†’      if (status.state === 'Indexing' && prevState !== 'Indexing') {\n   435â†’        startElapsedTimer();\n   436â†’      } else if (status.state !== 'Indexing' && prevState === 'Indexing') {\n   437â†’        stopElapsedTimer();\n   438â†’      }\n   439â†’      if (typeof status.scanned === 'number') {\n   440â†’        scanned = status.scanned;\n   441â†’      }\n   442â†’      if (status.state === 'Ready' && prevState !== 'Ready') {\n   443â†’        scheduleSearch();\n   444â†’      }\n   445â†’    } catch (err) {\n   446â†’      showToast(`Failed to get status: ${String(err)}`);\n   447â†’    } finally {\n   448â†’      statusRefreshInFlight = false;\n   449â†’    }\n   450â†’  }\n   451â†’\n   452â†’  function scheduleSearch(preserveScroll = false) {\n   453â†’    searchGeneration += 1;\n   454â†’    const scheduledGen = searchGeneration;\n   455â†’    clearTimeout(searchTimer);\n   456â†’\n   457â†’    const now = performance.now();\n   458â†’    if (now - lastSearchFiredAt >= 200) {\n   459â†’      // Leading edge: fire immediately if enough time has passed\n   460â†’      lastSearchFiredAt = now;\n   461â†’      void runSearch(preserveScroll);\n   462â†’    } else {\n   463â†’      // Trailing edge: debounce\n   464â†’      searchTimer = setTimeout(() => {\n   465â†’        if (scheduledGen !== searchGeneration) {\n   466â†’          return;\n   467â†’        }\n   468â†’        lastSearchFiredAt = performance.now();\n   469â†’        void runSearch(preserveScroll);\n   470â†’      }, 200);\n   471â†’    }\n   472â†’  }\n   473â†’\n   474â†’  async function runSearch(preserveScroll = false) {\n   475â†’    searchGeneration += 1;\n   476â†’    const gen = searchGeneration;\n   477â†’    const searchQuery = query;\n   478â†’    const searchSortBy = sortBy;\n   479â†’    const searchSortDir = sortDir;\n   480â†’    const startedAt = performance.now();\n   481â†’    try {\n   482â†’      const keepPaths = new Set(selectedPaths());\n   483â†’      const next = await invoke('search', {\n   484â†’        query: searchQuery,\n   485â†’        limit: PAGE_SIZE,\n   486â†’        offset: 0,\n   487â†’        sortBy: searchSortBy,\n   488â†’        sortDir: searchSortDir\n   489â†’      });\n   490â†’\n   491â†’      if (gen !== searchGeneration) return;\n   492â†’\n   493â†’      dbLatencyMs = Math.round(performance.now() - startedAt);\n   494â†’      dbLastQuery = searchQuery;\n   495â†’      const entries = Array.isArray(next.entries) ? next.entries : [];\n   496â†’      searchModeLabel = next.modeLabel || '';\n   497â†’      results = entries;\n   498â†’      if (next.totalCount > 0) {\n   499â†’        totalResults = next.totalCount;\n   500â†’        totalResultsKnown = true;\n   501â†’      } else {\n   502â†’        totalResults = entries.length;\n   503â†’        totalResultsKnown = false;\n   504â†’      }\n   505â†’      hasMore = totalResultsKnown ? results.length < totalResults : entries.length >= PAGE_SIZE;\n   506â†’      if (!preserveScroll && tableContainer) tableContainer.scrollTop = 0;\n   507â†’\n   508â†’      const restored = new Set();\n   509â†’      for (let i = 0; i < results.length; i += 1) {\n   510â†’        if (keepPaths.has(results[i].path)) {\n   511â†’          restored.add(i);\n   512â†’        }\n   513â†’      }\n   514â†’      selectedIndices = restored;\n   515â†’\n   516â†’      updateViewportHeight();\n   517â†’    } catch (err) {\n   518â†’      if (gen !== searchGeneration) return;\n   519â†’      showToast(`Search failed: ${String(err)}`);\n   520â†’    }\n   521â†’  }\n   522â†’\n   523â†’  async function loadMore() {\n   524â†’    if (!hasMore || loadingMore) return;\n   525â†’    const gen = searchGeneration;\n   526â†’    loadingMore = true;\n   527â†’    try {\n   528â†’      const batch = await invoke('search', {\n   529â†’        query,\n   530â†’        limit: PAGE_SIZE,\n   531â†’        offset: results.length,\n   532â†’        sortBy: sortBy,\n   533â†’        sortDir: sortDir\n   534â†’      });\n   535â†’      if (gen !== searchGeneration) return;\n   536â†’      const arr = Array.isArray(batch.entries) ? batch.entries : [];\n   537â†’      if (arr.length > 0) results = [...results, ...arr];\n   538â†’      hasMore = totalResultsKnown ? results.length < totalResults : arr.length >= PAGE_SIZE;\n   539â†’    } catch (err) {\n   540â†’      showToast(`Failed to load more: ${String(err)}`);\n   541â†’    } finally {\n   542â†’      loadingMore = false;\n   543â†’    }\n   544â†’  }\n   545â†’\n   546â†’  function moveSelection(delta, withRange = false) {\n   547â†’    if (results.length === 0) {\n   548â†’      return;\n   549â†’    }\n   550â†’\n   551â†’    const current = lastSelectedIndex >= 0 ? lastSelectedIndex : 0;\n   552â†’    const next = Math.max(0, Math.min(results.length - 1, current + delta));\n   553â†’\n   554â†’    if (withRange) {\n   555â†’      selectRange(next);\n   556â†’    } else {\n   557â†’      selectSingle(next);\n   558â†’    }\n   559â†’\n   560â†’    const top = next * rowHeight;\n   561â†’    const bottom = top + rowHeight;\n   562â†’    if (top < scrollTop) {\n   563â†’      tableContainer.scrollTop = top;\n   564â†’    } else if (bottom > scrollTop + viewportHeight) {\n   565â†’      tableContainer.scrollTop = bottom - viewportHeight;\n   566â†’    }\n   567â†’  }\n   568â†’\n   569â†’  function handleHeaderSort(column) {\n   570â†’    if (sortBy === column) {\n   571â†’      sortDir = sortDir === 'asc' ? 'desc' : 'asc';\n   572â†’    } else {\n   573â†’      sortBy = column;\n   574â†’      sortDir = 'asc';\n   575â†’    }\n   576â†’    if (tableContainer) tableContainer.scrollTop = 0;\n   577â†’    void runSearch();\n   578â†’  }\n   579â†’\n   580â†’  function handleRowClick(event, index) {\n   581â†’    contextMenu.visible = false;\n   582â†’\n   583â†’    if (event.shiftKey) {\n   584â†’      selectRange(index);\n   585â†’      return;\n   586â†’    }\n   587â†’\n   588â†’    if (event.metaKey || event.ctrlKey) {\n   589â†’      selectToggle(index);\n   590â†’      return;\n   591â†’    }\n   592â†’\n   593â†’    selectSingle(index);\n   594â†’  }\n   595â†’\n   596â†’  function handleRowContextMenu(event, index) {\n   597â†’    event.preventDefault();\n   598â†’\n   599â†’    if (!selectedIndices.has(index)) {\n   600â†’      selectSingle(index);\n   601â†’    }\n   602â†’\n   603â†’    if (platform === 'windows' || platform === 'macos') {\n   604â†’      contextMenu.visible = false;\n   605â†’      const paths = selectedPaths();\n   606â†’      if (paths.length > 0) {\n   607â†’        invoke('show_context_menu', {\n   608â†’          paths,\n   609â†’          x: event.clientX,\n   610â†’          y: event.clientY,\n   611â†’          singleSelection: selectedIndices.size === 1\n   612â†’        });\n   613â†’      }\n   614â†’      return;\n   615â†’    }\n   616â†’\n   617â†’    contextMenu = {\n   618â†’      visible: true,\n   619â†’      x: event.clientX,\n   620â†’      y: event.clientY\n   621â†’    };\n   622â†’  }\n   623â†’\n   624â†’  function handleRowA11yKeydown(event, index) {\n   625â†’    if (event.key === ' ' || event.key === 'Enter') {\n   626â†’      event.preventDefault();\n   627â†’      handleRowClick(event, index);\n   628â†’    }\n   629â†’  }\n   630â†’\n   631â†’  const DRAG_THRESHOLD = 5;\n   632â†’  let dragCleanup = null;\n   633â†’  const dragImgCache = new Map();\n   634â†’\n   635â†’  function dragPathsForIndex(index) {\n   636â†’    const entry = results[index];\n   637â†’    if (!entry) {\n   638â†’      return [];\n   639â†’    }\n   640â†’\n   641â†’    if (selectedIndices.has(index) && selectedIndices.size > 0) {\n   642â†’      return selectedPaths();\n   643â†’    }\n   644â†’\n   645â†’    return [entry.path];\n   646â†’  }\n   647â†’\n   648â†’  function getDragIconEl(entry) {\n   649â†’    const src = iconFor(entry);\n   650â†’    let img = dragImgCache.get(src);\n   651â†’    if (!img) {\n   652â†’      img = new Image();\n   653â†’      img.src = src;\n   654â†’      dragImgCache.set(src, img);\n   655â†’    }\n   656â†’    return img.complete && img.naturalWidth > 0 ? img : null;\n   657â†’  }\n   658â†’\n   659â†’  function fillRoundRect(ctx, x, y, w, h, r) {\n   660â†’    ctx.beginPath();\n   661â†’    ctx.moveTo(x + r, y);\n   662â†’    ctx.arcTo(x + w, y, x + w, y + h, r);\n   663â†’    ctx.arcTo(x + w, y + h, x, y + h, r);\n   664â†’    ctx.arcTo(x, y + h, x, y, r);\n   665â†’    ctx.arcTo(x, y, x + w, y, r);\n   666â†’    ctx.closePath();\n   667â†’    ctx.fill();\n   668â†’  }\n   669â†’\n   670â†’  function buildDragPreview(index) {\n   671â†’    const entry = results[index];\n   672â†’    if (!entry) return null;\n   673â†’\n   674â†’    const count = selectedIndices.has(index) ? selectedIndices.size : 1;\n   675â†’    const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\n   676â†’\n   677â†’    const w = 260;\n   678â†’    const h = 28;\n   679â†’    const stackGap = count > 1 ? 4 : 0;\n   680â†’\n   681â†’    const canvas = document.createElement('canvas');\n   682â†’    canvas.width = w;\n   683â†’    canvas.height = h + stackGap;\n   684â†’    const ctx = canvas.getContext('2d');\n   685â†’\n   686â†’    if (count > 1) {\n   687â†’      ctx.globalAlpha = 0.35;\n   688â†’      ctx.fillStyle = isDark ? '#5a6070' : '#b0c4de';\n   689â†’      fillRoundRect(ctx, 3, 0, w - 3, h, 5);\n   690â†’      ctx.globalAlpha = 1.0;\n   691â†’    }\n   692â†’\n   693â†’    const ry = stackGap;\n   694â†’    ctx.fillStyle = isDark ? 'rgba(58, 64, 74, 0.94)' : 'rgba(214, 231, 255, 0.94)';\n   695â†’    fillRoundRect(ctx, 0, ry, w, h, 5);\n   696â†’\n   697â†’    ctx.strokeStyle = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';\n   698â†’    ctx.lineWidth = 0.5;\n   699â†’    ctx.beginPath();\n   700â†’    ctx.moveTo(5, ry);\n   701â†’    ctx.arcTo(w, ry, w, ry + h, 5);\n   702â†’    ctx.arcTo(w, ry + h, 0, ry + h, 5);\n   703â†’    ctx.arcTo(0, ry + h, 0, ry, 5);\n   704â†’    ctx.arcTo(0, ry, w, ry, 5);\n   705â†’    ctx.closePath();\n   706â†’    ctx.stroke();\n   707â†’\n   708â†’    const iconEl = getDragIconEl(entry);\n   709â†’    if (iconEl) {\n   710â†’      ctx.drawImage(iconEl, 6, ry + 6, 16, 16);\n   711â†’    } else {\n   712â†’      ctx.fillStyle = entry.isDir ? '#d9b34f' : '#8d98a5';\n   713â†’      fillRoundRect(ctx, 6, ry + 6, 16, 16, 2);\n   714â†’    }\n   715â†’\n   716â†’    ctx.fillStyle = isDark ? '#e6e6e8' : '#1a1a1a';\n   717â†’    ctx.font = '12px -apple-system, \"SF Pro Text\", system-ui, sans-serif';\n   718â†’    ctx.textBaseline = 'middle';\n   719â†’\n   720â†’    let nameMaxW = w - 34;\n   721â†’    if (count > 1) nameMaxW -= 34;\n   722â†’\n   723â†’    let name = entry.name;\n   724â†’    if (ctx.measureText(name).width > nameMaxW) {\n   725â†’      while (name.length > 4 && ctx.measureText(name + '\\u2026').width > nameMaxW) {\n   726â†’        name = name.slice(0, -1);\n   727â†’      }\n   728â†’      name += '\\u2026';\n   729â†’    }\n   730â†’    ctx.fillText(name, 28, ry + h / 2 + 1);\n   731â†’\n   732â†’    if (count > 1) {\n   733â†’      const badge = String(count);\n   734â†’      ctx.font = 'bold 10px -apple-system, system-ui, sans-serif';\n   735â†’      const tw = ctx.measureText(badge).width;\n   736â†’      const bw = Math.max(20, tw + 10);\n   737â†’      const bx = w - bw - 6;\n   738â†’      const by = ry + (h - 18) / 2;\n   739â†’\n   740â†’      ctx.fillStyle = isDark ? '#5b8bd9' : '#007aff';\n   741â†’      fillRoundRect(ctx, bx, by, bw, 18, 9);\n   742â†’\n   743â†’      ctx.fillStyle = '#ffffff';\n   744â†’      ctx.textAlign = 'center';\n   745â†’      ctx.textBaseline = 'middle';\n   746â†’      ctx.fillText(badge, bx + bw / 2, by + 9);\n   747â†’    }\n   748â†’\n   749â†’    return canvas.toDataURL('image/png');\n   750â†’  }\n   751â†’\n   752â†’  function handleRowMouseDown(event, index) {\n   753â†’    if (event.button !== 0) return;\n   754â†’    if (event.metaKey || event.ctrlKey || event.shiftKey) return;\n   755â†’    if (editing.active) return;\n   756â†’\n   757â†’    const startX = event.clientX;\n   758â†’    const startY = event.clientY;\n   759â†’    let dragging = false;\n   760â†’\n   761â†’    dragCleanup?.();\n   762â†’\n   763â†’    const onMove = (e) => {\n   764â†’      if (dragging) return;\n   765â†’      const dx = e.clientX - startX;\n   766â†’      const dy = e.clientY - startY;\n   767â†’      if (dx * dx + dy * dy < DRAG_THRESHOLD * DRAG_THRESHOLD) return;\n   768â†’\n   769â†’      dragging = true;\n   770â†’      cleanup();\n   771â†’\n   772â†’      if (!selectedIndices.has(index)) {\n   773â†’        selectSingle(index);\n   774â†’      }\n   775â†’\n   776â†’      const paths = dragPathsForIndex(index);\n   777â†’      if (paths.length > 0) {\n   778â†’        const icon = buildDragPreview(index);\n   779â†’        startDrag({ item: paths, icon }).catch(() => {});\n   780â†’      }\n   781â†’    };\n   782â†’\n   783â†’    const onUp = () => cleanup();\n   784â†’\n   785â†’    const cleanup = () => {\n   786â†’      window.removeEventListener('mousemove', onMove);\n   787â†’      window.removeEventListener('mouseup', onUp);\n   788â†’      if (dragCleanup === cleanup) dragCleanup = null;\n   789â†’    };\n   790â†’\n   791â†’    dragCleanup = cleanup;\n   792â†’    window.addEventListener('mousemove', onMove);\n   793â†’    window.addEventListener('mouseup', onUp);\n   794â†’  }\n   795â†’\n   796â†’  async function handleRowDoubleClick(index) {\n   797â†’    if (!selectedIndices.has(index) || selectedIndices.size > 1) {\n   798â†’      selectSingle(index);\n   799â†’      await tick();\n   800â†’    }\n   801â†’    await invoke('open', { paths: [results[index].path] }).catch((err) => {\n   802â†’      showToast(`Failed to open: ${String(err)}`);\n   803â†’    });\n   804â†’  }\n   805â†’\n   806â†’  function closeContextMenu() {\n   807â†’    contextMenu = {\n   808â†’      ...contextMenu,\n   809â†’      visible: false\n   810â†’    };\n   811â†’  }\n   812â†’\n   813â†’  async function openSelected() {\n   814â†’    const paths = selectedPaths();\n   815â†’    if (paths.length === 0) {\n   816â†’      return;\n   817â†’    }\n   818â†’\n   819â†’    try {\n   820â†’      await invoke('open', { paths });\n   821â†’    } catch (err) {\n   822â†’      showToast(`Failed to open: ${String(err)}`);\n   823â†’    }\n   824â†’  }\n   825â†’\n   826â†’  async function openWithFallback() {\n   827â†’    const target = primaryEntry();\n   828â†’    if (!target) {\n   829â†’      return;\n   830â†’    }\n   831â†’\n   832â†’    try {\n   833â†’      await invoke('open_with', { path: target.path });\n   834â†’    } catch (err) {\n   835â†’      showToast(`Open With failed: ${String(err)}`);\n   836â†’    }\n   837â†’  }\n   838â†’\n   839â†’  async function revealSelected() {\n   840â†’    const paths = selectedPaths();\n   841â†’    if (paths.length === 0) {\n   842â†’      return;\n   843â†’    }\n   844â†’\n   845â†’    try {\n   846â†’      await invoke('reveal_in_finder', { paths });\n   847â†’    } catch (err) {\n   848â†’      showToast(`Failed to reveal in Finder: ${String(err)}`);\n   849â†’    }\n   850â†’  }\n   851â†’\n   852â†’  async function copySelectedPaths() {\n   853â†’    const paths = selectedPaths();\n   854â†’    if (paths.length === 0) {\n   855â†’      return;\n   856â†’    }\n   857â†’\n   858â†’    try {\n   859â†’      await invoke('copy_paths', { paths });\n   860â†’      showToast(`Copied ${paths.length} path(s)`);\n   861â†’    } catch (err) {\n   862â†’      showToast(`Failed to copy path: ${String(err)}`);\n   863â†’    }\n   864â†’  }\n   865â†’\n   866â†’  async function copyFiles() {\n   867â†’    const paths = selectedPaths();\n   868â†’    if (paths.length === 0) {\n   869â†’      return;\n   870â†’    }\n   871â†’\n   872â†’    try {\n   873â†’      await invoke('copy_files', { paths });\n   874â†’      showToast(`Copied ${paths.length} item(s)`);\n   875â†’    } catch (err) {\n   876â†’      showToast(`Failed to copy: ${String(err)}`);\n   877â†’    }\n   878â†’  }\n   879â†’\n   880â†’  async function trashSelected() {\n   881â†’    const paths = selectedPaths();\n   882â†’    if (paths.length === 0) {\n   883â†’      return;\n   884â†’    }\n   885â†’\n   886â†’    const message =\n   887â†’      paths.length === 1\n   888â†’        ? 'Move selected item to Trash?'\n   889â†’        : `Move ${paths.length} items to Trash?`;\n   890â†’\n   891â†’    if (!window.confirm(message)) {\n   892â†’      return;\n   893â†’    }\n   894â†’\n   895â†’    try {\n   896â†’      await invoke('move_to_trash', { paths });\n   897â†’      showToast('Moved to Trash.');\n   898â†’      clearSelection();\n   899â†’      await runSearch();\n   900â†’    } catch (err) {\n   901â†’      showToast(`Failed to move to Trash: ${String(err)}`);\n   902â†’    }\n   903â†’  }\n   904â†’\n   905â†’  async function resetIndex() {\n   906â†’    if (indexStatus.state === 'Indexing') {\n   907â†’      showToast('Indexing in progress. Please try again after it completes.');\n   908â†’      return;\n   909â†’    }\n   910â†’\n   911â†’    results = [];\n   912â†’    totalResults = 0;\n   913â†’    totalResultsKnown = false;\n   914â†’    clearSelection();\n   915â†’    scanned = 0;\n   916â†’    dbLatencyMs = null;\n   917â†’    dbLastQuery = '';\n   918â†’    indexStatus = { ...indexStatus, state: 'Indexing', entriesCount: 0, message: null };\n   919â†’    indexingStartTime = Date.now();\n   920â†’    indexingElapsed = '';\n   921â†’    indexingFinishedAt = '';\n   922â†’\n   923â†’    try {\n   924â†’      await invoke('reset_index');\n   925â†’    } catch (err) {\n   926â†’      showToast(`Failed to reset index: ${String(err)}`);\n   927â†’      await refreshStatus();\n   928â†’    }\n   929â†’  }\n   930â†’\n   931â†’  function isMultiSelected() {\n   932â†’    return selectedIndices.size > 1;\n   933â†’  }\n   934â†’\n   935â†’  function autoResizeRenameInput() {\n   936â†’    if (!renameInputEl) return;\n   937â†’    renameInputEl.style.height = '0';\n   938â†’    renameInputEl.style.height = renameInputEl.scrollHeight + 'px';\n   939â†’  }\n   940â†’\n   941â†’  async function startRename() {\n   942â†’    if (isMultiSelected()) {\n   943â†’      return;\n   944â†’    }\n   945â†’\n   946â†’    const idx = lastSelectedIndex;\n   947â†’    if (idx < 0 || !results[idx]) {\n   948â†’      return;\n   949â†’    }\n   950â†’\n   951â†’    const entry = results[idx];\n   952â†’\n   953â†’    // Calculate overlay position mathematically.\n   954â†’    // Name cell text starts at: padding-left(16) + icon(16) + gap(6) = 38px from cell left.\n   955â†’    // Textarea has padding-left: 0 and border: 1.5px, so text starts ~2px from overlay left.\n   956â†’    if (tableContainer) {\n   957â†’      const rect = tableContainer.getBoundingClientRect();\n   958â†’      const cellLeft = rect.left - tableContainer.scrollLeft;\n   959â†’      const textLeft = cellLeft + 38;\n   960â†’      const cellRight = cellLeft + colWidths.name;\n   961â†’      const rowTop = rect.top + idx * rowHeight - tableContainer.scrollTop;\n   962â†’      renameOverlay = {\n   963â†’        top: rowTop,\n   964â†’        left: textLeft - 2,\n   965â†’        width: cellRight - textLeft + 2 - 4\n   966â†’      };\n   967â†’    }\n   968â†’\n   969â†’    editing = {\n   970â†’      active: true,\n   971â†’      path: entry.path,\n   972â†’      index: idx,\n   973â†’      draftName: entry.name\n   974â†’    };\n   975â†’\n   976â†’    await tick();\n   977â†’\n   978â†’    if (renameInputEl) {\n   979â†’      autoResizeRenameInput();\n   980â†’      renameInputEl.focus();\n   981â†’      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n   982â†’      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n   983â†’      renameInputEl.setSelectionRange(0, selectionEnd);\n   984â†’    }\n   985â†’  }\n   986â†’\n   987â†’  function cancelRename() {\n   988â†’    editing = {\n   989â†’      active: false,\n   990â†’      path: '',\n   991â†’      index: -1,\n   992â†’      draftName: ''\n   993â†’    };\n   994â†’  }\n   995â†’\n   996â†’  async function commitRename() {\n   997â†’    if (!editing.active || editing.index < 0 || !results[editing.index]) {\n   998â†’      return;\n   999â†’    }\n  1000â†’\n  1001â†’    const current = results[editing.index];\n  1002â†’    const nextName = editing.draftName;\n  1003â†’\n  1004â†’    try {\n  1005â†’      await invoke('rename', {\n  1006â†’        path: current.path,\n  1007â†’        newName: nextName\n  1008â†’      });\n  1009â†’      cancelRename();\n  1010â†’      await runSearch();\n  1011â†’    } catch (err) {\n  1012â†’      showToast(`Failed to rename: ${String(err)}`);\n  1013â†’      await tick();\n  1014â†’      renameInputEl?.focus();\n  1015â†’    }\n  1016â†’  }\n  1017â†’\n  1018â†’  function onGlobalClick() {\n  1019â†’    closeContextMenu();\n  1020â†’  }\n  1021â†’\n  1022â†’  function onTitleBarMouseDown(event) {\n  1023â†’    if (event.button !== 0) {\n  1024â†’      return;\n  1025â†’    }\n  1026â†’\n  1027â†’    const activeElement = document.activeElement;\n  1028â†’    if (activeElement instanceof HTMLElement && isTextInputTarget(activeElement)) {\n  1029â†’      activeElement.blur();\n  1030â†’    }\n  1031â†’  }\n  1032â†’\n  1033â†’  async function focusSearch() {\n  1034â†’    await getCurrentWindow().show();\n  1035â†’    await getCurrentWindow().setFocus();\n  1036â†’    searchInputEl?.focus();\n  1037â†’    searchInputEl?.select();\n  1038â†’  }\n  1039â†’\n  1040â†’  function isTextInputTarget(target) {\n  1041â†’    return (\n  1042â†’      target instanceof HTMLInputElement ||\n  1043â†’      target instanceof HTMLTextAreaElement ||\n  1044â†’      target?.isContentEditable\n  1045â†’    );\n  1046â†’  }\n  1047â†’\n  1048â†’  async function handleKeydown(event) {\n  1049â†’    const isMetaSelectAll = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'a';\n  1050â†’    const isMetaCopy = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c';\n  1051â†’    const target = event.target;\n  1052â†’    const isTextInput = isTextInputTarget(target);\n  1053â†’\n  1054â†’    if (isMetaCopy && isTextInput) {\n  1055â†’      return;\n  1056â†’    }\n  1057â†’\n  1058â†’    if (isMetaSelectAll) {\n  1059â†’      if (isTextInput) {\n  1060â†’        event.preventDefault();\n  1061â†’        if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n  1062â†’          target.select();\n  1063â†’        }\n  1064â†’        return;\n  1065â†’      }\n  1066â†’    }\n  1067â†’\n  1068â†’    if (editing.active) {\n  1069â†’      if (event.key === 'Enter') {\n  1070â†’        event.preventDefault();\n  1071â†’        await commitRename();\n  1072â†’        return;\n  1073â†’      }\n  1074â†’\n  1075â†’      if (event.key === 'Escape') {\n  1076â†’        event.preventDefault();\n  1077â†’        cancelRename();\n  1078â†’        searchInputEl?.focus();\n  1079â†’        return;\n  1080â†’      }\n  1081â†’      return;\n  1082â†’    }\n  1083â†’\n  1084â†’    if (event.key === 'Escape') {\n  1085â†’      event.preventDefault();\n  1086â†’      clearSelection();\n  1087â†’      searchInputEl?.focus();\n  1088â†’      return;\n  1089â†’    }\n  1090â†’\n  1091â†’    if (event.key === 'ArrowDown') {\n  1092â†’      event.preventDefault();\n  1093â†’      moveSelection(1, event.shiftKey);\n  1094â†’      return;\n  1095â†’    }\n  1096â†’\n  1097â†’    if (event.key === 'ArrowUp') {\n  1098â†’      event.preventDefault();\n  1099â†’      moveSelection(-1, event.shiftKey);\n  1100â†’      return;\n  1101â†’    }\n  1102â†’\n  1103â†’    if (event.key === 'PageDown') {\n  1104â†’      event.preventDefault();\n  1105â†’      moveSelection(Math.floor(viewportHeight / rowHeight), event.shiftKey);\n  1106â†’      return;\n  1107â†’    }\n  1108â†’\n  1109â†’    if (event.key === 'PageUp') {\n  1110â†’      event.preventDefault();\n  1111â†’      moveSelection(-Math.floor(viewportHeight / rowHeight), event.shiftKey);\n  1112â†’      return;\n  1113â†’    }\n  1114â†’\n  1115â†’    if (event.key === 'Enter') {\n  1116â†’      event.preventDefault();\n  1117â†’      if (platform === 'windows') {\n  1118â†’        await openSelected();\n  1119â†’      } else {\n  1120â†’        await startRename();\n  1121â†’      }\n  1122â†’      return;\n  1123â†’    }\n  1124â†’\n  1125â†’    if (event.key === 'F2') {\n  1126â†’      event.preventDefault();\n  1127â†’      await startRename();\n  1128â†’      return;\n  1129â†’    }\n  1130â†’\n  1131â†’    if (event.key === ' ' && !isTextInput) {\n  1132â†’      event.preventDefault();\n  1133â†’      const entry = primaryEntry();\n  1134â†’      if (entry) {\n  1135â†’        await invoke('quick_look', { path: entry.path });\n  1136â†’      }\n  1137â†’      return;\n  1138â†’    }\n  1139â†’\n  1140â†’    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'f') {\n  1141â†’      event.preventDefault();\n  1142â†’      clearSelection();\n  1143â†’      searchInputEl?.focus();\n  1144â†’      searchInputEl?.select();\n  1145â†’      return;\n  1146â†’    }\n  1147â†’\n  1148â†’    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'o') {\n  1149â†’      event.preventDefault();\n  1150â†’      await openSelected();\n  1151â†’      return;\n  1152â†’    }\n  1153â†’\n  1154â†’    if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {\n  1155â†’      event.preventDefault();\n  1156â†’      await revealSelected();\n  1157â†’      return;\n  1158â†’    }\n  1159â†’\n  1160â†’    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c') {\n  1161â†’      event.preventDefault();\n  1162â†’      await copySelectedPaths();\n  1163â†’      return;\n  1164â†’    }\n  1165â†’\n  1166â†’    if (isMetaSelectAll) {\n  1167â†’      event.preventDefault();\n  1168â†’      selectedIndices = new Set(Array.from({ length: results.length }, (_, i) => i));\n  1169â†’      return;\n  1170â†’    }\n  1171â†’\n  1172â†’    if (event.key === 'Delete' || ((event.metaKey || event.ctrlKey) && event.key === 'Backspace')) {\n  1173â†’      if (!isTextInput) {\n  1174â†’        event.preventDefault();\n  1175â†’        await trashSelected();\n  1176â†’      }\n  1177â†’      return;\n  1178â†’    }\n  1179â†’  }\n  1180â†’\n  1181â†’  function formatSize(entry) {\n  1182â†’    if (entry.isDir || entry.size == null) return '';\n  1183â†’    const bytes = entry.size;\n  1184â†’    if (bytes < 1024) return `${bytes} B`;\n  1185â†’    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n  1186â†’    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n  1187â†’    return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n  1188â†’  }\n  1189â†’\n  1190â†’  function formatModified(entry) {\n  1191â†’    if (!entry.mtime) {\n  1192â†’      return '';\n  1193â†’    }\n  1194â†’\n  1195â†’    const d = new Date(entry.mtime * 1000);\n  1196â†’    const pad = (n) => String(n).padStart(2, '0');\n  1197â†’    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;\n  1198â†’  }\n  1199â†’\n  1200â†’  function formatLastUpdated(timestamp) {\n  1201â†’    if (!timestamp) {\n  1202â†’      return '-';\n  1203â†’    }\n  1204â†’\n  1205â†’    return new Date(timestamp * 1000).toLocaleString();\n  1206â†’  }\n  1207â†’\n  1208â†’  function formatElapsed(ms) {\n  1209â†’    const totalSec = Math.floor(ms / 1000);\n  1210â†’    const min = Math.floor(totalSec / 60);\n  1211â†’    const sec = totalSec % 60;\n  1212â†’    return min > 0 ? `${min}m ${sec}s` : `${sec}s`;\n  1213â†’  }\n  1214â†’\n  1215â†’  function updateElapsed() {\n  1216â†’    if (indexingStartTime && indexStatus.state === 'Indexing') {\n  1217â†’      indexingElapsed = formatElapsed(Date.now() - indexingStartTime);\n  1218â†’    }\n  1219â†’  }\n  1220â†’\n  1221â†’  function startElapsedTimer() {\n  1222â†’    clearInterval(elapsedTimer);\n  1223â†’    indexingStartTime = Date.now();\n  1224â†’    indexingElapsed = '0s';\n  1225â†’    indexingFinishedAt = '';\n  1226â†’    elapsedTimer = setInterval(updateElapsed, 1000);\n  1227â†’  }\n  1228â†’\n  1229â†’  function stopElapsedTimer() {\n  1230â†’    clearInterval(elapsedTimer);\n  1231â†’    if (indexingStartTime) {\n  1232â†’      const elapsed = Date.now() - indexingStartTime;\n  1233â†’      indexingFinishedAt = `${formatElapsed(elapsed)}`;\n  1234â†’    }\n  1235â†’    indexingStartTime = null;\n  1236â†’    indexingElapsed = '';\n  1237â†’  }\n  1238â†’\n  1239â†’  function displayPath(path) {\n  1240â†’    if (!path) {\n  1241â†’      return path;\n  1242â†’    }\n  1243â†’\n  1244â†’    if (!homePrefix) {\n  1245â†’      return path;\n  1246â†’    }\n  1247â†’\n  1248â†’    if (path === homePrefix) {\n  1249â†’      return '~';\n  1250â†’    }\n  1251â†’\n  1252â†’    if (path.startsWith(`${homePrefix}/`)) {\n  1253â†’      return `~${path.slice(homePrefix.length)}`;\n  1254â†’    }\n  1255â†’\n  1256â†’    return path;\n  1257â†’  }\n  1258â†’\n  1259â†’  let unlistenFns = [];\n  1260â†’\n  1261â†’  onMount(async () => {\n  1262â†’    const t0 = performance.now();\n  1263â†’    const ms = () => Math.round(performance.now() - t0);\n  1264â†’    const DEBUG_STARTUP = false;\n  1265â†’    const flog = DEBUG_STARTUP ? (msg) => invoke('frontend_log', { msg }).catch(() => {}) : () => {};\n  1266â†’\n  1267â†’    flog(`[startup/fe] onMount entered`);\n  1268â†’\n  1269â†’    updateViewportHeight();\n  1270â†’    flog(`[startup/fe] +${ms()}ms updateViewportHeight done`);\n  1271â†’\n  1272â†’    platform = await invoke('get_platform');\n  1273â†’    flog(`[startup/fe] +${ms()}ms get_platform done`);\n  1274â†’\n  1275â†’    const unlistenProgress = await listen('index_progress', (event) => {\n  1276â†’      scanned = event.payload.scanned;\n  1277â†’      if (indexStatus.state !== 'Indexing') {\n  1278â†’        indexStatus = {\n  1279â†’          ...indexStatus,\n  1280â†’          state: 'Indexing'\n  1281â†’        };\n  1282â†’      }\n  1283â†’    });\n  1284â†’    flog(`[startup/fe] +${ms()}ms listen(index_progress) registered`);\n  1285â†’\n  1286â†’    const unlistenState = await listen('index_state', (event) => {\n  1287â†’      flog(`[startup/fe] index_state event received: ${event.payload.state} at +${ms()}ms`);\n  1288â†’      const prevState = indexStatus.state;\n  1289â†’      indexStatus = {\n  1290â†’        ...indexStatus,\n  1291â†’        state: event.payload.state,\n  1292â†’        message: event.payload.message ?? null,\n  1293â†’        isCatchup: event.payload.isCatchup ?? false\n  1294â†’      };\n  1295â†’\n  1296â†’      if (event.payload.state === 'Indexing' && prevState !== 'Indexing') {\n  1297â†’        if (prevState === 'Ready') {\n  1298â†’          lastReadyCount = indexStatus.entriesCount;\n  1299â†’        }\n  1300â†’        startElapsedTimer();\n  1301â†’      } else if (event.payload.state !== 'Indexing' && prevState === 'Indexing') {\n  1302â†’        stopElapsedTimer();\n  1303â†’      }\n  1304â†’\n  1305â†’      if (event.payload.state === 'Ready') {\n  1306â†’        scheduleSearch();\n  1307â†’      }\n  1308â†’    });\n  1309â†’    flog(`[startup/fe] +${ms()}ms listen(index_state) registered`);\n  1310â†’\n  1311â†’    const unlistenUpdated = await listen('index_updated', (event) => {\n  1312â†’      indexStatus = {\n  1313â†’        ...indexStatus,\n  1314â†’        entriesCount: event.payload.entriesCount,\n  1315â†’        lastUpdated: event.payload.lastUpdated,\n  1316â†’        permissionErrors: event.payload.permissionErrors ?? indexStatus.permissionErrors\n  1317â†’      };\n  1318â†’\n  1319â†’      scheduleSearch(true);\n  1320â†’    });\n  1321â†’\n  1322â†’    const unlistenFocus = await listen('focus_search', () => {\n  1323â†’      void focusSearch();\n  1324â†’    });\n  1325â†’\n  1326â†’    const unlistenCtxMenuAction = await listen('context_menu_action', (event) => {\n  1327â†’      switch (event.payload) {\n  1328â†’        case 'open': void openSelected(); break;\n  1329â†’        case 'quick_look': {\n  1330â†’          const e = primaryEntry();\n  1331â†’          if (e) void invoke('quick_look', { path: e.path });\n  1332â†’          break;\n  1333â†’        }\n  1334â†’        case 'open_with': void openWithFallback(); break;\n  1335â†’        case 'reveal': void revealSelected(); break;\n  1336â†’        case 'copy_files': void copyFiles(); break;\n  1337â†’        case 'copy_path': void copySelectedPaths(); break;\n  1338â†’        case 'trash': void trashSelected(); break;\n  1339â†’        case 'rename': void startRename(); break;\n  1340â†’      }\n  1341â†’    });\n  1342â†’\n  1343â†’    unlistenFns = [unlistenProgress, unlistenState, unlistenUpdated, unlistenFocus, unlistenCtxMenuAction];\n  1344â†’    flog(`[startup/fe] +${ms()}ms all listeners registered`);\n  1345â†’\n  1346â†’    // Fetch backend state IMMEDIATELY after listeners are registered.\n  1347â†’    // Events emitted before listener registration are lost, so this\n  1348â†’    // is the only reliable way to get the current state.\n  1349â†’    await refreshStatus();\n  1350â†’    flog(`[startup/fe] +${ms()}ms refreshStatus done (state=${indexStatus.state})`);\n  1351â†’\n  1352â†’    // Show Svelte UI: remove skeleton, focus search input.\n  1353â†’    await tick();\n  1354â†’    document.getElementById('skeleton')?.remove();\n  1355â†’    await focusSearch();\n  1356â†’    flog(`[startup/fe] +${ms()}ms WINDOW VISIBLE â€” skeleton removed`);\n  1357â†’\n  1358â†’    try {\n  1359â†’      homePrefix = await invoke('get_home_dir');\n  1360â†’    } catch {\n  1361â†’      homePrefix = '';\n  1362â†’    }\n  1363â†’    flog(`[startup/fe] +${ms()}ms get_home_dir done`);\n  1364â†’\n  1365â†’    if (!localStorage.getItem('everything-fda-notice-v1')) {\n  1366â†’      showToast('macOS Full Disk Access permission may be required for full disk search.');\n  1367â†’      localStorage.setItem('everything-fda-notice-v1', '1');\n  1368â†’    }\n  1369â†’    flog(`[startup/fe] +${ms()}ms calling runSearch...`);\n  1370â†’    await runSearch();\n  1371â†’    flog(`[startup/fe] +${ms()}ms runSearch done`);\n  1372â†’\n  1373â†’    if (typeof ResizeObserver !== 'undefined') {\n  1374â†’      tableResizeObserver = new ResizeObserver(() => {\n  1375â†’        scheduleViewportHeightUpdate();\n  1376â†’      });\n  1377â†’      if (tableContainer) {\n  1378â†’        tableResizeObserver.observe(tableContainer);\n  1379â†’      } else if (tableAreaEl) {\n  1380â†’        tableResizeObserver.observe(tableAreaEl);\n  1381â†’      }\n  1382â†’    }\n  1383â†’\n  1384â†’    window.addEventListener('resize', scheduleViewportHeightUpdate);\n  1385â†’    window.addEventListener('click', onGlobalClick);\n  1386â†’    statusRefreshTimer = setInterval(() => {\n  1387â†’      if (indexStatus.state === 'Indexing') {\n  1388â†’        void refreshStatus();\n  1389â†’      }\n  1390â†’    }, 1000);\n  1391â†’    console.log(`[startup/fe] +${ms()}ms onMount complete`);\n  1392â†’  });\n  1393â†’\n  1394â†’  onDestroy(async () => {\n  1395â†’    clearTimeout(searchTimer);\n  1396â†’    clearTimeout(toastTimer);\n  1397â†’    clearInterval(statusRefreshTimer);\n  1398â†’    clearInterval(elapsedTimer);\n  1399â†’    resizeCleanup?.();\n  1400â†’\n  1401â†’    for (const unlisten of unlistenFns) {\n  1402â†’      unlisten();\n  1403â†’    }\n  1404â†’\n  1405â†’    tableResizeObserver?.disconnect();\n  1406â†’    tableResizeObserver = null;\n  1407â†’    if (viewportResizeRaf !== null) {\n  1408â†’      cancelAnimationFrame(viewportResizeRaf);\n  1409â†’      viewportResizeRaf = null;\n  1410â†’    }\n  1411â†’    window.removeEventListener('resize', scheduleViewportHeightUpdate);\n  1412â†’    window.removeEventListener('click', onGlobalClick);\n  1413â†’  });\n  1414â†’</script>\n  1415â†’\n  1416â†’<svelte:window on:keydown={handleKeydown} />\n  1417â†’\n  1418â†’<div class=\"app-shell\" data-theme={theme}>\n  1419â†’  <div class=\"title-bar\" role=\"presentation\" data-tauri-drag-region on:mousedown={onTitleBarMouseDown}>\n  1420â†’    <div class=\"title-left\"></div>\n  1421â†’    <div class=\"title-center\">\n  1422â†’      <svg class=\"title-icon\" viewBox=\"0 0 215 205\" fill-rule=\"evenodd\" aria-hidden=\"true\">\n  1423â†’        <path d=\"M85 0c46.9 0 85 38.1 85 85 0 20.1-7.2 38.5-19.2 52.7l40.7 40.8c5.8 5.8 5.8 15.2 0 21-5.8 5.8-15.2 5.8-21 0l-40.7-40.7c-13.6 9.7-30.4 15.2-44.8 15.2-46.9 0-85-42.1-85-89 0-46.9 38.1-85 85-85z m0 32c-29.3 0-53 23.7-53 53 0 29.3 23.7 53 53 53 29.3 0 53-23.7 53-53 0-29.3-23.7-53-53-53z\"/>\n  1424â†’      </svg>\n  1425â†’      <span class=\"title-text\">Everything</span>\n  1426â†’    </div>\n  1427â†’    <div class=\"title-right\"></div>\n  1428â†’  </div>\n  1429â†’\n  1430â†’  <header class=\"search-bar\">\n  1431â†’    <input\n  1432â†’      bind:this={searchInputEl}\n  1433â†’      class=\"search-input\"\n  1434â†’      type=\"text\"\n  1435â†’      bind:value={query}\n  1436â†’      on:input={scheduleSearch}\n  1437â†’      on:focus={clearSelection}\n  1438â†’      placeholder=\"Search file/folder names\"\n  1439â†’      autocomplete=\"off\"\n  1440â†’      spellcheck=\"false\"\n  1441â†’    />\n  1442â†’  </header>\n  1443â†’\n  1444â†’  <section class=\"table-area\" bind:this={tableAreaEl} style={tableGridStyle}>\n  1445â†’    <div class=\"table-header\">\n  1446â†’      <div class=\"table-header-track\">\n  1447â†’        <div class=\"col name\">\n  1448â†’          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('name')}>\n  1449â†’            Name{#if sortBy === 'name'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n  1450â†’          </button>\n  1451â†’          <button\n  1452â†’            type=\"button\"\n  1453â†’            class=\"col-resizer\"\n  1454â†’            class:active={resizingColumn === 'name'}\n  1455â†’            on:mousedown={(event) => startColumnResize(event, 'name')}\n  1456â†’            aria-label=\"Resize Name column\"\n  1457â†’          />\n  1458â†’        </div>\n  1459â†’\n  1460â†’        <div class=\"col path\">\n  1461â†’          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('dir')}>\n  1462â†’            Path{#if sortBy === 'dir'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n  1463â†’          </button>\n  1464â†’          <button\n  1465â†’            type=\"button\"\n  1466â†’            class=\"col-resizer\"\n  1467â†’            class:active={resizingColumn === 'path'}\n  1468â†’            on:mousedown={(event) => startColumnResize(event, 'path')}\n  1469â†’            aria-label=\"Resize Path column\"\n  1470â†’          />\n  1471â†’        </div>\n  1472â†’\n  1473â†’        <div class=\"col size\">\n  1474â†’          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('size')}>\n  1475â†’            Size{#if sortBy === 'size'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n  1476â†’          </button>\n  1477â†’        </div>\n  1478â†’\n  1479â†’        <div class=\"col modified\">\n  1480â†’          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('mtime')}>\n  1481â†’            Modified{#if sortBy === 'mtime'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n  1482â†’          </button>\n  1483â†’        </div>\n  1484â†’      </div>\n  1485â†’    </div>\n  1486â†’\n  1487â†’    <div\n  1488â†’      class=\"table-body\"\n  1489â†’      bind:this={tableContainer}\n  1490â†’      on:scroll={() => {\n  1491â†’        scrollTop = tableContainer.scrollTop;\n  1492â†’        headerScrollLeft = tableContainer.scrollLeft;\n  1493â†’        if (editing.active) cancelRename();\n  1494â†’        const scrollBottom = scrollTop + tableContainer.clientHeight;\n  1495â†’        if (scrollBottom >= totalHeight - rowHeight * 10) {\n  1496â†’          void loadMore();\n  1497â†’        }\n  1498â†’      }}\n  1499â†’    >\n  1500â†’      <div class=\"spacer\" style={`height:${totalHeight}px`}>\n  1501â†’        <div class=\"rows\" style={`transform: translateY(${translateY}px);`}>\n  1502â†’          {#each visibleRows as entry, localIndex}\n  1503â†’            {@const index = startIndex + localIndex}\n  1504â†’            <div\n  1505â†’              class=\"row {selectedIndices.has(index) ? 'selected' : ''}\"\n  1506â†’              on:mousedown={(event) => handleRowMouseDown(event, index)}\n  1507â†’              on:click={(event) => handleRowClick(event, index)}\n  1508â†’              on:keydown={(event) => handleRowA11yKeydown(event, index)}\n  1509â†’              on:dblclick={() => handleRowDoubleClick(index)}\n  1510â†’              on:contextmenu={(event) => handleRowContextMenu(event, index)}\n  1511â†’              role=\"row\"\n  1512â†’              tabindex=\"0\"\n  1513â†’            >\n  1514â†’              <div class=\"cell name\">\n  1515â†’                <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n  1516â†’                <span class=\"ellipsis\" class:name-editing={editing.active && editing.index === index}>{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n  1517â†’              </div>\n  1518â†’              <div class=\"cell path\"><span class=\"ellipsis\">{displayPath(entry.dir)}</span></div>\n  1519â†’              <div class=\"cell size\">{formatSize(entry)}</div>\n  1520â†’              <div class=\"cell modified\">{formatModified(entry)}</div>\n  1521â†’            </div>\n  1522â†’          {/each}\n  1523â†’        </div>\n  1524â†’      </div>\n  1525â†’    </div>\n  1526â†’  </section>\n  1527â†’\n  1528â†’  <footer class=\"status-bar\">\n  1529â†’    <div class=\"status-left\">\n  1530â†’      <span class=\"status-state\">\n  1531â†’        <span class=\"state-dot {indexStatus.state === 'Indexing' ? 'indexing' : indexStatus.state === 'Error' ? 'error' : 'ready'}\"></span>\n  1532â†’        {#if indexStatus.state === 'Indexing'}\n  1533â†’          Indexing{#if lastReadyCount > 0} ({Math.min(99, Math.round((scanned / lastReadyCount) * 100))}%){/if}{#if indexingElapsed} Â· {indexingElapsed}{/if}\n  1534â†’          {#if !indexStatus.isCatchup}\n  1535â†’            Â· {scanned.toLocaleString()} scanned\n  1536â†’          {/if}\n  1537â†’        {:else}\n  1538â†’          Index: {indexStatus.state}\n  1539â†’        {/if}\n  1540â†’      </span>\n  1541â†’      <span>{indexStatus.entriesCount.toLocaleString()} entries</span>\n  1542â†’      {#if indexingFinishedAt && indexStatus.state !== 'Indexing'}\n  1543â†’        <span>in {indexingFinishedAt}</span>\n  1544â†’      {/if}\n  1545â†’      {#if dbLatencyMs !== null && dbLastQuery}\n  1546â†’        <span>\"{dbLastQuery}\" {dbLatencyMs}ms Â· {totalResults} results</span>\n  1547â†’      {/if}\n  1548â†’      {#if searchModeLabel === 'spotlight' || searchModeLabel === 'spotlight_timeout'}\n  1549â†’        <span class=\"status-spotlight\">Spotlight fallback{#if searchModeLabel === 'spotlight_timeout'} (partial){/if}</span>\n  1550â†’      {/if}\n  1551â†’      {#if indexStatus.permissionErrors > 0}\n  1552â†’        <span class=\"status-warning\">{indexStatus.permissionErrors.toLocaleString()} permission errors</span>\n  1553â†’      {/if}\n  1554â†’      {#if indexStatus.message}\n  1555â†’        <span class={indexStatus.isCatchup ? 'index-progress' : 'status-error'}>{indexStatus.message}</span>\n  1556â†’      {/if}\n  1557â†’    </div>\n  1558â†’    <div class=\"status-right\">\n  1559â†’      <button class=\"status-btn theme-btn\" on:click={cycleTheme} title=\"Switch theme\">\n  1560â†’        {theme === 'dark' ? 'â˜€ Light' : 'â—‘ Dark'}\n  1561â†’      </button>\n  1562â†’      <button\n  1563â†’        class=\"status-btn rebuild-btn\"\n  1564â†’        on:click={resetIndex}\n  1565â†’        disabled={indexStatus.state === 'Indexing'}\n  1566â†’        title={indexStatus.state === 'Indexing' ? 'Cannot reset while indexing is in progress.' : 'Reset and rebuild the index.'}\n  1567â†’      >\n  1568â†’        <svg class=\"rebuild-icon\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n  1569â†’          <path d=\"M23 4v6h-6\"/><path d=\"M20.49 15a9 9 0 1 1-2.12-9.36L23 10\"/>\n  1570â†’        </svg>\n  1571â†’        Rebuild Index\n  1572â†’      </button>\n  1573â†’    </div>\n  1574â†’  </footer>\n  1575â†’\n  1576â†’  {#if editing.active}\n  1577â†’    <div\n  1578â†’      class=\"rename-overlay\"\n  1579â†’      style=\"top:{renameOverlay.top}px; left:{renameOverlay.left}px; width:{renameOverlay.width}px;\"\n  1580â†’      role=\"presentation\"\n  1581â†’      on:mousedown|stopPropagation\n  1582â†’    >\n  1583â†’      <textarea\n  1584â†’        bind:this={renameInputEl}\n  1585â†’        class=\"rename-textarea\"\n  1586â†’        bind:value={editing.draftName}\n  1587â†’        on:input={autoResizeRenameInput}\n  1588â†’        on:click|stopPropagation\n  1589â†’        on:blur={commitRename}\n  1590â†’      />\n  1591â†’    </div>\n  1592â†’  {/if}\n  1593â†’\n  1594â†’  {#if contextMenu.visible}\n  1595â†’    <div class=\"context-menu\" style={`left:${contextMenu.x}px;top:${contextMenu.y}px;`}>\n  1596â†’      <button on:click={() => (closeContextMenu(), openSelected())}>Open</button>\n  1597â†’      <button on:click={async () => { closeContextMenu(); const e = primaryEntry(); if (e) await invoke('quick_look', { path: e.path }); }}>Quick Look</button>\n  1598â†’      <button on:click={() => (closeContextMenu(), openWithFallback())}>Open With... (Reveal in Finder)</button>\n  1599â†’      <button on:click={() => (closeContextMenu(), revealSelected())}>Reveal in Finder</button>\n  1600â†’      <button on:click={() => (closeContextMenu(), copySelectedPaths())}>Copy Path</button>\n  1601â†’      <button on:click={() => (closeContextMenu(), trashSelected())}>Move to Trash</button>\n  1602â†’      {#if selectedIndices.size === 1}\n  1603â†’        <button on:click={() => (closeContextMenu(), startRename())}>Rename</button>\n  1604â†’      {/if}\n  1605â†’    </div>\n  1606â†’  {/if}\n  1607â†’\n  1608â†’  {#if toast}\n  1609â†’    <div class=\"toast\">{toast}</div>\n  1610â†’  {/if}\n  1611â†’</div>\n  1612â†’\n  1613â†’<style>\n  1614â†’  :global(:root) {\n  1615â†’    color-scheme: light dark;\n  1616â†’    --bg-app: transparent;\n  1617â†’    --text-primary: #0d1826;\n  1618â†’    --text-muted: #48596c;\n  1619â†’    --bar-grad-top: rgba(255, 255, 255, 0.48);\n  1620â†’    --bar-grad-bottom: rgba(248, 250, 253, 0.42);\n  1621â†’    --surface-header: rgba(252, 252, 255, 0.40);\n  1622â†’    --surface: rgba(255, 255, 255, 0.22);\n  1623â†’    --border-soft: rgba(0, 0, 0, 0.07);\n  1624â†’    --border-input: rgba(0, 0, 0, 0.13);\n  1625â†’    --focus-ring: #6f96e6;\n  1626â†’    --row-border: rgba(0, 0, 0, 0.032);\n  1627â†’    --row-hover: rgba(0, 0, 0, 0.06);\n  1628â†’    --row-selected: rgba(0, 0, 0, 0.12);\n  1629â†’    --button-bg: rgba(255, 255, 255, 0.62);\n  1630â†’    --button-border: rgba(0, 0, 0, 0.10);\n  1631â†’    --button-text: #2c3e50;\n  1632â†’    --menu-bg: rgba(240, 241, 248, 0.90);\n  1633â†’    --menu-border: rgba(0, 0, 0, 0.06);\n  1634â†’    --menu-hover: rgba(255, 255, 255, 0.62);\n  1635â†’    --menu-text: #1a2a38;\n  1636â†’    --error-text: #b64545;\n  1637â†’    --warning-text: #8f6500;\n  1638â†’    --toast-bg: rgba(18, 22, 32, 0.90);\n  1639â†’    --toast-text: #ffffff;\n  1640â†’  }\n  1641â†’\n  1642â†’  @media (prefers-color-scheme: dark) {\n  1643â†’    :global(:root) {\n  1644â†’      --bg-app: transparent;\n  1645â†’      --text-primary: #e6e6ea;\n  1646â†’      --text-muted: #9494a4;\n  1647â†’      --bar-grad-top: rgba(38, 38, 46, 0.52);\n  1648â†’      --bar-grad-bottom: rgba(30, 30, 38, 0.46);\n  1649â†’      --surface-header: rgba(32, 32, 40, 0.46);\n  1650â†’      --surface: rgba(18, 18, 26, 0.32);\n  1651â†’      --border-soft: rgba(255, 255, 255, 0.065);\n  1652â†’      --border-input: rgba(255, 255, 255, 0.14);\n  1653â†’      --focus-ring: #5b8bd9;\n  1654â†’      --row-border: rgba(255, 255, 255, 0.026);\n  1655â†’      --row-hover: rgba(255, 255, 255, 0.08);\n  1656â†’      --row-selected: rgba(255, 255, 255, 0.14);\n  1657â†’      --button-bg: rgba(255, 255, 255, 0.072);\n  1658â†’      --button-border: rgba(255, 255, 255, 0.11);\n  1659â†’      --button-text: #d6d6e0;\n  1660â†’      --menu-bg: rgba(36, 36, 46, 0.90);\n  1661â†’      --menu-border: rgba(255, 255, 255, 0.066);\n  1662â†’      --menu-hover: rgba(255, 255, 255, 0.062);\n  1663â†’      --menu-text: #e0e0e8;\n  1664â†’      --error-text: #ff9d9d;\n  1665â†’      --warning-text: #e0c670;\n  1666â†’      --toast-bg: rgba(10, 10, 16, 0.93);\n  1667â†’      --toast-text: #f2f2f6;\n  1668â†’    }\n  1669â†’  }\n  1670â†’\n  1671â†’  /* â”€â”€ Theme: Dark â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  1672â†’  :global([data-theme=\"dark\"]) {\n  1673â†’    color-scheme: dark;\n  1674â†’    --bg-app: #1E1E21;\n  1675â†’    --text-primary: #E2E8F0;\n  1676â†’    --text-muted: #94A3B8;\n  1677â†’    --bar-grad-top: #1E1E21;\n  1678â†’    --bar-grad-bottom: #1E1E21;\n  1679â†’    --surface-header: #1E1E21;\n  1680â†’    --surface: #1E1E21;\n  1681â†’    --bg-input: #161618;\n  1682â†’    --border-soft: #2A2A2D;\n  1683â†’    --border-input: rgba(255, 255, 255, 0.06);\n  1684â†’    --focus-ring: #4DA8FF;\n  1685â†’    --accent: #4DA8FF;\n  1686â†’    --row-border: rgba(255, 255, 255, 0.02);\n  1687â†’    --row-hover: #282828;\n  1688â†’    --row-selected: rgba(77, 168, 255, 0.10);\n  1689â†’    --button-bg: rgba(255, 255, 255, 0.05);\n  1690â†’    --button-border: #2A2A2D;\n  1691â†’    --button-text: #94A3B8;\n  1692â†’    --menu-bg: #252528;\n  1693â†’    --menu-border: #2A2A2D;\n  1694â†’    --menu-hover: rgba(255, 255, 255, 0.04);\n  1695â†’    --menu-text: #E2E8F0;\n  1696â†’    --error-text: #ff9d9d;\n  1697â†’    --warning-text: #e0c670;\n  1698â†’    --toast-bg: rgba(10, 10, 16, 0.93);\n  1699â†’    --toast-text: #f2f2f6;\n  1700â†’  }\n  1701â†’\n  1702â†’  /* â”€â”€ Theme: Light â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  1703â†’  :global([data-theme=\"light\"]) {\n  1704â†’    color-scheme: light;\n  1705â†’    --bg-app: #F5F5F7;\n  1706â†’    --text-primary: #1C1C1E;\n  1707â†’    --text-muted: #6E6E7A;\n  1708â†’    --bar-grad-top: #F5F5F7;\n  1709â†’    --bar-grad-bottom: #F5F5F7;\n  1710â†’    --surface-header: #F5F5F7;\n  1711â†’    --surface: #F5F5F7;\n  1712â†’    --bg-input: #FFFFFF;\n  1713â†’    --border-soft: #D1D1D6;\n  1714â†’    --border-input: rgba(0, 0, 0, 0.10);\n  1715â†’    --focus-ring: #3A8BF5;\n  1716â†’    --accent: #3A8BF5;\n  1717â†’    --row-border: rgba(0, 0, 0, 0.04);\n  1718â†’    --row-hover: rgba(0, 0, 0, 0.04);\n  1719â†’    --row-selected: rgba(58, 139, 245, 0.10);\n  1720â†’    --button-bg: #FFFFFF;\n  1721â†’    --button-border: #D1D1D6;\n  1722â†’    --button-text: #3C3C43;\n  1723â†’    --menu-bg: #FFFFFF;\n  1724â†’    --menu-border: #D1D1D6;\n  1725â†’    --menu-hover: rgba(0, 0, 0, 0.05);\n  1726â†’    --menu-text: #1C1C1E;\n  1727â†’    --error-text: #D93025;\n  1728â†’    --warning-text: #B45309;\n  1729â†’    --toast-bg: rgba(255, 255, 255, 0.95);\n  1730â†’    --toast-text: #1C1C1E;\n  1731â†’  }\n  1732â†’\n  1733â†’  /* â”€â”€ Themed element overrides â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  1734â†’  :global([data-theme]) {\n  1735â†’    background: var(--bg-app);\n  1736â†’  }\n  1737â†’\n  1738â†’  /* Search bar: flat, no gradient, no separator */\n  1739â†’  :global([data-theme]) .search-bar {\n  1740â†’    height: 44px;\n  1741â†’    padding: 0 16px;\n  1742â†’    background: var(--bg-app);\n  1743â†’    border-bottom: none;\n  1744â†’  }\n  1745â†’\n  1746â†’  :global([data-theme]) .search-input {\n  1747â†’    backdrop-filter: none;\n  1748â†’    -webkit-backdrop-filter: none;\n  1749â†’    font-family: 'JetBrains Mono', 'SF Mono', monospace;\n  1750â†’    font-size: 12px;\n  1751â†’    height: 34px;\n  1752â†’    border-radius: 8px;\n  1753â†’  }\n  1754â†’\n  1755â†’  /* Table header: flat bg, 16px edge padding */\n  1756â†’  :global([data-theme]) .table-header {\n  1757â†’    background: var(--bg-app);\n  1758â†’  }\n  1759â†’\n  1760â†’  :global([data-theme]) .col-button {\n  1761â†’    padding: 0 8px;\n  1762â†’  }\n  1763â†’\n  1764â†’  :global([data-theme]) .col.name .col-button {\n  1765â†’    padding-left: 16px;\n  1766â†’  }\n  1767â†’\n  1768â†’  /* Row cells: JetBrains Mono, 16px outer edges */\n  1769â†’  :global([data-theme]) .cell {\n  1770â†’    font-family: 'JetBrains Mono', monospace;\n  1771â†’  }\n  1772â†’\n  1773â†’  :global([data-theme]) .cell.name {\n  1774â†’    font-family: Inter, 'SF Pro Text', sans-serif;\n  1775â†’    padding-left: 16px;\n  1776â†’    font-size: 12px;\n  1777â†’    color: var(--text-primary);\n  1778â†’  }\n  1779â†’\n  1780â†’  :global([data-theme]) .cell.path {\n  1781â†’    font-size: 11px;\n  1782â†’  }\n  1783â†’\n  1784â†’  :global([data-theme]) .cell.size {\n  1785â†’    font-size: 11px;\n  1786â†’  }\n  1787â†’\n  1788â†’  :global([data-theme]) .cell.modified {\n  1789â†’    padding-right: 16px;\n  1790â†’    font-size: 11px;\n  1791â†’    white-space: nowrap;\n  1792â†’  }\n  1793â†’\n  1794â†’  :global([data-theme]) .row.selected {\n  1795â†’    box-shadow: inset 3px 0 0 var(--accent);\n  1796â†’  }\n  1797â†’\n  1798â†’  /* Dim path/size/date cells in themed mode */\n  1799â†’  :global([data-theme]) .cell.path,\n  1800â†’  :global([data-theme]) .cell.size,\n  1801â†’  :global([data-theme]) .cell.modified {\n  1802â†’    color: var(--text-muted);\n  1803â†’  }\n  1804â†’\n  1805â†’  :global(:root) {\n  1806â†’    background: transparent;\n  1807â†’  }\n  1808â†’\n  1809â†’  :global(html, body) {\n  1810â†’    margin: 0;\n  1811â†’    width: 100%;\n  1812â†’    height: 100%;\n  1813â†’    overflow: hidden;\n  1814â†’    background: transparent;\n  1815â†’    color: var(--text-primary);\n  1816â†’    font-family: Inter, 'SF Pro Text', 'Segoe UI', Helvetica, Arial, sans-serif;\n  1817â†’  }\n  1818â†’\n  1819â†’  :global(#app) {\n  1820â†’    width: 100%;\n  1821â†’    height: 100%;\n  1822â†’  }\n  1823â†’\n  1824â†’  .app-shell {\n  1825â†’    display: grid;\n  1826â†’    grid-template-rows: auto auto 1fr auto;\n  1827â†’    height: 100%;\n  1828â†’    min-width: 0;\n  1829â†’  }\n  1830â†’\n  1831â†’  .title-bar {\n  1832â†’    display: flex;\n  1833â†’    align-items: center;\n  1834â†’    justify-content: space-between;\n  1835â†’    height: 44px;\n  1836â†’    padding: 0 16px;\n  1837â†’    background: var(--surface-header);\n  1838â†’    cursor: default;\n  1839â†’    flex-shrink: 0;\n  1840â†’    user-select: none;\n  1841â†’    -webkit-user-select: none;\n  1842â†’  }\n  1843â†’\n  1844â†’  .title-left {\n  1845â†’    width: 72px;\n  1846â†’    pointer-events: none;\n  1847â†’    user-select: none;\n  1848â†’    -webkit-user-select: none;\n  1849â†’  }\n  1850â†’\n  1851â†’  .title-center {\n  1852â†’    display: flex;\n  1853â†’    align-items: center;\n  1854â†’    gap: 8px;\n  1855â†’    pointer-events: none;\n  1856â†’    user-select: none;\n  1857â†’    -webkit-user-select: none;\n  1858â†’  }\n  1859â†’\n  1860â†’  .title-right {\n  1861â†’    width: 72px;\n  1862â†’    pointer-events: none;\n  1863â†’    user-select: none;\n  1864â†’    -webkit-user-select: none;\n  1865â†’  }\n  1866â†’\n  1867â†’  .title-icon {\n  1868â†’    width: 14px;\n  1869â†’    height: 14px;\n  1870â†’    fill: var(--accent);\n  1871â†’    flex-shrink: 0;\n  1872â†’  }\n  1873â†’\n  1874â†’  .title-text {\n  1875â†’    font-family: Inter, 'SF Pro Text', sans-serif;\n  1876â†’    font-size: 13px;\n  1877â†’    font-weight: 500;\n  1878â†’    color: var(--text-primary);\n  1879â†’    letter-spacing: -0.01em;\n  1880â†’  }\n  1881â†’\n  1882â†’  .search-bar {\n  1883â†’    display: flex;\n  1884â†’    align-items: center;\n  1885â†’    gap: 6px;\n  1886â†’    padding: 8px;\n  1887â†’    background: linear-gradient(180deg, var(--bar-grad-top) 0%, var(--bar-grad-bottom) 100%);\n  1888â†’    border-bottom: 1px solid var(--border-soft);\n  1889â†’    min-width: 0;\n  1890â†’    flex-shrink: 0;\n  1891â†’  }\n  1892â†’\n  1893â†’  .search-input {\n  1894â†’    display: block;\n  1895â†’    box-sizing: border-box;\n  1896â†’    width: 100%;\n  1897â†’    min-width: 0;\n  1898â†’    flex: 1 1 auto;\n  1899â†’    height: 36px;\n  1900â†’    border: 1px solid var(--border-input);\n  1901â†’    border-radius: 14px;\n  1902â†’    padding: 0 10px;\n  1903â†’    font-size: 14px;\n  1904â†’    background: var(--bg-input, var(--surface));\n  1905â†’    color: var(--text-primary);\n  1906â†’    backdrop-filter: blur(12px) saturate(160%);\n  1907â†’    -webkit-backdrop-filter: blur(12px) saturate(160%);\n  1908â†’  }\n  1909â†’\n  1910â†’  .search-input::placeholder {\n  1911â†’    color: var(--text-muted);\n  1912â†’    opacity: 0.85;\n  1913â†’    font-size: 12px;\n  1914â†’  }\n  1915â†’\n  1916â†’  .search-input:focus {\n  1917â†’    outline: none;\n  1918â†’    border-color: var(--focus-ring);\n  1919â†’    box-shadow: 0 0 0 2px rgba(125, 169, 255, 0.25);\n  1920â†’  }\n  1921â†’\n  1922â†’  .table-area {\n  1923â†’    display: grid;\n  1924â†’    grid-template-rows: auto 1fr;\n  1925â†’    min-height: 0;\n  1926â†’    min-width: 0;\n  1927â†’  }\n  1928â†’\n  1929â†’  .table-header-track,\n  1930â†’  .row {\n  1931â†’    display: grid;\n  1932â†’    grid-template-columns: var(--col-name) var(--col-path) var(--col-size) var(--col-modified);\n  1933â†’    align-items: center;\n  1934â†’    width: max(var(--table-min-width, 0px), 100%);\n  1935â†’  }\n  1936â†’\n  1937â†’  .table-header {\n  1938â†’    height: 32px;\n  1939â†’    border-bottom: 1px solid var(--border-soft);\n  1940â†’    background: var(--surface-header);\n  1941â†’    user-select: none;\n  1942â†’    overflow: hidden;\n  1943â†’    flex-shrink: 0;\n  1944â†’  }\n  1945â†’\n  1946â†’  .table-header-track {\n  1947â†’    height: 100%;\n  1948â†’    transform: translateX(var(--header-offset, 0px));\n  1949â†’    will-change: transform;\n  1950â†’  }\n  1951â†’\n  1952â†’  .table-header .col {\n  1953â†’    position: relative;\n  1954â†’    min-width: 0;\n  1955â†’    height: 100%;\n  1956â†’  }\n  1957â†’\n  1958â†’  .col-button {\n  1959â†’    width: 100%;\n  1960â†’    height: 100%;\n  1961â†’    display: flex;\n  1962â†’    align-items: center;\n  1963â†’    justify-content: flex-start;\n  1964â†’    gap: 4px;\n  1965â†’    box-sizing: border-box;\n  1966â†’    padding: 0 8px;\n  1967â†’    font-family: Inter, 'SF Pro Text', sans-serif;\n  1968â†’    font-size: 11px;\n  1969â†’    font-weight: 600;\n  1970â†’    line-height: 1;\n  1971â†’    color: var(--text-muted);\n  1972â†’    text-align: left;\n  1973â†’    margin: 0;\n  1974â†’    border: none;\n  1975â†’    background: transparent;\n  1976â†’    cursor: pointer;\n  1977â†’  }\n  1978â†’\n  1979â†’  .sort-icon {\n  1980â†’    width: 10px;\n  1981â†’    height: 10px;\n  1982â†’    flex-shrink: 0;\n  1983â†’    color: var(--accent);\n  1984â†’  }\n  1985â†’\n  1986â†’  .col-resizer {\n  1987â†’    position: absolute;\n  1988â†’    top: 0;\n  1989â†’    right: -4px;\n  1990â†’    width: 8px;\n  1991â†’    height: 100%;\n  1992â†’    border: none;\n  1993â†’    padding: 0;\n  1994â†’    background: transparent;\n  1995â†’    cursor: col-resize;\n  1996â†’    z-index: 30;\n  1997â†’  }\n  1998â†’\n  1999â†’  .col-resizer::after {\n  2000â†’    content: '';\n  2001â†’    position: absolute;\n  2002â†’    top: 7px;\n  2003â†’    bottom: 7px;\n  2004â†’    left: 50%;\n  2005â†’    width: 1px;\n  2006â†’    transform: translateX(-50%);\n  2007â†’    background: var(--border-soft);\n  2008â†’    opacity: 0;\n  2009â†’    transition: opacity 0.15s ease;\n  2010â†’  }\n  2011â†’\n  2012â†’  .table-header .col:hover .col-resizer::after,\n  2013â†’  .col-resizer.active::after {\n  2014â†’    opacity: 1;\n  2015â†’  }\n  2016â†’\n  2017â†’  .table-body {\n  2018â†’    overflow: auto;\n  2019â†’    min-height: 0;\n  2020â†’    min-width: 0;\n  2021â†’    background: var(--surface);\n  2022â†’  }\n  2023â†’\n  2024â†’  .spacer {\n  2025â†’    position: relative;\n  2026â†’    width: max(var(--table-min-width, 0px), 100%);\n  2027â†’  }\n  2028â†’\n  2029â†’  .rows {\n  2030â†’    position: absolute;\n  2031â†’    top: 0;\n  2032â†’    left: 0;\n  2033â†’    width: max(var(--table-min-width, 0px), 100%);\n  2034â†’  }\n  2035â†’\n  2036â†’  .row {\n  2037â†’    height: 30px;\n  2038â†’    border-bottom: 1px solid var(--row-border);\n  2039â†’    cursor: default;\n  2040â†’    -webkit-user-select: none;\n  2041â†’    user-select: none;\n  2042â†’    outline: none;\n  2043â†’  }\n  2044â†’\n  2045â†’  .row:hover {\n  2046â†’    background: var(--row-hover);\n  2047â†’  }\n  2048â†’\n  2049â†’  .row.selected {\n  2050â†’    background: var(--row-selected);\n  2051â†’  }\n  2052â†’\n  2053â†’  .cell {\n  2054â†’    padding: 0 8px;\n  2055â†’    font-size: 12px;\n  2056â†’    display: flex;\n  2057â†’    align-items: center;\n  2058â†’    gap: 6px;\n  2059â†’    min-width: 0;\n  2060â†’  }\n  2061â†’\n  2062â†’  .cell.size {\n  2063â†’    text-align: right;\n  2064â†’    font-variant-numeric: tabular-nums;\n  2065â†’  }\n  2066â†’\n  2067â†’  .ellipsis {\n  2068â†’    overflow: hidden;\n  2069â†’    text-overflow: ellipsis;\n  2070â†’    white-space: nowrap;\n  2071â†’  }\n  2072â†’\n  2073â†’  .hl {\n  2074â†’    background: none;\n  2075â†’    color: inherit;\n  2076â†’    font-weight: 700;\n  2077â†’  }\n  2078â†’\n  2079â†’  .file-icon {\n  2080â†’    width: 16px;\n  2081â†’    height: 16px;\n  2082â†’    flex: 0 0 auto;\n  2083â†’  }\n  2084â†’\n  2085â†’  .name-editing {\n  2086â†’    opacity: 0.25;\n  2087â†’  }\n  2088â†’\n  2089â†’  .rename-overlay {\n  2090â†’    position: fixed;\n  2091â†’    z-index: 100;\n  2092â†’    min-width: 120px;\n  2093â†’  }\n  2094â†’\n  2095â†’  .rename-textarea {\n  2096â†’    display: block;\n  2097â†’    width: 100%;\n  2098â†’    box-sizing: border-box;\n  2099â†’    font-family: Inter, 'SF Pro Text', sans-serif;\n  2100â†’    font-size: 12px;\n  2101â†’    line-height: 18px;\n  2102â†’    padding: 5px 4px 5px 0;\n  2103â†’    border: 1.5px solid var(--focus-ring);\n  2104â†’    border-radius: 4px;\n  2105â†’    background: var(--bg-input, var(--surface));\n  2106â†’    color: var(--text-primary);\n  2107â†’    outline: none;\n  2108â†’    resize: none;\n  2109â†’    overflow: hidden;\n  2110â†’    box-shadow: 0 2px 14px rgba(0, 0, 0, 0.22), 0 0 0 3px rgba(77, 168, 255, 0.13);\n  2111â†’  }\n  2112â†’\n  2113â†’  .status-bar {\n  2114â†’    display: flex;\n  2115â†’    align-items: center;\n  2116â†’    justify-content: space-between;\n  2117â†’    height: 32px;\n  2118â†’    padding: 0 16px;\n  2119â†’    background: var(--surface-header);\n  2120â†’    border-top: 1px solid var(--border-soft);\n  2121â†’    font-family: 'JetBrains Mono', monospace;\n  2122â†’    font-size: 11px;\n  2123â†’    color: var(--text-muted);\n  2124â†’    white-space: nowrap;\n  2125â†’    overflow: hidden;\n  2126â†’    min-width: 0;\n  2127â†’    flex-shrink: 0;\n  2128â†’  }\n  2129â†’\n  2130â†’  .status-left {\n  2131â†’    display: flex;\n  2132â†’    align-items: center;\n  2133â†’    gap: 16px;\n  2134â†’    overflow: hidden;\n  2135â†’    min-width: 0;\n  2136â†’  }\n  2137â†’\n  2138â†’  .status-right {\n  2139â†’    display: flex;\n  2140â†’    align-items: center;\n  2141â†’    gap: 8px;\n  2142â†’    flex-shrink: 0;\n  2143â†’  }\n  2144â†’\n  2145â†’  .status-btn {\n  2146â†’    border: 1px solid var(--button-border);\n  2147â†’    border-radius: 5px;\n  2148â†’    background: var(--button-bg);\n  2149â†’    color: var(--button-text);\n  2150â†’    font-size: 11px;\n  2151â†’    height: 22px;\n  2152â†’    padding: 0 8px;\n  2153â†’    cursor: pointer;\n  2154â†’  }\n  2155â†’\n  2156â†’  .status-btn:hover {\n  2157â†’    filter: brightness(1.06);\n  2158â†’  }\n  2159â†’\n  2160â†’  .status-btn:disabled {\n  2161â†’    opacity: 0.55;\n  2162â†’    cursor: not-allowed;\n  2163â†’    filter: none;\n  2164â†’  }\n  2165â†’\n  2166â†’  .status-state {\n  2167â†’    display: flex;\n  2168â†’    align-items: center;\n  2169â†’    gap: 6px;\n  2170â†’  }\n  2171â†’\n  2172â†’  .state-dot {\n  2173â†’    width: 6px;\n  2174â†’    height: 6px;\n  2175â†’    border-radius: 50%;\n  2176â†’    flex-shrink: 0;\n  2177â†’  }\n  2178â†’\n  2179â†’  .state-dot.ready { background: #28C840; }\n  2180â†’  .state-dot.indexing { background: #FEBC2E; }\n  2181â†’  .state-dot.error { background: #FF5F57; }\n  2182â†’\n  2183â†’  .rebuild-btn {\n  2184â†’    display: flex;\n  2185â†’    align-items: center;\n  2186â†’    gap: 6px;\n  2187â†’    font-family: Inter, 'SF Pro Text', sans-serif;\n  2188â†’    font-size: 10px;\n  2189â†’    font-weight: 500;\n  2190â†’    background: var(--button-bg);\n  2191â†’    border: 1px solid var(--button-border);\n  2192â†’    border-radius: 4px;\n  2193â†’    color: var(--button-text);\n  2194â†’    height: 22px;\n  2195â†’    padding: 0 10px;\n  2196â†’    cursor: pointer;\n  2197â†’  }\n  2198â†’\n  2199â†’  .rebuild-btn:hover {\n  2200â†’    filter: brightness(1.1);\n  2201â†’  }\n  2202â†’\n  2203â†’  .rebuild-btn:disabled {\n  2204â†’    opacity: 0.5;\n  2205â†’    cursor: not-allowed;\n  2206â†’    filter: none;\n  2207â†’  }\n  2208â†’\n  2209â†’  .rebuild-icon {\n  2210â†’    width: 11px;\n  2211â†’    height: 11px;\n  2212â†’    color: var(--accent);\n  2213â†’    flex-shrink: 0;\n  2214â†’  }\n  2215â†’\n  2216â†’  .status-error {\n  2217â†’    color: var(--error-text);\n  2218â†’  }\n  2219â†’\n  2220â†’  .status-warning {\n  2221â†’    color: var(--warning-text);\n  2222â†’  }\n  2223â†’\n  2224â†’  .status-spotlight {\n  2225â†’    color: #f59e0b;\n  2226â†’    font-weight: 600;\n  2227â†’  }\n  2228â†’\n  2229â†’  .context-menu {\n  2230â†’    position: fixed;\n  2231â†’    z-index: 200;\n  2232â†’    width: 220px;\n  2233â†’    border: 1px solid var(--menu-border);\n  2234â†’    border-radius: 10px;\n  2235â†’    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.16), inset 0 0 0 0.5px rgba(255, 255, 255, 0.18);\n  2236â†’    background: var(--menu-bg);\n  2237â†’    backdrop-filter: blur(28px) saturate(180%);\n  2238â†’    -webkit-backdrop-filter: blur(28px) saturate(180%);\n  2239â†’    overflow: hidden;\n  2240â†’  }\n  2241â†’\n  2242â†’  .context-menu button {\n  2243â†’    width: 100%;\n  2244â†’    text-align: left;\n  2245â†’    border: none;\n  2246â†’    background: transparent;\n  2247â†’    padding: 8px 10px;\n  2248â†’    font-size: 12px;\n  2249â†’    color: var(--menu-text);\n  2250â†’  }\n  2251â†’\n  2252â†’  .context-menu button:hover {\n  2253â†’    background: var(--menu-hover);\n  2254â†’  }\n  2255â†’\n  2256â†’  .toast {\n  2257â†’    position: fixed;\n  2258â†’    right: 14px;\n  2259â†’    bottom: 18px;\n  2260â†’    background: var(--toast-bg);\n  2261â†’    color: var(--toast-text);\n  2262â†’    border-radius: 10px;\n  2263â†’    padding: 9px 12px;\n  2264â†’    font-size: 12px;\n  2265â†’    z-index: 250;\n  2266â†’    backdrop-filter: blur(20px) saturate(180%);\n  2267â†’    -webkit-backdrop-filter: blur(20px) saturate(180%);\n  2268â†’    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);\n  2269â†’  }\n  2270â†’</style>\n  2271â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"845ef5d4-08d9-4bac-b064-d22f87dd6f9b","timestamp":"2026-02-21T14:32:26.031Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src/App.svelte","content":"<script>\n  import { onDestroy, onMount, tick } from 'svelte';\n  import { invoke } from '@tauri-apps/api/core';\n  import { listen } from '@tauri-apps/api/event';\n  import { getCurrentWindow } from '@tauri-apps/api/window';\n  import { startDrag } from '@crabnebula/tauri-plugin-drag';\n\n  const rowHeight = 30;\n  const PAGE_SIZE = 500;\n  let homePrefix = '';\n  const COL_WIDTHS_KEY = 'REDACTED';\n  const THEME_KEY = 'everything-theme';\n  const columnKeys = ['name', 'path', 'size', 'modified'];\n  const minColumnWidth = {\n    name: 180,\n    path: 240,\n    size: 75,\n    modified: 150\n  };\n  const defaultColumnRatios = {\n    name: 0.3,\n    path: 0.45,\n    size: 0.1\n  };\n\n  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || 'dark'; } catch { return 'dark'; } })();\n  function cycleTheme() {\n    theme = theme === 'dark' ? 'light' : 'dark';\n    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n  }\n\n  let query = '';\n  let results = [];\n  let totalResults = 0;\n  let totalResultsKnown = false;\n\n  let dbLatencyMs = null;\n  let dbLastQuery = '';\n  let searchModeLabel = '';\n  let selectedIndices = new Set();\n  let selectionAnchor = -1;\n  let lastSelectedIndex = -1;\n  let editing = {\n    active: false,\n    path: '',\n    index: -1,\n    draftName: ''\n  };\n\n  let renameOverlay = { top: 0, left: 0, width: 0 };\n\n  let indexStatus = {\n    state: 'Indexing',\n    entriesCount: 0,\n    lastUpdated: null,\n    permissionErrors: 0,\n    message: null,\n    isCatchup: false\n  };\n\n  let indexingStartTime = null;\n  let indexingElapsed = '';\n  let indexingFinishedAt = '';\n\n  let sortBy = 'name';\n  let sortDir = 'asc';\n\n  let hasMore = true;\n  let loadingMore = false;\n  let searchGeneration = 0;\n\n  let scanned = 0;\n\n  let searchInputEl;\n  let renameInputEl;\n  let tableAreaEl;\n  let tableContainer;\n  let tableResizeObserver = null;\n  let viewportResizeRaf = null;\n  let scrollTop = 0;\n  let headerScrollLeft = 0;\n  let viewportHeight = 520;\n  let lastTableWidth = 0;\n  let resizingColumn = '';\n  let resizeCleanup = null;\n  let colWidths = {\n    name: 250,\n    path: 350,\n    size: 75,\n    modified: 150\n  };\n\n  let contextMenu = {\n    visible: false,\n    x: 0,\n    y: 0\n  };\n\n  let platform = '';\n  let toast = '';\n  let searchTimer;\n  let lastSearchFiredAt = 0;\n  let toastTimer;\n  let statusRefreshTimer;\n  let elapsedTimer;\n  let statusRefreshInFlight = false;\n  let lastReadyCount = 0;\n\n  const iconCache = new Map();\n  const iconLoading = new Set();\n\n  let highlightCache = new Map();\n  let highlightCacheQuery = '';\n\n  const folderFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='1' y='4' width='14' height='10' rx='2' fill='#d9b34f'/><rect x='1' y='2' width='6' height='4' rx='1' fill='#e6ca7a'/></svg>`\n    );\n  const fileFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='3' y='1' width='10' height='14' rx='1.5' fill='#b4bec9'/><rect x='5' y='5' width='6' height='1.2' fill='#8d98a5'/><rect x='5' y='8' width='6' height='1.2' fill='#8d98a5'/></svg>`\n    );\n\n  $: totalHeight = results.length * rowHeight;\n  $: startIndex = Math.max(0, Math.floor(scrollTop / rowHeight) - 10);\n  $: visibleCount = Math.ceil(viewportHeight / rowHeight) + 20;\n  $: endIndex = Math.min(results.length, startIndex + visibleCount);\n  $: visibleRows = results.slice(startIndex, endIndex);\n  $: translateY = startIndex * rowHeight;\n  $: tableMinWidth = colWidths.name + colWidths.path + colWidths.size + colWidths.modified;\n  $: tableGridStyle = `--col-name:${colWidths.name}px;--col-path:${colWidths.path}px;--col-size:${colWidths.size}px;--col-modified:${colWidths.modified}px;--table-min-width:${tableMinWidth}px;--header-offset:${-headerScrollLeft}px;`;\n\n  $: {\n    for (const entry of visibleRows) {\n      void ensureIcon(entry);\n    }\n  }\n\n  function showToast(message) {\n    toast = message;\n    clearTimeout(toastTimer);\n    toastTimer = setTimeout(() => {\n      toast = '';\n    }, 3000);\n  }\n\n  function bytesToBase64(bytes) {\n    let binary = '';\n    const chunk = 0x8000;\n    for (let i = 0; i < bytes.length; i += chunk) {\n      const part = bytes.subarray(i, i + chunk);\n      binary += String.fromCharCode(...part);\n    }\n    return btoa(binary);\n  }\n\n  function highlightSegments(name, q) {\n    q = (q || '').trim();\n    if (!q) return [{ text: name, hl: false }];\n\n    // Reset cache when query changes\n    if (q !== highlightCacheQuery) {\n      highlightCache = new Map();\n      highlightCacheQuery = q;\n    }\n\n    // Check cache\n    const cached = highlightCache.get(name);\n    if (cached) return cached;\n\n    if (q.includes('/')) q = q.slice(q.lastIndexOf('/') + 1);\n    q = q.replace(/[*?]/g, '');\n    const terms = q.split(/\\s+/).filter(Boolean);\n    if (terms.length === 0) return [{ text: name, hl: false }];\n\n    const lower = name.toLowerCase();\n    const marks = new Uint8Array(name.length);\n    for (const t of terms) {\n      const tl = t.toLowerCase();\n      let idx = lower.indexOf(tl);\n      while (idx !== -1) {\n        for (let i = idx; i < idx + tl.length; i++) marks[i] = 1;\n        idx = lower.indexOf(tl, idx + 1);\n      }\n    }\n\n    const segs = [];\n    let i = 0;\n    while (i < name.length) {\n      const m = marks[i];\n      let j = i + 1;\n      while (j < name.length && marks[j] === m) j++;\n      segs.push({ text: name.slice(i, j), hl: m === 1 });\n      i = j;\n    }\n\n    highlightCache.set(name, segs);\n    return segs;\n  }\n\n  const perFileIconExts = new Set(['exe', 'lnk', 'ico', 'url', 'scr', 'appx']);\n\n  function iconKey(entry) {\n    if (entry.isDir) return '__folder__';\n    const ext = (entry.ext || '').toLowerCase();\n    if (perFileIconExts.has(ext)) return entry.path;\n    return ext || '__file__';\n  }\n\n  function iconFor(entry) {\n    return iconCache.get(iconKey(entry)) || (entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n  }\n\n  async function ensureIcon(entry) {\n    const key = iconKey(entry);\n    if (iconCache.has(key) || iconLoading.has(key)) {\n      return;\n    }\n\n    iconLoading.add(key);\n    try {\n      const bytes = await invoke('get_file_icon', {\n        path: entry.path,\n        ext: entry.isDir ? 'folder' : entry.ext || '',\n      });\n      if (Array.isArray(bytes) && bytes.length > 0) {\n        const image = `data:image/png;base64,${bytesToBase64(Uint8Array.from(bytes))}`;\n        iconCache.set(key, image);\n      } else {\n        iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n      }\n    } catch {\n      iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n    } finally {\n      iconLoading.delete(key);\n    }\n  }\n\n  function syncColumnWidthsToContainer() {\n    const width = tableContainer?.clientWidth || tableAreaEl?.clientWidth;\n    if (!width || lastTableWidth !== 0) {\n      return;\n    }\n\n    const saved = loadColWidths();\n    if (saved) {\n      const total = columnKeys.reduce((s, k) => s + saved[k], 0);\n      if (Math.abs(total - width) > 2) {\n        const scale = (width - saved.modified) / (total - saved.modified);\n        let scaledName = Math.max(minColumnWidth.name, Math.round(saved.name * scale));\n        let scaledSize = Math.max(minColumnWidth.size, Math.round(saved.size * scale));\n        let rawPath = width - saved.modified - scaledName - scaledSize;\n        if (rawPath < minColumnWidth.path) {\n          const shortfall = minColumnWidth.path - rawPath;\n          const nameReduction = Math.min(shortfall, scaledName - minColumnWidth.name);\n          scaledName -= nameReduction;\n          const remaining = shortfall - nameReduction;\n          if (remaining > 0) {\n            scaledSize -= Math.min(remaining, scaledSize - minColumnWidth.size);\n          }\n          rawPath = width - saved.modified - scaledName - scaledSize;\n        }\n        const scaledPath = Math.max(minColumnWidth.path, rawPath);\n        colWidths = { name: scaledName, path: scaledPath, size: scaledSize, modified: saved.modified };\n      } else {\n        colWidths = saved;\n      }\n    } else {\n      const fixedModified = minColumnWidth.modified;\n      const rest = width - fixedModified;\n      const ratioSum = defaultColumnRatios.name + defaultColumnRatios.path + defaultColumnRatios.size;\n      colWidths = {\n        name: Math.max(minColumnWidth.name, Math.round(rest * defaultColumnRatios.name / ratioSum)),\n        path: Math.max(minColumnWidth.path, Math.round(rest * defaultColumnRatios.path / ratioSum)),\n        size: Math.max(minColumnWidth.size, Math.round(rest * defaultColumnRatios.size / ratioSum)),\n        modified: fixedModified\n      };\n    }\n    lastTableWidth = width;\n  }\n\n  function loadColWidths() {\n    try {\n      const raw = localStorage.getItem(COL_WIDTHS_KEY);\n      if (!raw) return null;\n      const parsed = JSON.parse(raw);\n      for (const key of columnKeys) {\n        if (typeof parsed[key] !== 'number' || parsed[key] < (minColumnWidth[key] || 0)) return null;\n      }\n      return parsed;\n    } catch {\n      return null;\n    }\n  }\n\n  function saveColWidths() {\n    localStorage.setItem(COL_WIDTHS_KEY, JSON.stringify(colWidths));\n  }\n\n  function updateViewportHeight() {\n    viewportHeight = tableContainer?.clientHeight || 520;\n    syncColumnWidthsToContainer();\n  }\n\n  function scheduleViewportHeightUpdate() {\n    if (viewportResizeRaf !== null) {\n      return;\n    }\n    viewportResizeRaf = requestAnimationFrame(() => {\n      viewportResizeRaf = null;\n      updateViewportHeight();\n    });\n  }\n\n  function startColumnResize(event, leftKey) {\n    event.preventDefault();\n    event.stopPropagation();\n\n    const index = columnKeys.indexOf(leftKey);\n    if (index < 0 || index >= columnKeys.length - 1) {\n      return;\n    }\n\n    const startX = event.clientX;\n    const startLeft = colWidths[leftKey];\n    const rightKey = columnKeys[index + 1];\n    const startRight = colWidths[rightKey];\n\n    resizeCleanup?.();\n    resizingColumn = leftKey;\n\n    const onMove = (moveEvent) => {\n      const delta = Math.round(moveEvent.clientX - startX);\n      if (leftKey === 'name') {\n        // Two-column trade: name and path swap space, each respects its minimum\n        const nextLeft = Math.max(\n          minColumnWidth[leftKey],\n          Math.min(startLeft + delta, startLeft + startRight - minColumnWidth[rightKey])\n        );\n        const nextRight = startLeft + startRight - nextLeft;\n        colWidths = { ...colWidths, [leftKey]: nextLeft, [rightKey]: nextRight };\n      } else {\n        // path splitter: path grows unconstrained (allows horizontal scroll on right drag)\n        const nextLeft = Math.max(minColumnWidth[leftKey], startLeft + delta);\n        colWidths = { ...colWidths, [leftKey]: nextLeft };\n      }\n    };\n\n    const onUp = () => {\n      cleanup();\n    };\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      document.body.style.cursor = '';\n      document.body.style.userSelect = '';\n      resizingColumn = '';\n      saveColWidths();\n      if (resizeCleanup === cleanup) {\n        resizeCleanup = null;\n      }\n    };\n\n    resizeCleanup = cleanup;\n    document.body.style.cursor = 'col-resize';\n    document.body.style.userSelect = 'none';\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  function selectedPaths() {\n    const sorted = [...selectedIndices].sort((a, b) => a - b);\n    return sorted.map((idx) => results[idx]).filter(Boolean).map((entry) => entry.path);\n  }\n\n  function clearSelection() {\n    selectedIndices = new Set();\n    selectionAnchor = -1;\n    lastSelectedIndex = -1;\n  }\n\n  function selectSingle(index) {\n    selectedIndices = new Set([index]);\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectToggle(index) {\n    const next = new Set(selectedIndices);\n    if (next.has(index)) {\n      next.delete(index);\n    } else {\n      next.add(index);\n    }\n    selectedIndices = next;\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectRange(index) {\n    const anchor = selectionAnchor >= 0 ? selectionAnchor : index;\n    const [from, to] = [Math.min(anchor, index), Math.max(anchor, index)];\n    const next = new Set();\n    for (let i = from; i <= to; i += 1) {\n      next.add(i);\n    }\n    selectedIndices = next;\n    lastSelectedIndex = index;\n  }\n\n  function primaryEntry() {\n    const idx = lastSelectedIndex >= 0 ? lastSelectedIndex : -1;\n    return idx >= 0 ? results[idx] : null;\n  }\n\n  async function refreshStatus() {\n    if (statusRefreshInFlight) {\n      return;\n    }\n    statusRefreshInFlight = true;\n    try {\n      const status = await invoke('get_index_status');\n      const prevState = indexStatus.state;\n      indexStatus = {\n        state: status.state,\n        entriesCount: status.entriesCount,\n        lastUpdated: status.lastUpdated,\n        permissionErrors: status.permissionErrors ?? 0,\n        message: status.message\n      };\n      if (status.state === 'Indexing' && prevState !== 'Indexing') {\n        startElapsedTimer();\n      } else if (status.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n      if (typeof status.scanned === 'number') {\n        scanned = status.scanned;\n      }\n      if (status.state === 'Ready' && prevState !== 'Ready') {\n        scheduleSearch();\n      }\n    } catch (err) {\n      showToast(`Failed to get status: ${String(err)}`);\n    } finally {\n      statusRefreshInFlight = false;\n    }\n  }\n\n  function scheduleSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const scheduledGen = searchGeneration;\n    clearTimeout(searchTimer);\n\n    const now = performance.now();\n    if (now - lastSearchFiredAt >= 200) {\n      // Leading edge: fire immediately if enough time has passed\n      lastSearchFiredAt = now;\n      void runSearch(preserveScroll);\n    } else {\n      // Trailing edge: debounce\n      searchTimer = setTimeout(() => {\n        if (scheduledGen !== searchGeneration) {\n          return;\n        }\n        lastSearchFiredAt = performance.now();\n        void runSearch(preserveScroll);\n      }, 200);\n    }\n  }\n\n  async function runSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const gen = searchGeneration;\n    const searchQuery = query;\n    const searchSortBy = sortBy;\n    const searchSortDir = sortDir;\n    const startedAt = performance.now();\n    try {\n      const keepPaths = new Set(selectedPaths());\n      const next = await invoke('search', {\n        query: searchQuery,\n        limit: PAGE_SIZE,\n        offset: 0,\n        sortBy: searchSortBy,\n        sortDir: searchSortDir\n      });\n\n      if (gen !== searchGeneration) return;\n\n      dbLatencyMs = Math.round(performance.now() - startedAt);\n      dbLastQuery = searchQuery;\n      const entries = Array.isArray(next.entries) ? next.entries : [];\n      searchModeLabel = next.modeLabel || '';\n      results = entries;\n      if (next.totalCount > 0) {\n        totalResults = next.totalCount;\n        totalResultsKnown = true;\n      } else {\n        totalResults = entries.length;\n        totalResultsKnown = false;\n      }\n      hasMore = totalResultsKnown ? results.length < totalResults : entries.length >= PAGE_SIZE;\n      if (!preserveScroll && tableContainer) tableContainer.scrollTop = 0;\n\n      const restored = new Set();\n      for (let i = 0; i < results.length; i += 1) {\n        if (keepPaths.has(results[i].path)) {\n          restored.add(i);\n        }\n      }\n      selectedIndices = restored;\n\n      updateViewportHeight();\n    } catch (err) {\n      if (gen !== searchGeneration) return;\n      showToast(`Search failed: ${String(err)}`);\n    }\n  }\n\n  async function loadMore() {\n    if (!hasMore || loadingMore) return;\n    const gen = searchGeneration;\n    loadingMore = true;\n    try {\n      const batch = await invoke('search', {\n        query,\n        limit: PAGE_SIZE,\n        offset: results.length,\n        sortBy: sortBy,\n        sortDir: sortDir\n      });\n      if (gen !== searchGeneration) return;\n      const arr = Array.isArray(batch.entries) ? batch.entries : [];\n      if (arr.length > 0) results = [...results, ...arr];\n      hasMore = totalResultsKnown ? results.length < totalResults : arr.length >= PAGE_SIZE;\n    } catch (err) {\n      showToast(`Failed to load more: ${String(err)}`);\n    } finally {\n      loadingMore = false;\n    }\n  }\n\n  function moveSelection(delta, withRange = false) {\n    if (results.length === 0) {\n      return;\n    }\n\n    const current = lastSelectedIndex >= 0 ? lastSelectedIndex : 0;\n    const next = Math.max(0, Math.min(results.length - 1, current + delta));\n\n    if (withRange) {\n      selectRange(next);\n    } else {\n      selectSingle(next);\n    }\n\n    const top = next * rowHeight;\n    const bottom = top + rowHeight;\n    if (top < scrollTop) {\n      tableContainer.scrollTop = top;\n    } else if (bottom > scrollTop + viewportHeight) {\n      tableContainer.scrollTop = bottom - viewportHeight;\n    }\n  }\n\n  function handleHeaderSort(column) {\n    if (sortBy === column) {\n      sortDir = sortDir === 'asc' ? 'desc' : 'asc';\n    } else {\n      sortBy = column;\n      sortDir = 'asc';\n    }\n    if (tableContainer) tableContainer.scrollTop = 0;\n    void runSearch();\n  }\n\n  function handleRowClick(event, index) {\n    contextMenu.visible = false;\n\n    if (event.shiftKey) {\n      selectRange(index);\n      return;\n    }\n\n    if (event.metaKey || event.ctrlKey) {\n      selectToggle(index);\n      return;\n    }\n\n    selectSingle(index);\n  }\n\n  function handleRowContextMenu(event, index) {\n    event.preventDefault();\n\n    if (!selectedIndices.has(index)) {\n      selectSingle(index);\n    }\n\n    if (platform === 'windows' || platform === 'macos') {\n      contextMenu.visible = false;\n      const paths = selectedPaths();\n      if (paths.length > 0) {\n        invoke('show_context_menu', {\n          paths,\n          x: event.clientX,\n          y: event.clientY,\n          singleSelection: selectedIndices.size === 1\n        });\n      }\n      return;\n    }\n\n    contextMenu = {\n      visible: true,\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n\n  function handleRowA11yKeydown(event, index) {\n    if (event.key === ' ' || event.key === 'Enter') {\n      event.preventDefault();\n      handleRowClick(event, index);\n    }\n  }\n\n  const DRAG_THRESHOLD = 5;\n  let dragCleanup = null;\n  const dragImgCache = new Map();\n\n  function dragPathsForIndex(index) {\n    const entry = results[index];\n    if (!entry) {\n      return [];\n    }\n\n    if (selectedIndices.has(index) && selectedIndices.size > 0) {\n      return selectedPaths();\n    }\n\n    return [entry.path];\n  }\n\n  function getDragIconEl(entry) {\n    const src = iconFor(entry);\n    let img = dragImgCache.get(src);\n    if (!img) {\n      img = new Image();\n      img.src = src;\n      dragImgCache.set(src, img);\n    }\n    return img.complete && img.naturalWidth > 0 ? img : null;\n  }\n\n  function fillRoundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function buildDragPreview(index) {\n    const entry = results[index];\n    if (!entry) return null;\n\n    const count = selectedIndices.has(index) ? selectedIndices.size : 1;\n    const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\n\n    const w = 260;\n    const h = 28;\n    const stackGap = count > 1 ? 4 : 0;\n\n    const canvas = document.createElement('canvas');\n    canvas.width = w;\n    canvas.height = h + stackGap;\n    const ctx = canvas.getContext('2d');\n\n    if (count > 1) {\n      ctx.globalAlpha = 0.35;\n      ctx.fillStyle = isDark ? '#5a6070' : '#b0c4de';\n      fillRoundRect(ctx, 3, 0, w - 3, h, 5);\n      ctx.globalAlpha = 1.0;\n    }\n\n    const ry = stackGap;\n    ctx.fillStyle = isDark ? 'rgba(58, 64, 74, 0.94)' : 'rgba(214, 231, 255, 0.94)';\n    fillRoundRect(ctx, 0, ry, w, h, 5);\n\n    ctx.strokeStyle = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';\n    ctx.lineWidth = 0.5;\n    ctx.beginPath();\n    ctx.moveTo(5, ry);\n    ctx.arcTo(w, ry, w, ry + h, 5);\n    ctx.arcTo(w, ry + h, 0, ry + h, 5);\n    ctx.arcTo(0, ry + h, 0, ry, 5);\n    ctx.arcTo(0, ry, w, ry, 5);\n    ctx.closePath();\n    ctx.stroke();\n\n    const iconEl = getDragIconEl(entry);\n    if (iconEl) {\n      ctx.drawImage(iconEl, 6, ry + 6, 16, 16);\n    } else {\n      ctx.fillStyle = entry.isDir ? '#d9b34f' : '#8d98a5';\n      fillRoundRect(ctx, 6, ry + 6, 16, 16, 2);\n    }\n\n    ctx.fillStyle = isDark ? '#e6e6e8' : '#1a1a1a';\n    ctx.font = '12px -apple-system, \"SF Pro Text\", system-ui, sans-serif';\n    ctx.textBaseline = 'middle';\n\n    let nameMaxW = w - 34;\n    if (count > 1) nameMaxW -= 34;\n\n    let name = entry.name;\n    if (ctx.measureText(name).width > nameMaxW) {\n      while (name.length > 4 && ctx.measureText(name + '\\u2026').width > nameMaxW) {\n        name = name.slice(0, -1);\n      }\n      name += '\\u2026';\n    }\n    ctx.fillText(name, 28, ry + h / 2 + 1);\n\n    if (count > 1) {\n      const badge = String(count);\n      ctx.font = 'bold 10px -apple-system, system-ui, sans-serif';\n      const tw = ctx.measureText(badge).width;\n      const bw = Math.max(20, tw + 10);\n      const bx = w - bw - 6;\n      const by = ry + (h - 18) / 2;\n\n      ctx.fillStyle = isDark ? '#5b8bd9' : '#007aff';\n      fillRoundRect(ctx, bx, by, bw, 18, 9);\n\n      ctx.fillStyle = '#ffffff';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(badge, bx + bw / 2, by + 9);\n    }\n\n    return canvas.toDataURL('image/png');\n  }\n\n  function handleRowMouseDown(event, index) {\n    if (event.button !== 0) return;\n    if (event.metaKey || event.ctrlKey || event.shiftKey) return;\n    if (editing.active) return;\n\n    const startX = event.clientX;\n    const startY = event.clientY;\n    let dragging = false;\n\n    dragCleanup?.();\n\n    const onMove = (e) => {\n      if (dragging) return;\n      const dx = e.clientX - startX;\n      const dy = e.clientY - startY;\n      if (dx * dx + dy * dy < DRAG_THRESHOLD * DRAG_THRESHOLD) return;\n\n      dragging = true;\n      cleanup();\n\n      if (!selectedIndices.has(index)) {\n        selectSingle(index);\n      }\n\n      const paths = dragPathsForIndex(index);\n      if (paths.length > 0) {\n        const icon = buildDragPreview(index);\n        startDrag({ item: paths, icon }).catch(() => {});\n      }\n    };\n\n    const onUp = () => cleanup();\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      if (dragCleanup === cleanup) dragCleanup = null;\n    };\n\n    dragCleanup = cleanup;\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  async function handleRowDoubleClick(index) {\n    if (!selectedIndices.has(index) || selectedIndices.size > 1) {\n      selectSingle(index);\n      await tick();\n    }\n    await invoke('open', { paths: [results[index].path] }).catch((err) => {\n      showToast(`Failed to open: ${String(err)}`);\n    });\n  }\n\n  function closeContextMenu() {\n    contextMenu = {\n      ...contextMenu,\n      visible: false\n    };\n  }\n\n  async function openSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('open', { paths });\n    } catch (err) {\n      showToast(`Failed to open: ${String(err)}`);\n    }\n  }\n\n  async function openWithFallback() {\n    const target = primaryEntry();\n    if (!target) {\n      return;\n    }\n\n    try {\n      await invoke('open_with', { path: target.path });\n    } catch (err) {\n      showToast(`Open With failed: ${String(err)}`);\n    }\n  }\n\n  async function revealSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('reveal_in_finder', { paths });\n    } catch (err) {\n      showToast(`Failed to reveal in Finder: ${String(err)}`);\n    }\n  }\n\n  async function copySelectedPaths() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_paths', { paths });\n      showToast(`Copied ${paths.length} path(s)`);\n    } catch (err) {\n      showToast(`Failed to copy path: ${String(err)}`);\n    }\n  }\n\n  async function copyFiles() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_files', { paths });\n      showToast(`Copied ${paths.length} item(s)`);\n    } catch (err) {\n      showToast(`Failed to copy: ${String(err)}`);\n    }\n  }\n\n  async function trashSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    const message =\n      paths.length === 1\n        ? 'Move selected item to Trash?'\n        : `Move ${paths.length} items to Trash?`;\n\n    if (!window.confirm(message)) {\n      return;\n    }\n\n    try {\n      await invoke('move_to_trash', { paths });\n      showToast('Moved to Trash.');\n      clearSelection();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to move to Trash: ${String(err)}`);\n    }\n  }\n\n  async function resetIndex() {\n    if (indexStatus.state === 'Indexing') {\n      showToast('Indexing in progress. Please try again after it completes.');\n      return;\n    }\n\n    results = [];\n    totalResults = 0;\n    totalResultsKnown = false;\n    clearSelection();\n    scanned = 0;\n    dbLatencyMs = null;\n    dbLastQuery = '';\n    indexStatus = { ...indexStatus, state: 'Indexing', entriesCount: 0, message: null };\n    indexingStartTime = Date.now();\n    indexingElapsed = '';\n    indexingFinishedAt = '';\n\n    try {\n      await invoke('reset_index');\n    } catch (err) {\n      showToast(`Failed to reset index: ${String(err)}`);\n      await refreshStatus();\n    }\n  }\n\n  function isMultiSelected() {\n    return selectedIndices.size > 1;\n  }\n\n  function autoResizeRenameInput() {\n    if (!renameInputEl) return;\n    renameInputEl.style.height = '0';\n    renameInputEl.style.height = renameInputEl.scrollHeight + 'px';\n  }\n\n  async function startRename() {\n    if (isMultiSelected()) {\n      return;\n    }\n\n    const idx = lastSelectedIndex;\n    if (idx < 0 || !results[idx]) {\n      return;\n    }\n\n    const entry = results[idx];\n\n    // Calculate overlay position mathematically.\n    // Name cell text starts at: padding-left(16) + icon(16) + gap(6) = 38px from cell left.\n    // Textarea has padding-left: 0 and border: 1.5px, so text starts ~2px from overlay left.\n    if (tableContainer) {\n      const rect = tableContainer.getBoundingClientRect();\n      const cellLeft = rect.left - tableContainer.scrollLeft;\n      const textLeft = cellLeft + 38;\n      const cellRight = cellLeft + colWidths.name;\n      const rowTop = rect.top + idx * rowHeight - tableContainer.scrollTop;\n      renameOverlay = {\n        top: rowTop,\n        left: textLeft - 2,\n        width: cellRight - textLeft + 2 - 4\n      };\n    }\n\n    editing = {\n      active: true,\n      path: entry.path,\n      index: idx,\n      draftName: entry.name\n    };\n\n    await tick();\n\n    if (renameInputEl) {\n      autoResizeRenameInput();\n      renameInputEl.focus();\n      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n      renameInputEl.setSelectionRange(0, selectionEnd);\n    }\n  }\n\n  function cancelRename() {\n    editing = {\n      active: false,\n      path: '',\n      index: -1,\n      draftName: ''\n    };\n  }\n\n  async function commitRename() {\n    if (!editing.active || editing.index < 0 || !results[editing.index]) {\n      return;\n    }\n\n    const current = results[editing.index];\n    const nextName = editing.draftName;\n\n    try {\n      await invoke('rename', {\n        path: current.path,\n        newName: nextName\n      });\n      cancelRename();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to rename: ${String(err)}`);\n      await tick();\n      renameInputEl?.focus();\n    }\n  }\n\n  function onGlobalClick() {\n    closeContextMenu();\n  }\n\n  function onTitleBarMouseDown(event) {\n    if (event.button !== 0) {\n      return;\n    }\n\n    const activeElement = document.activeElement;\n    if (activeElement instanceof HTMLElement && isTextInputTarget(activeElement)) {\n      activeElement.blur();\n    }\n  }\n\n  async function focusSearch() {\n    await getCurrentWindow().show();\n    await getCurrentWindow().setFocus();\n    searchInputEl?.focus();\n    searchInputEl?.select();\n  }\n\n  function isTextInputTarget(target) {\n    return (\n      target instanceof HTMLInputElement ||\n      target instanceof HTMLTextAreaElement ||\n      target?.isContentEditable\n    );\n  }\n\n  async function handleKeydown(event) {\n    const isMetaSelectAll = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'a';\n    const isMetaCopy = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c';\n    const target = event.target;\n    const isTextInput = isTextInputTarget(target);\n\n    if (isMetaCopy && isTextInput) {\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      if (isTextInput) {\n        event.preventDefault();\n        if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n          target.select();\n        }\n        return;\n      }\n    }\n\n    if (editing.active) {\n      if (event.key === 'Enter') {\n        event.preventDefault();\n        await commitRename();\n        return;\n      }\n\n      if (event.key === 'Escape') {\n        event.preventDefault();\n        cancelRename();\n        searchInputEl?.focus();\n        return;\n      }\n      return;\n    }\n\n    if (event.key === 'Escape') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      return;\n    }\n\n    if (event.key === 'ArrowDown') {\n      event.preventDefault();\n      moveSelection(1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'ArrowUp') {\n      event.preventDefault();\n      moveSelection(-1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageDown') {\n      event.preventDefault();\n      moveSelection(Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageUp') {\n      event.preventDefault();\n      moveSelection(-Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'Enter') {\n      event.preventDefault();\n      if (platform === 'windows') {\n        await openSelected();\n      } else {\n        await startRename();\n      }\n      return;\n    }\n\n    if (event.key === 'F2') {\n      event.preventDefault();\n      await startRename();\n      return;\n    }\n\n    if (event.key === ' ' && !isTextInput) {\n      event.preventDefault();\n      const entry = primaryEntry();\n      if (entry) {\n        await invoke('quick_look', { path: entry.path });\n      }\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'f') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      searchInputEl?.select();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'o') {\n      event.preventDefault();\n      await openSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {\n      event.preventDefault();\n      await revealSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c') {\n      event.preventDefault();\n      await copySelectedPaths();\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      event.preventDefault();\n      selectedIndices = new Set(Array.from({ length: results.length }, (_, i) => i));\n      return;\n    }\n\n    if (event.key === 'Delete' || ((event.metaKey || event.ctrlKey) && event.key === 'Backspace')) {\n      if (!isTextInput) {\n        event.preventDefault();\n        await trashSelected();\n      }\n      return;\n    }\n  }\n\n  function formatSize(entry) {\n    if (entry.isDir || entry.size == null) return '';\n    const bytes = entry.size;\n    if (bytes < 1024) return `${bytes} B`;\n    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n    return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n  }\n\n  function formatModified(entry) {\n    if (!entry.mtime) {\n      return '';\n    }\n\n    const d = new Date(entry.mtime * 1000);\n    const pad = (n) => String(n).padStart(2, '0');\n    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;\n  }\n\n  function formatLastUpdated(timestamp) {\n    if (!timestamp) {\n      return '-';\n    }\n\n    return new Date(timestamp * 1000).toLocaleString();\n  }\n\n  function formatElapsed(ms) {\n    const totalSec = Math.floor(ms / 1000);\n    const min = Math.floor(totalSec / 60);\n    const sec = totalSec % 60;\n    return min > 0 ? `${min}m ${sec}s` : `${sec}s`;\n  }\n\n  function updateElapsed() {\n    if (indexingStartTime && indexStatus.state === 'Indexing') {\n      indexingElapsed = formatElapsed(Date.now() - indexingStartTime);\n    }\n  }\n\n  function startElapsedTimer() {\n    clearInterval(elapsedTimer);\n    indexingStartTime = Date.now();\n    indexingElapsed = '0s';\n    indexingFinishedAt = '';\n    elapsedTimer = setInterval(updateElapsed, 1000);\n  }\n\n  function stopElapsedTimer() {\n    clearInterval(elapsedTimer);\n    if (indexingStartTime) {\n      const elapsed = Date.now() - indexingStartTime;\n      indexingFinishedAt = `${formatElapsed(elapsed)}`;\n    }\n    indexingStartTime = null;\n    indexingElapsed = '';\n  }\n\n  function displayPath(path) {\n    if (!path) {\n      return path;\n    }\n\n    if (!homePrefix) {\n      return path;\n    }\n\n    if (path === homePrefix) {\n      return '~';\n    }\n\n    if (path.startsWith(`${homePrefix}/`)) {\n      return `~${path.slice(homePrefix.length)}`;\n    }\n\n    return path;\n  }\n\n  let unlistenFns = [];\n\n  onMount(async () => {\n    const t0 = performance.now();\n    const ms = () => Math.round(performance.now() - t0);\n    const DEBUG_STARTUP = false;\n    const flog = DEBUG_STARTUP ? (msg) => invoke('frontend_log', { msg }).catch(() => {}) : () => {};\n\n    flog(`[startup/fe] onMount entered`);\n\n    updateViewportHeight();\n    flog(`[startup/fe] +${ms()}ms updateViewportHeight done`);\n\n    platform = await invoke('get_platform');\n    flog(`[startup/fe] +${ms()}ms get_platform done`);\n\n    const unlistenProgress = await listen('index_progress', (event) => {\n      scanned = event.payload.scanned;\n      if (indexStatus.state !== 'Indexing') {\n        indexStatus = {\n          ...indexStatus,\n          state: 'Indexing'\n        };\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_progress) registered`);\n\n    const unlistenState = await listen('index_state', (event) => {\n      flog(`[startup/fe] index_state event received: ${event.payload.state} at +${ms()}ms`);\n      const prevState = indexStatus.state;\n      indexStatus = {\n        ...indexStatus,\n        state: event.payload.state,\n        message: event.payload.message ?? null,\n        isCatchup: event.payload.isCatchup ?? false\n      };\n\n      if (event.payload.state === 'Indexing' && prevState !== 'Indexing') {\n        if (prevState === 'Ready') {\n          lastReadyCount = indexStatus.entriesCount;\n        }\n        startElapsedTimer();\n      } else if (event.payload.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n\n      if (event.payload.state === 'Ready') {\n        scheduleSearch();\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_state) registered`);\n\n    const unlistenUpdated = await listen('index_updated', (event) => {\n      indexStatus = {\n        ...indexStatus,\n        entriesCount: event.payload.entriesCount,\n        lastUpdated: event.payload.lastUpdated,\n        permissionErrors: event.payload.permissionErrors ?? indexStatus.permissionErrors\n      };\n\n      scheduleSearch(true);\n    });\n\n    const unlistenFocus = await listen('focus_search', () => {\n      void focusSearch();\n    });\n\n    const unlistenCtxMenuAction = await listen('context_menu_action', (event) => {\n      switch (event.payload) {\n        case 'open': void openSelected(); break;\n        case 'quick_look': {\n          const e = primaryEntry();\n          if (e) void invoke('quick_look', { path: e.path });\n          break;\n        }\n        case 'open_with': void openWithFallback(); break;\n        case 'reveal': void revealSelected(); break;\n        case 'copy_files': void copyFiles(); break;\n        case 'copy_path': void copySelectedPaths(); break;\n        case 'trash': void trashSelected(); break;\n        case 'rename': void startRename(); break;\n      }\n    });\n\n    unlistenFns = [unlistenProgress, unlistenState, unlistenUpdated, unlistenFocus, unlistenCtxMenuAction];\n    flog(`[startup/fe] +${ms()}ms all listeners registered`);\n\n    // Fetch backend state IMMEDIATELY after listeners are registered.\n    // Events emitted before listener registration are lost, so this\n    // is the only reliable way to get the current state.\n    await refreshStatus();\n    flog(`[startup/fe] +${ms()}ms refreshStatus done (state=${indexStatus.state})`);\n\n    // Show Svelte UI: remove skeleton, focus search input.\n    await tick();\n    document.getElementById('skeleton')?.remove();\n    await focusSearch();\n    flog(`[startup/fe] +${ms()}ms WINDOW VISIBLE â€” skeleton removed`);\n\n    try {\n      homePrefix = await invoke('get_home_dir');\n    } catch {\n      homePrefix = '';\n    }\n    flog(`[startup/fe] +${ms()}ms get_home_dir done`);\n\n    if (!localStorage.getItem('everything-fda-notice-v1')) {\n      showToast('macOS Full Disk Access permission may be required for full disk search.');\n      localStorage.setItem('everything-fda-notice-v1', '1');\n    }\n    flog(`[startup/fe] +${ms()}ms calling runSearch...`);\n    await runSearch();\n    flog(`[startup/fe] +${ms()}ms runSearch done`);\n\n    if (typeof ResizeObserver !== 'undefined') {\n      tableResizeObserver = new ResizeObserver(() => {\n        scheduleViewportHeightUpdate();\n      });\n      if (tableContainer) {\n        tableResizeObserver.observe(tableContainer);\n      } else if (tableAreaEl) {\n        tableResizeObserver.observe(tableAreaEl);\n      }\n    }\n\n    window.addEventListener('resize', scheduleViewportHeightUpdate);\n    window.addEventListener('click', onGlobalClick);\n    statusRefreshTimer = setInterval(() => {\n      if (indexStatus.state === 'Indexing') {\n        void refreshStatus();\n      }\n    }, 1000);\n    console.log(`[startup/fe] +${ms()}ms onMount complete`);\n  });\n\n  onDestroy(async () => {\n    clearTimeout(searchTimer);\n    clearTimeout(toastTimer);\n    clearInterval(statusRefreshTimer);\n    clearInterval(elapsedTimer);\n    resizeCleanup?.();\n\n    for (const unlisten of unlistenFns) {\n      unlisten();\n    }\n\n    tableResizeObserver?.disconnect();\n    tableResizeObserver = null;\n    if (viewportResizeRaf !== null) {\n      cancelAnimationFrame(viewportResizeRaf);\n      viewportResizeRaf = null;\n    }\n    window.removeEventListener('resize', scheduleViewportHeightUpdate);\n    window.removeEventListener('click', onGlobalClick);\n  });\n</script>\n\n<svelte:window on:keydown={handleKeydown} />\n\n<div class=\"app-shell\" data-theme={theme}>\n  <div class=\"title-bar\" role=\"presentation\" data-tauri-drag-region on:mousedown={onTitleBarMouseDown}>\n    <div class=\"title-left\"></div>\n    <div class=\"title-center\">\n      <svg class=\"title-icon\" viewBox=\"0 0 215 205\" fill-rule=\"evenodd\" aria-hidden=\"true\">\n        <path d=\"M85 0c46.9 0 85 38.1 85 85 0 20.1-7.2 38.5-19.2 52.7l40.7 40.8c5.8 5.8 5.8 15.2 0 21-5.8 5.8-15.2 5.8-21 0l-40.7-40.7c-13.6 9.7-30.4 15.2-44.8 15.2-46.9 0-85-42.1-85-89 0-46.9 38.1-85 85-85z m0 32c-29.3 0-53 23.7-53 53 0 29.3 23.7 53 53 53 29.3 0 53-23.7 53-53 0-29.3-23.7-53-53-53z\"/>\n      </svg>\n      <span class=\"title-text\">Everything</span>\n    </div>\n    <div class=\"title-right\"></div>\n  </div>\n\n  <header class=\"search-bar\">\n    <input\n      bind:this={searchInputEl}\n      class=\"search-input\"\n      type=\"text\"\n      bind:value={query}\n      on:input={scheduleSearch}\n      on:focus={clearSelection}\n      placeholder=\"Search file/folder names\"\n      autocomplete=\"off\"\n      spellcheck=\"false\"\n    />\n  </header>\n\n  <section class=\"table-area\" bind:this={tableAreaEl} style={tableGridStyle}>\n    <div class=\"table-header\">\n      <div class=\"table-header-track\">\n        <div class=\"col name\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('name')}>\n            Name{#if sortBy === 'name'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'name'}\n            on:mousedown={(event) => startColumnResize(event, 'name')}\n            aria-label=\"Resize Name column\"\n          />\n        </div>\n\n        <div class=\"col path\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('dir')}>\n            Path{#if sortBy === 'dir'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'path'}\n            on:mousedown={(event) => startColumnResize(event, 'path')}\n            aria-label=\"Resize Path column\"\n          />\n        </div>\n\n        <div class=\"col size\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('size')}>\n            Size{#if sortBy === 'size'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n\n        <div class=\"col modified\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('mtime')}>\n            Modified{#if sortBy === 'mtime'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n      </div>\n    </div>\n\n    <div\n      class=\"table-body\"\n      bind:this={tableContainer}\n      on:scroll={() => {\n        scrollTop = tableContainer.scrollTop;\n        headerScrollLeft = tableContainer.scrollLeft;\n        if (editing.active) cancelRename();\n        const scrollBottom = scrollTop + tableContainer.clientHeight;\n        if (scrollBottom >= totalHeight - rowHeight * 10) {\n          void loadMore();\n        }\n      }}\n    >\n      <div class=\"spacer\" style={`height:${totalHeight}px`}>\n        <div class=\"rows\" style={`transform: translateY(${translateY}px);`}>\n          {#each visibleRows as entry, localIndex}\n            {@const index = startIndex + localIndex}\n            <div\n              class=\"row {selectedIndices.has(index) ? 'selected' : ''}\"\n              on:mousedown={(event) => handleRowMouseDown(event, index)}\n              on:click={(event) => handleRowClick(event, index)}\n              on:keydown={(event) => handleRowA11yKeydown(event, index)}\n              on:dblclick={() => handleRowDoubleClick(index)}\n              on:contextmenu={(event) => handleRowContextMenu(event, index)}\n              role=\"row\"\n              tabindex=\"0\"\n            >\n              <div class=\"cell name\">\n                <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n                <span class=\"ellipsis\" class:name-editing={editing.active && editing.index === index}>{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n              </div>\n              <div class=\"cell path\"><span class=\"ellipsis\">{displayPath(entry.dir)}</span></div>\n              <div class=\"cell size\">{formatSize(entry)}</div>\n              <div class=\"cell modified\">{formatModified(entry)}</div>\n            </div>\n          {/each}\n        </div>\n      </div>\n    </div>\n  </section>\n\n  <footer class=\"status-bar\">\n    <div class=\"status-left\">\n      <span class=\"status-state\">\n        <span class=\"state-dot {indexStatus.state === 'Indexing' ? 'indexing' : indexStatus.state === 'Error' ? 'error' : 'ready'}\"></span>\n        {#if indexStatus.state === 'Indexing'}\n          Indexing{#if lastReadyCount > 0} ({Math.min(99, Math.round((scanned / lastReadyCount) * 100))}%){/if}{#if indexingElapsed} Â· {indexingElapsed}{/if}\n          {#if !indexStatus.isCatchup}\n            Â· {scanned.toLocaleString()} scanned\n          {/if}\n        {:else}\n          Index: {indexStatus.state}\n        {/if}\n      </span>\n      <span>{indexStatus.entriesCount.toLocaleString()} entries</span>\n      {#if indexingFinishedAt && indexStatus.state !== 'Indexing'}\n        <span>in {indexingFinishedAt}</span>\n      {/if}\n      {#if dbLatencyMs !== null && dbLastQuery}\n        <span>\"{dbLastQuery}\" {dbLatencyMs}ms Â· {totalResults} results</span>\n      {/if}\n      {#if searchModeLabel === 'spotlight' || searchModeLabel === 'spotlight_timeout'}\n        <span class=\"status-spotlight\">Spotlight fallback{#if searchModeLabel === 'spotlight_timeout'} (partial){/if}</span>\n      {/if}\n      {#if indexStatus.permissionErrors > 0}\n        <span class=\"status-warning\">{indexStatus.permissionErrors.toLocaleString()} permission errors</span>\n      {/if}\n      {#if indexStatus.message}\n        <span class={indexStatus.isCatchup ? 'index-progress' : 'status-error'}>{indexStatus.message}</span>\n      {/if}\n    </div>\n    <div class=\"status-right\">\n      <button class=\"status-btn theme-btn\" on:click={cycleTheme} title=\"Switch theme\">\n        {theme === 'dark' ? 'â˜€ Light' : 'â—‘ Dark'}\n      </button>\n      <button\n        class=\"status-btn rebuild-btn\"\n        on:click={resetIndex}\n        disabled={indexStatus.state === 'Indexing'}\n        title={indexStatus.state === 'Indexing' ? 'Cannot reset while indexing is in progress.' : 'Reset and rebuild the index.'}\n      >\n        <svg class=\"rebuild-icon\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n          <path d=\"M23 4v6h-6\"/><path d=\"M20.49 15a9 9 0 1 1-2.12-9.36L23 10\"/>\n        </svg>\n        Rebuild Index\n      </button>\n    </div>\n  </footer>\n\n  {#if editing.active}\n    <div\n      class=\"rename-overlay\"\n      style=\"top:{renameOverlay.top}px; left:{renameOverlay.left}px; width:{renameOverlay.width}px;\"\n      role=\"presentation\"\n      on:mousedown|stopPropagation\n    >\n      <textarea\n        bind:this={renameInputEl}\n        class=\"rename-textarea\"\n        bind:value={editing.draftName}\n        on:input={autoResizeRenameInput}\n        on:click|stopPropagation\n        on:blur={commitRename}\n      />\n    </div>\n  {/if}\n\n  {#if contextMenu.visible}\n    <div class=\"context-menu\" style={`left:${contextMenu.x}px;top:${contextMenu.y}px;`}>\n      <button on:click={() => (closeContextMenu(), openSelected())}>Open</button>\n      <button on:click={async () => { closeContextMenu(); const e = primaryEntry(); if (e) await invoke('quick_look', { path: e.path }); }}>Quick Look</button>\n      <button on:click={() => (closeContextMenu(), openWithFallback())}>Open With... (Reveal in Finder)</button>\n      <button on:click={() => (closeContextMenu(), revealSelected())}>Reveal in Finder</button>\n      <button on:click={() => (closeContextMenu(), copySelectedPaths())}>Copy Path</button>\n      <button on:click={() => (closeContextMenu(), trashSelected())}>Move to Trash</button>\n      {#if selectedIndices.size === 1}\n        <button on:click={() => (closeContextMenu(), startRename())}>Rename</button>\n      {/if}\n    </div>\n  {/if}\n\n  {#if toast}\n    <div class=\"toast\">{toast}</div>\n  {/if}\n</div>\n\n<style>\n  :global(:root) {\n    color-scheme: light dark;\n    --bg-app: transparent;\n    --text-primary: #0d1826;\n    --text-muted: #48596c;\n    --bar-grad-top: rgba(255, 255, 255, 0.48);\n    --bar-grad-bottom: rgba(248, 250, 253, 0.42);\n    --surface-header: rgba(252, 252, 255, 0.40);\n    --surface: rgba(255, 255, 255, 0.22);\n    --border-soft: rgba(0, 0, 0, 0.07);\n    --border-input: rgba(0, 0, 0, 0.13);\n    --focus-ring: #6f96e6;\n    --row-border: rgba(0, 0, 0, 0.032);\n    --row-hover: rgba(0, 0, 0, 0.06);\n    --row-selected: rgba(0, 0, 0, 0.12);\n    --button-bg: rgba(255, 255, 255, 0.62);\n    --button-border: rgba(0, 0, 0, 0.10);\n    --button-text: #2c3e50;\n    --menu-bg: rgba(240, 241, 248, 0.90);\n    --menu-border: rgba(0, 0, 0, 0.06);\n    --menu-hover: rgba(255, 255, 255, 0.62);\n    --menu-text: #1a2a38;\n    --error-text: #b64545;\n    --warning-text: #8f6500;\n    --toast-bg: rgba(18, 22, 32, 0.90);\n    --toast-text: #ffffff;\n  }\n\n  @media (prefers-color-scheme: dark) {\n    :global(:root) {\n      --bg-app: transparent;\n      --text-primary: #e6e6ea;\n      --text-muted: #9494a4;\n      --bar-grad-top: rgba(38, 38, 46, 0.52);\n      --bar-grad-bottom: rgba(30, 30, 38, 0.46);\n      --surface-header: rgba(32, 32, 40, 0.46);\n      --surface: rgba(18, 18, 26, 0.32);\n      --border-soft: rgba(255, 255, 255, 0.065);\n      --border-input: rgba(255, 255, 255, 0.14);\n      --focus-ring: #5b8bd9;\n      --row-border: rgba(255, 255, 255, 0.026);\n      --row-hover: rgba(255, 255, 255, 0.08);\n      --row-selected: rgba(255, 255, 255, 0.14);\n      --button-bg: rgba(255, 255, 255, 0.072);\n      --button-border: rgba(255, 255, 255, 0.11);\n      --button-text: #d6d6e0;\n      --menu-bg: rgba(36, 36, 46, 0.90);\n      --menu-border: rgba(255, 255, 255, 0.066);\n      --menu-hover: rgba(255, 255, 255, 0.062);\n      --menu-text: #e0e0e8;\n      --error-text: #ff9d9d;\n      --warning-text: #e0c670;\n      --toast-bg: rgba(10, 10, 16, 0.93);\n      --toast-text: #f2f2f6;\n    }\n  }\n\n  /* â”€â”€ Theme: Dark â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme=\"dark\"]) {\n    color-scheme: dark;\n    --bg-app: #1E1E21;\n    --text-primary: #E2E8F0;\n    --text-muted: #94A3B8;\n    --bar-grad-top: #1E1E21;\n    --bar-grad-bottom: #1E1E21;\n    --surface-header: #1E1E21;\n    --surface: #1E1E21;\n    --bg-input: #161618;\n    --border-soft: #2A2A2D;\n    --border-input: rgba(255, 255, 255, 0.06);\n    --focus-ring: #4DA8FF;\n    --accent: #4DA8FF;\n    --row-border: rgba(255, 255, 255, 0.02);\n    --row-hover: #282828;\n    --row-selected: rgba(77, 168, 255, 0.10);\n    --button-bg: rgba(255, 255, 255, 0.05);\n    --button-border: #2A2A2D;\n    --button-text: #94A3B8;\n    --menu-bg: #252528;\n    --menu-border: #2A2A2D;\n    --menu-hover: rgba(255, 255, 255, 0.04);\n    --menu-text: #E2E8F0;\n    --error-text: #ff9d9d;\n    --warning-text: #e0c670;\n    --toast-bg: rgba(10, 10, 16, 0.93);\n    --toast-text: #f2f2f6;\n  }\n\n  /* â”€â”€ Theme: Light â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme=\"light\"]) {\n    color-scheme: light;\n    --bg-app: #F5F5F7;\n    --text-primary: #1C1C1E;\n    --text-muted: #6E6E7A;\n    --bar-grad-top: #F5F5F7;\n    --bar-grad-bottom: #F5F5F7;\n    --surface-header: #F5F5F7;\n    --surface: #F5F5F7;\n    --bg-input: #FFFFFF;\n    --border-soft: #D1D1D6;\n    --border-input: rgba(0, 0, 0, 0.10);\n    --focus-ring: #3A8BF5;\n    --accent: #3A8BF5;\n    --row-border: rgba(0, 0, 0, 0.04);\n    --row-hover: rgba(0, 0, 0, 0.04);\n    --row-selected: rgba(58, 139, 245, 0.10);\n    --button-bg: #FFFFFF;\n    --button-border: #D1D1D6;\n    --button-text: #3C3C43;\n    --menu-bg: #FFFFFF;\n    --menu-border: #D1D1D6;\n    --menu-hover: rgba(0, 0, 0, 0.05);\n    --menu-text: #1C1C1E;\n    --error-text: #D93025;\n    --warning-text: #B45309;\n    --toast-bg: rgba(255, 255, 255, 0.95);\n    --toast-text: #1C1C1E;\n  }\n\n  /* â”€â”€ Themed element overrides â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme]) {\n    background: var(--bg-app);\n  }\n\n  /* Search bar: flat, no gradient, no separator */\n  :global([data-theme]) .search-bar {\n    height: 44px;\n    padding: 0 16px;\n    background: var(--bg-app);\n    border-bottom: none;\n  }\n\n  :global([data-theme]) .search-input {\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n    font-family: 'JetBrains Mono', 'SF Mono', monospace;\n    font-size: 12px;\n    height: 34px;\n    border-radius: 8px;\n  }\n\n  /* Table header: flat bg, 16px edge padding */\n  :global([data-theme]) .table-header {\n    background: var(--bg-app);\n  }\n\n  :global([data-theme]) .col-button {\n    padding: 0 8px;\n  }\n\n  :global([data-theme]) .col.name .col-button {\n    padding-left: 16px;\n  }\n\n  /* Row cells: JetBrains Mono, 16px outer edges */\n  :global([data-theme]) .cell {\n    font-family: 'JetBrains Mono', monospace;\n  }\n\n  :global([data-theme]) .cell.name {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    padding-left: 16px;\n    font-size: 12px;\n    color: var(--text-primary);\n  }\n\n  :global([data-theme]) .cell.path {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.size {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.modified {\n    padding-right: 16px;\n    font-size: 11px;\n    white-space: nowrap;\n  }\n\n  :global([data-theme]) .row.selected {\n    box-shadow: inset 3px 0 0 var(--accent);\n  }\n\n  /* Dim path/size/date cells in themed mode */\n  :global([data-theme]) .cell.path,\n  :global([data-theme]) .cell.size,\n  :global([data-theme]) .cell.modified {\n    color: var(--text-muted);\n  }\n\n  :global(:root) {\n    background: transparent;\n  }\n\n  :global(html, body) {\n    margin: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    background: transparent;\n    color: var(--text-primary);\n    font-family: Inter, 'SF Pro Text', 'Segoe UI', Helvetica, Arial, sans-serif;\n  }\n\n  :global(#app) {\n    width: 100%;\n    height: 100%;\n  }\n\n  .app-shell {\n    display: grid;\n    grid-template-rows: auto auto 1fr auto;\n    height: 100%;\n    min-width: 0;\n  }\n\n  .title-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 44px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    cursor: default;\n    flex-shrink: 0;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-left {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-center {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-right {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-icon {\n    width: 14px;\n    height: 14px;\n    fill: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .title-text {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 13px;\n    font-weight: 500;\n    color: var(--text-primary);\n    letter-spacing: -0.01em;\n  }\n\n  .search-bar {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding: 8px;\n    background: linear-gradient(180deg, var(--bar-grad-top) 0%, var(--bar-grad-bottom) 100%);\n    border-bottom: 1px solid var(--border-soft);\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .search-input {\n    display: block;\n    box-sizing: border-box;\n    width: 100%;\n    min-width: 0;\n    flex: 1 1 auto;\n    height: 36px;\n    border: 1px solid var(--border-input);\n    border-radius: 14px;\n    padding: 0 10px;\n    font-size: 14px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    backdrop-filter: blur(12px) saturate(160%);\n    -webkit-backdrop-filter: blur(12px) saturate(160%);\n  }\n\n  .search-input::placeholder {\n    color: var(--text-muted);\n    opacity: 0.85;\n    font-size: 12px;\n  }\n\n  .search-input:focus {\n    outline: none;\n    border-color: var(--focus-ring);\n    box-shadow: 0 0 0 2px rgba(125, 169, 255, 0.25);\n  }\n\n  .table-area {\n    display: grid;\n    grid-template-rows: auto 1fr;\n    min-height: 0;\n    min-width: 0;\n  }\n\n  .table-header-track,\n  .row {\n    display: grid;\n    grid-template-columns: var(--col-name) var(--col-path) var(--col-size) var(--col-modified);\n    align-items: center;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .table-header {\n    height: 32px;\n    border-bottom: 1px solid var(--border-soft);\n    background: var(--surface-header);\n    user-select: none;\n    overflow: hidden;\n    flex-shrink: 0;\n  }\n\n  .table-header-track {\n    height: 100%;\n    transform: translateX(var(--header-offset, 0px));\n    will-change: transform;\n  }\n\n  .table-header .col {\n    position: relative;\n    min-width: 0;\n    height: 100%;\n  }\n\n  .col-button {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n    gap: 4px;\n    box-sizing: border-box;\n    padding: 0 8px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 11px;\n    font-weight: 600;\n    line-height: 1;\n    color: var(--text-muted);\n    text-align: left;\n    margin: 0;\n    border: none;\n    background: transparent;\n    cursor: pointer;\n  }\n\n  .sort-icon {\n    width: 10px;\n    height: 10px;\n    flex-shrink: 0;\n    color: var(--accent);\n  }\n\n  .col-resizer {\n    position: absolute;\n    top: 0;\n    right: -4px;\n    width: 8px;\n    height: 100%;\n    border: none;\n    padding: 0;\n    background: transparent;\n    cursor: col-resize;\n    z-index: 30;\n  }\n\n  .col-resizer::after {\n    content: '';\n    position: absolute;\n    top: 7px;\n    bottom: 7px;\n    left: 50%;\n    width: 1px;\n    transform: translateX(-50%);\n    background: var(--border-soft);\n    opacity: 0;\n    transition: opacity 0.15s ease;\n  }\n\n  .table-header .col:hover .col-resizer::after,\n  .col-resizer.active::after {\n    opacity: 1;\n  }\n\n  .table-body {\n    overflow: auto;\n    min-height: 0;\n    min-width: 0;\n    background: var(--surface);\n  }\n\n  .spacer {\n    position: relative;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .rows {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .row {\n    height: 30px;\n    border-bottom: 1px solid var(--row-border);\n    cursor: default;\n    -webkit-user-select: none;\n    user-select: none;\n    outline: none;\n  }\n\n  .row:hover {\n    background: var(--row-hover);\n  }\n\n  .row.selected {\n    background: var(--row-selected);\n  }\n\n  .cell {\n    padding: 0 8px;\n    font-size: 12px;\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    min-width: 0;\n  }\n\n  .cell.size {\n    text-align: right;\n    font-variant-numeric: tabular-nums;\n  }\n\n  .ellipsis {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n\n  .hl {\n    background: none;\n    color: inherit;\n    font-weight: 700;\n  }\n\n  .file-icon {\n    width: 16px;\n    height: 16px;\n    flex: 0 0 auto;\n  }\n\n  .name-editing {\n    opacity: 0.25;\n  }\n\n  .rename-overlay {\n    position: fixed;\n    z-index: 100;\n    min-width: 120px;\n  }\n\n  .rename-textarea {\n    display: block;\n    width: 100%;\n    box-sizing: border-box;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 12px;\n    line-height: 18px;\n    padding: 5px 4px 5px 0;\n    border: 1.5px solid var(--focus-ring);\n    border-radius: 4px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    outline: none;\n    resize: none;\n    overflow: hidden;\n    box-shadow: 0 2px 14px rgba(0, 0, 0, 0.22), 0 0 0 3px rgba(77, 168, 255, 0.13);\n  }\n\n  .status-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 32px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    border-top: 1px solid var(--border-soft);\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 11px;\n    color: var(--text-muted);\n    white-space: nowrap;\n    overflow: hidden;\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .status-left {\n    display: flex;\n    align-items: center;\n    gap: 16px;\n    overflow: hidden;\n    min-width: 0;\n  }\n\n  .status-right {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    flex-shrink: 0;\n  }\n\n  .status-btn {\n    border: 1px solid var(--button-border);\n    border-radius: 5px;\n    background: var(--button-bg);\n    color: var(--button-text);\n    font-size: 11px;\n    height: 22px;\n    padding: 0 8px;\n    cursor: pointer;\n  }\n\n  .status-btn:hover {\n    filter: brightness(1.06);\n  }\n\n  .status-btn:disabled {\n    opacity: 0.55;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .status-state {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n  }\n\n  .state-dot {\n    width: 6px;\n    height: 6px;\n    border-radius: 50%;\n    flex-shrink: 0;\n  }\n\n  .state-dot.ready { background: #28C840; }\n  .state-dot.indexing { background: #FEBC2E; }\n  .state-dot.error { background: #FF5F57; }\n\n  .rebuild-btn {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 10px;\n    font-weight: 500;\n    background: var(--button-bg);\n    border: 1px solid var(--button-border);\n    border-radius: 4px;\n    color: var(--button-text);\n    height: 22px;\n    padding: 0 10px;\n    cursor: pointer;\n  }\n\n  .rebuild-btn:hover {\n    filter: brightness(1.1);\n  }\n\n  .rebuild-btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .rebuild-icon {\n    width: 11px;\n    height: 11px;\n    color: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .status-error {\n    color: var(--error-text);\n  }\n\n  .status-warning {\n    color: var(--warning-text);\n  }\n\n  .status-spotlight {\n    color: #f59e0b;\n    font-weight: 600;\n  }\n\n  .context-menu {\n    position: fixed;\n    z-index: 200;\n    width: 220px;\n    border: 1px solid var(--menu-border);\n    border-radius: 10px;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.16), inset 0 0 0 0.5px rgba(255, 255, 255, 0.18);\n    background: var(--menu-bg);\n    backdrop-filter: blur(28px) saturate(180%);\n    -webkit-backdrop-filter: blur(28px) saturate(180%);\n    overflow: hidden;\n  }\n\n  .context-menu button {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    padding: 8px 10px;\n    font-size: 12px;\n    color: var(--menu-text);\n  }\n\n  .context-menu button:hover {\n    background: var(--menu-hover);\n  }\n\n  .toast {\n    position: fixed;\n    right: 14px;\n    bottom: 18px;\n    background: var(--toast-bg);\n    color: var(--toast-text);\n    border-radius: 10px;\n    padding: 9px 12px;\n    font-size: 12px;\n    z-index: 250;\n    backdrop-filter: blur(20px) saturate(180%);\n    -webkit-backdrop-filter: blur(20px) saturate(180%);\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);\n  }\n</style>\n","numLines":2271,"startLine":1,"totalLines":2271}},"sourceToolAssistantUUID":"9da282ea-e4a9-49c5-8d9d-6c67bb4e3f6a"}
{"parentUuid":"845ef5d4-08d9-4bac-b064-d22f87dd6f9b","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_014bggPqP4dDP5KyeHSZcHjN","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Now I have the full picture. Let me analyze the changes carefully.\n\n## Summary of Changes\n\n1. **`rowHeight` changed**: 28 â†’ 30px\n2. **`THEME_KEY` constant added** for localStorage\n3. **`minColumnWidth.modified` changed**: 120 â†’ 150px\n4. **`theme` state + `cycleTheme()` function** added â€” dark/light toggle with localStorage persistence\n5. **`renameOverlay` state** added â€” for fixed-positioned rename textarea\n6. **`indexed` and `currentPath` state removed** â€” these were tracking indexing progress\n\n\n7. **`tableResizeObserver` and `viewportResizeRaf`** added â€” using `ResizeObserver` and `requestAnimationFrame` to handle viewport height updates\n8. **`scheduleViewportHeightUpdate()`** added â€” debounced viewport height recalculation\n9. **`indexStatus` in `refreshStatus()`** â€” removed the indexed/currentPath tracking from status updates\n10. **`resetIndex()`** â€” cleaned up to remove indexed and currentPath resets\n11. **`autoResizeRenameInput()`** â€” dynamically adjusts the rename textarea height based on content\n12. Still implementing rename functionality...\n13. **`onTitleBarMouseDown()`** â€” handling title bar interactions for dragging\n14. **Escape key behavior** â€” now focuses the search input after canceling a rename\n15. **Scroll cancellation** â€” rename gets cancelled when the user scrolls\n16. **`index_progress` event** â€” no longer updates indexed/currentPath fields\n17. **`ResizeObserver`** â€” replacing the old window resize listener with a more efficient observer pattern\n18. **Title bar redesign** â€” adding a draggable region with icon and centered text\n19. **Sort icons** â€” switching from unicode to SVG icons for better control\n20. **Status bar layout** â€” restructured with left/right sections, state indicator, theme toggle, and rebuild button\n21. **Rename input repositioning** â€” moving from inline to a fixed overlay...\n\nNow I'm looking at the theme system with dark/light CSS variables using data attributes, plus some styling adjustments like the row height change from 28 to 30 pixels. I'm also spotting a potential bug in how the rename overlay position is being calculated â€” the viewport-relative rect coordinates and scroll offset math doesn't quite add up correctly. Container positioning is getting confusing. Let me reconsider how the viewport coordinates work when the table scrolls horizontallyâ€”the name column starts at x=0 within the scrollable container, so its viewport-relative position should account for the scroll offset differently than I initially thought. I need to reconsider how the positioning works with the absolute-positioned rows inside the scrollable container. When `scrollLeft` is 0, the rows align with the container's viewport edge at `rect.left`, but as scrolling increases, the viewport position shifts to `rect.left - scrollLeft`. The text offset calculation of `textLeft = cellLeft + 38` should then give me the correct viewport coordinate where the text actually begins.\n\nFor the vertical positioning, I'm checking the `rowTop` calculation where `lastSelectedIndex * rowHeight` gives the absolute position within the virtual scroll content, and subtracting `scrollTop` accounts for how much has scrolled out of view, then adding `rect.top` converts it to viewport coordinates. The logic tracksâ€”I'm just verifying that `lastSelectedIndex` is indeed the right index to use here rather than a loop variable.\n\nNow I'm looking at the `commitRename` function triggered by the textarea blur event. The issue is that blurring the textarea (whether intentional or accidental, like clicking elsewhere) will silently commit the rename. The `cancelRename` function handles Escape and scroll events, and it sets `editing.active = false`, which should prevent the blur handler from firing, but I need to trace through that logic more carefully. causes `{#if editing.active}` to be false, so the textarea would be removed from DOM... Actually it's a Svelte reactive block. When `cancelRename()` is called, it sets `editing = { active: false, ... }`, which means the `{#if editing.active}` block becomes false. Svelte will then remove the textarea from DOM, which should trigger the blur event. But by the time blur fires, `editing.active` is already false, so `commitRename` will check `if (!editing.active ...)` and return early. So this case is safe.\n\nWhat about scrolling? The scroll handler calls `cancelRename()` at line 1493, which would also cause the textarea to be removed, triggering blur â†’ `commitRename()`. But here's the thing: in Svelte 4, the reactive assignment and DOM update are batched asynchronously. When scroll fires and `cancelRename()` sets `editing = { active: false, ... }`, the DOM update gets scheduled as a microtask, so the blur event might actually fire before the textarea is removed from the DOM. At that point, `editing.active` could still be true, which would let `commitRename()` proceed instead of returning early.\n\nActually, let me reconsider. Svelte's reactivity is synchronous for the JavaScript state updates. So when `cancelRename()` runs, `editing.active` becomes false immediately in JavaScript, even though the DOM update is scheduled for later. So when blur fires (whether before or after the DOM update), `editing.active` is already false, and `commitRename()` returns early. This is safe.\n\nNow what about clicking the title bar? The title bar has a mousedown handler that calls `activeElement.blur()`. This triggers blur on the textarea, which calls `commitRename()`. At this point `editing.active` is still true, so the rename gets committed. That seems intentionalâ€”clicking outside the rename area should save the changes. But I need to check if there's an issue with the `stopPropagation` on the rename input itself.\n\nWhen the user clicks on a table row while the textarea is focused, the row's mousedown handler would normally run, but it has a guard that returns early if `editing.active` is true. So the row click is effectively ignored while renaming is active, and the blur from clicking the row will trigger `commitRename()` with `editing.active` still true.\n\nNow I'm looking at the CSS variable issue: `--accent` is used throughout the component for icon fills and the selected row highlight, but it's only defined within the dark and light theme blocks, not in the global root. This means if the `data-theme` attribute isn't set, the variable won't be available.\n\nActually, reconsidering thisâ€”the `app-shell` div always gets a `data-theme` attribute set from the theme variable, which is initialized synchronously to either `'dark'` or `'light'` before the component mounts. So the themed selectors will always match and the global root variables won't be needed for the main content. But there's a potential flash of unstyled content in the HTML skeleton before Svelte takes over.\n\nThe real problem is that both the old `:root` variable system and the new `data-theme` system are coexisting. The `data-theme` rules override the root variables within `.app-shell`, but the skeleton and any elements outside that wrapper still rely on the root variables. And critically, `--accent` isn't defined in `:global(:root)`, only in the `data-theme` selectorsâ€”so any elements using `var(--accent)` before the theme system kicks in would have no color.\n\nSince `.app-shell` always gets a `data-theme` attribute, this works in practice. The SVG icons inherit `--accent` correctly through the CSS cascade from the themed container.\n\nNow I'm noticing that `onTitleBarMouseDown` calls `isTextInputTarget` before it's defined in the code, though function hoisting should handle this in the compiled output.\n\nThere's also a mismatch where `buildDragPreview` uses the OS color scheme preference directly instead of respecting the user's theme toggleâ€”if someone switches to light mode but their system is set to dark, the drag preview won't match. It's a minor inconsistency but not critical.\n\nLooking at the cell name positioning calculation, the comment references padding values that only apply when `data-theme` is active, which might not account for all scenarios. rically correct, though there's an edge case where if the cell scrolls off-screen to the left, the rename overlay would position off-screen tooâ€”but that's unlikely since you'd only rename a visible row. I'm also noticing some style duplication: `.rebuild-btn` redefines most of the same properties as `.status-btn` even though it has both classes in the HTML, which is a minor issue. And the `.theme-btn` class is applied to a button but has no corresponding CSS definition anywhere, so it only inherits `.status-btn` styles.\n\nThere's also a bug in `refreshStatus()` where it creates a new `indexStatus` object but omits the `isCatchup` field, leaving it undefined. This means the \"Â· scanned\" indicator would always show during indexing when the status refreshes, since the falsy value would lose the original `isCatchup` state.\n\nThe `sort-icon` SVG is duplicated four times across the template, which is minor duplication. The `state-dot` class uses dynamic conditional logic to apply different styles based on the indexing state.\n\nWhen scrolling the table, `cancelRename()` fires if editing is active, which makes sense now that the rename overlay is fixed rather than inline. But there's a timing issue: `on:blur={commitRename}` will fire after `cancelRename()` sets `editing.active` to false, causing `commitRename` to return early without saving the changes.\n\nSo if a user accidentally scrolls while renaming, their edits get discardedâ€”not a correctness bug, but a UX problem worth noting.\n\nThe `isTextInputTarget` check for Cmd+A in the rename textarea looks correct since it properly identifies `HTMLTextAreaElement` and calls `select()`.\n\nNow I'm thinking through what actually matters to report here. The critical issues are noneâ€”no crashes or data loss. For major issues, the rename discard on scroll is the main concern. arded (not committed) on table scroll** â€” When user scrolls the table with rename active, `cancelRename()` is called, discarding the in-progress rename. The `on:blur={commitRename}` won't commit it because `editing.active` is false by then. This is a behavior change from inline editing (where blur would commit). If this is intentional, it should be documented; if unintentional, scrolling should commit rather than discard.\n\n2. **`--accent` not defined in `:global(:root)`** â€” The `--accent` variable is used in base styles but only defined in the dark and light theme blocks. Since `data-theme` is always set on `.app-shell`, this works in practice. However, the glassmorphism default theme won't have full accent support.\n\n3. **`isDark` in `buildDragPreview` uses OS preference instead of the user's theme setting** â€” If someone switches to light mode but their OS is set to dark, the drag preview will still use dark colors, creating a minor visual inconsistency.\n\nFor the minor issues, the `theme-btn` CSS class is referenced in HTML but never defined in the stylesheet, and there's some duplicate styling between `.status-btn` and `.rebuild-btn` that could be consolidated. I'm tracing through the blur event behavior more carefully. When the user presses Enter, `commitRename` fires from the keydown handler, which calls `cancelRename()` and sets editing to inactive. The textarea then unmounts, triggering its blur event, which calls `commitRename` againâ€”but the guard clause catches it since `editing.active` is already false, so the rename gets discarded safely. This is the correct behavior, though it might surprise users expecting the rename to persist. editing.active is false). âœ“\n2. User presses Escape â†’ `cancelRename` called â†’ editing inactive â†’ textarea unmounts â†’ blur fires â†’ `commitRename` â†’ guard catches it. âœ“  \n3. User clicks on title bar â†’ `activeElement.blur()` called â†’ blur fires â†’ `commitRename` â†’ editing.active is true â†’ commits rename. âœ“\n4. User clicks elsewhere (non-focusable) â†’ browser blurs textarea â†’ `commitRename` â†’ editing.active is true â†’ commits rename. âœ“\n5. User scrolls â†’ `cancelRename` â†’ editing inactive â†’ textarea unmounts â†’ blur fires â†’ `commitRename` â†’ guard. âœ“\n\nSo the blur-based commit is safe. The only behavioral concern is that scroll cancels (discards) rename rather than committing it.\n\nWait, let me trace through the scroll scenario more carefully. When scroll fires, `cancelRename()` runs synchronously and sets `editing.active` to false, but Svelte batches the DOM update as a microtask. So there's a window where the textarea still exists in the DOM even though `editing.active` is already false in JavaScript. When blur fires during this phase, `commitRename` checks the guard and returns early since the store is inactive. The key insight is that blur fires when the element loses focus, which happens after the synchronous event handler completes.\n\nNow I'm checking the `onTitleBarMouseDown` function, which explicitly blurs any active text input when the title bar is clicked.  This allows the title bar drag to work properly, but it also means a rename would be committed if one is activeâ€”which seems like the intended behavior when the user interacts with the title bar.\n\nI'm also noticing the `--accent` CSS variable issue: it's defined in the dark and light theme selectors but not in the root, so I need to verify how that's being handled across the theme system.\n\nLooking at the actual usage, all the places where `--accent` is referenced are scoped within `[data-theme]` elements, so there's no real problem hereâ€”it's just not defined at the root level, which is fine given how it's being used.\n\nNow I'm noticing the `buildDragPreview` function has a separate issue: it reads the OS preference for dark mode to style the drag preview canvas, but the UI uses the `theme` state instead. If someone manually switches to light mode while their OS is set to dark, the drag preview will still render with dark styling, creating an inconsistency between what they see in the UI and what appears when dragging. I'll flag this as a minor UX issue.","signature":"Et/IAQpGCAsYAipA1DmEdm8PGJuGpzjm729Rg5m1vuFZXhV84yOPOXhC6qtblvHSlT2REeON01HTh/9nPK87oILmgVOADWozzCUJiRIMn+9VMaWlFopUXgJBGgymNvSOociIRAx8InQiMKzbp7PvOXg5diGSSj5VKunSbRdoiT9B7Xpb8RcQE8X+UQcTwMKUaUSSqXspvkHRjCrFxwE0H+4qhhDtd3hWLyI+nMOLEDNDYLXIr1AcSAIT/STTrCed4yUpv/OFNTn3TZJ0Fm6CouBD5vKtX+xHcifLmlRvxcuIA0yEXEv7mRIIZajSDvyBx4XxF0ek77TedaBFihLfFdooGcSS6IJ/Waqw1sX84Ud8Z+jiRxBeAKmSkl69W9q5EaP59Z6y3UGVfy+a7k+8itUPt8TrMY6VsqReUdvfEWJ6GbJ3leavZMxdo3qlkY19pHLKiFuL9WcNsR7VCkA7NcKm88Mmbvs8DJkVlEIdDYm5fLzb5m9Yhsng1gkkGYbSRRwAph0ysqFMHodWzbpaJDrqJNXOMPaighSb1F0g4TSYlJLdVMBND1PiMs9s05ZErK+7sOze3zGP/oCB9XVYVZ4yy4zuLwT/1QCqAjes8QumLQNdgVAIf+u/uAshiXtYP3gGN0oDg0rzB3y1k644N97OAK/JMsMfcv+oaddxKWLlra81cnS3EHhJzxnpwSvnsfLHxtZEzV+rJHiFccPFh1rMI1woBEcCBGsLiS/NIOEsXOnlX29fmn11VYikoSM+AQPAo250i0XaQ8sYizQZ/iI1rUojH6tsng+Uv0B2cVX8UzsiUIy+/+oFOkGmsX96StkHak/8O6Jf9/Y2h8g2ua0ZDRYRYT2AlRWUtA3xWdM1rUbErXoMc0znzuEP6uovyXyKHWgBxkaySxJBmmP28j431ahVYfRF4TMkB/UET/yPKIV+saWDlUu4igeiQBneY2t9etJwLzNQRvPYN0gJRy7OAv1/0JVVFQPEa6nrpHLaAl8WPebk7S000v7PhH5Ya2rJht2UKPB9qmC4qe59Zvp2hhi+suBXbKkeSkMC+qF12foOFjhbEE/x/HTqHzCg5zm8qwsaACBTjdWasUopWnl3bFM5VcTN44rIVrs9wJHiOViFN1y5f6dCTIp83oBufERzMvnPy8JJ5N6DsXWLA1/j8sQw4vsKKBwTdHSEfmfzDfh54Ddft6FtaYGK/4m5WvjmrU28J3L2NFWBrCE4/TrpKa/rzDPCjPPAzlx5v9f9jEq+pq8AXSPHMZ/xoLmcu3nKz6Zj4uPsEQJTO0yCPoE9g62bh9QlDIyw9i1mgFz7BoXvEu8arfPAl8gDorlyBn/od3y/QRUeiyEmysNsQ583MS8y1M80mVC2SlokGC88PPs2TeruzD8fBB87baRupHdz2WlJBbX31T/bPzIRtfqmluKQ71aOgp/Qi3ywVuIlTG/MhoDTsp6ZVFXBhlb6WAjjPlUVjFZFu74qFfoEzHNZWNowDz9SYEHQ+2cqVVppETFrd+o4cg5RiSYLFJS5puuP6577CIMoTY4lN/PPq6XFTLpfPwpikLaVFtaF3hEKNI8LVhPe3LbMp0XJgFv3vbuPt5ZDDN2sa/GBPgrsGfzfJbRUDBAfawnH0iqlu95OHFe3/GevyGip+z+HmSXc9EbBK0mOViMRLL5zXVbFHz4+aR/xHyyJZ2QgIkiDFBpnDcSL4xL3bf7Ve43KauTJJmeF3Sc3QYraDZ+hOc1xrbd0aHG9bkW4u5FAzqrXw/FFJnv+ge0j/kw5u1V77OyHl6njJydB0oSAtdU3oQA3cd3gtFk5pAzb8ohtPDfnjjrQ4gfKXNuIpANszohARagNG7kHZBZaZ2yRRrQcXqjGQRGyyfct/MZqzekBmCuameyQ2upKnrgGj1voEiwEdO2jbsikDuDykGHxVz8TwqUnFA4fnpYbGikLDPNWY27tdbco3jK8h242oJ1LDTOSlJjCkuvFwYWxRAEGDXxpD+334BTQwtWatbHMtRI1VnzAMP8ePxdES1G/ENti4VJR21Qu7gQFc38rzvIE+4/I+c3P3qNp90slM1b2+QsosyEEv+jybZr1TX1+XepCv6pTtmV9tTHCQQnSO8hLI1UOgIHavDvyEhTDR3PwEGIN2HhPfLthZh9B7kd6HxiKyiHR8U8lN9VUAjcTmOsFKmEZ0P7suJP16d4IXUA23eExpbRH6LaRe6izktPfkeH06+p/71FrSxBvOwNetuyTl4/AS5pRGOzds4jkwu7YyCcqX9Vuj2cB+qNfytVNLOUZZl0euAr/UUNJDS9Qp7HTgHkcbjpsTAqqztnMmWhn4af05FNarGmeJtn9gmlpO1s7bdRcNhAPlmqT691NomQSoU1u1lSw2eE15uixa7zsFxz010LAOC9st7qF7PMjyTKNqkc1LTNoydmzZ46Oqnw5pMTSlx2xG3g/dPRFIHB1sys2ytMygPPniQATygCzrv3X4T++vf08118pCGZT8B43oIsIOUAPxa18C4oBIF29FQFzGI9nZ0W2LdcLYcfDIKCJBbI2Mw9ICxt/7Z2LYVGerEPVl5ErWE3BHsMinfPGBKMJfFKRFttBTreiqrIOO3KYW/4FKG0ABJGAYU0v1wPtEpwO79A5d7yo/f7O2Licj4afcinXUzL6rxVoWaycBgoaB/l+iJosU7sA7YhaDJHcBQzdhFF6hD4of0WJa00Ai7lNBjEdgwOuLvHbBwegAzkFKTlPV+8SsHhH16+QjOmkqJS4sPDIR1RqUm4cqg6OxSPL0suahR78pbafyABa6JlwkqJVtWY9EZa1iotaZ6r2knni/dc+daYa1PtXGX6aSVSRTn/XpXfY7orrSUfJh6DJ7qp0Yb9eW+aZ1pUM4vpIkbRIt9xpvMJlPaOkOx4UMHQLRq0yQ08whJvgCL8PMXkHf76EyqBzVLTV66o1urTUcl+2bMGBYBXicbTIsnjs9sG6GTrpzyDkyOAhfq3HGySCNupp8M75L5+MHNYJtXrehqQy3qEG+fPFqk9Q0pFmIJwg7KNuB036UqGX5+uso12uLgg+xi69U/Uy0v6aC8HyRm9ydXGF7FTU/C+M07eRNsmzMevkXmDxeyW9ZAy/wpz/UH6CiLk9RKi6WF/heAv40dRIptPJ2cWVwr8vlMow2IMz5hO65fE9A3/77lDNVscG7Q1CKx+inj/tUsZ6tcxALzHv0aHc6NIz88s70AcVkrryqlY3LrPVmqQC733qbOSH1ERfpUqLkSGm+9sxkSRGT+YS56xHBnOZeL1mpMb54+m80/uUWEXQYmDtu1zmY9K7Q/sxcW86dO+PoEE5xqK+YPpKUfdZw1lCoHKQJ3Nol+ilNVnQNy/hE94IrW840Mp5WPDN6bk6FnVDsl1IsyAuIkCQXyl88H9aAQNseR9QTUvluOtfZV3F3JzhsZcJGOh5UuRVz3CwTd5kWZPDs58uqriKOj+fwt7xpJd9XT7/35QJHyw8YVcl6EbGCT42C3O/WKsMoDfRef8MjdD+E63IZefatreSolee6FlY9w1GHvLdAMxHnvY8QlVJxXYxNOU++1OUJXomLmMRwSqlEfm/3zFIxp2hcSRJuU334xqNk0/Yo+6Gm975MB6hFeA1gVeWWzMsk3SxYY4LWFRDp6a+QyisdJxNbAfTZJnah6z4Mn8jyks9CDV/iBAhBF/NURrRqn8kPjNRQ1j0b7LcMrlSYusyPOKiXLUQIMvBKe1dOWolbzKkYIbKk5LUmEHDVmpZlRlKllfqvOGdJLYC7dInx7k6eN7c47VtjtEvbGPZMAf3z3Iw5+15LMVpAhETHLLDKLPV0bGDc2yLOAFQ1NkTBsqz+okI9I3GNjsgE64axvdkUwnoXSAjYXNWoP34wmuBbOa+brB1momVu4kWjOV2QMxSFOi74SLJoqbYBpRcGf+fsjdYvkmUmttxRWo7j3Mtd8cmZfugzJTIhJTTKFvCqKzVaBENwZriFBo5nuxcSAzXKIBQ5KmrJZrpyD2SO39pW+I1RC/FATXOpnuur/pWTq5h4MZPTj7kWNwR5zKBLuCHa3IBngrAkt8NxdtvTJFgvRZ/QOFScixlZFWRFqM/hz0QKGuCkdD/YbNKK/E9I4ZwgiPj55rmM0aSHy1ZzkUiUvqSn23nutDoeXsEtA5s22IDwrNCJBy6hzsb+Pbc+P8X7zo4ZViN3uFzsfVzSkaLgalqi+BuEtkDDke0kvOIQ/8Bq0reaWRhtIXCNjmrKX5FUFiaVtFPhyYvpT96bzGBT9jQ24KcLyu6rcH/9fNwuP7sn5yK/wUv2+90vIXztF6KDv3VVvUQWhYC/4iaXKGPiKqdb5nxSmFyzXrMHWajAjaXcoZaH/j/XMZOcv5v17QQFafli6odckwqPHvupuXwINv/FlsTrJCVSZhwXnoyJ0oEqwRQKKHmxBC0B9nsUOa3fJ1Biu4NM+wMrigbbFbLHwO+BgGiom403oqa/Wqk0nRgne0FpY3EpEseaOCaG3WmIgdImCLW6l1D/g4FCRuobe6Lw4g+O81gKLoUclJqIQILpnCq8ZZ+9FTUhorlfebQNxQyTyeP5hNPhFcUP/P1HM3C23S32J9zpbcGFgAMUG1zzOfSroEry1MpW4QTAO7PVeDufcEjg49nbgT9Tw8r6ghRPLSZpnFL09NRk24C+q07HQAnCBw5LpnjlNMmjbEmOCAI9bvLhWEj6UAgBQ3Z1xfoU4k5Q/jfDAp3K0oY00WAQAjm2gYXyvsiAVsp5JfgGgQGMpVjqv19Y1TdPM1q5d2UGXr5FzX/BQa6QR4wdExhVRfaUv6E+Cm3mqjce+wSfkbMBMb0NyqtMzIFV98y/wx46qQF82u1BplEVaGLw86luIkZy64veVS8xXNhwg+9FE9YXFbzi+YxrQuWrymwf4z0CxmxNQiKNbJQj0UBarypqFCxeuEDp71CpZrzjKbP7lVhhuem2gOIsdvXiXv21DjuqJP+40v392tAbMk9DT1gbDnVlj/VUagPgX/ZSNmxiXn0gk0VFVIaJFcIiuD9qJ0xtOlHwqi4wTvkiY4OwGAV9VAo6eRo530uub9pPFGztaVUNkdOaLNkwDYOntYlQ9YN12W7NFN1fUVl7ffbHy0fxvVZ+PqexxU/L6qTOSAmgo2xJ1qzA0OF00BkntbC3PdUhyBs2q/HT60zCwwY8GfVqAdMoXxHcTYff3Sh5U4QizCOf1E8Z77nLfhMFTpTdddJnUx6pIebUr2M4QLI5vggDPgVidyPF3DAQ3dzjR6sY10yPa9mUIuair5wRlnwJfkXCsJXUm8Jp8jW8C+FoSG/r7TMe3dkJlorftfj7bmlnXMl1I+DTdxjLMKUVFUoMtadjtWCNqkxO87eyWw+9d6d082IuGQeIVVWXsHO7BEdscww15B4ZwYXPB5lV8lf/22IixQJc9u/r1vef9Foh4tlNv8p3NxO1RKoMYqxoeCWQyUtmKO+9fP/t60KdWbTFd4QDT+TepHkEACOxs5TBauQsyF6Jre4ghLCwQHsRPWV9n+A9Nc9HohfziUnNtkm3eEiiIFx8w1KY06bBuwFYVDrtNqSYaTR6cPmqaftwGbVt+PV1FywVPOWa859qmNQmPooWMx1k+qQ6t8j/vNm2Vj02lkZ/sfAe5rp2TSy4DcGvhIv0PRtCp4RgIkQ4XXe3Hl3SmgUwy1RVcOOcS9nr3fRG4UeJseDLsem30m15vKFJombnD2TZ0I4oqa2XRQlXv9K0naLgi1rx1GVGXDOmv3m8+j2PX8lmMoIL6fnQC6avsKHpCTb4s9wxMqbKl15UPx7K3INRVETk6QEIRnjQ8IxEnLhmjl/4zjp0oBwhQjeWEbte5U2jGizWDpWvsnR7cNYxmy5PwBbzU4OffcaD4NlCro5LME3prS3+BlCu0XyoxoaV7T+KR4xLVxyH+xn1kSUcaQgyvSINTOsFMGrADUGDlf+mh9A/+Iebe+hy0Wjuswn4R8J62Mth/wQn7f/NsuMRjpsaZ1f4+QVTIwf2fnjL4iDqXLgpaS7nQiVgpr2Wl1RqO5S2NtdA5hCzeBtOf+uhU55hPMuzmb0b26/COaSXfnPcPV8ZOwH1mUx2oWnEHjZJyC0j5eMog1qRxrX72LBOXOfyQDP/XXUyUZ36KqmH2H4vgU+VMPrvbhEgGM+m3PuRaRT+BwXSYXIZ3A3xgY2lEebI6gxdmvAde/FTD4a0A2ze90CvErmwnqIW6CvNr+XEcMc96SbDCGZYyzfcwYOEQuhqeI5WcGGYiIcAzRDzdjz9TqSBjN33I+Gr45wLnb8VtnNoaooVy/h3q6zlsS3DoGxMP7nZWjJQWKc+qDaoAguoBv2CACdjN5lcIR5jT5KWLQWwTe7J5CjSJAh+Gsf+66vwbAXjHQW6OIAwivyYOmp6ApfLSPlkYtEtEnTp8fVA8UAPI7xNsLYOjykE+f+ndIFqbkE/lT9KbXgnFtWbLD5Rh7UmIvJO9eKdXmo0+kRq8LukybqumLqlHZiV83Oca482haP81CTcwoZIaCIyRhYINFMIFsbTi7XLQB+3WCwUCEZNASDtpcRM8U8yFAFODoZE334VJ5MWrK7I2w+Gj4tsYs0y7/RftbQ+kbn5dpKpvP0VVzD45IloimRTtbmlMar07OR8Z8Q/FTZNPV35EzbSul6SstG+zRHkljzH5m3HA9ro6OxbCelDO0j1gFHE5NO/M2GvW33//bT6KmnaSRTlqLTUGcpovfYoVdDsTrMus/MbA4NM4juO6iebZXubtV8tub2bax+/WxcdOJFd206ZATnvpuFLhKnTNsQysE0fYMrx1iKceJQArPdewXEg3wRLFbslJ1guJgHMNYJKddj7bNT1KixrUqtbiuvxM1IZwAK9CiwugoFdecJceACn4DZpQwj+Q+U9Mtx7XogSkT7WeTs1JQtcYl21ix0VnNgiibGPOd8+Gfb4W1bnsTrG5oHxZ8P2pyJBY1QsHjBeC6EO3y6hgHBBe5wpP0QdAMX9A7QqJXTmvXhkgRhVWBr8ez6hqzS3V2aixdU9QuDBydoXTe87yJaiZkeDWidcFpu9lsGFMWMPn6IkRCVE+eqVMPoAOQcd9Yrypf1kiw+ChCFQ1Cz/IX1QSo17Z8FApz6H7CaXTzXuiRYluj8c2j9FuOaSn1PuVXjjr2BGVBojT+8l/xxwdvrgXbwTgGXwrMmGvGwotjLsmacmxRlYjwHzEaMUp245vd9Sc6mLqo9cKsQmeDmDrfpjXSoR4xlyzS9PlUT0JeqjDgU8W0C8PTgG4sioO5pm0kH4fsH2GRWegNMNZ01aERLrsofl5In7y0/5Jv+TYenXMvwXuBJ2e9fMR3crXd1ZlW6dp12jXnh1M9v0rsMFeU4V4PTXja6cpJzHB9NRcjoDONwaRCC5zcMGJ0BsNoab8YQ0QQF/lPycV8wWnN7bSHBv3xFfcTzb7uC6lr4ABw0FrIiv8vuiQpSwXXU6WaYLzJ/f3TjseY4GQGBB5Oy9PskK+3u7gBBFW56XT8LdpZrwRxk+ttVx6tnYpF1mPeLTW0DcF1Ws1Yzl3rEyI854zDhzRyKUG5KzfQ6hT8jGNwMnp6WH1Idul+XmZYXyEFRmeuk2GeA67jWMRUT5gZyM4fwOzpleRQKV1BJsIOR+Qfu4eHPLLfxVb1TXARN5+SAegvUL66pzRqxupYOs5NM68Zg454Wi9eSJA2052AzVL4jOmL6YwKTnU1dNRdfJhR+SxIvNgws8Mb7qaLiqSNfwR9DlH8g4qqWStbgA8XQKPLiykv3Sh2Sn575+DJwZfdqCQEU8hozz1XYTYmmQjp2Mqc8tEgBM2NK45sOjmJ9+zsCb32tHWONf5LVXsTyvsBSLg8dxaWUpRF7SjrdBt/j2ZJgfn86MT/8fbufN75uL3g71Cw2II/3gMfi8iCEkGEJscs4Bnyc/bDeZkesIfO5AWB2x2ab97nhX+fzZ/Sjakw6CGilITvDrY+7TMPAbGLqd2/dgluRG3LbP1hVT+8Bh1R+RhUH2hchbw+rJ+jHK7hUAf9t36uonW8F0cdOGEBLnVC7aUegSvEzWOjkti4PmvrLMJMKcqV7+Unn4vAEaKIFV8e2Uc+r96Wchtcu0/CahuFwShU5+uzKfSXugabb0lvs+64j9/b023SM/Xt/71YPI5YijFNg/ENgsdRxNtTFFw2sdJ4OKHLx3PjnjM7E40xA8idENPFe8thT0TKWUBWdoQ9EF/wHFjtUkxQnAtrS7ISv9chRS6ZfCRmofE+vwM1pXgq8Ig385WLbWj9Qcb8uB9Zvk3Mxe7tVR6xgBHOf4Ak2Lov6k5zk4123jfDc0YsUfLRcW824XfhGqIFJ6TGsIHfVoiPFpd0iXJHgireU9ZFQNTW1afC/SqkHUjre4729CwTOmoJ1s1b0tCwWAajn6f2LikeA7tf8IEXUuddB/v2XrKJW92+9To0R/Hoq3DA488n7pW/gF/ayvUNQuEE6VUE39nNbsCez0DXLWx67bdDf7VPaBq73RdBPW5nW+oBl92cDq005ARAmKOgtkaeq12PMPpoyfkCfk+5erfguguf08FhpSkRlFDNDMRTpnxXfbrjfUNJ3Xo6JHN3vWANfFSrh25Tzc6aIi81/WIhRW5qxfywAmcxBAHNqSNqlXiFq6lRcfhHoMBxNslE9f3ph65df9yGItR5c329h5zVZ+xOTFTVyY1yo2OHV0h0D6H6DlWirlOV7a2go2BiMUDQU46o5pAYDCdTiWkodEmGSlBiQjvdgN4DwC9eAtRiJ7XznvGmMUrh3c1dKjHjk8RAwLuZmMWMe1SMDQYskCWuPV+GsrMD6/kt+JqAbgVa451VpogkqNtONnLl9oRAlW0Mi6d2FaavRRfUTcbM6oYrli8UZTDlMz+e7aB6kiScBhWGfaYinhzsBXzgLkQ0SjjjYK+bUis0WBRizOvvB/tnAv8rBIflFSkmL7mi6HhcjiSqBJhrMi/V6bJbm+kYvslh9kloSbdp2PucmppW9aEDDjmpA3eeEPH9NzlSWH6jvFL/+B+nzPHPaIOi8cPVddCct2KleTLzXL3iZcv96zI/4iiFBZjznn6nzFjW+XCTlV48HzMyXpxZBj4cj8cddUugMOAF+1xFhbuQUz0wF9Trfvrp6nq0orpt/zLImPeByVWzwCc7lxeJz6ErAjIgGbnCXqurUs3tEPnvxvyboKQ654lIXigkt7/81NE2y2BtLHdXPX/ZypJrWxud1rnPmDNtzO7gTnqZQhtJchT00y0YuLd3p8j8b+lKfp3iH0xauCMxFzSMRMJSJhhkr5NdCqDpLuvJR7KgQaqQR8FEEqXKVnuss5z9s8rxvem/yoR9M0hIIG+X8nJQh49UwPBdVAHNxW0zj0sEQSMhZCTNlAmAQm0AOU9YrQ/TzomgRDB1y314VCGb59sYaOyPAZkNLo2IX2KG4zatr0HQKCJFSIgLGZtSKk+Kvsanr4qqSEwRIUO433czOfs632B0vSYdYGLSVV8CpTMHgs2ZkSKddr7eeNxRXMEu0WvXJ7oQevkBgBEx8GJ1vqWFZbvjBMfIW10r5P24iPCxiKXwvaJkxUc9D+M9MQmoojwJmf821VsrtSf+SAgDHu6sKtjeayLIMo3YJ56WqYqk8s5C98LyUzq+XjNwxAIDZm15AFKknxxcp4NtfN5yDMwTx9/YlY8uKXV4yGVDSlpDqnlPf48x2TQYYWJpNca5U7l1tqYRillw2t1qomQVvtaQby1oLjSy1KgL/X+6Oj94hZ7pB7Vy+kNBGRBaFttpAOogmlVyloJnxnpk0iAfShdZbqM2dbOAeIs1chI/Ua5MV9r0+5xhC/rAQtqy9OpF1/w9c5Nc9NsW/u0DXWO6neTSyzg5NGltmPV4kGQCNEEdKqP0fb3CPnjjq18B+Ymn4uTsov+zWb6DPW919c56IpLy30Xkd3jdVY7urcZbo6j2yB6/qZD4WE44OuwveWjmx+XOkZrc2PfHBA54rMX6/tU2whsxdix8TonqiJsiRO8jgcbr3YSsSrrGcNFkZOfJDY4Tdg3ndWMK2vAwUdUVrmzxR7unCxD/cjMEtyheaeN3vZq7A6AV/RuXcd4oaM/xV79ApN6DnjvZdCipe/DkIMG2pOFH2TKaTbPNUbHhvVHVGzPXaSXTFZ3GULX8d6AlIWCjUi+HTWK/On5/x8D0BszlF4jzYZc8Iy/Ra4AVM975mOtKnYVtHi/CubMELav9OjnnSOMqHm5MfP8LDkBHaQ62r8SS0VZSCRVCY+uhJz8ewuTNcaSdgqY2Qod0TNb6mexCBdWrYPqHjHZXi88atTjAIELW+3FSSKEKpkKKctAcLboDfG8aDK0ErbLnl+NFVPRLB3fpAcDmW6d3JCmj/CMWBJbPlBx6rxewAJycjRmuYJDXOloZkzy1LHghVwKpMJ5fN44tQ12p9dkGtXoDQXITLCjuNh3QC3OX4hZm8Bq3m7xOm/YWDBAEDsP27gnb/ESj3bGfhfP7Iuv4YIViEAeztUldDUEvVujYW6quBxmifK/MyttdAirny2AR0Yut3j7PGA/Eg2KVI9+wbs6BtJ0KNvhs3rrDxKmmtuGkRaR8O7gNbQV2ra/BsR/s+YoOj5+RX52GMv0tgdwIQUyS5UsLErutWDN8/LyVjzsmgRNtarIbO3b98xN94OQBOPCZz1aFlDj/pm+FB+7nprXRmkULxe2D+TL6v+aUOuz5tDe49NQJS9iMRkkfDfUkJnYqkii2/QBWcP0AL+MqzEA8b+2o6jPoIoRKuUxbXfup6N21NHL1HCFfU9sMfr5CWCfEdCtwoDAe/iJ4FQ0BJFUt19LWhtdAnOqmTWmxjglwZSE7OQJL0ivzwzRXJ/JecuFID+fvM71a1ZawSPdQrMWf4uopDrZglB8kCQpFesW6Vz5vz7x9SW9x52oYUDdCQBWFuNVwqPpB22uPF9+hT1avmNPNeZGWKDqMi15izgnBi+ypC7nR0DkLseGbgyoL4FKla9l4zDXa1bfYdt7I63cEmfhyvqrKQWJx7Wq0dNw4IVrGRU/vfhikL88zxep2FWbMMh9hAylbq+g4hwBgP5uiSTYvPTjQttU0l/gXMHQs2d/onNL3fIyjVT0MA7FK3M/L+Xuko+MsT3hPTUj6huwf7z3MnaV4HfGTg4N5cFY+3Qh1VnCUJ/MRQsJpesy19o7R+ChUxOrQyhKiH7wqFBaFMIiK6bYIHpIJBA3kmzGEpbjQCWMsbFheTB1cEq2sYXRkolXR6Nj4JMWpPIsTJy/dXqFyZ5B+CVND0IxO7Gn+2cbwPuJWkfhE2cfh9EmW3Pzxl5UrE/+Nf/cbG6iZ9EET4HODxH1h9pPD03JyuSI7U88Efd6IEOPlXfYZhHlM/fzWeBleKIVAP64tz4eprbPgTNA6jalgdA7m5atk6x7ctaVghXf2PHPalZzGYeQ4te2002Sjy4+BAwRMrZmnEYJlc/ScYBP8xhlW/TxLami1CUK8Fk2+xUDuTLkcFkzOmMwlhANynanwUUjyThAINSm+yq3NyPeMghP3XNq9MZRd/tNt9TFkaGCRW3QJf0ddQPWif6XAaHFsIIdmBDiE+n5pFXhPAA0GSNOwk8Y6fu5v39EJSulmkgLYga6JOmPc0gp9M7cXGYfmqlelaOWb/PKZCFHhJ4EpPP9oXj8oyTR2imaTpQ83YshKhLJOvDiY7zLaKUhBFGKO2UUEhTauVKdKM3KrDJvN1FNFobgytRDxYZ6rKxu8IXbF3SBHzYmXCl24mutMMpRCV3J/uOSsRQMm75Kfg2p+hWm6HomM7rv730M3fq0hmnL6OVL9QeQ6tuchhxIJenLh7sB6BasIM32adSjzZozng9Q6+pkuYqvDhqewBdfAMZ8tX1p3PhweEXp+NghaukfZu6NTiokskCJ66uv+75SAjr5rElcLo3aIzr8LIEfv2zKHozpjae0vEbXfyoBqQEet74swIuTTveXVGJYmmuPFirNYPCUaNq2Bp7essfSl0BTLdTlIqUaE0ZgbzKCEEhBd9QY63U19j4YE/x68KyPfi0mYwnQeDcJpDCKqvN8yo1Bdm+mPGo3oJaIZWpumC2H8YKj5PoXcmbNtr/gnf0873ymz75+3+jVr+Oh1C0n/5+QneW/lWJP9Z/zzquRvn5EScpVywWB2bdbtYumQQOFd6h+eTO5VDBzXfOXg7xRYcbOAW9bNNt8MlCXPC2DQu4gOOT84CB9Mdg4yDxRp2uUXUrzwV4FTndF/p3kGMvIlfpcpQYnuIVHCEpT3cuZX2w89nWC+5ILMhsTMOg5XfEhJwoa2oZcGt6ouEhO+GVVgTK0tURqcJPT4zxuB9rnEEUwAGHMvT2vNxegRXaIBPfIvONL1xfmziVGRpKE90qqAqxAhJIK3ixNVDbXo4geporIB4YjUCs/RMGXqEl2Ek8bGcU9IcN1DxGw/vhCff1sYPdydWKVKbIeRsBtw2uW2jsm1QR9TX4WkHIN8xWf1EhvLZm3ttcaRcwi+vdK1GJef+gHtgvQiDR8UlDUaqSHsB3Xbr1L/cutAQme9LOxaFUd4RbQLerUK1RsU5nJ9tCznEcNLJolMpfUGFHLkS8YZNDpliQS2M/Ug8PIWlczTCdB8SfYQSfn1Yh2p0CKiQUdSwhvxddxIXzL0JlxNXOBlppnGYE+a/I19lA1zqTn74q3ZN3Nmswz+hYlDlfDs3NarQDS9LXU6TTBbFIjAkihv89eFnncYCq2S9J100mEKPAMPKEL87jqpZ6hFGgpVYcL2VcwuOro1DqVV8M+EBanHJmuXn3bv4PxinIjXuEQwssnOhnnmZ6wvZPy1M/4OmsNkavi8PDFMWO5GiyMu7ZZpprxjoYFoUBeTSa/M2Vk+2TYARkxRxScHZNstCrMOI6469+1TT6ZcMUAE8r0495VQINt261OlPq7tt4nhe0M6ullzcRYiJa6Wul3vjSrrL01cEbxvIj3gI54Vq5r/QW4IhgjWtvMu/DYlSAkaO5JS10+XNyODQFQUpuByxdSJrsX7ISkcKaGVrR5YfZz+Anmo4nogVqyu3WZt5LPlNUjmsHl5FEtH02/AIqeiA7DUDRnfWRzhiQIXtV9mtxNG8tRfj3aK3fHYnFmp9EbP2XwbuewMOrBWh+uU9XabLos1x2SJ8u7ym92xxS2OiRVtfRhs9bz1xCKFsUBfIQYnffP0CWYHffS8Jg96Up3uFsXnGcN5yOMVN1FsWo5/qlKI3gjyjNM5pZHlm61Tijsk4agDUAXB+S+/+wniiMSBUDIkvMVi2YSXcgcqC5xqMtY2aGJKHI+I77JZ2JZYrY9UqFVaZ0zBbzq8NrE0u9xYXpUZWmgGDS/7XknQhfMoWnfeX8FlW13jO4kp+ackfesFxYnbbfevXtwluOvhhNlqGb9+HQNM5/EU1+BZOcY/T6CcHeNytiS41otDl9tp7PLNFC5tbZeYVYnyxbue8nZIzKNXJ111/wMo130B3KXRAfJ92XxBnHXEAmZ6Pi/Cd7hav1VGCI0LaQz8oTaI+Iqh146kEPlTf3LKd1cNuMctLfvSLvMGJwI/l++XcxMdvjrO/QSkpU/FleLeyHo+LVC5fRjKO75MCU0mgaUVIlpe1LOICZy5L0CHDeAYyQ/TZvSNiDyg/Lub3z/5yIaivUHQKqE7/RWL77pussTPDt2RWXLdgn/TKrJ9x7Fo039LGjzKqXZS2d1a08erWxVnx5dT43jBZRnqIDrDuHZXVTadEpA+R46mhkzlSlzApai//L26ozjvt8dYaZJ55RpwkLOFFPOsUmCWzG92GAHSX2i0nCL9fY+6ztXM4sVMEDhULAfozeZ21l6z0MeoSUGjxaS8Zs7kY8BX5DNgVFAiXoee/jznL5BiJ3fqggXEP0Lt76CTdMpjlERQp6p1ANg6lni9IEbAn5QIU+/QD8IsqW1Ogd45IodH5Lq9FT1b82RedtZzpEsn/u68HTc8UafQtzD0JNpXY3H/R0HLs8wkrw/6BUo761O+Yux7S6t+pfAD489O367AVWJAE5e5K6hkbXciC9GuMniYrs+ypeZ/aPu9HhmsUT5r4EQq2UxLX2erVTTP5Q2qX5yEhfWBB1fJKjK9ZCDNUs7jc264hq15LJbY0ihmnFIwX2Gnm6fle6uICekoLneO72oXQiSQMBrKS9ySQcR9J6L7rxK5uyiwgTA8ZaBI0QE4LCkP0Tv9+cPYh8plKQc6ZwJ8ukJyJAC2rml6ooODI30XmcI2sZqqUqpWZIV+zVu6nF4ZJsCEGCW6oFz09lIRXZoWbfTuqoZQJj6wIChoZsPEeZDvol0SM8YrJ4dJhvWT16Zzm00X34/d0lo3VJHBQbmGPFbXCDx0DtDiOA+QLsQWuzaw7M1JJlLTivxAKTGRO+WxhIB3XlQj60rg+C1HlbSFgt1MIgIS2hQGBOdY4N12cciPLyKXEO090hEqzN/X/xZY1Ga1TPndy3Jr5OdkjeD/J7CM2+QhDtukEvJLTs+ys8DV3dTP2Uz9i93L1bcTRjBhVCf15ftlyvyYwRB0KkOqBuwu9mBSoIPw7Wd4FgFoYDRghDGtSI37KGZyvfqDnZ2dnvHzF9RHQX+Qv1Hghivcc+DKAOTJmRwbulDAWcaaQpy4/KpO4ysMwILu2dxE3APlgTCA/jDY/LNYLt0MmJ0dFjARV2aHDySvW3OW94zQVbdxt2s8qns9GU/f2BIpbvSsnyohtPvR/SnHwRVLBui8L4J77ixWsa/urTMLEtgZ7KnWNwx9N3z9QEYIgAX+R28lBtW50jAEnszkFmH7oVTUN/xo1SOHH+Aqi/0UTtKlXkeeK+Hl1dd2yBcroynzwZ5k3r5eEjddXEdwCUpYoYxIadGZPDNDY/qP5TWwynlQyyWKuTfxUxlSnbIDZkkfGjfUYRvHYNOyT5PD1pLbC5IODb3Iba4Xnh6h4zUZxlEqIREgo6hQ6a/aXAgCeX4uGI4KC7kIqdf42GT82HUF7O3u1a5o9h4g/sHbCauTHuFqlAN+JGYI+0pReTTfGuETVF+uYq6i6I7Nixu1gfSyLVKTxf60ipOLX+d+YuZLkEKXfqmm20Ey/qctVcc7VED9YDY3BShFdoJthkFvmi6RG/pa6BY+w8mJJs5BEWYR88baaIfZFK2/Hx8AMU71P6kVBtvgGo8VNhpOPWv9HZEYQjsyuFLV4JHgEAyM1yuEJtOW9aiZgOZ0JMT5NYceTdhVVskoi41IUIocKPbWfAIY/ki8TDps2Si3fz6oi+NuNzb0s08tVx2fPd5ITRjZ9vF0unM7Uz8m6g+W08jp1RYbOQQcSZ0vENYDMUKTZineXj7KQno+sbp57qu7GuaNsrtRJSS5TTEwcl18x9/khPmO6BdSwzdwP0y4zcvfTP3tDNDEXQJZl9E23Cn5XNd8mjyiqLDXKv387xj1DkopRYiup5nzq0e9bkOsv9Yw/7r2nG0Ax5GIm8l+NSm4YRWQBPjqL1MuE072pwfzO3z5Mhp2xKjf1bsYrv9sSy8ZJ/ToDWr+qS4T1w59XmIrcxsgBZIpGooEWEfZWv4w12qOeCReivmYvGv0LK9oXWnwMChzhvJ314ExDdZHcGKrFajd4rP5+9ZUpLYhuyRfNDj+Uhht6byffIVdcvhLOKVeQfIVEQOznzofbiyzmCA27iT68vlnz4LbctamFiEkYc5r9KXYaoVHPrpbM/I/QG7W0R0sTx++KBIDJqODWkGUiBCAnv4j/Nzn1IfKkXizVEqDOYnjPwZ1JmIpsZkuPw65V1+70TF3P/sA0Dygfi5eXLAUPV1GATtNjn2CU2UsjPOItIuZOX3qLB5MJXEmEsDXSFSbKVoEBv9gUuZelav4eEh+YYt2gjmPBdfOcI6FHbUW9mBYDRTyeZCuMy2t0AfWU10vcy1PSg3PTccU6m3VDmHrQedGeMpM/csHqHUNxLKenX0HSNt7HagelDS/kRJjIv0zbZIZbx7W2F0sVti9tBfB87Uom+MlME1LAZ+bhQvfyRH/cJQvPIRxzzckCe8OZYi9VgfB4J0aEqnpwixUKcfNpDDeNPDMtwhHfJ3+ROPdLESngn+Ui6ywts2PNGunp1cQ060lmIdZ8tCm/kYwELPpCd1kgy361OwLEhsvbEl7mNEyLykkuBm4KeNubM0rHqDqFX1eTqB/K0iJKFD2Ezf9hsKDA1hTlp0BVgmdcbKxNFaDtW7W7nCcqI1WxOdCviIuVEeEZznO9ZirngN5y0Ibz+M9Zau/kek8ljw5IToOA5xi7spb40NBOrp4wFZ/zaLfBmmZETviJgLcmlmYZd6jSsPZme/NCzA1C7QeF5TlmeRdD76GnueSOlM3ZEJQ6+33uJT5WXZhj4dc2Co+jmLEtae082IzU5UvloU+fvDxIIXoElacjaprDV6sgQZE/KmJE2/Qad4B8jhek93y8vFPbOpo2Zdh3LzSQcOeRLjA6ocj26CVEEFgj+GBuNmr9bNjQnVL7cKcZ9WVFBEeXoCS6x8tj6TdZXCgjfDDFyPnR6SDhbfhakZVeEC8jL8c0/wd57j/0F3ACaxcsE3K3NsawRbvmlVcPMK3BixGq773Ej55Df42rwL2ZVO7XwXMxonfrP/umZwr2ogwETD5uYz+blZDNdsSRjgbOZt32Dr5mlM9hPHithoSClxBUXWpQ9d2qKRKQ4yOk0OjgHwEcrXCvF5ji+KnDBImKVzMy+AJh/qLydytEDUCOUQFlK65u2fhUV06VB5DauNRLVoYuRB8lV03LD39Y0tNTjXtA95ZlgFpJlxWlz2GaxSB24NEg+z9MT7UMMpdjKQDdjw+fixY92dO1ywLLd4E/s6yfpEeS/DKdf54O1rF5FtsW+5dH0G4xVwi6YIuxc2fm3Fb3h1Nn1hNa74rRmwKsTCuFsSlYx/wMXwFQZHTV+pXtLmbLXkhu2kbkt0gtVorBZauZRUHtY8JbTCjdZVdN9HSFbChzvDGYioIl6uvGXwHiqVB8fBvO8Q8G/Gqp8w8nA5S9TbSWgnCXH4WkudhCPR4zfgQH3wC5wVbAed7JOjkH40luRPqQPkhwh3ED14V5M8Ip12IoEuF75klxB8MWZGjeIhHFxsmCeOTG5r1tLMgXRItVk6rptkUdK0haJawAtlpBcZhFrCNwSZgcp0+LA6c8dM4in2ipAcnTSiACpC9P37NPlpUD9xU1XzEumpf15HjvmM+j1haOapXBW0OSrFD/XEaZkFYM8MzhXorq02L9ILM1hb9H5TChSTXmoQ7vFgPzIZndD8PgObStf/xjJSme+qXEPssWRhF9Jt9Ma+Ne03BnyfU2CBjSENoiCabatVgmkxnl3WMENc5ya4HlLHGL/lUFpx8Audp9ix1IH6Mpy9YEzVBc3KLGeO2kNgLp2/SU8fvn4Sh7EA0Jk5JZf4nTLwSUetvQbNF+C2EHPmuUYwt94JxfgedgvjN++IyKpXpNBVPoNYPIKEW+g3vCovWEmcKZAf2Y2/NOMb4OhV1hrDbZ0wE4wkqunwgTS5vPJFCpBILkqRbcDoU4nUOp44fuQjJr4j/d/VFLB4ElmDXlcqklq5KuSWqBLBCKFq6hQzGqdTPNMZszXdAOxgMas77ntONu21gqKo1yA2hQwVKWCm2nGvzIav5DN8yu8WlM+MR9gQyzfyyZg8lRqMZgtS5G++CV0H69QiVJWEfMUQcAWLtb2KR8h/kFhVPSU6c8qTMAdZsK9I7GQCMnqC3NBU8M3ruPtVypDzWFFyIwIRANi8iPVfhVg2NIvqRbPL/QyWGUCftrINRsDeJ+EJPAbXASogJkC/3EbwbXc81Rhu7aYiab6Dr4hByhT8TpNyelzt4DzhygbAF3wCjU4VwcPL924NgxsEoglpk5y3kw/t79Sf9Bd9jXdNyvA6O4SEaIrzmeMqcjsErxA8Yog9sbY4A1rbijCHLY+r4AYDsNHSwimnnNL96gkvVFl394Qwoy6/BSjiWdbbqaYQ/qTD0YkpeblF4e2xetuPDrKHTHsITS63GMMjLO/5cjs8Qyi/QGOrmDgRdyyhV0SZN4sinFV50JClsheIhas8kyr+Ei643K/gY8dJd1AFCpp3ym4dtwrHMtjuQDJOHYpvQDOTHQypMHJ8pf7mzxaVgNzMj+m18M04ESoNqYJaYeE7DUP20AOF58ACzjaPMXy3RrfxDoLFsTucIqm+4zvuDQiRM8Xp7MGpYi914D895kRQzvsXkqn4NWsIu3+p7NgiWPrf6eM6JgqGj5NBdz5bAB8PPLF92bK6Ct4Qpq7z+3xuZcaRlGE3NmJMloNmqnF4HThbncxVZ/bxXNV4hFa2FT+jr+MG2EM0n9Xu0mjmLdUO+tDGrKSBY9xH7q0ocyy6r0whriULLOU5YNRW/DOXlU50yLig0EFt/JEHoXacxjN+2hF/H+0zm1QZaHVKCJuGL4g8Cpav3pSZMG5y4SUar6wQYJAoCYcYGHGq1VqVwy2y2E/paSDmOkJSSoO03HZfLS7ux/6WJFLfJ+aqA8lII+WdQJWfNSS+FViXByxLGPACI60XfDAaz1CK7SOneiIkcEL23/sr4/S1SeueSdzhCXLczRvF4ILg/RBpKf2AEC76uAHshcHQ7DJ8q/e/wSzhyzEHbvJxuVhV0BKkHjnEYKqZQ8JQ38f4gywrGWK4ZVH2q+1AakAeNSXfmDaMPyzNlz7lojy/DhXiT3DxIz0kNF+MRwM5gQhtsoEPb/ArZiW/xL59KnFFj0Jf3ArZ35TjaXzMiG33aauITNQnt1YQLUCAKYtIMBpuFPGIEZdtSnsgOlYeEERBugaddcVloFcAjy7dLlqcspkGMqWzA9uoBtri0WPZFp392dtqM2Yb2JD2FFEN9QfjG7wpQZrqVpa+UFmoG9AAWlF6FJQa9VfHExOd6xzY9NOnIV9b8SXFdO76CAZCtBSHAvcxt0HzfPgZB4uGgRb5qxDLorHq1nA3IWPunrvWThVAAB7Xby8udsE+PtiR0Iqm/vM5D0+I94biTYuaOWyk7jlADIXED1bNd44+nOMWTQJYy3tpWs6T2hpN9UTUu7DzCgr/XfEVmSHvArrIMbNZJFjlRp69XkJPDW+t8bMw6tBN6lhQWjXl03uyztFPLjy9LaEEYdaowuKIPUXSkMT4mfwLd+ewIpwGsW505wyOSd74iuch2sWNr4b6B20oGuKq14Dia36wu8Y9RDPyGu7Ne0rXRysG7iseD09W7e3OcZ+xeah2GlW2eGqjMPwSTmXr8MollzK1gdf5NG20BBoceLlu9QZ/Ow/XQg3kthmOO/GycIICpRL1f9gzlKEQjY+4tPIIV/+vSa8oLwLAnhWV81/MsU5gV5PFy7uMc+LxxmHUlFlLVjxIgTUClbSgHPtF8JqbXD8sQISar8WgG1SIh2qzimFm7ZCvuWypPDNvUewGIK4tQpduYPZJ4ueEv8ESfOkI2XDS3dYAKOp36BLTAjXtVtMHPgb61yfY4MkUUlWAZC+dmul0k0Q47pA6UJnVYYp3YF65pYIKsmqaM1v4iBk64mxfW2Lkbh8P9P49ax6rLzr0YoXNTnXyp5Jw5kXHZosgheOgbKjbDnavTuZMM9QpxyX6mxw8xoNdIudj6V+L75fi7unWWvs/zA68Jkwe2izmirsqJgxRATGRijjHVq/zGXu/eZDh+AOEYWc59Psfq477ifgObqk/0DAa5tovWrVqNc1FYKG38uSuyAcy6haCnWG9eqe9vfVu37s1JIGAppkCw/swXvd+vd7xB7qmtdlTC7dum7Oku8Y6C7nMv02cWjTxoMMJmqI0Imv5eGVsDV0fPgZYu/u85+QHfanWkUwN1VSijna3Pimx9Buimw4C6ryySoh7GrUQSAOqboqniACiFuX4m3nV6FvbQbt/gFtytrT7PBsTr+IgaHLVpdpt5osZLyKt1FwiNPvClM6MEE6qchnxfEbGP7ArWwtI7ir70sEBASYeQn7zEk/rHAy9dyfw8WwGzcYY95CkoGz4ib3mPtlMgLr4C3Xl/JAE15uL/N3DehsoMzPo8D5uVwKWqftEkI8L2CBIXPYRzsCL+g+hv7aiK2zg3lpXotu0/PsgrtHCj5A71NzZgRztwYxxer6ma3ck3bS35+WA5nMvNoXB5Ab4RJGDCC99JEQoFnChHm32RMdw2r4+ND7rR//vaYJDOjXKTdjQM7FAU981sLWoOUzoAjmwtIXD39Rnposr4NPtnTfDmUmWG2fCASU+pHISRpmr+T4DVGDTNqjpX+t8HP2C46q+rd3cPxsbppYFD63N7bqdsyHSvmuZ3XEQTK3qefNcgOsScJnAGIBITS0O89uAnYD6eWLky9TaaYAZNcEEeS7IRi9A2nwn4bnIqJLc1Vk7IXQVabA/cb7A4sxjuR9QqW1riZw9AxYa9bY7RR7Fey+V7ogvyjhNnN/qeIS0zzF6MVxtFVGPfyWPxxy1Ju+Pr/f55njavFtl1v2WB3ra/NGYvSh/9lGwTo7efhGqbFOV7KWepq2Rd0ENZuX02IQZjuszeuQPYMmjgpwb9fd8gSLJWkd2Bi1ircNKvuYK7/UcBEfWfKxeQ/1vd8DSny1RNAPP8p3Pg8c1P0PmnWnITj6PlhRdXSXs0Mf5Iv6OegTiP5awYEA2Vftgsx8SGnblu006vJZnCZPpk7ns3VAhHdEUXJBo1FRcJlZLqv37yi2ZHiiJana6hXopCiZsJWxZuLHyFfifw/fjDJ7U+h2MxwjbPkO+iQcAtAw1Cr1h4i7WZS8xqZykRr7BgGT6nfivpbUfYkUKPhr7pgQ0Bg033+bnyB8icoYP4yowin652QwMbqI2Ge5gg6asNjkJ52nJZmHIYCRkGPWLbXfNwfmdBOvZ3EpUl5ZyBsbwDfptG0HnFJNbBJiL5yCpadaetkafIkxzX5Ku8GHWNo8a6MvqGE7pMSt65KIixlnCmFoYvx8lTym4aT96DgghtfBeki03BPxTUAfDrMAQTSBvbetzOhNUQjSQaaqPhUe2Pm/WV6Bkrp5syFUFcpR3m46hqkhIBYsg5/IYxrVkgCgZipfv7x2Bm/j9e2nVzBvwU8BXYQsEkqmBVC7u35DNlR2nvkcyaakEGwpWAnIpBAAkOkJ5ctAukHM7kpz9S9ttCqJyTelnPdpBlYq6kTBHFDwez/GkUZaLuzSdGwET912BroIVtQXgtNnU0MOBuGkFcXZwSbmntzV8hplqPlyau1uNeybtkeaOzXPqWnMzbzfKhlgAc/wS3ijr0HkKrxynl/Gojm/U7sXMU87pRrLdGzg4DW5cn+tt8Fb8mXznGeHWfrEK3epNaT+LYjPLHcj61hrVAjFEc9hbwF5roBAalltk7mRFrgoVefsJXGqFK2VYkHFeWeN5mQAJhw9zvRmWgjwb4ALmnzz+74ctSD+XZCfAxaMEBg0uz0H9s/MUiqUDb8AsAQBi1Vq8oXq7rs0tu70de7JATvYayjol9hmiVEKxs2ioDedkxo185miQ0BUi4GGXlzZoyhM1p6uIbVNPTun3oqCHoG2IX92rKgNuAenTgX4oS3swDEA/yLwsf8+U7MuNyK9WhFi0LqG+YswnzSgTivpLNUg5tiP3NeIMBZESOHhhpbMF4MJVIt5emzvQSycInEab0onVYtDbyOA1QlytiYHhd4wkyJ0kPT/TUxAZTEPMX4zTLYjP3mHEAAPFkEwtRW01zT+ABWmld94bBCLR1kX8Ih35Kq9S7/paTt3OkcPDMVoEczJgy+RhxW2qAKPPztn+sVE7jNE2lhp8Ckxz4fHGBle1583Jfg+9SryT5k4pQ3SBOkkV8iInkPPswaOhAw1+SL8+I3/Oiky1/0iE+eLgOq9+DmgdkvjlgwkLatGxmXm4/jxXH3eQb3dLIQG3Z6rJg0+RID5rbWx1rgfW4FeFGXUHj09tzbrGCc/BvzfBybfqRzMKFOHh4bITmue8SIigf/3UWWAA8KOhYSlT+m/1IxsRq0pbQNA6OJDLOjqRka+qEtxNDW8CfcPppNiE57q+XVDoiCczu2QVPJlEvZF7ce/S1gftaoytxN78GFTjuCEyuds3LruhDVQ315GBkUsL92DJl0u3Dr3YTCOeA1LzRiaUJtBDocjW5NmH2LWJOn8CqwrRM3AfrvdI6+4iVbKwzRM3lavVNVvuf5vpueQHZ6hL4QxdrSFH8LBg2FYClUVt+ZGCDK/EJaJFUkYeHKrPP4SN4pjXOFsG8k/Am8sZ9Up2IT+iQPCVudcmssO4+z74cDXgaXV+7NMqo6RBw2iNlaPShq/18I1IUDQjUy/uBukzRCrtz4z1p29sN5J87AJysxqTS39HzhlwcBC7A2trjXOcyi/9I8M8CfltvIdDucOFJYla4DbXUXH/Xk/aMPay9ay4yyDEs3i+zQsqIiuvV2Cvtl/KA19bz1Lhq0AxXtlKY9OcVcRlZgE3frWaIv3Gzr2D3qZlArVUMFZb7s9kCDDv3KfspFpOJIUdW/wbmx5JGiCKpPn7Ep1wdUVs1NixgrqNf6eUPUCucxVG+A/4XULlmYhQ7OtBvFkoFcD/cYC/0KBfPpWdtnSM9Kc6foua1fXWo51V7U1z6108a31qaJsUJ9zo4JC0o5FAu95Ytqe0p0QtYfxVvLExInDY1wPRYBMLqc2jYxrEsjHFyUNQn1YfZe308C3F5I/wupbr0k5CQu5dFS0GDoMDrmM4hYTFDZcRiqtHNZlp3tNWdb3fz1MpzlN7gywA7avSFHXTok9u7rDPXdEN8v0Z4UYXWTHqqq9eM8Rpoob+WPQ3UaGrPKHrYIzDiZZhg1WOFnGv6YUQwuBxkkmfKDFMEZKtiWAj91xuIMNrpd7YKUgbeDHYCDz3g/bJ5Nd9iE2EE/nX6o+Cx3PE+l7HgYGm+/A3e3U8Jo6g31eZWaaHToIPBo/1lVpA0PpxCiFOSnU+o3Wg2c3cJEBGCYP/ObE6X5u1ucwGv74uknYXbE2rcFSyi9qW3a3NfiR/K+FRgP8zQUKxF9HgyMTOKUs5MDz9t1JIfpxuOy0ePNSofQpkXjDtcoDqVG7Y80esvm6yBUrWruv9G7cB/h58twLE3G26+xF7UBYpE9291nDYW/qqjna7u15uptmUQ4pzei0usKV45OEef3ep8Be87adR7W77q0vTcaLYEoad5W+2wstJoOnSnhT7LTKNenlEL2Wu+xQ8BXwT0Rg9gg9fScTxIO1hHGfOe8SUtzZ316nN5lYjdjdp1X9OAm/+p1CC1plpICAD+8eYENOP/TjSfyEFkX1jgZpljoL067OPa/3yzx4WRRy6XA5XZmlgthh0deTnMhRHbJsJs2hilzFwbLEA1z7Av+mZCBI5I17nuH4OKiyFVHhfQVO3imPdB4tp0h2z7U2PYaBFHG+XAyY7rz5JVLf1vsDkLcUqriPCZUvI85U3zQg8eImhmQUl3BP8Ghct6neHTWjp6DSWXvwMagtx/HaknWiu0OjlSktS4+TY1s+YYsp3p62bs16qYcxGydrEueo3U3m12VEnRXPZ+zBbMZB2IPCLPRS0Z5wMULXDl26819vbkjIlhsJ4zv8jWWGNQgs0SJXoo10hNM0WylTIEytUssaXvd3TmcsW486UgyPcJOotP6zvdStsvpG4+d9DVQNbswfG8T4MqPKAn5RFz9vA1HmN8xo6rPMj3Cc8YgxoMqgKkJPce7mJ2udhyFAjBUbiHAMpdqCuQdJl828+E2kFZlk6gQld1BBRDG85yG7N/Pjv1QWiWXrnHDeQcmf73imMWjOQ26GL9PPLEuRyEgHdeXBmAEswIOd8z0aeOhVNzJBs8DvFbnSlh9BMrUhOB6pHy0UmKqge4uvHGVg/2rkRCFcMY18zJTbcPlnuPyD8SiwsU1EO11QUCM4gBKq9ZhkUdjnclxs8wtabEiERkPdK/Na+kF2DHvDrgAMHrcmCCwNMjCwiXqsghsYB/sWT2vAcDyfziu/u0Vg1bUeaQijAf8vAe27wshBg9WANmvJ3fEdK0BBBkemC1AjSNmdfZXQmtMgaJ1x16mcKgHtwOXXFKGmHg/9mfVa8eD1DsUzAgShtrzK/p+Fwaz+R4BM7c4ItdXv20Dy2VInn1jDIf1SaE3arXC9vAf5Bys+9tkbvM3RhzaxptsezsxF0iUVjNrmeIFf64MYb+0q7/183TL+SvMuBax0550gAOYcp9DqYQorPBYCQTu92MMp+7bPvPYg6yVCG0zzUb+bz3Le4BgRxWL0zmpoSuFgN5HzwxsfhSLr7DSBTmQn1fiYLWDD+EV7oDc9UiZcX+CtJz+tJXUnrZ4/4Y7igQO1xqjyzyWadr4Z9nEhHNeSXeAHNxJR4xbdsNoLCKWrL8Iaw0P9rED8odLf+6Nvntq6xjkHhTzfPbQmuyeLrQKsI7UUviX6bujvJnTN+qfLOi+LmnxlbNWzbdQ0Vr+/o4yWPdiXGBQeTDAKo46SHrVgoy/yY/EPY4A2OfvCUq9XVsMLDRWRM0m5878sRjv9VSjvmpwmloen3r1RNxc87sm4WkY3yM7UkriTTAY+C6vQkZ/zR63A1vNew1XGunqEfiVF0IUY+v9CfMSJCPiomXOd/FYbazFW/HfwySVwBzPsnxIVYTZMvGzcKHBaP+aXFfV3M+xUaRtbaIQAjOIuqym9ArSf8wx9t9ApQQ0Q+AvwRVW+bPhCfQRriqEtIJdMpBk8l3w4qaw/NI1YSVdmEOC+SL1vcqnwU5zM4R7BdbVFnrOALPaEEXi4WGuGyn6ZQqfFqItEMRqacgNCzpzY83LZXR5ne7hkEao7TDLElQkh4h88I/3UH303aSd/QjaXmacP/uMj+KdyFuqx7zt2wQsZcot0xV+VOU2xm6vHQnU22DgEI80vK4ur6pvnN0sRwafu+YbTY6W/D4i0tpTvs/wLmzkUVLj/LD6Gg7DTdYD9rGJ/PQFyjswcOIEGFt99nMsI7v1IUVyKhpF82ZwSdr3er01qip62c/nffo2EaA74MqNAATIBt+PttOH6pjkiRU7xDdN6Yhoe9zr+Rm4b425ticXintcY8wT3UYZUDyGTlaiXxfQa/8/mEV/2Pfy3rH02TA+3HIUyyQyguJ7KubEUJFmtLirWELyOoF7qEy/BrT+N2Blw4huDm7gjKlJ0zAzMF2HeSaVL2339rldXhQsLAzYJCDnssdhUmvR4CYkIdyM0D47aeWQe8tVV2AylSAeyWtPaoOGyGzK+ZfK2cnpV+2UqbaEueghcluFrMt6MCz2AgJXcUHnemqjaKj/kJRjlkJXcL5AW7PLI2EpMdplQgc/iYsR8KkOgCbfzWRFsh5aiDtRV/LdZKh4QL9Y5uLhJdjYeKq1De3e0vK1vgr1YdaSic0ms3Lm9Spvkaka+UruHcKTtIjZRaE8mrml+gZHOvdooSC73ISZPIbmQkRimsMKw/Cr9bnsuqTh/sHAW9GiNNOD04BcaxQtA95JRAKzWz0YVGOagUQPba6yccayNkUUHT5H31caeyw6T7NyvCIa3Os19nJ27Ot8C8IvC/kU5uUX/cOiIH0XRhP/rKA5WfmITGzrbHn405F0am6iYisJwIOmF6B7/79bsTzNCXSmSBpA9dwCWEMOh83OkgoIBxoTcTwMlmxCrOowKHg/6QKZLs/bFUiDV+a8g/7yqN/p4xIhe5rjkJmDu0TzYOJ7UxJwF8+/FGhauf8GuozPBy9niU+Nt5vAyfoKUuOkkaq2TUV6lJeU9bVxiZrHFOyMk4ufdKjbUvwWC91wftGzVokwHYIZfBYohvxeF/ol9k+WxqYDKuNsNEXXp88q1Av2cQF3C4cKvvKf040olAyJA9yx8vGpwwEspIpQUItJmKUMvW2PscvvxxyISWUnjOuORt+Xn98qfSVtMUVDoPX74EehzvKOjrvOK9yNmTL7WgMAFeB/OKbXhfN+82O2O75FbKa0/SZq2CPpTMFAJD2Rt3GUB4cqX5CA4HFqj34bEHpJX0XgvsVIZa+/+ToJM37OT1hwcJT9AUMt+bvLOOJU560/vipvBI1/FkNLN2ym9Y1oitSp7N8hcMMjDWudzkyYpSvSdbxW+Ef5b40pGTorbNDJ2BASKVDpBudIAmMCt4ofOEVD3T77YTZlz70CAp8vILgbIOPnc0yHgmfIhC3So30eHG69m7dZFWTZwNhM+0s92NI560hOtA7PU0CwFk72CtX9rH2i9kIib6rQRhAQBZYDjKC+n3F2HrzZDDfTlv2c+c3q0xSHS7vmT8uV1DOqDNOBBIUP3gatOEN06EZ4wFW9P/IZUQf+nfwa1SiNI0j04VEGBNkPTkFE3eQUj4QJ5DHUPxsban9NvyOlnOIMZX27P/MdEhZ3aerkEOalW0ve8feyr+3hYacDLgkW9Lz4ZOlezTO72NQ6BAXYxf//xkKqMIxiogDV+8i/rkgPso6ndLm35d71UuNOeM4IdG+k/GZJe4L27eJ92WsuQsBZrEwWn5X1nGmoNOipvOpIxNnxyzVBd2EbiTCpG73C72i5Xp33W4loZ09IB45M98vbu0rKoUmhjZd4L0UftvSm4kjwxTB7Iz7dzxaLhJW3RQsqEjkb9xIhyXcmk5Ae0Yq6lNmi3vwdYPitkqQttpM65jAcslRza+6PLnTVlfasAYITaq0Rr0CSZ09S4SeKejjAdC/YoZjNWNHg71ssHi09lA2okWTN+GDHiLfquzMDbKTH7dGM8h71aOyYy425llLM8C4SsKle26jvmZSnt7NHPIDG8/hTQb50xop3ZkRWgAFjzvlbELG8AQYyLgsrTwmQe10UI4pk304GDdo0WxvFP0FJU07D/ROm8GBxlZiLCThCuL6yGVy2a4WQBBysACXWX9tzn4O77nsgMZdBClQZdQ/ZZbl0/h1sWHnktkqC/hdJcbJuO+HjveNTR0N7uMaXzlnEU0p4ZylZuMNveG1IC9uSzQ9XbTdgDgmRAVLb+QHdCZI9erKKA4+1yc3r+GJ4BM5HMd42AZN1vdQMv8QGQjsXiqYiWk0e5K41XQbuVtokswHAtRINxbyRuk6bBSFTT274ZlLhiTrDG3/uElQa0keadR/bJnWPBz2PXsv/8GOwts15Gqz8Y7AyH8q+OM7EvYfcGfIDfjOiW0fmA2gLAZijSMd32oNdDtc2U0Cn6QpFSXt4yJ5TVk8X3V7qr4vNPO40pk7IMlGvtYiFLmWaDacpIY0fU0fxzSxtNt5eKpsz/S1t3KpwRGHSAs1mgGqhsTg3P1+DRsCHB5asHEl5u5iw+73swwj68fb9ILmH2zkCb9RY3uCkLMCusYHWzMPXUNRgWWvFri3KTH0wAzuNFeaBvvgDEQ6R0vFR0v6L1oX7wFJOyqizFgDgYKhX6ose4sAxWhwQ8s/MGoHoxV+oZrT2Zw1VqdfqfrYlURbx7m4iARAGb2qEtU3tb+ANSZgBIeO5lGJjYu1DS4QaHfjPPJxblzF7RT1mJJDWCOGNdTxOt1E4iVkml/C5snMBVAeednITi6F/j/U0gsYdB80u3qT48lfrvK9UXYYPcEdi6PUYw8ablIEbpU8klGt22BvQ/C0bMjOoqavZyiptPfaFB3KRWtEECi7V1E30jrIYnBKLgdLIuqFXHFKu3Jev6I6xwLEK+HQw/+5dhvh0VgHNTcFNv7e27EePabB7xxh8XawmmniotAVb6+WkY3F4TF2a1w7/8TAtU+yl+SxQuLC3R4StjKAxTRjTqnkQW+H0C6fZtA8nAY3G8t2fL317/hSTfm7WILJMsKByCA6vCYSZn5k1imFcgj+GUuJBNOSaEJRu88zAKrQXXw0JI85AoQJJsH9I0LHypY4FXl617jSI695XqImTpg7q2JU7xm5qkLMHT2eYga9m2ZSIG3BURm/UrB75A47pje7fprxkh+Guy2Ztsdm1W6URTj/GHH+CEbIdXyeSP3QiQYlvk2u1KvCGoX0FhLEy93tekV22SidtWTec+YrREp/AOFe+pESwoQGSJrA8V14gzLybXf3GGRsHK1RyGfV7cufml5NqDHZloysxniK3FI6wYzLBvprtvCQ70YTd6fAYz8rz0Q1q+DhjBdM75jq0SmDA21XM8ndfvEgqGfifppoz7nSg7QBnpDwtCTQ2M2sPA6yHyQ+6tGi7nDnoTrOn0FAJQhUP47nVxbTx9VCCdPLIo4XjqkUZdY4pTx9JMF3fTb9Iw1sbXnGS13nzRFPjC9VfVPPPvUAxiUjHReeEBZobnAwoR2s9KBtxbr1iunowi9Ymr25xHnlY32wkPL9/2JIaft6Vcg3FGYH/7tTlxO0YgsMUmDl+5uD5Ii/wfNomy+euPYe2AgLx5GqNcrK+IOVsPNLauwcsL5flJ9KnTFAXgWSWbb6bH7R/3XZFZDMtQrEsS8iOpfSfRupbUMQqUIIcqamTYwNZaeoq4b7RyxYLWi0K59ETjjHJAgXnGKsMnUtsR1bXYysp8L+LHILBpbj+FfKQ7OZvE0PV+oa2B6LEQY2ENLITIGUSOmS/KzZc7+U1UJE/9JLCCDHt1e9riP3ECo/cTsHicXKKRy9MVFS4whzugXt+7MrGUWiz8P4ZvCA7BR3+HBvTGA5Zy0k/mhZPpDeYaWLL0VvPJqKkLwkQfZ3Or8rQ4FSqBmvyrVhPeRS+J5vZBXcuZ1L8EC8Fo7tdtdtdvVX3pGJ8i3GpkOfbi/o/yYJx0TcOmGWXg33clvPil35jR0qCFe24iY5WqAhuzSvi+gtj92/xIvInKuPeiwf5Z3AWTkdqwqiBiJwA93rygLn3W32jnGih9I+Sv+D+xZgsy8zTgffNh24HEW6xhoelolYvzgn2gtpZxTJ8PwOmiroEUzgFlSeIfpyDOWnwHXsFqFzL8tN8d7hlZcUtXhM9hiHxkn+L5k9jGf8/3AvpOHKadKfd8i10jfr6rXZh2kFjOxnojb7c4y98liNGIZTHXNyt9ZqhMqSjXVxAvqmKy5OiDJe1cKoLuHT0fHHz82ZDs/1hWkBj8dZtqIv+kM+9hfqYiAq9P6AMOq2eEN20fx1FXThMhfLFNYpfURo7OZi3gUrqcwu4m7p4z+HvBR92rkXt66dCakL1P0Je5oyzzDFr35C5MdYH8EU1BLRPrdEFXbYYmBDykp1SqO2tRPJ7k4tMmlhEEGizCbEthVksBtr3AQB3rrUMchtD9rkFCQUCkoJ68K0bBmxTCwLnxtxp619/x0DrYQ/nyq2D0fzF3E75E9ROVW355JffvUsQ5vyzicCJx8QCVysAOFLdspnLYz3Uu4CWaN0V3Zvm8fgYYkJ7wGre4nM7OR0OBX+bM7teq+1N06vrUE9Gm7M8+fsCS3K8iO1n+Y/xMRrsK1ryap93H2+cpq+uPZy5uwkcLcJlyxCbyvTmbZRs4G3ti7J9tfMiUpzQghrz+N/wWEkwclGgOQWupJFBMqCV8oUOPjZldDK3BuYQZ9Cgp0w7u+jRqIJvVgYlB44CRSUBrUWDtqOI77W69RWkrQ8DbKg6uSGhV9grcKNah/jneTwltpZ1lFK2rMzcRBsDBdiicvD6cFW9wnGxkrh4qqUWtBQUfS6DvF8jCXO7cDWyG4h2rusHwqYH6C/2p2N3vwi6S6jOdRP8W1iuvqLo9oW+2WO0ETI7YHWQypZPUH546FItVn/jPPK4c2W3yDwFByFq9kgHsp7SAAmsIIjrVNfagMlIePTeBzXsO7o6tI4Uji4cEjzG84ufqYb+R8SndQFHEF7X1UAWggVROntvINofJgDk2JtMifNa8LF+YrS7tVw0jTx0vQ3fxL8h4Q2cZut2H79+btnzKJewv1dtiJI3LYis8+v0vgwn4q0u5cvWNKdYzxL8+ZsmtfoY8lktgRBe1bgy0uQJGLSslE2vmCIX2XRHePBEpRM2o84s0u8mvoA/PX5/SnhzV4f3pE6bpGdLGjpfQv2xBrdzP+qu1BHWKAKDBhVCbTr4FvNyAi1ZJifkZ9vE4Wu6xg6YwAG302ziPjgmivgt8tD488CxLHVaMV9uGSFzDQh1nmoGt18Ov4xaylizfdJs35LTDBp5Xlw39cmwInlOC0nj+ebvHkBncifKxOMrQGbrCdQCHZQAeeOKlmd5/PFGQo+FivLiNUXawjEWWxk6IpNM3tkwM7hPtE+3z3wuVgZd1aOYAGJAVYsNJIQlAh4THPGorXBmMO7COQV5B+Kma2tYpu5chHUQrMB0b/GgP7GFutGlLZeI00rDLGyENTFRrgSXNwLGWsIUC8ihoV0OpaItbQyWxSaHRiZrXCcrlb75Xhmo+FA1LmwDCGpqeT1wdO5wo+Ld1EhqAMwnd5Bv4WI3fuHn1L9iLOef5hTHd9aCNVD0lbCKIMH1jSXRmbiWuivLcuACek5NXKD3voFNzQ6TzINcuqZBKwxLdL5r7KzNcr/xNodPdFUylKIgi4T27wBG2QpSGnZ5UOV+2XXaDlKi8904LiDOvUILys1ZrXau8n+Yox4KFy2F3NjusYjIByVazb14+Nou/Yh72YCUsC1Jnd9281imjhHeeBsHHwiGNabfFEPQjXYt2yk+WvTsarvCxIHyw4/vMGrLWS9wlSr8FfkESL1i+Ep4WGthUuRQ94lRR9146OXgt91z6LVx+UtygvgIOxq0LOh/TBFApQ4WVMupCfimLc4WVaWJ7k9SeV7yjppSRVoUJpnWKhs41kVK5Y42R8+YjT9UxzdVKAM6imNik4JIyprdyarNQFYbvWdNkWfyN78jxeiFnRWY20G18Z0eQkZnQLUaeupxC61QsWrHYzurC6WnenXNSK1bQ0lyL9zpa8/20uIVbUcLZ/ZDecw9uOFXhoxC5JPfGgEKxnKIreQunF27y5fRDshwDPUOiG9nrF4EinMPgE9ABvdnX9qi8+wh/hPtJZnUfVZRTpVMTY8R+Xn1AM6n1IyMKWx8EvJmug/imbHJD8KkQH0QqMMhS7DtB1n3ZVEV4iwiCHj+K6ZtFrSjANZSURzc20BX/9xfqOEAlkdLo8AA7ax5cp9nZJQWUSLOFObQZ9j4zhvZErgYIPldL256P76bOSDBewAeEVqERXHhD7mWhfd0BvLPw3bQSDZMe1H2Pt8z4u0o6snKl7zd8gzJ3MKDtAcjOxUqMt+l6tMUO3zJNtS+LAzRpYy/zV995G/s5576pe3NqN6RBmlOkdhaoroD6tW1rLxXgaQKacVzHOphW8WO3qACePVY7VxThpkzQYZZtPZzbuLwAssdfcMgJ1roKt6Cpcj4H3t1OCiO1VfmHUy4P61LA/sR0EAthB5Y9HRrXnvC2wqOG3+yZHoYmx8RkFs3cT9iXer+pqUy40CYnJOM7cVGN5Bu8oDjXVhKzxLBlTf9l3Kp9ewe8q1/XLmZL91swUWTDvo4ceLKQRJlLWMrywuVKrfVKY//SzSFvtESStBzeNJl/7VQksEN+clgkiscir8PCI/6z/s/oQRaym9NdRmh9GV4XBJF732zHGMCAOyANlo0N7MsajcmIyZ0lMgnlKwu3qv4QS3BGC4JjnyOdPJa+bVS29wTZkgqpn7wUAQDW0TMT0e39AIx6Iprq/V1q48NLpPr+aJjfCUj25c4V6V1fkbD6uUZkk+3ucvkBm5D71M8zAZXzQsJUM8q+lU9RCO32oNq+Wme8UKv9aiJnd8V4sr/3alc0byGmFu+mBX7co7yoXofqtmYHOraB0KeDUoHXPSW3E99zSfmPNE5oY9mtodkt83jFD9t6yDsh0ZV24K9jDtxxW+tRShXb5bSsDBpdsHq31RYdMUsNlQVrfv6uwhlW4/wyZb5guMTtJL+EVL6OM2AE7LJRhRwqwX1U+nKvE5Ir2znAn4xfhTGhLyGCTfaaC5c07rcnOMDOdZzhx/2Vyq37S7NqiWyiEMw29wPh/GB2iP1brLoiQJ7f/qSYDAPXappOXGl+SeiatctIsOwF88GwgDZsHPyHNpI1kYfYa7DTYbAPa+RmJzY/ZGkIeaLiU/pcZQgiOONzsNuWA9j3arTnj46fRQLG25+RU5/YMYyKmGpEEFC5fD+oy3hNqN9yaE5pY5Aupbeifo99+X7XevrSRHiNxxtFqPtHEt3e5s/PeykeKsE26TL+uXa9kEkmO5IhhTz0rUTNom4FckkioHB+DwmqIOzyalqqhOrFISl55MOLP9PMoSNTxPDB2NrQfQnV0VX3y/KxsRLjXEc157/4dNgAPmoCUpvF66caFY+QH4lbPIDUPNo60AINO6LS8JgvRZjP+oizKy+y2XhGcglJfbyUdHnHJAEosY0Bj9wnl5iJedKF6hA3Lz1jU3ctPdroRFVt5SBRFaj0PJSNf1QTt/r/5t5EYtPktgfFt6r0MD+10JWvcpfL004Ro8LVN4SRZ+BSRtFvRoocvJ+c4zJ22fWyn6qfkRCG3VKD1nL8TwGvgCoRSqi+n7gdd9JmYKkxLjbNRm0/r2x0yrB8JrfqeavhJ1KNRGGjMn0is8h5pLHjLNcrnSfSQxT4Df/Ue7ME9Sv1JdfpWEoa9X4XZUtAhWRCf0zI5Ltm5En1N9zH+VYtQPjf/I9Ww8hoXZvPp+hzVd5ju3UtKHrVWrB0g/6YdR9K3Hc8R7ZnmTQLxuCtHsbf8iiz09UIfZYZc0H+URDd8r7jXbNlVsCaAxcd6CqshckIjn/n2i1NnYleHjW+VbQe94UefT0nNjcTz5RJnmhKkpXTY9jXVUw4kr8rNh53p90GJydCboC9x6t2t9Lgk5tUcTACwGdyxRK/JYpRQjNrxS94oMy1f0rWKyVZiebGLTJNybnagYGWPKYYHkKIHTGc9Ot0y11gDmmTUvB7JNiyi2cY+Hrhp9OJKA6ZVXkh9tbFsF6b5x+d++UcSXwv3RFHFhVLESEpa7daK+jw6hi7BDu2XiFTSaYjQUWjN/PMGrxB5k2lBcFfQFNhO2EViJURGwDRA9bE19U3PAYp+iIsBVqxGCSerV97fk2g5ACe1YRzBNuu4T+jJBDXPuYPCCtrwWWnQbZrNXML89qqeDrUsq7vkMWe/jamc+NaTxVXTDyoY6F4LjUg0NoF+QXgh6V4dhzm1sg1+fAeWa1GhEmPpSffIpclFRlmkEVab75plbCPKDseyJkkwHZUFbhsMD9pe2l/J9wahyXBL6ByFDqe7NpdXROIRBp9r0DcI6cPOhHWo/2+0VG8HWFn9+4ZIonGEhLCGuCsazTX8dS4bODjFoFas4pNeGs5zO50B99HV+kRII+u9sJjFQs5lO/o7l24P77XBIB6ig7pRkHqz8ddvhTksDfwFZxuaL2sFLH65d9SfkaOT/d0Rg0JFRuOaLGi6JPMUcS8zViwHXf3tixbuCnDoh4MEJUMaUqLawlUeljB5GDG7B0J8vyBFWBvts6EZZ5zO6iF8Ih2SZ8Gc5FNMtfAbeeQ80dWBzsQgDvGkO5PniyEfePtwwulU/5/MM8jJDg6xhCW/A5Hq54p6jbtXebg68BQxQuyL0L3pERfSdIbsMY5PvZ2RNwdycM9NGX36cA6OaWgB/ReC6j3ZV1/Jz1YrYuQiOfAB3JylOgMEW7ca1YXa4WXmfyZe5q8en7WAkfFSvLPn84UIDdRXrCJ8KjsSE6mit9m+fnGlktx6SAFvag5KhAZltHNV+Apcwyzgds5eNsQ/RzB52hv4NTO8JTBrxaAT5vU+sivZ2MfCBHGT24X4DCp4L2noZX+a5FGbMt91ak8PkCCk15bczWWR9oCTynDRYAUGdkNXCyFRueMW1IYEJ8K7LR6crP4dzz/jCFuwQyMjEVSisFa747tF1LlHdZ2/ZMIw/u27OW6VWbvKdKULxGKAl7mObAbIPITRQef3dYyAMEjT1N1F+//f0UydGeTTKfL78CNWPlKcdj1jXIOMH7srvP18z8vwk5/PEz4cDQLe7phoA6IDJRzoueVHDUmp8tOHHumcOre5D0YMScT4QY1uMbVV3MjpNV2o6vEc4nziSY4DwPz1mrhrQs+UzAWRfnDf+DjOL/p7UII0zdRuI7eB047hCg2beytDtjNvgS8tY9AVG8ydHv8cBYHEMDMHJBtpRLXGKMm6y0QLPSXN0BXhn4fIGNCyo6UhH3FrHsx9qLlCK7byqa3tLohXQvRDFJnQoqf8dTbR9EuV8f9AXh6E/1JUZ2lrpw8MdxIQYRfgd87/fdwq/kkZzjHL0Ya0Wk0tmUroprWOR2biB3IO38VQ8De27OKqwoWIp6eVGazr0puvYNfzxHF0qK9h7kIZloWV61wqhFW28n7Z6KFAg0t+H2u17s+X8sADPlC6Hzlg+KwRgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":30837,"cache_read_input_tokens":45687,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":30837},"output_tokens":10,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMNqWcfCq7HeoXb9cTNR","type":"assistant","uuid":"d54e1b5b-7bb4-4003-91fa-672c36873c76","timestamp":"2026-02-21T14:34:31.826Z"}
{"parentUuid":"d54e1b5b-7bb4-4003-91fa-672c36873c76","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_014bggPqP4dDP5KyeHSZcHjN","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a full picture. Let me write the review.\n\n---\n\n## Code Review â€” `src/App.svelte`\n\nThis is a significant UI update adding: theme toggle (dark/light), title bar, SVG sort indicators, a fixed-position rename overlay, `ResizeObserver` for viewport sizing, and a redesigned status bar.\n\n---\n\n### Critical Issues ðŸš¨\n\nNone.\n\n---\n\n### Major Issues âš ï¸\n\n**1. Scroll during rename discards (not commits) the in-progress edit â€” silent data loss**\n\n`src/App.svelte:1493`\n\n```js\nif (editing.active) cancelRename();\n```\n\n`cancelRename()` sets `editing.active = false` synchronously. The Svelte DOM update is batched, so `editing.active` is already `false` when the textarea unmounts and `on:blur={commitRename}` fires. `commitRename` returns early because `!editing.active`. The user's in-progress name is silently thrown away.\n\nPreviously the rename input was inline and scrolled with the row, making scroll-while-editing sensible. The new fixed overlay approach changes the contract â€” the rename box floats in place while the list scrolls underneath it. The expected behavior when scrolling off the renamed row is ambiguous, but **silent discard** is the worst outcome. Consider either committing on scroll, or at minimum making the user explicitly cancel.\n\n---\n\n**2. `buildDragPreview` uses OS color-scheme instead of the `theme` state**\n\n`src/App.svelte:675`\n\n```js\nconst isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\n```\n\nIf the user has toggled to light theme (OS = dark), the drag preview renders dark-colored cards while the rest of the UI is light. Since the canvas is drawn imperatively and can't use CSS variables, the fix is to read `theme` directly:\n\n```js\nconst isDark = theme === 'dark';\n```\n\n---\n\n### Minor Issues ðŸ’¡\n\n**1. `.theme-btn` CSS class is referenced but never defined**\n\n`src/App.svelte:1559`\n\n```html\n<button class=\"status-btn theme-btn\" ...>\n```\n\nNo `.theme-btn` rule exists. The class has no effect. Remove it or add a rule if differentiating this button from `.rebuild-btn` is intended.\n\n---\n\n**2. `.rebuild-btn` redundantly redeclares all `.status-btn` properties**\n\n`src/App.svelte` (CSS, `.rebuild-btn` block)\n\nThe HTML gives this button both `class=\"status-btn rebuild-btn\"`. `.rebuild-btn` re-declares `background`, `border`, `border-radius`, `color`, `height`, `padding`, and `cursor` â€” most of which are already set by `.status-btn`. The duplicated `:hover` and `:disabled` states also replicate `.status-btn`'s rules. Keep only the *differences* (e.g., `display: flex`, `gap`, `font-family`, `font-size`, `font-weight`, `border-radius`).\n\n---\n\n**3. Sort icon SVG is inlined identically in four places**\n\n`src/App.svelte:1449, 1462, 1475, 1481`\n\nThe same 10Ã—10 chevron SVG is copy-pasted for each column header. If the icon design changes this needs updating in 4 places. A local Svelte component or a single `sortIconPath` helper constant would eliminate the duplication.\n\n---\n\n### Positive Highlights âœ…\n\n- **`scheduleViewportHeightUpdate()`** correctly debounces `ResizeObserver` callbacks via `requestAnimationFrame` and cancels the pending frame in `onDestroy`. Proper cleanup.\n- **`on:blur={commitRename}`** interaction is correctly guarded â€” all paths that cancel editing (Escape, scroll, programmatic cancel) set `editing.active = false` *before* the DOM update that triggers blur, so `commitRename` safely returns early. No double-commit possible.\n- **`cycleTheme()`** wraps `localStorage` access in try/catch â€” correct defensive pattern for environments where storage access might be blocked.\n- **`renameOverlay` position math** is geometrically sound: uses `getBoundingClientRect()` (viewport-relative) + subtracts `scrollTop`/`scrollLeft` to produce correct `position: fixed` coordinates.\n- Removing `indexed` and `currentPath` state is a clean simplification â€” these were never displayed in a meaningful way.\n\n---\n\n### Overall Assessment\n\nThe changes are well-structured and the rename overlay architecture is sound. The one real behavior concern is the silent discard of rename content on scroll (#1 above). Everything else compiles cleanly conceptually; run `npm run tauri dev` to verify visual parity."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":30837,"cache_read_input_tokens":45687,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":30837},"output_tokens":10,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMNqWcfCq7HeoXb9cTNR","type":"assistant","uuid":"bd610725-980c-4e50-9304-f4027fcf9ea0","timestamp":"2026-02-21T14:34:53.904Z"}
{"parentUuid":"bd610725-980c-4e50-9304-f4027fcf9ea0","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"entire hooks claude-code stop"},"parentToolUseID":"2eed66a3-67d3-4fdb-b5b4-ce7dc94c05fd","toolUseID":"2eed66a3-67d3-4fdb-b5b4-ce7dc94c05fd","timestamp":"2026-02-21T14:34:53.955Z","uuid":"bd99bd38-36be-4a37-b972-2b02d40fbc9c"}
{"parentUuid":"bd99bd38-36be-4a37-b972-2b02d40fbc9c","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"system","subtype":"stop_hook_summary","hookCount":1,"hookInfos":[{"command":"entire hooks claude-code stop","durationMs":1440}],"hookErrors":[],"preventedContinuation":false,"stopReason":"","hasOutput":true,"level":"suggestion","timestamp":"2026-02-21T14:34:55.396Z","uuid":"93f8b2c0-90bb-45b6-bb25-686bb357d1c3","toolUseID":"2eed66a3-67d3-4fdb-b5b4-ce7dc94c05fd"}
{"parentUuid":"93f8b2c0-90bb-45b6-bb25-686bb357d1c3","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"system","subtype":"turn_duration","durationMs":158580,"timestamp":"2026-02-21T14:34:55.398Z","uuid":"ffbe1a21-298e-49f8-b121-ad2d4e5bb3fd","isMeta":false}
{"type":"file-history-snapshot","messageId":"1328a288-d2f6-4263-8570-b556ad230dfd","snapshot":{"messageId":"1328a288-d2f6-4263-8570-b556ad230dfd","trackedFileBackups":{},"timestamp":"2026-02-21T14:36:33.132Z"},"isSnapshotUpdate":false}
{"parentUuid":"ffbe1a21-298e-49f8-b121-ad2d4e5bb3fd","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":"ìˆ˜ì •í•´ì¤˜"},"uuid":"1328a288-d2f6-4263-8570-b556ad230dfd","timestamp":"2026-02-21T14:36:30.894Z","permissionMode":"bypassPermissions"}
{"parentUuid":"1328a288-d2f6-4263-8570-b556ad230dfd","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01F4YofEMbREC4bdWvqKqqcN","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user wants me to fix the issues identified in the code review. Let me address each one:\n\n1. **Major: Scroll during rename discards the in-progress edit** â€” Change `cancelRename()` to `commitRename()` on scroll, or at minimum commit instead of discard.\n\n2. **Major: `buildDragPreview` uses OS color-scheme instead of `theme` state** â€” Change `window.matchMedia(...)` to use `theme` variable.\n\n3. **Minor: `.theme-btn` CSS class is referenced but never defined** â€” Remove the class.\n\n4. **Minor: `.rebuild-btn` redundantly redeclares `.status-btn` properties** â€” Clean up the duplicate CSS.\n\n\n5. **Minor: Sort icon SVG inlined 4 times** â€” Extract to a helper or constant.\n\nNow I'm going through each fix. For the scroll handler, I need to swap out the cancel call with a commit instead, using `void` since it's async. For the drag preview, I'll replace the media query check with the actual theme state variable. Fixing the CSS issues is straightforwardâ€”removing the undefined class and consolidating the button styles. And for the SVG duplication, I'll pull that sort icon out into a reusable constant.\n\nExtracting the sort icon... I'm creating a helper function that generates the sort icon SVG dynamically based on direction, then using `{@html}` to render it in the template, though I'm running into issues with Svelte's scoping when using class attributes this way.\n\nInstead, I'll extract the path data as constants and render the SVG directly in the template so the scoped styles apply properly. Extracting the SVG attributes into constants...\n\nActually, the real issue is that the entire SVG element is duplicated four times across the code. I should create a reusable SortIcon component in Svelte to handle this properly. But waitâ€”the user asked me to fix the issues from the review, not refactor everything. Let me focus on the actual bugs: the scroll commit/discard problem, the isDark state inconsistency, removing unused CSS classes, and simplifying the button styles. The sort icon duplication is lower priority compared to these functional issues. For #5, the simplest approach in Svelte 4 without creating a new file is to use a `{#snippet}` - wait, that's Svelte 5. In Svelte 4 there's no snippet. We can create a helper string and use `{@html}` but that has the scoped CSS issue.\n\nThe cleanest approach without creating a new file would be to accept that the SVG is repeated 4 times but factor out just the `d` attribute values. But honestly, I think for this case, creating a simple `SortIcon.svelte` is the right call as the skill says to fix it.\n\nActually let me reconsider. The sort icon duplication is a *minor* issue. Let me keep it simple: I'll factor out the SVG markup with `{@html}` but move the `.sort-icon` style to `:global` to work around the scoping issue. I can use `{@html}` and apply the CSS via a global rule since sort icons are always inside `.col-button`. So I'll change `.sort-icon` to a global style and create a helper function that generates the SVG markup with the appropriate `d` attribute based on the sort direction.\n\nWriting SVG helper function... Extracting the path data constants...\n\nActually, I'm realizing the real issue is that the full SVG markup gets repeated four times, not just the paths. Using `{@html}` with global CSS would be cleaner, but I need to account for Svelte's scopingâ€”the hash added to scoped selectors won't apply to elements created via `{@html}`, so I'd need to make sure the `.sort-icon` styles are truly global or use `:global()` to bypass the scoping.\n\nMy approach is to create a helper function that returns the SVG as an HTML string, then render it with `{@html}` in each column header while using `:global(.sort-icon)` in the styles to ensure the icons are styled correctly without collision risk since they're always nested within the scoped `.col-button`.\n\nFor the scroll handler issue, I need to commit the rename instead of canceling it when scrolling, but since `commitRename` is async, I should handle that properly. Looking at the error handling, on failure it shows a toast and refocuses the input while the overlay stays fixed in placeâ€”which could feel disconnected if the table has scrolled. But weighing the UX tradeoffs, silently canceling on scroll might surprise the user by discarding their changes, while committing could also be unexpected, so the current behavior of letting them retry seems like the safer choice.\n\nActually, I'm reconsideringâ€”most file managers commit the rename when you click away, so committing on scroll would be more consistent. The user can always press Escape if they want to cancel. Let me switch to that approach.\n\nThere's a potential async issue though: when `commitRename()` is called from the scroll handler, the rename request runs asynchronously while scrolling continues. Once it succeeds and calls `cancelRename()`, that unmounts the textarea and triggers the blur handler again. But since `editing.active` is already false, the blur handler exits early, so there's no infinite loop.\n\nActually, I need to think through a race condition more carefully. The textarea has a blur handler that also calls `commitRename()`, so if both the scroll handler and blur fire while the rename is in flight, I could end up with concurrent calls to `commitRename()` that don't have any guard against simultaneous execution. of `commitRename` instead of `cancelRename`, I'd create a race condition where both the scroll handler and blur event could trigger concurrent rename calls. The current code avoids this because `cancelRename` clears the flag before blur can fire, but switching to `commitRename` would leave `editing.active` true during the await, allowing blur to sneak in and call it again.\n\nI need to add a guard flag to prevent `commitRename` from running concurrentlyâ€”something that tracks whether a rename is already in flight and bails out if one is. Adding this guard...\n\nActually, let me trace through the event sequence more carefully. When scroll fires and then blur fires, the scroll handler calls `commitRename()` which suspends at the async invoke. Meanwhile, the textarea stays in the DOM with focus until `cancelRename()` runs and sets `editing.active` to false, which triggers the DOM update that removes the textarea. By the time blur fires and calls `commitRename()` again, `editing.active` is already false, so it returns early. The double-commit might not actually happen in practice because the guard check catches it.\n\nThe real question is whether blur can fire while the invoke is still pending. During an async call, the event loop keeps running, so technically yesâ€”but in the scroll scenario, the textarea only loses focus if something else takes focus, which is unlikely while scrolling. So I'll go with the straightforward fix: change `cancelRename()` to call `commitRename()` instead.\n\nNow I'm mapping out all the fixes needed: the scroll handler should commit the rename, fix the isDark logic, remove the theme-btn class, clean up the rebuild-btn CSS, and handle sort icon deduplication. For the sort icons, I'm thinking the cleanest approach is to generate the SVG HTML dynamically in the script and use `:global` CSS to style it.\n\nGenerating sort icon markup... I'm refactoring the template to use a helper function instead of repeating the SVG markup four times, which is much cleaner. The `sortIconHtml` function generates the appropriate arrow path based on sort direction, and I'm using `{@html}` to render it. I should also scope the CSS class with `:global()` since it's being injected dynamically. There's a minor security consideration with `{@html}`, but since the function only uses controlled string constants from the application state, it's safe here.\n\nNow I need to go through and apply all the fixes systematicallyâ€”updating the theme detection logic, fixing the rename handler, removing the redundant theme class from the button, implementing the SVG refactor, and cleaning up the CSS.\n\nLooking at the style overlap, `.status-btn` already covers most of the base styling, so `.rebuild-btn` just needs to add its unique flexbox layout, alignment, gap, and font family while adjusting the font size down to 10px. Still writing styles... I need to walk through the rename flow when scroll triggers itâ€”`commitRename` runs async until the invoke call, and during that await the textarea keeps focus, then once it succeeds `cancelRename` clears the editing state and blurs the field. I'm realizing there's a potential race condition: if blur fires while the scroll-triggered `commitRename()` is suspended at the `await invoke()` step, the blur handler would call `commitRename()` again while `editing.active` is still true, causing it to also invoke the rename operation.\n\nI could add an in-progress flag to guard against this, but that introduces complexityâ€”especially since `cancelRename` would also need to reset it. Let me check what the original code already handles...\n\nactually, the existing `on:blur={commitRename}` was considered safe, and the only new risk is scroll triggering `commitRename` while the textarea still has focus. For blur to fire during the async rename, the user would need to actively click something else in those milliseconds, which is extremely unlikely. I'll skip the guard and keep it simple.\n\nNow I'm making the actual code changes...\n\nImplementing the modifications...\n\nI'm identifying the exact lines to change: updating the theme detection logic, modifying the rename cancellation behavior, removing the theme-btn class, and adding a helper function to generate sort icon SVG paths dynamically instead of hardcoding them inline. I'm realizing each column header only displays the sort icon when that column is the active sort target, and the icon direction depends on whether we're sorting ascending or descending. The `sortIconHtml` function is safe from XSS since the direction parameter is always constrained to `'asc'` or `'desc'`. Now I need to implement the function and update all four template locations where sort icons appear, then clean up the old `.rebuild-btn` styles. I see that `.rebuild-btn` has both `status-btn` and `rebuild-btn` classes, so I need to keep the overrides for `:hover` and `:disabled` since they differ from the base status button styles. The cleaned-up CSS will include the core styling properties along with these necessary state overrides.\n\nNow I'm looking at the sort icon template to identify exactly what needs to be replaced. Adding sort icons to table headers...","signature":"EsblAQpGCAsYAipAQcw2f+mTERbwFoO5EQ7tAyGapeuEwSvx/CcVoGqU6AEofgCxw602niCRGS09r+uFH8iB40vBmaq27IK44ZOSDRIMvy7X6SoV4xVhjRPMGgxIc2RuN+6CpMaeEiYiMDHNHCXtBn9VA/cp77ZZsgLmj1Yc9CsXV6cuwNz0S5Xnlk5D7QvzTjluxiFgsBzFBCqs5AEcVdhKeuzAZfSUw8YLir3X0HQVc8HqbVLxUOjVngvRFEuFSW+IWeGKFnj88LEjtsf11GGu7mb1eEba+YOgUKpvXYCr5sTnojUQBfXiSHt2Lux0ZTXBxZyxtR9UQKDzZochlbEbi43tXASr9OJ19I3/C69jr0pE/YKokD+HzWeYxtOm2SCyaErdFmgAZyPtFR2WJAI3MdCMofjLhXNdDp+a2WIsE5BYJ1ZH5JVdF2HhKrKT22YtU+wvXbTxoUbDp2zZ9RB1HknJTxeU9FwWmk7zAULFerJPHQmVP/f7A4dXQ21iN3AsO1TKe0ZpYjbZoXX9Hdl2lGJt0hQPCfQQ/cemmPgM/snAVEoHCqY8LABmW6y2r3fYQOdtNVxgwb0KpeKxRNd5vxtvB8CI0yjhnEIKv8Oqy8C01qcPToM9BHrnXAQfP2GnFPehEOfXGraekXRHoJPM7hbfFM8d6rEq9/C4wg0GpwYqpPFcZDUOLFV3nocDDm2YNeNo5He4aufR76dzCPjEAcTVMibtxhhV26FN5XV/OOl+AgfHxPH8ODnBc/mZHMe1OZZIZMgk4cd7jRsYD6fayDnm0UhRArQzNR87Z2du0e/6jw1XYK0zhXlzvNGOT6jLSPwDNM0E/DYfoJ/p5VwKYmxZXf3wCIjN/M3uP8EwgqaZV4y4RTdSfatgK5Szj58pPMY2Scz4iCxvaXJn5CLQmo3MU7lnxAXJmwar64aH8mOjcRoV+a14TqR3VCbCanFKHOVWAjJdwQtp0rQzGWBtsKTOYAGZ0/nyeNL+lE6sztRqB5U15LsIX82AK39QppSjPRGMQhI15P5XriT3G3zuxucNIm7DShiL3Gj/vPjiisfT54QEWVuQ1hTKMq8hviAqKXFyzFbcztGh+6YAGm36jgAKdwa2+BTF1zOBPUyUBsM5KG3PiKpUG6bJ4iRbsVdoyrepqi2uOEmoEq3T64B0MSOWhu1zZYSeMbZqXOmiZkT2lQlWcp5ikFEcX6FDdkX4GnAfPL7RZKo5sdSijF24V2Ctc7RcOgYb9iQjI3uy4/raV+V4KywHz+VyP4FNDR/zvmkWg2ZjtBIdxsvUTf4Ai1W4gJSrwO7AhOMEbv4OLmW2qWhYpWx8alf7UayEo0RydsCHgFp0cQ6RFROvNfK7Q2j/0X+/fqMhC3M/JnOgyB2O/AB2KFFXJ48H2WEhPJeBpXQREwHiigVo/mr7nyS65KCPnHJE/qDU4w2xj+ivVx74VRfOmQ2KZJpYD1mikKhXr7tlPyDGvxWQvO5bSGmeScDzmz+y1euH9TBg5fOgLBtZ52bNtWYh8kfSAAZBiZNmJx9xnv6EHHPNRDYygz/QmG0sIyaeER4GhCeiRkWGd25/WWaBmflqgbPTULAJRFLrTYxBBcuywY+40F2iGzFCJB91VptrC+i9OfSODqGdvhTGTr4dBt0Fj+DWASiCojqHQX6/+vrU2xywK7Xv7+/W1TgDizQXxIgNKWW3QsCmqu0jVuIJkmxVX7l21ukWPhZiUnzWsWbFpuK3d4F3ydrKG8g+cgb3xXqqE3QV6bjx8AI+2PpB4YPjH+qvpclOsIM5Klgorf6YdF0QdtpBIo1nuopqcEdc1eZRE0i0CRFuDxj8Exx9d6jWKhoLhDY04PlE49ndv/YGkPVnY5jfVb7tRYULD7WpocC7CzseOQ9vGzw1rweqMIVC3nqSbeUJDgCQFmrL1es52duylJy7qs4RPOW6VtdKJoFeAf8xtO4hw4lUVnue57csfmDUJSabULCDSXAkqgrm7DkXsKP+qGY+tZ1P8+KCjYDhcFxCwlR7yol07pJ/xsYHfhFRqufET1rSibYhI5HC2oOqL9HkkYDtNxNedGv1z9rc6i9nWATsK03Vg6A61Xetr8Tn/Dxc5bSlffokDv9TRQHGVM7JtkUWTDvcMVl4HwDHVV+CPIdd6a6HuFwXHeT95n+t53ou+a4HHNv+mfyiO0MMo5/VhpZ2/wf8T0jmhUY0Uq354rWQ7ObMAUB48gmZUVzE4TURgtqbDNA/kzlvAJHND+q+2BT7axmiE1qCVO9Ad5Xhgepzr/N6lQjw/HSuuYRxV3AQtgsCfoCxOZruqjBfl3UvdmmDz8Wpe5VP3IIrmDBC7iA2beVEBESJYctsyqU8S135kcQvstmaMygvFzjXrzkBzTBJaNIzUpqkuj/AxOW8bGlnTre1qUXxjjQdUg3+zfUEHhCEzVRv06KYSdQuz7aJQVHtdhtoVvsHwZLcmllj1RVcfm7hae6mF6zTvOMyovS1Y2WpC2CG3ZOohpjUvMt7GdSEqGiT+g0SOS/UBvC57h3Mr0Q5T/ukBKQzy8opsW4i8rW6R0ySsTgiHW0N/4YJ65Ybg1S0G9WCn6xIEjA9NyH7/c97uD9V+3z9bXXph3dqgLitkzXEILsGrl9l5iNFiWTmhnvBWLMoF9TxPoUvn0oZV4EXcK2zyxH8/3XwuLnsWnHO4VfOIJlvcZ1nZJiXGYfZNxHdLIlPGtutfhCZNsh9Eqk2xpdwnWxU0WI5ihfbFEHjtkQIgqKq6en90V5JkvcBFtID2sbmNQy5uB4DzTxLQ4r4//D90JO13bVG42jM1m6sh3rwz/JKUQSPO9l2/+3G+6Pfs8remPsIrxE4I88s1NBL4iaZho5CuCoCxG3es4evNNPzxkTiJ5ONez7TFN1WFUwt0bZGdJsYXApLSS1+OLoriMip0h0CB8Zz382g51LKVC90z+k+tsDdv0fqjQf/f52UZp6s0IKxbVUTOt4NBVubVOKlO+vA1roGWktBlQblKitywoooex9Eziwr21mkEDcoTnDTt7ADG/pBalpXe7+IlF46/I7tGXDuF1k8c/PQSGTk25pBkBT18gSWMTM0lkr8Ye6UFkVKEMr3ZTcLnmIEl4p5ZKt59uYfK6KKO8+dNDdSksRN2Z+hr98gm+VDA3E67KQwQFp8kIl+Gvpi8JmUphzQQhKv7K9yjnSVxXOJZwmbvDfl8oU8bF3TCbAk92zLG/x94p6rZXCl2C0wKwOobbNVv9fy8Loi38+BAJXx/9hJH3ACkz83yKmsyoAM8toptEypXIpYeRgp4Ga+VfKUD6jKkhNipKkSIqkeFJOzeoSRwuiVuc+QcRObLXUV6gOT2Pf/Ot9iQWeBwOAzRQmAJ6nrXGmbvRpWddCVNw3LbLkQwgs0Lg8s5l0ciqO6WuFolcicR0O9M4gvnIzoalyYhyDdLaD9LIAx4ado/pM5MJHcPHRb6z5qTwTZYNqH0kqA0DJcl/ZpTbrdknU9jEuRpLQHtcKE2ABx1B4N6D9YJj4FBaVhHGJDrqRiU7RvjQ0O/joJ+DqH8+NHq/40qEreFDYMJyb6f3G24Tm5xfk2Pl9k02DaYzQcY45NYN0EOYajKE/4BRuJmzozfOW6PIqINZXU2TZubhlbDHDWKZVQkoNheAb6zLwvHT0G0f3nMUsn0eLsxviforbuj877Uu829cR2+c8UoLdwVc8yA5nQy/d5kAqTYT3UJvzoyhuD5d8tY+eyBQlVSkWdsSDigB8NxHcGZkYuIbeDhZPOsci/mSXHjDMimn5kpD81q+lTz2MYwisFg5kukkag9krKDBro6KHFHIC1/T24ZCPNBLNZB5YRXMiO/qHUBbGgLIx9ytE06wLchzaYpooOTabYRIV4Tv7fmoKFXMBZUeyTKtKt8nqal9z2iqNYERT+WDqC+BALe/8HqlOWPipo3FIbLOPYa2klwh2tn3LIsCuAYaT3v6KWAYyFs2Wcdyq5OmMuiCgmW1OAOtc+eRbiw6PG5Kmee9fx1Z0HKE4bjGq3czYa3tde/bfCO8HKFvqIy7h60v+NxXV30IPiCmX37uou7RvgVmNSoZe6Xx+KrVyIrIKeasSFbBRUfCb53tv9jD3QJ20aesbpo9aYxywUVW1yy+mnBUdAwkz0nWfjlQrFFDoZs58v9CW9JrI6kpHzuIkbJK/ZeCT2fbu4DS4G8K1Bj1vQhNq5uWJ0ejKUKmNuQL15IUGIPevWj08FCj7B2PO/tKpwdJofzbrKG9jnjtpHUP3SNxNeKO4ifIEZyqlPwpLJBiPd5gRF4GWkY8f6SBybtQtK779x2tdY1BiV8S2W2FjF3KFNkv+52OU9dsIPVfGXJW9Jb4G6hiEQ+GdBa0uYhR6v6wDN/rlXS8d3I2MqQj4nFaf48rUeq94Mcbm9TJxPwHUa3oS32LujZnxEhwDQgPihzWsB4M0j+g/BGuGGa9EYjAbfLMWHi+0K87V5hu9gG+fHZc7xHywHy38UV2rkEtZG8rUPfTFZyDVNR6EJ0xU6vX9B/XuMyNWB2lWS5G9aRRfPjvYFLBE0T3oHqXKERx3GP+s+Rcdce9ub0tTm5c8osSo6WijeVi2rVR56hz8wuxujGj7ZfJAjPjrpburS0NL5xsBPunUzWXZi5y89H5BXTLG1FwiXsCgAeRPa2HMqm0QDvsUtvHmNP/l5J7oeHE9uT+s9Tlg1AbKwy8ICBPsxlEC+mkMlqasuI7NNK1HWavJpH7/fp1Oy+wJ/xrxUiWRit4ax1lpPCW/u8KVjOheNTee77QUxlHjfbie3fZMOkOW8NRTl9+PLbD1GB8s6yG8NdcpaI7ol0TFlo82Fk4A2CPz2ZDkbRToM0zgeVByk/JvshSxxLgCbOl+Wn7JJ2SsA2yNJXlueB0KULsJNx0lZveNn2QZ5VZoXpRSaiRuEcpsyIbg4xHED6g+2aJEz+C2cbRNEJOE+3BrBaD/9ZA6kCluyWuuVF6BnEvRMAtkoFtTExNzIHKm5ssovqxNQtSV6fzmC61bpuhzUlKgmfkhDadDcureRkPI0M2MPuE9kdLADoL8iPr7Nzi8ZrBEjxpSEPbI11/RWJUJ2m1D+qfUgP5Jn+q6zLR8RANhU1StT/xxCXEWdsqxE2saEymwUl4d05FpLZaP2+zdY5MRA0nAlFtmOpNrSpSeWNgkFetxc1zQkZ5pIYiB3AErl6PR+e4d7kSZ3uxCVow4S5v/fdSMb2y6I+niZtd/uGgdQXV79A9cJE10GnaILl05ZHgIONHHbczbpsj8xzD4t5EKZqsgUBW46U7MAOeoomxWk4h4twzD5dYbyYcxPqDnuzImJgBzKH+xonjX+yHZRkitFhSfyshN+Pf6R+/9X5SOJCcevF41a/LoUfq5jpBUfr89EUFkId7qpJYculwNzgKTcToWBl0/TRkYIls0jWe92TyivZTgHkVUcyvO5NUrCeeszFvEC73/TJEOg1BntrL7GCHNGnvUOghlZEQVjaDf56y54NzWtk2vNo8JiAbb6uEBUzrNYUKzQhAmQvwCkmBN5OLtT46YRdeIDwcr4nRYxukiXekB1HUatuM1xh6WVvqZ8IvE9eTcMGrQsVA5gr898Pem+3llZav7qVtPd0bzf+pUy8NqjTUObGzi3uNYhX/kB3rWVi8r1/n81AbwV5HScb2VpQKkFM2rlmUiZdV5dfieH6U5Ps9Vf4r0DOwgfEia7G7JgUF8ws1yExRE0zhZL9/6yMviq78Q3cePVmrkHFdd1lYxSha02KK/Ai3qOzHyGF8SdU1/FCo0uR/PjRsDJBAHNj+KD/yJ6l6oJlgIplsuLeyieIPVYFip8A2k/Ao+kBybZla4Om7yqLh9JyQ1AZjA8aIeDoJx6HxgYR8I71rscWfB14pzO81Q/V4GmvO4RByPzrhb5sdlMWfJn6RZBvGR9LndHZYQ3x655mx6yGPvSvX6fRLQ+RWXKU5jyqunmAGQ4OtCYyQWFaQfxV5UGO/DGmFI+5vFMvCBMRreqswev4eyVqgk4uRbNJXCYSPnUywNfM/hNclb5J2UTyfHIYTyJxPJxkja1RGY4m2iwBqLrubxXrk/bD4TR8U+DfvXjwX5ysRlArcoPPwBoMhUKZDPrihpY6MKo/I+NCHLelf1O2KHv7ejPlH6a/pWcoYyg/rXawLYNmEu72GVhOkrYlNxd3MGtQPcEl3Ou3mG/FrMQ8g9cM0X7ZFHZGSYE7wOcmYn0orKkSLwtvsyWvUmtAO3zdMmbX76vzxz6ZTGeSBAhS3I+WXqFII5oE4UEgoJGeeOWEu+cYN33MNGp77RCR7BgQlPjo7jk+YX0edTjQUIju8lMBRN0fggthg8Gtc6pRJP4E0QjBjFTf+6kE4q0IxJb8lu1/h4UrxFe9X2oTue7wyu/JUmCTkuqZgGlc8P0Ld2sZgK8NDd6vqI89qI+NG0/AG/SgeYdgCZFh6LOc6Z5hXNkQqTNogNJ7h36UgC8tUDfxq3wa4RG/ZIBJVgs7tGibyvUkivMQEJq/wm0dAtlaV3XccytU4DlCF1nc3bPeun5tu6XAg/H5Ys2GNWc3R7X/yYXQkokOe5lKA1DgrhO3Un1L9fDoWCDWg8dgfC8A+XLUF0H4VrXcFnH+xUEJlKjYk46AYtpuiMfim8NnBlhf0XyYc95UB3yquY0Wt264k7t1lKoqncm07diaBM4E+cAGd14a0/R5s22D/5Z/lmCJDSOTp4jXsUzRqv8f9UkktKjNYOZ//TicpSITCHRpbfgtFXuAFQr+bheF80uKvmoAy6y6Mw7jTueWtstuGKyW0CTb1CjLdXdrEuacrOQH2iHKqnW3CI3O+MF7eBYPnv0Ic/Row95OLqeln0NQVFWemvsyEFso5wO8l1+Gid311VOPm5oFK7wmUGNFNRv0PnsuE2+C2qSDHqQ6Fy2yPUATVwArza29a0FXfIBlEJWX5WvpBawntvNDX9YIPh/0RbrS7+mmUUoFCNQr9f9Im7DfpYGwr0T/6Q3CTX1LYFHny2iRVR9JW/3O8h1MkkxB5GjhAyqV0TrjPZ019s67qbHD+gNYW4Qo9CIlHkyK52Fm70EggVjWxEmDdzCp6NIowtsgj5e0LKTLPR5DmGAyQA2JNdOrcdaCmlPJNfc4v4OpREW2A5cg+kKXtV4VHNNHc7M/AqfJt8MtkR1PV1N8zfqVVT2i3zWOIzVjsx4ofFSMF7r5QKM+uqA36nKHmlGu1u0e4RS36sajUnV6ij6BHnIqPWTAsQMCDXtcJXcaBHLaRl+H0TsWbPcbKMaT8wcZL/mybwTSFREBrut7wmrMcOrSoeW3rdN6OOayNpfPGyzcstIDRl/jCzxism/dFFRNryDu2YlkByfvJ82NW5qIf5RHK2g1nMb3ppHaKBD+kLG6cS4jQUjuAvD/x9ENhKDJyqYlc1fTtywbA4YXKfUyzfXSmC+83UKs2Ziysry3WjJIJB5GfSTue/JgGRuMmD1EVq6q5GnfnjCcU6Ag+Y5733r6o5VdYLlmUyctHg+qRIX38Es541hYrYwolkYx6XJ8BLK1fFgc9AUzo7+hon+2Kz9jU+H5rFZNXzEoXjLKrg6ZAxyFe1bFAzTJu17/r2Y4j+j0GiYhKjwmex4Yq+yJyG3QoN3nmrgUKmXJVkXFjk6Jeny4vEKTbkz/j/CNQU0yUXahqiIJmBcIaSeji8f8avAP/MEX6wKOj8ZCJaEeIOOnnwP0YxBGz+33ap1zTqowMV5Pc0Hblw2Vp5vn5yGifKAMm2cKIvWDAPGFL+jHrZ8e81ROjeMhr5TCrKXWC/UZWx+piQxw1UiFW8hdFwUQQhcbMzj87FsZtAPToxPB8WU883LVZZS0DbOmvxWtx7qCBEkCiGDxCr+HqVCfsEqfLlgFPDaYvFpQ/Fmigk1auIues4mr8SLHwKJA2t3o789UKug8jt5aN7qluw7ruB+DFqy8e9/lk8rTYkRM2Tkto5IaLd1jioAbkg0EUhH6UhfhdW5Z1qLW0kOwevJueg571p6HZtpz4lqT1FMj591SNw+LNTOwjv+vv+lsTOEdNdUvL2xMScGJhl807gSZRxzOvQZbAQ5Td78R8SkHb9Z28JouZ6vOtBSlW6BrXluMz/6xp9q8lsooGmJ6hO4E6hEPkD4rHDtUy95LcL1t11za2n1hikmi8IUd9ppCYpUuZW9KHtghtNua7CyenjqE+Z8Ba02M68ownCP7iWK/Wu15Ej+OQuOJNdhQaCSQKmVZVMgiHf5gEVbsiSSpQNt+KoZu1aaE5xUhoUyxE33GAKsV4hJRr25psR0MDv3NysnL60/Sxm14++0gvUKKSbkjS7lMWFvLMnaxv7fMejU2Z+EdEGCLIxfNq0PAE5/JPkVMgVwFOBxW0SscNhal0jTDpbld4+pXN37ZvD3PvnvklXKR9/ZwdNKYuO0RDeVUlqFK1ugpiU12OybWqd3CgcUdgPBErwqVxitGDkHinEhSe7hg+FzyyFpPV1CsavluhHNcbtrqZBCKmRCRi787SyAewyDAEOaCFN88ovbOFfOvzaTEn3ee8TUtK6jG/UGbrKotiCL9aMwEuOyspgnRMconxtCq0QjWiJog4JeiLP2zYkbw5+SG5AAH9Dmvk5sypn+xycZPiXbmVO3YN8CN+cZLdp3JiM67cNIMet3TqXee1xk1TqIm/qF4pMXeDkaf05kwGjMhbgzqzL4NfGDM30Y0+WkPFElYCxUAaZZTv/TYYaXuWeNaDCIvxAbSpNpaEb+NJTtYUl+QyBGjclUYaPE5RouW+d4iKQUncTLuzmgN+WEkdvGDnNjzAd+kppnANg1fgdKCPtsTbVM++169vXYXS04n7GPkLdZUVi7wJ0hOFbrNJmAf0QwKuofvI6M/EUCR0GvC2Ue+xoNxCUI9B3F4unu5IPyOZztDMz/fY44807cPoNhAGfixFtKz/2GWe0wEKa57h5i9hbj+Ukf4dGn1y9a/FkzlBEROZkwPbc97yXImV8TL1GqP3YERSDRnBwWHY/vU9RiN2E0yNKUq9puuKuBIBqf11bLRYICctPWmI9mOJWwXCyulIiVD+7g3e9hBOKtbjD7wXQTO3iwTb/tV63CvFji2E8ZtCiHA93lSE2uIbc6NgetmZ2uiWf7PQRwF9nPC/wxH1NInJeK3opsY54nLi58NbDrKrnmjIXgq18hsRKZnKJCil1GkhxtIm3yoHAsgwK7yzJKqpCL/0hwfCtrCnCREEX3gwCpFcs54DYm6EDV0h97MiW6wzNT6VHqnM3r02ozFjxmukxy1wlgi6HWsz8ZthsWAArL7lWIzXutaNQphUKAbVW57521zOC2WvAl+qvVGz1ysbtKX/03l4aRiZ4eHxt81Dry56I7dIb15AIuFTu5CB9A6nU7/fcC8wDR2p20RIWHuBFgqSM89XMparrB7SDpz90o2PRqQlYIy408hrQXJ0ZlM1MoX/ZTchaM1kQpImk6WMJfXS9bpZC5XC6nIyuxhKrlpaRcTxqk6RfRnoZxvNFkXaTWruGHOuuHcRMS78Hlm8QrTtR6eXR1GYpA2Fg2ir0IZVKpOCNfADUVd4Ba4+uMS+Kct/l9IHJjLZTWWO+dbvYylyAK9sBqxoveBWJUIU1mA0XKU8Qi2WMqHdHyXREl7Nyy/U6j9F3BsdVTThcWoIZRLWZk/8nse0c6WcUpXmROSLUInHqJt/9dD+lsRsVW7EINTv5TnH3av8c8aWyN+khvsDEyzU1xNYWNqpCEo92pHCA6J52HW0UeDJ+/8i7PAwm7REPc4lhHxmrBdd6wW1QmePgi51YR/kWeAgaSUNpzlqGV3fS0AVk/6DvMGF1Ej4o8k5+7NP2prlUJzQ/1uyL/OdCkZkOlTEyH567obZ6VZUM1VhJGvuDFlLnZ+m9mzr6bNRFmdWdCjJT2TyUviLI0k1CaMG7KuE5M6fJUEByQmBNAbqjiFrWxfsR0KBb9lmYlSVcBraideb+5lXR8oRvZ4CBGY8vcUi6TMDcXvLVmX1K677EhLNR0Cclmc9+NJtivlQ9vjReNOUYLapMjULvW6hcuuDLkQ/YYlcO6OlDXEzyo/pL8iM9LuCpDeSwFOiJpAdLLLRnEp9itmbP0hq2id6/wk3cyCGDEtGesA8Tt13oIweKHbghQc1BCIe4KYOcdVVXU6+Y9hT27v0b14oVdiMUwV7nGPPK3JPk22WTHwkyxinZov+WPE+QWaznYhhL82HP5SWtQkV2WaM94qo13k0u4Qmtclty0+3zcBqEWY38mQ7deMTAvqHaOn+JZ203X7XEO/0aOlBnScN9nL3sFXMDGQBTlcChzQFnyXgcw+yy2HBSidgICxxpeyvLCLtI0klpvaA+p1X47oAC/WHdd97vZ7/RLs0US+OMuxp9MZxrTytOXG/SBEzYW2aRjNeHGYcXAJbjPWY7BjzUUuZZiWFETNRy/RSR8hToI8UtuXtrNtcR8F3Xd4km0Maba7r2EUoQiub6ipGbWHrUd0Qj46ky6eIyjEpipwjO7dE8ydHp9/fFZS2f2fU1PHelholH6PRglGgTS1Fo+Crltgov/hTQ2u3eQcn1vUwdDBvcAB6TUSea6+J1mTvboWakc4XCG3hz7DwFO60GtxzdUnKNKe0dv9C+/5bSXx9JW4krAGHXgkMOwku86AVV1NtZECXuY8gHVdovWOy/Cd94hTgfL0Ig57sKtMooPFxYd9nr+UnUU3jdVVHN7r5JNo/KQJtmKtWiG88+AKD93E3ZX2Tyxl0ElheLeGvpFbe8FXRZyLfiPEgxStqoagHjVYMOvBJhhGCDN+B7dEYnnoRBeKJxlOGQmeXcqG/GDPm/7O2xPcFJV18IXi7Dl18bZcFVhBoEwdHlf1KwdW/CBOrwdBLiMJ4U0PoGjKYLePhf+bGmCAv6e/HosWEUwYpmdhumEympYG5+faXTtoNctYHWtk/qhJ9f62eosi8F3ruWdR84W4k4rhSUD/Tk+rZ4o40uJ+S+649oiQowuIzr89KuRjowihxG91I47hFTOCLtxOYJa78GpGf1AZVDGgDThsvIq7DQpzgczLbThS1thAlmxxe6F6Axrq30QLljKQaQ8De/mZyr5A4BjHReAHq7hWZav5V5CYiK0kJxmirFtQrJl6uP0sSHbVvrOdHQOUDa22IKEyyb+gccRWFzSHf+Atkv4YS/r0H2TUopjEkEqlaPgxjm3199TOsrEWhbRSuuve2ZrYSXZu39/FKAT9VJBWZIKv8lMDYbyQ654+Y7mqDPTDErT0zkslFJgkBzxqparA7/lUtlToud4wBHuZF4n7o8Idhpp2GhHi816VLrOJeacBDPz+F1rssuh3q7EOeMX+CkBUWWmT5dGXefUT9Eco2QeXYAXzj7NdWEDqI11IrQ44H19fdgPIKx8y2MB+1C0PUeeLl0N/eCoJzdA709d/mANAptF4xhrkQcL/fFCfJ8d5orCKKW7x8WUINDHQIPD56JRppPTFfk3B1fG5wHJkT+oShOEI2njCHCqmJe3G409nmnJxd3V56zp2e22C3hz3NgzOuiPPqFlS6HsuDFzW0jzIPQCJJ9dowjJQ22SYoDOnwUoSknAHMHzaoj71pdZocUX1QcIerz8asuwfHPMnYtMqyILtX9U75BC4VvEfDMbu+93/c4n5aLwf6em60L9NJmsIsMdEzIxIpvmhohBdAbX1w4lxIti+NmNnPVmAA1ElBUuuttYgLgauv7jdY621HSE/sjSny+Ot/2aMDAGr1Jq9vOnIWgbgeqOLthKDwxqpA0gHjTfeQOCbLFjxR96anXGvwIPwU9DWGOjvuVBhCyPy0m+dqEctdFsT7WgFWmkMOhvxIRsg4hGJiRpZ5mIF4ypNMbc0ZszLNiQTs7ZnxbntE0NvuYj7KN4wTBrqLGe7vLBW2wdPg+uBq+RTURPN755HcMI8QXRkptrTQ5TNjq/NAUKifSWXJ4ksfKcVorhE5NW8ghyXsAF1oMf3FTkHRycMVz1Mr6MJ4ri7pfh3GX5qNJ+8Hblx2TXfuhSUWojGzteNmauQpchQWp61LK/J+HGdgntC+IMlxBlQtJ+Sysfd9rDq2CU/r7zJfC1jluB3B1qgcZg41wqO/C7cVQw09hALCxLyZQQMobQecMJ6wBwNVOFQ6vNqgcSwB/d4H6tq7vGZ9hvMfvS9wiApcVZTbLCvbntMLN04RPZirDnsXJbJWUQNBLu/40G47JEF2mBXmAMhTprgLufAw24myzNlxT4wg33FpqM1o75cIbX6VNeIHO5ldjwD4PTY3oXM9iaH8Ww7OtE0XQG2J2cOI7uX8SVV8p9QpkFWJ5qrA8JuYujdahp0O7P5XC6zK83EQdxLstdiFPEHwcDEG0vVpiOnRZWQ+/Xv9VLR8+BK/x3UuUkYtYqgaHS2ungRjtl8dBTC0kOyTMk8DKSmZLcIz75Dt3y5xL1l7/FqHd+kieX+ynd9T+sqk5Ud68RjGi34nBvSgcNfgW9arwRm6jl4IeMEm8rONLpQ+fOT0YhUj4QLTnX/3rLxIcRp1gP5utQmPhPASiYrolMnkbiezS5zHvyh6LTFjRV0NK7AqYLVS9odb7QJ/3hdqjOoLT8pWtMXfcaijGBfL8w6rScKQptZ6kq97wdUo+dhj+hYLPERv3mc3tAYrLtZpPoG7jcrWusU0LCTAFNDsKtfuPjIr6BXv/4mZ1aGmiBxWs8UU5XJMxr6ylqVzf4xbVYR0Gil/hlv9kZw08wxPUzBXLbUEHETPfCOxSWl68HNtDTV49EcmcUAUv4kODo1ae5e2hE+6ZA+x2mvMCaU070okIw0yhrbq3Dy0p8bz5HAQl15T34TXBAS/YrB3BjAQEUpO9IIcwThwmtauryfkM2l399CHjLWl+vGQCEZ09TvWAERd3731M9SALCXRwb/GyYNvfLoPsstUyDBxwpEMKd0Za6UHuyDvNj93JsyL1g0nhqf7gLQJdZXpSYI/JvyszgC7eyQVrvsUrULGtvKD8mGiTNBtCo930JIYILPgi1umNtZ2rtiqL9pB6FM1PNdBANQLPbOW1s7ggwMZ+dsCdwgBd5Ex4QVHorLKCElEVbvIHGU3U545twt637QWJ5kgzC7XVIlKvGvnMNHitjirivh5HxHRNhlC9aM7/3e4rEX13R40tJe4W8L/xbosemPUQqHxItSK7gR+Q9bWDLmkqa/TzoLgmxzc4jTO2E1jSTU7dJg3HGSOWMI4qE51/uSRTDFJUj/hWz9OXq2jesjW/qp3EiVtayqvGHmexkKfZA1iZ0elxyz3HVimxzt3hdC3aAfKxs04q/yf8/WpAF8nHKSPUS4F+FmVraxrvvr+EWMCCnmWwmhRzb4CqL0MNP/sKuW5KjDpgX5hMtT3rxE8d3s8TcM8w9z46dA3mGzAcf4N9D6eOMnFG/kokayJhPmkkenDjsiWR7EkCwzk+AJLOJGeU5VduL7qWF5+HnaZO9jyeBzCXL8EWZ+yoVASC6BjkSu+WrDJK1pKNl5wW8e4KU6hpGaiQ7gRvzyP06OPG2rfw9EsCq+9Qh9FuwD4LAWatDMPz/V+wuG9J7kn0pm06PXqqPMbU4GU22yeVR6uf92Spd/MQid7GM6URB9wiCGhlznWkczz0fR7UJ9T0S9gHK+z6Ip8HnOd76pbdLH7ZOdTZhjNyJA70OF8hDSa9RS8YGYKz+yuk61NVcDHkEUqZFqM9qQBl9t7fijqcMjw1R+pvitLcDs8p2Y7CbB3e2RShR9L9CKgSnbkanozA8BSDqzLsZnqD+3XTtwx6E7jtO0WFDx098WbqPC4tXQ4iGiICn4R7QmEqIzGdU8t5mxO/Jy8RifjsiNX1l40+j/27il7ffL0vLlTxBO2g6bkPebQEtnVvKQBGVQ8IS2z6Z31ox4q3fyh0pwW5bFKNOuMyhslgJOi1NVZ9VBr73wdbW9JpTv6aftEJaPyqIeP7595gqJNQ5nCmSoGiVAMtSpGIiV0QDCzpBJ0CnnFOTpBp0EHnia0guS246hZ7zsRoSIjMKSM9YMBrtItrc9PV9GxOgsvuC7l5SMGxwVl8jkQKEJ5fpFD6gPy+ULRTJDbv97N90s9RPyOgP2jT9kQx2xiV1ZuknwAykT8GXjo12jP4U5AO52Hk9Qna0djkUDCJEQuttFx+nbtRisdi3Kof7qI6kaiEWFgGZgsls616tg9BTeEdYA0imNB7nck+Qlod7J/f/NwjVYP3pVcAOQxAru5dKFmxHc6o+FwM8eVa/78f8HEmQC8vtLYPrLcm/QtN184ZYaKKrfSHI937tjrV+dmaC5MbP4k/0DogHR3CaEOHJD7meZH8NZOWYHnAF49IECNuLBRhpwg8svdcpEcPRprOVO//yQVs/1UgPLj6QftCnUnobE7fjYy7toV44jRqj+R8sAOpYLR2nN+DqAJzzipBqP8Fa+jp4l2j8nENcdPY2gUzMk9K/LzGmo5iGmGb0G7dCNbKo0boQx7n3mddmh20MafUUvcHZGvL1Dx+MjV+FymLLg3xIUCkFQ48ADtr7bQhDj5JE7r521Cd9dhwwBb9VkCAR5W2XmIRl4tg77/ic+Zppv4PuB/1/YqLn3JoLzjQjP7ag4iaiMG+S3yP2w2K869HyZIONfEiL//qAK+jtZvEy/qGAPiWpAVFrIrJXswYJnHDLr92qYYMC4HM0OjwZA372L9cApb2OPoBzavZ5zusda8SbZIm1he0CPlrhPR9osZnmZKFBcmY875ZWFxFvY7xRs7OhSV2DRmAeFS5SSDv7N2FyoALE7+3VVNRdV9+KhKTwJiLRx1UQBsaltFc3D6kli3NI0Oi8fr4jMX3dJYvbpFcOvMgtLvE5SxglsHsNybLXBqeX/mCmFpjyYI7ajq5/Nie49B95MPK00osoVY5SOCWZizEJHgts/dw7yXNkHUTzGr64dG/mrjHXwFJMFjxg4RtAOsZfBuzfRKn3i0dJNfKBMgENKgfwg+YO9Sc7GvmklupltjdnXcMqlVEOmxDdHDxhEtLcTnz5o8kskPEZ2SUQABgpVmZ31PVzrqQdmEnolfaR+Sm1S8u+cK8tL3tOTcwzMU/ZKi9xU0g4bk1+0em9/QXy2MTlIE4ZWcOrWhMUAmeuFgdgN74aJ51+y2BhEkVdDKz/bsBEG5lapBUyW27QYeet0d+wU/HHzGw6lT9NsvXKUkL0X/BvyzHls4tBH729/yMPhiU67BSnhkMMTCEN4eZJnX/XuozsW8ep0hi2JYEqYYTrTzR8YJkPZ8Lw7w76aHIM8Nvu4z1GN/gqeyBvuF7gci05MQvBvbp9BTg+2IpbNkB9pntsEbSiQDCb+73/OAtMif65i8yMlXrJ4pPacWWEm0f4LM4WyLJwhrjyk8navpNHPJuSsRyIoiVhBH+XFALVnwzGaB8Hp3FUKn8XHYsfrhimPjd0ncsKBAJ9CYxnz299VNqjP+5lhubDzYDY5nbxJFvn9At6idyN/ILDo8mBPWWNYL+ISf78I5bK2BzDYIRBw7xBD7axjWrf63stce9QvfwCphQzXkU1w9bVUUHmZ5HWf88zIa+X6rEPCSi7MEUr4DaJld9BwDmzur0TzPe6+e5qYlyWxMfhpYGEMAkfqpDoIpOnAgJ4e4bz55SkoSYtITbJTa0ygqlgkKCq0cLUjn6wMbRZukgx267RpDvr0kckhK8+LtqDWaKI1eTHKcXOrOF5ck3dp2acxDnMrKtLSeLWTKdE597ahzdFZmLPNRE7CIgt10184EKKRXWJQSc/1NgDKDds/o/UZF/RVrq7cCsWPE+UN2PUzLtBMs1lnHSYpl43zLrvHfSYYDAcxSTFIZ2CQHwU1IomWTr5tLSaZ0Jp2GmwC1mCRe4qfKDBhCKzhy0WaGIyCief35prQ+3iDTZaYqXAuCefoseg5lP6IrfSjhu1FRgo6P4kXNnuaAF4uO8Udq7HnWMzFO77k0rxwWRkT7RtvYcvgEzUTgEPOe6XKUQxZqx9XL//iYxySXTgnQzo7FUGQ4ApU6yzIv5loiiixZaxT5p+885RJVfdTl5Bw5XAQG0yuO6QszQr3pRD9z/MtF1NqHSmd2AMsHF8xE/187lMtzcsJnS/8ghBrAGRPh7y8OJiBEAQ6h3ZoPcsR0RNK5a03ZzfUnFqmPnqKvU5rpyPem317XJNQFD6mOV71ni4ZLGF4eky1MlM4dzYew5TT1llkwss3WAPveooFjLqsMIvJJPFzXsq3QHo6njmI2k4QjBn4ATpnjeETe4jb4vG2m+BoW1RtTcgQup7dlOeWt/TwwRfG9H+/z5/7tG1BWB+JRW/NMczP3FlWjoYXmOSaPqwf0wjI2HTWquHGlJL7J0Ij7YQDqVkVGducM1UB6Ro5j35TEHHLmdtAORjmkoZNFPzLO3SSNxNRz85E+rDI2+4PYaSLHLyanhLrjYMQQVROq8j1SjtCUgcP9njMmgU4u/MsFxLsOkPviByQKQQUQADrX49tQFH9ML40SSy0r+83ZMLlNJXA4XCxYNiGntVltG8Ag0i5I4uUJR3VxcJ7cD14xkawPKGXYSpwEe9M4vEl/xWjlql2EoUoTAauLNGa9C40/b5eOXrppNHiKHt3w+IXs4LQNCxPowiuCh1K3VIGusPiHXgFGgIGQS4LZeHcF2KkzCPfIVnf90IEcBkAl1Qgnj3vqjXUoyHoAI8JuIKNnoq2CWJLhth/nqfA4o2jGfBBmC+vifHkWdbgu7jZF7Ln2idqQVqQy07VeJCg6G6ohnmwhzEyHsCd+8RKjpzgDTc+T5o8PCZD+96dNzNXb2XAM6RJ2HtY8EBfmsWyWnwfidIu0FRjib0yuhMBPqigm4sfZlYtHU9Vnnzl6THBoA+iFnAMbbs3hc2QD4s7J8TK6IkOaRk8ZXGQxJWILqZpDE70isB9/EFTelCJpCfdkT25Me5/bRJkvOLTgqlXGKNq54mStNBuwSyeIHfh9MwoknkjcX4ZwjY9OoBjzgBHJmQWVVJKg1Oqij8l208bObWqDLglhb4P+kXJoGjfhFSRzZzXco7zSiBYMqWDaLO5JuOy9k9QJXjbhlb/jpae5LBaGSuoOICpKs+oAhZjykTfLVaMrKgFp/PfA4odrR3roIFf7XmjwDRuHQpYKTDp/czSCEB3Oy8to+ZxkAK/aGe4Hx1m1GH7XcAlbsP0dvVO73uWU9rrYS75pmLLXJK8wSKWR9jBGuawulGVaWlYfk9ahMUq4twU8F8MYWWWtM3VVlAxgy0yFEF7ogTar63vQqfzJca/qAJ9WnZ88ozhBQ3jZ0JC1FH3o3Xz/uA2Rzw4YC0Z5KbgRB7HvFvqaV9/QPC+CdiXsaItBtVnsVpCM0dM/zLc6Zy1IU662NKZ6fwstOKCvgKizVHU9pb93VUddyPF67+HQIl/Zjrd/UcmOoSEDYlIckksbwDExrwoO8f+wLj8QrNFhTCEzfCrhPG/HzhOuvQJwJtg1L8iYUvYrz/YMOLQzYECYyxgEwwrkvouSxz4HzutPSXnDEogxSsyCJPmiS3ziCO50YN7wkxIDnNmk8XMfAthmS58kUrBz2t+kKKjBDzumMkSOc36uf1EhpxwhNXrc4uu77xJVWLSh16wh6XlxBWLaFUDoNxK8JO5n/dkW14+o/YBJJtPBcssUxRG0hu4V7Hzx55aZMlADALKjSBI9Re85eUmC/7NQQP/il7z2j0wbuMVGqElqytUOisiKeFAH1rt5IXG4rTnZmIerz5Q23IT/fXHSn6qPBMwTUpCYCa67bUJOxP4dmsvYn0O0WABGqGHQTijyuU4JHiwU/9uOzDVbfXsiT6aWzYy40hUbGUv1Oj4C7GqDC4tm8h9coL303IXIF0ftQkvIsNUU4UB0a0C68/bezAtyRp8jHQ9B1hC2M9CIyBEVN9P7RmifcoHNpCdPqnMXpw9gTfEDo+52Y3o0sF6AV0Wyqk59acKt5S6V/vvQSu2CUP74KSDPwchg2oQ6+8C+HBXs4yeWQjm3fedDf3KibHfn8uM2SEfeBaf+UzugyLVMqDvFpKCA5s7nU3eR8LI4cbum4k1jXqVZPCQNnL5rEB0zYeREkB6qNs2OjVATPwl0MSCOItahFJaLR24TGeZ/XUYzcsBFvGsaoswQ5cPl3SLrLEkkCz1Ayuk5jbkwnOdIMaxAYWReTgSjsoQB2EBaxh9B8RDvpfea18nUm6xnno3MfXFoayORsgJWcHKpEeNurLW2NQ3yo4t71ikSqbNALfQux0tbFEQEvXMBkmevZAz/jBkCcKblfvsAzoGHBcV6Nq9j2Mi3TO+/qn11HVqqYHE+36femXovWUuNZLTfG/0nbgF6Uj0qTtymatDhG2Um2bJIt/X09/Ec0zKV54TolROZSFAHVf6uD7blDcwsMVyDLeUG7z1s9Uz/f5UT0do68zObGbbeLpTluzvtzhvQUqVqNM+qJZW/v2Eb7WkEHrtsBPHovTkAbW9+QWUJozSKLCwLK/L/HQf3bMaCkWrkcTKCDhlMouEwKHVR0kztMW7V+OoS9qrY55JwTmvthMF/4AAfab4DxHoabQPy9tHD0Qj3ZeQVwGWvvmidqIXK0NhjX/kDJ6J/C3gfOP1APMYXHAQYWOM7fO7vAa3glq/rGzYnLW++5xrWzaRllHucFIG5SJMrHnTryK3OjKvRysP982Zyvf2+S+1tgUghXcIMdsJuiewK17zzv7bqPeF1Iriv/orgcr3aoD/4Tz0+9s3S00NPr5BcqhXeTIJqcIYuPaMHaCChgGbINPADCCYjjVh5v79AtA6qQ8mCjNippyETMouTSTDTJYrh8QCNn1FRK+U6e5Dltv+dZiCWUCn4An1mEv347/rxXcBU+3fs3ajHResaVQh+2tHxKSoxtE/6M08Z3+np9HLZ4MVSt5s9PnQC+3Mq7ae24K4P6Ie1tKAKn9CgrBMAdElbi8OkqCCKdFkSuTXvREm16CM1zunyF/VFyYJ/23gXgh8N+cYBq7J3ASLXPFrYcRHYGQ0WzFyNlNGcF46/KlirAJ6mjUKh0MbZmRD4AsnCP92vYTYswxJNSp1NAzamGyvCog13inlpT/ZlOm5FBesKQFRCldmGODvLu2yMqSz9SJvPpgiCmFHmOGIWtVTl1O2BQmTgYLZYHPEouDj+r2S1ciTNToO1Uuy7FGA6mpE8VxYOUrN396/REi3AFDX2VnYnKKuH3UtSxgTd1SNlrOoMmFqQ6Cd8sOJeJd4zPfPplRSeLJR8eAklqHwufu/hoXMb+6DbhZJ7hAQb5zwGAS7PQ38owzruzzBzOx82pcXg3Lg5z9xkS0pi25xzV6/qT8FDdST5FuAU5X8S0qDSdJvgv2NL6peaRzqBCAXZps2XYXbxhTSLl6GGj8NblWhLAXQUBtKhERBKtihyjLz1THbcq93KhC0d3tcySTKfi/GVWygNDqgi0QIZrJwo52c//qr4qXBLmum8ePqvfuue8R4vCGsipiK8hSfBp+FUgJ8QFiXKGgkiHVvocBBZbu/xdT8d96rEGURDzgNAL8D6txE4r/Z8Yhv9FzUi4Xo3RvljEcGwVFoBI1q3HIreDmdwoHKIzzq/6sN/I1WeyBk2qr/T8nyOZiqrvnFpBGJOULs3FQ9DtMzDvQNN4LMwhrzQJoWzfScUVAJkSbC+Hx1Uc9dYuINBCTgqg+TpzQriAIT9EIKkvXoS/1TBIC956Z6fVpdo4UBP4Mkpw/YDqmYUjT/dSB7D5ObRGNRxaAd3G8nqKkac43ITlpXz4Nc7KUoR6hqRmwj35p81d2tnH04wuUpwaY8wRi55id5R+L02Ysh8uzuO3zLgcANdhIX6U8u8S/UtlD9u/p4AlHitPwECB3YHADgQHF1Gy2aHxUVdi1/kH8WkXP3/HUSLszNhveWdvIf9gYxwJwkeQEPwTrwRBzoL+2ZnITEukUyh8v1csR2nuCoGxT+bYS6b9Vq5DCDVzXm4RBXbewqntWBrB6ap4a7snYBEcldSslHD1OAthzDknumBXwmz6iNZ5m+law9/Md8e3R24AIBR5oOC26Ytg9KpygAtjFtAwfbagTH7nCejtZoy+WiY9OJSqG2mL0BOsVs+WR4fVVXZKT0VtC0KIas62DToLzr9YlPzuOAHBVpIc6xRiESr+uFnCHbAOhExhyXgdnDitA272PgtUHa/d+LI3pxi5bVSXqNqrP6yB+AXGhuhjHfXTTgzoUiYkuRD/dnEUsViHbsKdl2mJ6M2GwvrxSWt5LnKzvPaOEOwh4Cb6io2P33ZAJxiseOOeqRVQyvIrk1VvGPwHrCRYEf3yT0u7mTb4KoYsq2yDdhZs616y5c2ercme0mG4Cb/wukGB9nU1RetSIwg+mggVRgEJ1+ZLDHtB7VaxXPMB1q6kHBQpKud5jKcMQ/554CkVV7nEpT2M10OYP0bUecEmZP6upioTJajaTTR2Fab0rC4DJCDImHNEmLztjE7V3gLuYyrw2KDNqX7w1WpcWmnYFTTsfCng3bjg02KfS2mk/UKH+xIo0dL1bSSLTMfq2Y3gX7fBwYIklXD+b0uw/XcuO/g4AobyHRim7X4uHaENpfnhi6RX408hZvL+6RRvJhgAllOVikZR0bDrMEY87asKk1cWXTWU/CopQoKAhhjHTPVQHojjwAH8qyO7aPecbLcU+Hu2nRMvLsLcobHPNyG1azgP1eKV+fV0JTVQlV+lS1RwvINS9MRzecZ13nsmlIFtljvY7LWtWBAc3RVeqKFA8jSFS41hT3Uvo0uzh03Kk9+pWI0aUbTZvMAAUmhmM7nDiWvrsscDb9Sd0MbvR55b0yCYew4KEdHkITLVIRHe5NwA7/JDYZg3nEUGbrWALSVB0lO9dpIKRQ7pnRc8SjnLBaz6kKQUbQQkNsxycOSFY3oRH6ta2QJuW91kwToegDcBvauDiKLd/Yn89zhGFZ6FXFefoYXZ5sLY4hHdn84fxo32xHv9eQ59cLTBc8ZkI4dzUBbraCBle86RN60h+0eKg6VKYFDG1OUfYsvz8QfzZOljWrgk9RYvBx99yR/VgGAGsBYNWtOD8fjtXy75D8nTEi/1RR+IIbpYrrHOdSbBJ2LwpcfvBqrAnMQ8gWKZVCXr+QjKNV+3RBJ/TisO6KgvzC3i8psfs4Fj0cZ2QU5509K2HOrUYwd1v1OFY5+2hcU3vxxzZHYERm7I3dmo7phKTXo7pxokTlpWe/aFmWRdsgoq/GTGUAFS7Woqzxd+DhzRuLfsh0Rz0mgc8XW8ltcnt9x9AhzDMU6rrdffC3dqZ2lIR9N/5vm14+6hIzQsd25dHGKjiym5QohrA6etcx5jCPZbW9iS7V0iy24N6OSywgwUVV0BEEh26TMvq+VK/bnlCqLpI2+SgFdUf2Tg4TdX4Tn2Axqdv8OB0Epqy8qG4auxG6cgUi/XjDZavIpmWg3WVRIxxlz9Ex+e4ERDi7KEKGkkZy6Ud9m5/CRoGJi4At924vAbFhcuWADBeYmRk3FAKL8DT9MFNsJ1sKx5UgdWyP8u512o4zFDM3PKDbAZJfheOTsaDqOWG/Y28H9JKgWq8Alwv5vvIICkb3nI1wCdTZnJgaqUlOZ9kumL2W/7eIswhSVSs+1zaRqF97xAYgzGzFxIOPIAYJ3Ov6LLmhFzzajTCgCYQlL9+L4tH8ZT3TnX0RAsXv6PrD72YfLIZHt0V2mWfEg0i7mX/IX2azHCdTsw49poUEbaewBXh92OqS3fECHqvxhwceAaKjNY2lrNl69ds/L3hzgRgcAwxwdEqM/k6+AUi0pGbHxkmYAZiM/rCFaekTwIwZfzwGTwVS56v2QXSXY7jPQcyW/YEXvUZzDWhU5h52Bl1vMHQinCs9/+Sn6tBVyDs8qYNQINhfx86x21Ku42ntiay6mfbouB+KSktT4OJE4ELmVtn2lDPDyIJBx1KjlMS8Sb2cYRUJe2KOg5M6mPeAhdbLERmuQtdlL8LpY+DWFV7yk/eiYTsclqfZE6jdXb+yc2ZeCtrQ+mNdXVottOUQlTDymR9YJax8wvwY7h1q2mZTg9+GqGzkRRRr3YHvbcm0EYYuzZykt0wkMqz+7j3NKl6GZvYDVELklFJwDmvxui8GWKAHpT4TQSle/wHT16ON31JGTxyfdvtAy8yBbcERbQNRwI2NtyjbiEVqpS3rafjgNcAK5G0eBS4cm2fodlfXL0pij8OaWbeepEypwRrlkozGozJBrKW/wFwycW1EmKXW0IUNCvk2Vf5mZW0hbYCXzWLTz5u8D+sQI2cYC4HW+cfDjJcpMfxIhExXw4t6pSoexGt9YbSR0zedS1bB9pFd1jmPtjz9/qt5jJwvKRuiQiYf0wPb140tdLVSJev8ZsUFkBKCdbcgbHhE9WCl6HakisFEJcdwpYXhyVcua68So8HJs5DzEa3rO9ckcrYHTUeJ2eUPSl+UXff2XqfL1kXQtbYrb+gNLMtY9oR8aAJdnQqnmZIOdTVaaFKmQxiA/exlkXC6UOk5tHzO1nSH0BzS27p3MsCVSrmz5ALcdg3ET83MzneA5ftWqWFPruPbgujsi+Z9tDiQQ4WEYoVkkxkDlKGj06G6TWdv6fLgo01mZdWCVbdTbZDUIh8wkTxf4A/H+37SYTlx8h+yCZ9aSLQXjjhJ0ytwFb2rDHWw3vh18MszTyG4g2jWOKjyHqsQYHl510tM6Bzm/cgm1mYjNhtHhzz8NMEpvIuchJn+UA/wq3KTpBegm+SAcgkqCoPcU4fXfnqjZNgzrtovc3S6RUfvM2rsa1mbP6vWSZhn3lpqB1LQg434V1bhDDPt9VkcF80p3AXW+7vD5fe3Vf/JId6BMc5S8jsPO1x8uSn0bac0JIam3sNT7dOurjyRrxAzUsNoHKkWdF4xnQtSAenNH4R9hSXx2p0/srjvL8zXWvvowVJ5CGwr8qT0oUdygZjtQR/oUDChcH/W8PbOvjmu3Vm5HOYbyKI7F7TBAfaZLBXM1Q7juztV5Sf3uzHh6HzxB+srX3cqsDE/nGNmwk/7Ps8SThWIUjRWsEYYtWJsKWqzzj89BncrgicAC7QJA6J8KlHN1aUzOf8ZwycV9207ofvR+cTDBD85U/f4HIECFRap3fmkx6vVMmPakbvEwOeOpLbZEITXoQR+t94rPRxu0Rjf+IFgGjp0Roo6qLAliQUMva1M7yjn5tsFmr9/rBoTpnu4TxNZ+cBpL/rse/Gr4TOwsRzKE2/GycZNv1w4vcaNZ+hsFtTMpaSgztv7zyX8ozX5Su8/OwAQUoZrHTFJsD/M17OJ/ay2KhD/my7zSbpd+/S5+3Vp+REdgJPEpw2DTDyNI4HHKBgkHjPbIBOdIVNX/eP98O0afdJgoBJSoFO/AGxGqZDs6/mr7S1dsnRGMxK+D7O32of6xSRtgYYmUypYIY8zqpP5FhMsVr+TEh7UgoD3hIX8PpcONjA4ORfG4ey3zVhZ/ktZ+3cNCP+RUkmKUDAykgNlCv8hXXvd8cvoCnNzr36eS4nnIh4rRiEeopZsebFf0hLYjkpKfclPwbrjlJlBjDHhIyna8CVOF8bY+NU5yV0W4IAn8WtEyKhz9eaCx9mLZ/MUV3MyJCd2QNZljr9D8GcaWub93tm5+8SsREiKGmgzEIoA9WzNTdR5GuLrpehlUhLaqP8IcpFn0qeMN8/CfyJBJdZVZiIfGpDPqnlAa8mlb6KyoVSyJaNbxNPv4qcDmJl5/VIyL50LfE2qJVh1Y84hOKcXzLX8T0+uw8H/La2xSqgeaNpAMYrXVzA8DKjwrE/W0H2YtNWycW7/Ln+m+0AdUhqOYzThlHX0oKWsPc8wFwQRHxhHgAmfKfwvBYvUepH1Eu7ZHvW2qdC22pm8tcDbK/ty/3JjPE+O7c6c4WXvlC0v2navm5stgD4NQ3mebkOoNI73ibC/88udwOFnEtUePg+R8YvpW6GXRjKbA72x5WyQIVLEA4LWvcQ5fdlGHqmQFOYppBD0YKc0S4czzxn6VmvDb8flMW/RTIB/hmxMSgnh+JoobgAIIicGvNK4U5wyX/BIJ0Ty/MWYflBKxzj5swecxlP/BOngqY1Jn9+gzlwfqlmFiDkk7BaIRhpxpXOXpjrzSUmYShDn9RmxpY8KVsI4rua5ThcFRVHWGxdjHO4itCHS5X5GU6072CgitEqGu69CjFI23vkopwrpexH9Wr37TVv4EzphXPgkRrf91I3zCYGEZ9YfituVnPY+tvbyRDSm7fynJlzSGFl9hlxKdrKGvnQgHOjIrHiqjSCwqpZQq2rQPKx0CHBfLtBAwYTuEOTaW3ax1TFTU6AFpupatcbkSshXzW2vXhjqyMgPo66gi1f5RL4xPL0gET0H8mSPwNmdrmSFYZIXWFPmaUpuWl3cBLlAs83rYnwQ0qGjeTSuSK1vqrO+o0HZhupAQVO8htSV59bHAfryqRTNBqg+clP+ZyLV/PAvLupIiI6FF7z7d/R5udjz7V/XG0B5L7qo0f39FwWDY/HeQC7S6De8siN+NrH6QJ9jRaSYNvSKNhQmmHWUMO+FszqeUfyHm58mtpZGa6sXbKRFbkbq1BQmbqLhsWrDmjiYORYb+5MrAHW7Jp0rpaGPYlYaQIQGuXK+ybggyRupyBpdl40nyNX7CADRRDHo6+gIUJ1rfJ6xNpIAQBMnrcbZFwtYz6Mey2Ot0iSw3x0S17kb2AbkadFGw7LSUCzWbCBQN8YaV0aLFzIhBEIKuWX5eskbiqd0X1w0J6CmUQwe7aSxNgdZF4nacqYLHdRvNxzn2g9/p3AZZjNFUtlvoU4p7VvQIB67KnDQtb8g33KEbf5brNiuIFsd4aNCgqyPsd07OY8scYQr+MhTDUQTitQii62ij5U1f7UqWVag3kOo1ULPUh9r7lcR5V3iFGF5yqLWdvtzvz4KE2VQJvlrblngpPGlP8xusyjS/Q7sHZymGjDsLjQEEW9thYmTZGLKHPteimLn5KVIDWj/zTr5B5qvnCHlLcl496+rYk/jJrAVOwxhA1cdcsbY2Cagxu75MKCXqa1ss5B2ycM7BALkzSbTbLxqK9F8ORtNNVbtHo7fNGQ47GUaWWT5XyEKjHtsQWpdRgaKOzEn1HUbzKBAeA1rCpwP+0nE7LLEpyf/7V3yI0nRRuulSSrLcQG+KaTYVyAZb2mvJ67gPs8znaI1wBdqvtv0FYCITyWtL9Ag+Uhfz63zd56SVTThU0xTMNUyLFJVwd4l+AwnYDbkNJxKYVOL8YrTGJ7CpkOsk/39+po8t14RBBpv//UVolv1CXsOoU0cD1ruFeF26U/IvWrY2T7X8HUPDVwEZ/Zwvoqz2mKcxyMQ50orWc6aLq1A9WJhQ1ejG171NT3ZLckO68Jj76/59q+1qNg2qP45IuAGrnsl3Z8UslDn/7XR9NCSzZr3z0MDFzFAvsRm4AGx4Y9l9qxq3TVgmzMifw/Mf1HFMgOTPmcR+gE1ZuNleODTqoUwm81KSLbipJCvX3MtUQOx8pS9iq42TlLywL9BqAXJlU4BOxwRtirKI3g3eg9P85AgQSehxjD0kZeKuae1wHeBPDMWlfDrKUP6oboEKx5KpujxYXTIpdli6e1s8MmvVUZK1EXBsfwfGxTJI0ccDHxC0H3zKq3j5STTP0Dk3UcS2W9v3droiU+k0vmWn1tzTgCoeQWozQs2qFWSgei2F2O/L0T37aw96parPni1A4eqZbhl5zj6mVVqddvms9KKtUwCWXY4ko1qkcm5cetPooXwMaDLrZ7ixLYMd3LDHFDoCULAyw0zm6lTXkupEiCDWPXp7uJ1c++QTza+DcH7oflLUcStRy/ANGUwkfLi99AvLX7KVCWiYxsHVpfaCKn+pqrpzljN97W4wZp1vTjlNpq5DERBfJQ+jx9o4FHrbuqRFY6jsTYYxunkqLeD6vg2HfOMoJngiylKvW8GyAQnvGVLw4JaQoNhpDv8v87qcP6fWKdvNvDo9p2pNTb2OJUmsRMWwzI1p2lEQruX60x0diUvm3yzkCWGR/Mphdnj4zT8YsSYhsoGKYpllzAjBYNuE37PU9tK5LiZrSWxYnYGUy0UxSXD9b+JLKSYyixa07KjgiMWb6WzNNBNjLZn0H8+60ayBOQw0eAKcjFpTIbY1DRErrwEIc5MnZCkcaMGpc12KF0rRen4FUXISFjXlFF01GKcZ2iuqW7GedwP0tKqHTzE/5lazevE9eZv0YDIJrA7QE9w8Eyc2VndWzXEU8TDmGtzwNMyaeMsUYTHAZt6uE0vnLa8WhCFmoellrDe0VscrP6xaYX9TN/X2twXIEjUZZTM2AU18a/hCRFXNHjEOOB69Z6YMPSCzmu9aSeJtopGPPvA+85Dm2Z5kp/rXnH9+tiiz/JlJxQGZbrIbqe77CxJ9YAilmrNOTHWOZjlF6U10fMMALf/Gn1Hear4JyDCi0sNqB7mrTwU15GG/urdKZBuIO4fRHxVt/DTBT2N/HI9gUViwP7pl2FOiL4QGBmAAylPNXvenBagRqfZS+iWHqobZRNmdDQ4eeJANfgRoHwDgVazD+B/6yKegURDzgNVKzIe3QPMnb8DPPwdpXYm1Vwrb3FTEWCpNwMObjJYJCyw2ohArUKw3XjQ8LADpynkr3PW0Y6QEk0YNhoz6agz8JmHI8tEPdO/jnBSnR6AdOQ7pnk40hVKqln3G1xvCUWD6T15NXhGrMn6wqV6z1ta0wuxWPAyyEXw2mr90P3a57eeagHs/mobG3oWEdqmSVe7pn7emF0obsmbamFEQozxaDaRIz80vywKgaLU+8CAsL+jFYiIQJYNATjt2qsnJhuIKzz+ybWXA5uAOfcH0yeUS12h0mOs6oO/VDbqHdRpuwjbgRkg2mmlgqcshZ9uE4/EF2wOzlMmiI3cvLAAdXBBOON/0IXg8HF8cnHRFgq92bD0SkzUdVKJIvsv8SKTdnhTYbt2f39P/42hdVvAUA8tLedPrZckvaR7hSoVV6hOfh6o7UismdWRWmVtKMca3g2xORJqTBPTW3iVrgdFt2Bz5UtJClyGIJav0LZasDJsR7wK8BSPwo0IG7pXwJEHwx63FQwFCygjxEdW95EwCa03TIJ/DLKgm50IJhcSPk0V/LDWJyX+QSeggvoKC18z02EUpuBshE5ZWR6dD7d622zwI4l+3oOIqbZ0JgFhyrI3cvklnf/MFWkp3EURv8pxqKpDoyv7yKT/tb50pKhSW31Dot74QI006y/7Z9pSstZEk8ND4vp8mpr/4N1zhpDXghjhnjEPT4ZncS2+9sYLdTIa9wlEiB/dUUD8oEfSwwBQAB3myx7H103zqIMOa9S6Qc839ojpL8kT3Dh37DZIMCypUmnRwzjm3KehevJdcy2F/+yX53+P71OCZ/JNKXkH9bWhLpBZbuhFOpcXKIU/eTe9y9QYkrleAD6mdcgDccplEK7KDp29XHhDP/8Ot5JR8G61A2FM6fquU+Ig70Wlxwmg/M7y/jmXNllsMJtL0BA1AzwXXJ9MR2HmlPfYJgcUUhxVlzvwv0CWLr4vdfQX2INSXXVTfER5q5ACBvgT9XqRDkJewubSvXRbmXRrzbDc4e+gCyB6Zj1JVXca/7ZdSnHzmNEkwDIS/aRaqGEU9URENpoJjppvUwylWIgh0n6kfabGemoWxwMoYZ1BF/PqOWXjVoF4v4B9+vmBOmZwKIPXx+U3CkuspevWCmuJcG9lZFGR6veEheEPuTweiWHiAop+tjMPXpGgYXe2z/8JjfVB/GyVWDbkzl0BwFATdwOANdgLvNyvBEUHyn5TU8awNMTtOg6j4eplEj38MCsrXAzhiyBeKsK3cXdslWyBxLME2cR65MLXnOqvfjtn6xxs9xRIxDhsps5fJsdn2F+niaDRWWlP6m87Nxub2XLyZ5B6d0BFa6KbhOcB8L6OoWK87pk/rBNPN2Pjo9YrVVWTloQ50xyQrpsOLxfazoX0sz8ptRWHmPEGMNbIH+qUVx3NXsqh0HvpwgGnTRHiI5gwDj7MFwha31Q7+5+XdjRsIUhrVuHn6iyzxTYxIiX/7LpQOwf/AU/1nItq4y5blssz/yJnx0Zx3RZ2CrijHirsL3WXcRipU1QgYB4sa4VrynJIRL/49NSciPyK7HrYKk7MHDKH+n6zP/EUqGLQx0MXtZFuEu9QTG6axNzXem4Da8Zue/KXdeGEyS48fx/H0irNPCTp6Yj1LZjJkUxwaRYeDlbxALXlDAIzvndGHLlzWPGEWnB//6jqW8HUGaqmQ4AcgYdXTT1ohWdB9u4L0wVhjD3/jc4V58JY7wmObpWtp5ePwdIMmF48Du4Meg7UySlOiTFKwXA2QytUFWyHrinEC1VxQ67L+6CJtKZBcSbBwV/x8DqBYVkNrfnJyzIGoA1ySvMOOJMZwxvTzmJI3OOnrRxzZlgcg25QEnmEd6xXKoiP7CQMTVggRZtHYpFvO9q11BmNnN1u9uLBlWZZmkai53iB4WgYCISW9IlHV5Q8S3yuNwAg6E6e6oh+sVXGpLsYcfNgXOym16bqqqSCj3ninYjlVm00hSILH3k9CgfEqXFNj7Dy3c+CShu6m7EnodfcsSmF/2oz/blocJDmxpsu9UMWNiNPi95QysrMaFzDFLIzjlVIR9SpwAYtd2WnzfZ8Dj1nNN9fbGwqAkhEtBoTgW5JGh87XBjTjUY53il6HXXbSS8fmSQiBzNIx6N9hlZosdoV7oTdZkfRsfOsp+IX1I0syEomUrGOwz8rLBznoJIsAjBv1GN1WBuz5epU2SeewUz/beolTVxBydimbpJCIJ/8BIdLL89l6jfpirV/bVl4F0vXSuWfpj3Zk/y0fd7Utf+akfDfr29X7G6CXLKDKrTJkY2vxpNtycvMnGnsjEHyXclw6OmGWgtVfI9kpQ5+4PdWjcMVlFGsVp0bcnSUAYELVIMG8jiW1Li/Wf5t0HOM4IGFbGZgxtkDgKSvTyy8T7gTipA5xy4TQ8wwGNDYGT6jN/Woo26BkUy0jlcVn7HhblKesQpV7o7OBiadxQ+KAknwkZh+agWyq6RMjUvuQzAKHMmL5Ujny/tBeQxFr4nD/yLyaql7MU2twTa0IXJunOLUrvCwJfZ+0rpGzEzE0z3zpL4r4o0sbnrd+PtZqAtkELEhWmVd08MoyjhjjRYa+aWOLeKS2NCpeRH20v+wUVgznjpcB+RIFVNIZtv2Wjwu2A1Z0m0j3DhpuXVvhFJqNR4gAKASS8+5AIXEuAEkKUAOHIEYT+JE1n95vSfvQEd9R4+hoD6024F2Eki/xbA4CtiwhT3fdmBZmKJDSD2Ah7D1qZba4NNsTXHSbliYq9evG7R8IwU+es1ZgVdqHTCzz60zm/1k5WviH8/nM8xy+mJnltTVlylQylHXYY2v5QK5M/fmmtNzdwTC2UlHZQsHnSEWADEbYCCL/5o7VxXvwdOQL0ViEVlXJw6f4w3Ag9fYch8jKqJSeXHiNTWAiuaYB2MuxSre8fntSzhlCbqcOwwLdJVUQiKZsS2qoYPcznQw2rk0lnAN1h98tCTWVn3+flOEp4+PnzBQQzr/3fIDcP8eHpxZ/n1WaDexyq8DRk6smZFpHtVmYYyjP9xs3snc+cZg3s4b51BpvgA5XihS5qsCnMn/Ff6hUa8I3aJoEVLPwzntMVWpu+RzSaaACKt3W3ujevu7kNBHMx2B/D5yslk4LKeh2dVzh1C1GGcxOvyc1btItmXPy4S8tlgxQnkqd9nI2l1zQr7TzMqEvhZAc1eWL04Wg+E9t/7rLXgxYdHyB9ZQG5EXrbfR0LHU2Q2AMoqEXfbZde8U65m1HNZEMHtjqHEQmqtr0/rPbveGdkGCqUNDznCgsGIW2zYcUZOul8Iq+gPURY0SYxdaU4EQ4mHUUge368AZJfAGyt9o6W0Ixsi3GyXwVK4qMRoPBGIxJ+p6/X39NJA1IoBNShPET8L960sA583mnIzqDtF8YFpOnkMRDvMbELvZNkbWkyHZ4Kz1acUtTTAvYYOMGwDbBAEcHjA5qVb2AsrRvacJJhcWAKoDUCYat/sdTjLLApWN7YGfuEiU/Ul/T2Bh6V6NA9BpNv4nii2mw60+7Cteq0ukmR7M5qzYF+2XBILPql1luJckbgJswZoOzb7I8uhVH6IhMXgnTfaGlBTWWcoceG2X/4JnXm995THcgkd9zm7IXvRXiSgrrWuoSzNljW2NSrS6icPWv9qtOepWZpTVZm9DmjsTeACwiGj6tZ+XUDZgksgmzOrxsNhA1a80e/31fzUrV9PF6GamCzvKQ/OLhTVv13qOF7eEJXijzSr9weNRK/6jqloXRJxpMWE+n+LpxBqUGq5QCPB7XFkmCbBX72UhO3INz2vwO59kkWSB/28w8kS2uVn2GkU8s0AlD0BcikeimbYDwCN3boRJbChHGh92Es01VIeehLRdH4aeiiJKZplr6DLk2XtEfGJr4yQhc1yjY4qVEsGA0wKsZNnepJ522roa0HWjQI8lEwaY21U3YwaM2xgyB/4BjVgsDhYBo7TjPEn1Y6hLddWZQKnnBiKvGZ4h25YNEsy2yrINDAzPjeLtsD+F4C5doVN5yrqWoq5ks/GugqrzqJyKYVwR11hJ7MxSqUHR+/LKHynklnu9aH5OPB5CF7pUDsZ2PZE/b1FoLYIsPILTs0ecODMFgsbOY1R3BMA0SAgQLzQybKW5PUh2kh1czjlrKEnywXMaY/yylj3MwXISFsIp2vxWKqNNVUjk9NT4VWq3KCORbLOCk2e5l0znSC2HC1msZVUo+HVFFd4mFmR30HKtGYGkMvc78yaHRw9QBGKhvCXQklVW3GkHkeuGv25fmgbwnNW/sWmJqE3POD4rvSd2QCoBV1yfaO4u+3wnebR7lm64BnbHBym58v7lnbJ4+3dao1YjhZ2AQaZfmASuDcSBJviR0wgYP7vFDutpi9wu3jt+ikku9512kN45w+oTKnYALNKqOcIq0LxpcjchKto6h81bXeKQx++hEh9HHBmZGyieK/++aiCQ+TjjwcHj4U69JI5spt1F7n+/sUI0yWIVIxVtvRpHYRPfUcj5WJWxcPpiKF+N+HMui+4ji6DtaqU6jTOegGkMxWsxzqRd96FObLMsBLm2ZAodsjAS5kMTMKK/wzwthxTpmc8v2Wj67Eu95usU9s2g21Rc3JGNj6SlIHux9m9WZpzOOMp3YLBBXtlkgaqgIox61KwWNzCKJgU7yfIBxptUVA4mTpxixySt2L0b3VtwqUP8uoU+slEBdoQoyJifLlViAj5Fuu7ZkoY+fCBtzZVY2ngVUzdO0fysfqfD4f1PHDWxRXHAsI5Um9OskikZ5bECNQqnvYEGJu/zXZ0nqIzKkb+L4m4yOzZq9BjL+7v+Df7SiC9que6/JpIQtcBz68GXgVih1i9hO29WB02Pq6t3/icZpCU3t2Qd+CyDVA+b08W7Q1Yt/K/lItchVc9htGbvgVKDGtOL4v5cxGs23tHAjuhA9+95ga8x+CAdo7K+0tVq9F+RtpVXfREL2KuXzvUXshGsj8eBNwhWMXMaHONTVqh/sz1/m/yduou5Fhe0c7Yt5T17Mrcl3EPkid5Lb5l92doigOHK8Y7EbpWKadnz/OU/WaXbSPaj5jHRFh7bub6xYrPQVZSdG37e4WlOvwfM5rYHV0fBzviLxv+ApKwG1v4PAzIoqFtWFExEy5le1iiJWEylJK5Tw24U105MSEzuBnynk2phKEm0f4zNk4u+lDrsFJ4JO8aDV/ibT2f1rrHMkpcs6t5ZKH2bBfnKBOAANqOIt9NebdMUjWlM5mfgnlE6YT+xxZaGwpKFFlBrGsDm2S0NqZt/aOPKDJxM1UKQZ+qHqqKhximoM+nshNONLOOEx76vjQL/7GPyZglPbgfFixSn1MXd33pXmLXFI/M1uvF++QmxRvU9N4HPAxoT0YvYz3qaVbhMOS4OqB5sdme7vEObMRwg/XG+y4LxIO3KwcMXReL3OUlIgIoXaOx12p0P8KlFxcRUKwI9fIt+tjR4Ti0hxiUX/YCseVQ11Lomf/XWP6lpicMGkavKIeEt5fGChHTtaMW3u+vvd1qf3fUi5zR3PLgfq7+rPby1FgH4DkdWsiySkKSpRN2fFuwzz8/LW2A/4wyCHCR8RrK2xkAKNrlotbxImxqtZsRWTtlhWJsYtJx3Tkj4WVAs0KC5DsbPsRHuTZeERXoqOtB9y4swX2pwQk18t/2jfmaEHviefsvXt/OzSa9Nu4vbZEDnLzK3tpvmG0koXWNsiiUh0ppC5FM1HsGQOsQUlZl0maqegcS9UB5KOujULCLfGylANX1RsheWRBfv+53WE+Yxe9EcMAp98zUJ2CnbzTrMpp5urbsfHW77TfYSGg15vlg0aGUoe8Bz/BEZvIWNzMVPuuYOHSndDaZFkJ2oBnUOnzs3uuKKsgdJmThgHEzgpdOZNMVLIwWfGuQLnfjhB0MzWcNKOhNtKimywLA7fr09v2U9BEdND3KUr0/sJuO2CdXhBPyTScEWdnE6AU3lMIEI53vl2TEl/ypdYK7yRI6eiZQ4eHgPBMD15aHDyth19Emyhh23Gk9wgnMzLcQL8Vk10Dkmo6tP6PHoheUNn2X2rKLelOjRE6hzf5aG4rj8uTmJxHLqpld6e8dswJ4SvxzP/5VrgLIF1jlnLum8/mH6B6T7Stre6pD235keSdWAFAc/rn3ClCVnilizVsVL2EnPu+3K9UEPEL8aYIXXmLy8x35H8AEaDUmqd2p1WCzVm54l6KVlC3OyKuRtOkDRipuYLCuTD3BDnePxHDVZuPrkYczZBODkqYVPQ5Sce71H3s85vum+Dq6EPRucO5QBvRsP3p/3lOuF2BFlavzYx/XykZ3ru8axQGioeFBji1akILNxYX6n6RfOXAAAmN4NpqZyqwXwwbcqNgwF4JDMnL9f230rGb26kL80cLl4RB0krkQO3H5N+g7F/hwPglVSiLmQwFdfNYviWoZkNsfuMcA+u+CQSxZt49b5lSaDi1BZXzIoW1C5Juec/tHXKS17vQsH7iFgQLIdyNwJJQmWziTsnkKWbFVMQNeF1V4nnf2t1rngIkSG4vRgNdVb0w3yY56u3FJKWfwZz1PQT/ev9JR8wjNp4jmgP8MbTzhBc8jUJSZIOSNGGUHXqhInntFtXjEPuO/gckvMKQs0VHbiKB4lO0vdKYWiijucpi9UccKmf8NPJn7RaeF+XtTh4CF4/5Td8o2euFWgXcoXPw1SZ3meT+mutkn7UHdtNM75YH4ki1EXSi6wUybmQPwhItvsenKAhMvV6E7VEA5ARu1uNme6yGMSHj1U9ge13IcugT9v5WWchCa5S4d+/jkLoKsynnvfnE3qyl0GwwAoTpsde1O8QSJMXu749zA/SzsTdahCWE6JB3mKix5PnWHG+ppi0IUj81SdYaZg4o498gaacKt+yLt5Z9cuLW6u7Rn9Vor+eAOpJ5FghCo6VKPYwLhZmvxfW75bKlRoakMEgJlip5AL5fBNmqZrIynP0KqrchHYoeiYKnQfs8MEW+n8hBJkhS/RIJjL+SqCde2PJ0y8VWQaHiM1ZuA/zY5gEZIEIb4Mmbb9xkk1U3bIQnu4KMeWpng7bBDLbSZPldsWygLeVlw8hRYBCdpsgWOaLVWtM9bEvc2xwwg4tl2hJ555N4XTkdPS1gzNVzVCX2NuV+FAUp58ikYgv2sWes3f5Nne/QuuFU4tXe8b4gciPFFSgRb7ysv2o3FR4bmpusXuVXKzRUWjqI4/N+5dniDFEmTVEJow/FRCGSqgoyQxgLINb+YNhEcKgPtWNG697IX9Xm8LFks+rG/jxQztxZkbOtFSeMzBwgm27tAjTxMUKAoGeAeID2vM+iZKrvozfWHlem/1S11xrbogc4BV/jPVunIdAhnxEe5c6p+SxlfAedv1XSTGZ0a4r0ccs4I3OTKMbDVten1EOVWzitkLbSKSIMCs3wTQy7cfrcO85RLd5Fa9685NA3q5grNLk1bkGcRhksaBhOS9BqH2/2MMPxCglthvPizANiFZ86yRUrzZ+fp0n6wWJ+LEhCn6Bv9jOGjk7732/A/DGnIq/P+LJ4oKu1NZtIvNszV39oxB74I6hU96yzbAmPf7HZrNGEQRDjRYAd2SBCorItQ+va4PGmzyy10RRza/L8WxGgEeAjKhmm7YaH9P0T6cvd1RbkTGZuIyd0CacuKrIfml0SWpIihKpIXvVy8DVNBvg7BBjR9PZHTvTc/HrMByK+hSQ5e2Xx24ZDCc4oTx2y5ewxd8GoKwf36gFylC4xe77krPW+3LSewHfB5CFuzUHbQyHCseKKUb/n0YYKJyuBk6pUABuREgzRSG4tVCOWIquNzEkDzzMkfVn1kGXU25ogDpTDBOPV9cK3UvQ9LBJet6hO+LO9GV9VwWeNk35OzsbbCrkWDffcM3NiCxA8eel7XmOySGI1s1D6H1big42MC5xilSZhlsaPLKBeFS1NJYWQ96xbb+pPG1n1v7F2aPcefjwgNGg7tnyNVtEoX0DV9vspvt/BwP5DbLclN2XKwrzLJzBS453VqLXtUIQxv8j8E+WUw0FmHPxMXPvupUNKiZWsnBt94aQkPVHG59Pe7CHC4R8l6Crpd5bOkxr+ovw6yM+3VfMqXtk9hsIbOzpeHAx/agWtxdeujWnv1ag8dropBPqMM2S8mKl3WgfmPaDuiGPgaOQYsHx0pn4OUtWCOZdAis+RvxV6rimDa2+KWNIMazQXxwnZBE3Uuy5/Av+TV2F2plyFD4c6o1I1cKj5hoa64h7rDsL2zSMkMrbiTX9Brmu8NMdrkIbRFcktJtnWJTPd9aenwX7JETtLdreA40mmgY0ZXOLyvb7aYou4tNn8CFV5Z7WRySQrV2BHiD1+gfOevsK+2RswRs4tG0UjxhyFOmfMxbWETzNtwqV8QfbbgAMR9KhifHv4TWWplYj3AY/j4ZA0UWQRnsbBg2rW7UGY+W6sTHX0Ll06a7gl9k9tIXhqhDLqHkWC4MKdk5bu9j/KAO7q95XSHbGJMJAZ+xG39gCBgeyVxZONSLaPWevuEje0kp75wGCnoyVzi5bBqBqXUv6aUGkzgNUQgOa98p6UWXErh2YUs8z32TFpnyK1pxQqtqK3yJYxozu4XrLN6M+fM9tIuaM1Hc2EBYaFF7Nho7uoDcOTHqPWm8Jd9wvcwjxUE4p0EBJjgKBRbHAMT8ZlR521lNXHH11Gln+mfbfrcrQ8kgs/NvwgZ54p4VaXM1h2myKBlpvP6zGCJzNGa6IbmH0WUz2nuK2XOkLovXjkmgkyMFojk5NCKlj0IGNC6NgTZmaf9XtgAd+bMBMSt8fPEHHrLgrnsdgZ53wlFYfCWZ3OLxpGpP30vmQKRqnA2DgsRzID6VXbxFQvPZVf8Fd1ZW7SP3oVlGSch3J1/wlRscrWtrligAR7Zvk/Attebd+0qRu3Vxnmcfq2ygmFo/oh0rfJR6FukWb0zUZal/+qpqlyTB7wNtwYkEKidEWguSacycGOvI0Ol6havR8GoT3EbweXRCtaspJKOM8RJYVWtgfB8MJ+F4H23/Q6wzSXjIxHfDIQZ7aMZc04r4Tb3M0ati7Fp5zC0SzO03quWQBEVzjgIPfyjAMXOZE2qnUstja3jzrt/3/qAaprQFRIRLrBZpXNJZFMPVx/Q8LEtO1xAVpoXfs+UftfmLMLN0lYm5j630nUmQIEPtj/B7jV6vXXXZdV40EC8rDyvIbRDeDfr5z9I95pOWGJ1HiYalqyoUtsGZQz6MNfjY135oVegbMQIs4zswlJEJt0FDqHusgFgBEui93Az1RZQr7DpCZscIKqhqa1AozKYSu4rnrVYz+Zz4ab3R6fCi8+u1ya7kumpXQET4oaNVagXYK9HjJTy7LOKraXAgxXnc6UmxnSGJ2SSzAH1ZuOQH36R3+HIrgGtksj2VLNxWEpUEYWsqplzE8ImeX2j6FCy8ZZkN95xoLRFmMM0fIIfySWFjs0ZBTsH7jwSw/FPPj/xoFKLqH5GpWlmwoPq0uSnv6QS37rItpEpbbNJ2FPMThwRr1hpS2oxL7T/IA02hWEaYuBLN6+hJW0Y60s5XwE0p7nGdsgXzFgrjqWyjnjNUCkZJbBBnLN6jQlnIw468dyhJmwXBf5KALPjtJ6foA1Q41utEyDs5VkZY7dA2Ug3rE8Nx3VRDuUYrnxnniWQmsQ7FVLJkHV7jI6bEKZ5B5jPiLtC4PfxGUDFww+ti6MhRgMehyWvNjkJ0sVzvxGYD3RiEVIFQ9PqOsmPPEDbOTQKFj8W9+CA0wDVdT8IePBvwsh8YqtwzGa8YYgYeNSJTfEe6rX7r4IPnjzY7bIKbxFo0n/p7/3nwWbHAuceIWAFFJApU0S0VTVXT4DSe3bwzU2XjT124bUlAjNyyWif/O8DjL5i++63UZBcXD2DXbUFBsc5iwLMeTcHnUnWa/8zWA48J4ZCYAHB3QFI7f85hyQhvJdMBFmgBOr2o78lEuFm+hl2DRgB3V+27muQYtSMRNXZMqIiquVoztjVzmIylr51JVJeqTepesrmPZjhybpIjniKr6OlFmdkIQ6JU8UIxtcaK2I0afphCVCC0J/kwP/JmS9T33QSfgpXPMqHDUVYWorAv/DCJ/mj9yDxSxKwI8JciqXqQX3Ar3P9IuH6iCgzjFirRsaRrfJbDAmIbTGbX+ywfg6JjTwlyVgcbJGE30ixlb+yTtv8OqkXjEV4scf74O2qEdWomWHrYnquUGA4KMD1tb3lGSYw7z2RTTqbTxsmiIDxRbvRtYeF4irWU3NHINaoTMjT3VxmnaKntYpIFVME1yGyr5NY6wIrwpbmI1FTUGrvOloHT8lW9gHvwhj97k9FwilOQsQDLiv+qam2fwR4jOlZqL08pAbdv42tEm49g3fgUyQVpuI6p8ifoWHMt2rL54ZGpSrjds7vRXJCxu4fJWEbS7K696W2A6HF66u4MUirdU5spDVmRhSdyw0fT9QGe8ke5YyNuDbS8fZnwuHA52FHgrkhGOYkcYWLNgMeDHeS1t9Cc4NJ2fkXR9zkos5QyVstcf3QYr0cLzGu/7ZBqtW6ryKZd2WbampcHfkYicOswdXlX2oypvAYh+ULRtDCVoRUk4o8tVAiazsycijriBhKEx/PF84z6rBjxgxpIgO3LPF1kXloAZJSCljE5rKFQ8njzvhorSMtRJR9mfMomQAi5pvmysuiSQMqTEUNfxumMAl5YGx9zjfE0JgXnHUyezlIl7dYIagx+cCpz/Ro/KMrtZfCpu9JW7O9t1CrCw9lXf7NMtQcdNbE/ApY5RFOzAEfiEMn9sF5cg0UTuGsfq6pmlBoWT08WGr7NPUMPoBNoC3QGcsoDla7gofUOZTZ88Mw5HROqdzmxZd19S/4AmdzMN3P2O65Ub3oIyn660SsQprcQpui+IT0OGZzHXpQ9f3oSNm+7C9BBKEpgPIPyKZMx12Kl9+3oIAvxX4Za2FIe2H3GEiDlU58BYNOAYctpozWEobDoRI2queZnf16eqtIZfkXPD7dDNsXHLxyGMaHGxGKVBv4YT2gFVV5pcQ3HvmsML1mDsZ8qyQa4aSRsJRxFebcdNwZ6HfpjsnRUwS7xaJ/OynjqRTvDmKMaX81oyucqPbK8GfYcHizKfCA5inUcQETZ/C08aZo0edaFuJZBidLj1xk6p9IzvBeMqqI1YI++alQEr2cw8djwf1uSeOKW2m3BSTzpNAleqSNhq1yYB5x9Tv55NkX/BiGuMtkp3w8116aiTAnE9vk/R2zKcHP7hfQmwsGyvjtKPrAJ9OIgTFyNB4/dchSfHNnC20JZsoG7b+Cd9v7X2APyPKrd3lUZVX3/m1WUyEb/YQl85mGJxpp4CjzoFLxLQuRXdOibEmxjF1RwdaRgiSv+UxHztQQF5gtrsJd8q97HJsp67Mofy0mQ6NBufv5vc4vszBIHdQ2lqcJmF0JNVDzJaZlFYoKM3UXvylKiiLlsJiI0QG/PVxXn5l8ZpM0wXp6XryATBw4nwYkotnmQ4eS21rS8tenYoMNHjwgV1Gkl9SdaO5/SmZvURAj+u4shC1TfP5USji1bbcMvTc6hTKeHGmIrEguK8mZXnqF37wJ4F2QsE2z/EX+sqKXNju9CXF34QgZfzGAk7gYTa01p1b7J4If5VnXLyQTngNUmr6ulzbiGdd+9iXFl1plo0d5GU0gTiUuif3cPB11zqp6+z6ycPrk0kfRpRy3N8iBkrRz9KKn0hMEEb1XwhSLA48RtjTGYCys6ZqaOYXnuL94GF1uG2emTwVKWY8/fBpEp56+w7k8C4cQmniGkVSycO4MDCJkEqCcioifMJj5IQFxrg+MjJdnCPKYI91S+ubTn0AsW2vRSqM89DQ010/6ZYHlLYlXI4bNSf8WEg89JStY5PeNCj33+pZ2GJX+TGvSJllrBhQfUItf1ddJTpcFrHRX88fqlJ+l8Eg96bXiaTlm6H+hvbhxomWpN9/bi76IROMheOsKeQ7U1RxqU2ejPMtCGz+rRk0nKuimKza6mly+wLxosfBpdwjE7Jq8TaCjDIR8XNVWTvXQVL28e3qHuARgVooOjmViyYQ2KvWqp98A65uMEmno5buIDo4gRxDrRHkSs3A/39PjB0TQxcnUqj/dZiw2PH0DtgO9j1a27L13JWEgJ2se1GfLfDuFvAwgmqVgWqGgYtyQIWtiVxPGTnh2y/vaOjb5Tc9VotlIYizxjq4fK73JGBoVDJuLonj4ez5M5Ltz/P1qKc4JBPZhTgU0KrPoMpJ564hCpzITxVZ92ClK/6UVE5EB6WyyLNfMENL9kSwWmgXGRxXZoSq7t4ec1P5DRkXgzFEMP5r3mUInBWiVQuypy9KbqjsKTuK6bscJAwVFY90IR9a7+XO/k0khjNr5FSyPWXgrYD8l4oin3ZOMTrsc3qTBQC37wzoS93GoaoSJkJTfAULnVz9b7Ma1qxToDmw6FVdbjWV23cqulWwlT05D6OZDlqho98xJgjqlLO35I6PeEFzv8ox/7xWOp5kA5ShXMCnlWOJcL67+LsK/aV8ZCP6wv1FfgxSCXfAtff5WWQhwTROEwq/3LU/wKoIhS+EFwfN9FIY5GN45cfn3M9DXNJcb+55zSipsXy01GzTVtNReBzehHtPMR4k/ySrck4zCJ4L2uRgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":9,"cache_read_input_tokens":84467,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":9},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMP9iyody1DZrw8aFpBD","type":"assistant","uuid":"e89783a2-92c2-4dbb-bf7f-a40702511407","timestamp":"2026-02-21T14:38:52.124Z"}
{"parentUuid":"e89783a2-92c2-4dbb-bf7f-a40702511407","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01F4YofEMbREC4bdWvqKqqcN","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DCwsS5ZdvffJSg7HhRJVRS","name":"TaskCreate","input":{"subject":"Fix all code review issues in App.svelte","description":"Fix 5 issues: 1) scroll discards rename â†’ commit instead, 2) drag preview uses OS theme â†’ use theme state, 3) remove unused .theme-btn class, 4) clean up duplicate .rebuild-btn CSS, 5) deduplicate sort icon SVG x4","activeForm":"Fixing code review issues"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":9,"cache_read_input_tokens":84467,"output_tokens":9553,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":9,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYMP9iyody1DZrw8aFpBD","type":"assistant","uuid":"64915270-5d88-4830-9d8d-44e86e76a692","timestamp":"2026-02-21T14:38:54.394Z"}
{"parentUuid":"64915270-5d88-4830-9d8d-44e86e76a692","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DCwsS5ZdvffJSg7HhRJVRS","type":"tool_result","content":"Task #1 created successfully: Fix all code review issues in App.svelte"}]},"uuid":"00818609-4795-46d7-8429-d09377e82b61","timestamp":"2026-02-21T14:38:54.419Z","toolUseResult":{"task":{"id":"1","subject":"Fix all code review issues in App.svelte"}},"sourceToolAssistantUUID":"64915270-5d88-4830-9d8d-44e86e76a692"}
{"parentUuid":"00818609-4795-46d7-8429-d09377e82b61","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01WCyM4EoAww6SeEH17et5WV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015ryKf18Y5dkubyykDSZRv4","name":"TaskUpdate","input":{"taskId":"1","status":"in_progress"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":9409,"cache_read_input_tokens":84476,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":9409},"output_tokens":26,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPL92hFKAqRYwniFcPN","type":"assistant","uuid":"d351b862-7a66-4b2b-8716-83ff1c0300dd","timestamp":"2026-02-21T14:38:56.515Z"}
{"parentUuid":"d351b862-7a66-4b2b-8716-83ff1c0300dd","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015ryKf18Y5dkubyykDSZRv4","type":"tool_result","content":"Updated task #1 status"}]},"uuid":"9896d7f1-938a-42b2-bcbf-a1cee7b3cf6e","timestamp":"2026-02-21T14:38:56.519Z","toolUseResult":{"success":true,"taskId":"1","updatedFields":["status"],"statusChange":{"from":"pending","to":"in_progress"}},"sourceToolAssistantUUID":"d351b862-7a66-4b2b-8716-83ff1c0300dd"}
{"parentUuid":"9896d7f1-938a-42b2-bcbf-a1cee7b3cf6e","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01KA9CXRhQgszmyHmWw1mcCt","type":"message","role":"assistant","content":[{"type":"text","text":"5ê°€ì§€ ì´ìŠˆë¥¼ ë™ì‹œì— ìˆ˜ì •í•©ë‹ˆë‹¤."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":90,"cache_read_input_tokens":93885,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":90},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPLJC75uE1NgJrrYTwK","type":"assistant","uuid":"3eabc1a1-7dce-4582-b1fb-8fea6da42009","timestamp":"2026-02-21T14:38:58.918Z"}
{"parentUuid":"3eabc1a1-7dce-4582-b1fb-8fea6da42009","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01KA9CXRhQgszmyHmWw1mcCt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XReSSi69dvd7gMNj291x6R","name":"Edit","input":{"replace_all":false,"file_path":"/Users/al02402336/everything/src/App.svelte","old_string":"    const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;","new_string":"    const isDark = theme === 'dark';"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":90,"cache_read_input_tokens":93885,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":90},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPLJC75uE1NgJrrYTwK","type":"assistant","uuid":"c4df8436-5711-4ed6-b1a1-9f7cf57ff642","timestamp":"2026-02-21T14:39:00.494Z"}
{"parentUuid":"c4df8436-5711-4ed6-b1a1-9f7cf57ff642","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>File has been modified since read, either by the user or by a linter. Read it again before attempting to write it.</tool_use_error>","is_error":true,"tool_use_id":"toolu_01XReSSi69dvd7gMNj291x6R"}]},"uuid":"16917a90-25ea-4dfc-aeac-9319cfe4f0e7","timestamp":"2026-02-21T14:39:00.494Z","toolUseResult":"Error: File has been modified since read, either by the user or by a linter. Read it again before attempting to write it.","sourceToolAssistantUUID":"c4df8436-5711-4ed6-b1a1-9f7cf57ff642"}
{"parentUuid":"16917a90-25ea-4dfc-aeac-9319cfe4f0e7","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01TkLeRrz2LhrV7tY46Zunrq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UZbCNPwhnkZFev7rH8Gq8X","name":"Read","input":{"file_path":"/Users/al02402336/everything/src/App.svelte","offset":670,"limit":10},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":233,"cache_read_input_tokens":93975,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":233},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPLb4rvnaMJfW7e4aG8","type":"assistant","uuid":"db79cd21-158c-4353-b209-6722c9967736","timestamp":"2026-02-21T14:39:02.780Z"}
{"parentUuid":"db79cd21-158c-4353-b209-6722c9967736","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01UZbCNPwhnkZFev7rH8Gq8X","toolUseID":"toolu_01UZbCNPwhnkZFev7rH8Gq8X","timestamp":"2026-02-21T14:39:02.788Z","uuid":"ba1ce53e-8373-4367-84d2-50dd2aad0036"}
{"parentUuid":"db79cd21-158c-4353-b209-6722c9967736","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UZbCNPwhnkZFev7rH8Gq8X","type":"tool_result","content":"   670â†’  }\n   671â†’\n   672â†’  function buildDragPreview(index) {\n   673â†’    const entry = results[index];\n   674â†’    if (!entry) return null;\n   675â†’\n   676â†’    const count = selectedIndices.has(index) ? selectedIndices.size : 1;\n   677â†’    const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\n   678â†’\n   679â†’    const w = 260;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"ef9fcb33-d8f9-4ccc-897e-38bbefbc0890","timestamp":"2026-02-21T14:39:02.787Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src/App.svelte","content":"  }\n\n  function buildDragPreview(index) {\n    const entry = results[index];\n    if (!entry) return null;\n\n    const count = selectedIndices.has(index) ? selectedIndices.size : 1;\n    const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\n\n    const w = 260;","numLines":10,"startLine":670,"totalLines":2277}},"sourceToolAssistantUUID":"db79cd21-158c-4353-b209-6722c9967736"}
{"type":"file-history-snapshot","messageId":"8baef013-3843-4882-98e8-e431ade589d2","snapshot":{"messageId":"1328a288-d2f6-4263-8570-b556ad230dfd","trackedFileBackups":{"src/App.svelte":{"backupFileName":"f2ffc3f5647f6015@v1","version":1,"backupTime":"2026-02-21T14:39:05.714Z"}},"timestamp":"2026-02-21T14:36:33.132Z"},"isSnapshotUpdate":true}
{"parentUuid":"ef9fcb33-d8f9-4ccc-897e-38bbefbc0890","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_019vz8jaPModkNamtL2ij44E","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NiJg1beLNcWdzC9VjfbAvs","name":"Edit","input":{"replace_all":false,"file_path":"/Users/al02402336/everything/src/App.svelte","old_string":"    const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;","new_string":"    const isDark = theme === 'dark';"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":314,"cache_read_input_tokens":94208,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":314},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPLmjoeNFvQGNbycgZy","type":"assistant","uuid":"8baef013-3843-4882-98e8-e431ade589d2","timestamp":"2026-02-21T14:39:05.710Z"}
{"parentUuid":"8baef013-3843-4882-98e8-e431ade589d2","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01NiJg1beLNcWdzC9VjfbAvs","toolUseID":"toolu_01NiJg1beLNcWdzC9VjfbAvs","timestamp":"2026-02-21T14:39:05.719Z","uuid":"096d169e-0d0f-49e5-afb7-021d45bad937"}
{"parentUuid":"8baef013-3843-4882-98e8-e431ade589d2","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NiJg1beLNcWdzC9VjfbAvs","type":"tool_result","content":"The file /Users/al02402336/everything/src/App.svelte has been updated successfully."}]},"uuid":"b8fc5a41-c56a-4165-8a4e-7c9bab901911","timestamp":"2026-02-21T14:39:05.718Z","toolUseResult":{"filePath":"/Users/al02402336/everything/src/App.svelte","oldString":"    const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;","newString":"    const isDark = theme === 'dark';","originalFile":"<script>\n  import { onDestroy, onMount, tick } from 'svelte';\n  import { invoke } from '@tauri-apps/api/core';\n  import { listen } from '@tauri-apps/api/event';\n  import { getCurrentWindow } from '@tauri-apps/api/window';\n  import { startDrag } from '@crabnebula/tauri-plugin-drag';\n\n  const rowHeight = 30;\n  const PAGE_SIZE = 500;\n  let homePrefix = '';\n  const COL_WIDTHS_KEY = 'REDACTED';\n  const THEME_KEY = 'everything-theme';\n  const columnKeys = ['name', 'path', 'size', 'modified'];\n  const minColumnWidth = {\n    name: 180,\n    path: 240,\n    size: 75,\n    modified: 150\n  };\n  const defaultColumnRatios = {\n    name: 0.3,\n    path: 0.45,\n    size: 0.1\n  };\n\n  const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';\n  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || systemTheme; } catch { return systemTheme; } })();\n  function cycleTheme() {\n    theme = theme === 'dark' ? 'light' : 'dark';\n    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n    invoke('set_native_theme', { theme });\n  }\n\n  let query = '';\n  let results = [];\n  let totalResults = 0;\n  let totalResultsKnown = false;\n\n  let dbLatencyMs = null;\n  let dbLastQuery = '';\n  let searchModeLabel = '';\n  let selectedIndices = new Set();\n  let selectionAnchor = -1;\n  let lastSelectedIndex = -1;\n  let editing = {\n    active: false,\n    path: '',\n    index: -1,\n    draftName: ''\n  };\n\n  let renameOverlay = { top: 0, left: 0, width: 0 };\n\n  let indexStatus = {\n    state: 'Indexing',\n    entriesCount: 0,\n    lastUpdated: null,\n    permissionErrors: 0,\n    message: null,\n    isCatchup: false\n  };\n\n  let indexingStartTime = null;\n  let indexingElapsed = '';\n  let indexingFinishedAt = '';\n\n  let sortBy = 'name';\n  let sortDir = 'asc';\n\n  let hasMore = true;\n  let loadingMore = false;\n  let searchGeneration = 0;\n\n  let scanned = 0;\n\n  let searchInputEl;\n  let renameInputEl;\n  let tableAreaEl;\n  let tableContainer;\n  let tableResizeObserver = null;\n  let viewportResizeRaf = null;\n  let scrollTop = 0;\n  let headerScrollLeft = 0;\n  let viewportHeight = 520;\n  let lastTableWidth = 0;\n  let resizingColumn = '';\n  let resizeCleanup = null;\n  let colWidths = {\n    name: 250,\n    path: 350,\n    size: 75,\n    modified: 150\n  };\n\n  let contextMenu = {\n    visible: false,\n    x: 0,\n    y: 0\n  };\n\n  let platform = '';\n  let toast = '';\n  let searchTimer;\n  let lastSearchFiredAt = 0;\n  let toastTimer;\n  let statusRefreshTimer;\n  let elapsedTimer;\n  let statusRefreshInFlight = false;\n  let lastReadyCount = 0;\n\n  const iconCache = new Map();\n  const iconLoading = new Set();\n\n  let highlightCache = new Map();\n  let highlightCacheQuery = '';\n\n  const folderFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='1' y='4' width='14' height='10' rx='2' fill='#d9b34f'/><rect x='1' y='2' width='6' height='4' rx='1' fill='#e6ca7a'/></svg>`\n    );\n  const fileFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='3' y='1' width='10' height='14' rx='1.5' fill='#b4bec9'/><rect x='5' y='5' width='6' height='1.2' fill='#8d98a5'/><rect x='5' y='8' width='6' height='1.2' fill='#8d98a5'/></svg>`\n    );\n\n  $: totalHeight = results.length * rowHeight;\n  $: startIndex = Math.max(0, Math.floor(scrollTop / rowHeight) - 10);\n  $: visibleCount = Math.ceil(viewportHeight / rowHeight) + 20;\n  $: endIndex = Math.min(results.length, startIndex + visibleCount);\n  $: visibleRows = results.slice(startIndex, endIndex);\n  $: translateY = startIndex * rowHeight;\n  $: tableMinWidth = colWidths.name + colWidths.path + colWidths.size + colWidths.modified;\n  $: tableGridStyle = `--col-name:${colWidths.name}px;--col-path:${colWidths.path}px;--col-size:${colWidths.size}px;--col-modified:${colWidths.modified}px;--table-min-width:${tableMinWidth}px;--header-offset:${-headerScrollLeft}px;`;\n\n  $: {\n    for (const entry of visibleRows) {\n      void ensureIcon(entry);\n    }\n  }\n\n  function showToast(message) {\n    toast = message;\n    clearTimeout(toastTimer);\n    toastTimer = setTimeout(() => {\n      toast = '';\n    }, 3000);\n  }\n\n  function bytesToBase64(bytes) {\n    let binary = '';\n    const chunk = 0x8000;\n    for (let i = 0; i < bytes.length; i += chunk) {\n      const part = bytes.subarray(i, i + chunk);\n      binary += String.fromCharCode(...part);\n    }\n    return btoa(binary);\n  }\n\n  function highlightSegments(name, q) {\n    q = (q || '').trim();\n    if (!q) return [{ text: name, hl: false }];\n\n    // Reset cache when query changes\n    if (q !== highlightCacheQuery) {\n      highlightCache = new Map();\n      highlightCacheQuery = q;\n    }\n\n    // Check cache\n    const cached = highlightCache.get(name);\n    if (cached) return cached;\n\n    if (q.includes('/')) q = q.slice(q.lastIndexOf('/') + 1);\n    q = q.replace(/[*?]/g, '');\n    const terms = q.split(/\\s+/).filter(Boolean);\n    if (terms.length === 0) return [{ text: name, hl: false }];\n\n    const lower = name.toLowerCase();\n    const marks = new Uint8Array(name.length);\n    for (const t of terms) {\n      const tl = t.toLowerCase();\n      let idx = lower.indexOf(tl);\n      while (idx !== -1) {\n        for (let i = idx; i < idx + tl.length; i++) marks[i] = 1;\n        idx = lower.indexOf(tl, idx + 1);\n      }\n    }\n\n    const segs = [];\n    let i = 0;\n    while (i < name.length) {\n      const m = marks[i];\n      let j = i + 1;\n      while (j < name.length && marks[j] === m) j++;\n      segs.push({ text: name.slice(i, j), hl: m === 1 });\n      i = j;\n    }\n\n    highlightCache.set(name, segs);\n    return segs;\n  }\n\n  const perFileIconExts = new Set(['exe', 'lnk', 'ico', 'url', 'scr', 'appx']);\n\n  function iconKey(entry) {\n    if (entry.isDir) return '__folder__';\n    const ext = (entry.ext || '').toLowerCase();\n    if (perFileIconExts.has(ext)) return entry.path;\n    return ext || '__file__';\n  }\n\n  function iconFor(entry) {\n    return iconCache.get(iconKey(entry)) || (entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n  }\n\n  async function ensureIcon(entry) {\n    const key = iconKey(entry);\n    if (iconCache.has(key) || iconLoading.has(key)) {\n      return;\n    }\n\n    iconLoading.add(key);\n    try {\n      const bytes = await invoke('get_file_icon', {\n        path: entry.path,\n        ext: entry.isDir ? 'folder' : entry.ext || '',\n      });\n      if (Array.isArray(bytes) && bytes.length > 0) {\n        const image = `data:image/png;base64,${bytesToBase64(Uint8Array.from(bytes))}`;\n        iconCache.set(key, image);\n      } else {\n        iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n      }\n    } catch {\n      iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n    } finally {\n      iconLoading.delete(key);\n    }\n  }\n\n  function syncColumnWidthsToContainer() {\n    const width = tableContainer?.clientWidth || tableAreaEl?.clientWidth;\n    if (!width || lastTableWidth !== 0) {\n      return;\n    }\n\n    const saved = loadColWidths();\n    if (saved) {\n      const total = columnKeys.reduce((s, k) => s + saved[k], 0);\n      if (Math.abs(total - width) > 2) {\n        const scale = (width - saved.modified) / (total - saved.modified);\n        let scaledName = Math.max(minColumnWidth.name, Math.round(saved.name * scale));\n        let scaledSize = Math.max(minColumnWidth.size, Math.round(saved.size * scale));\n        let rawPath = width - saved.modified - scaledName - scaledSize;\n        if (rawPath < minColumnWidth.path) {\n          const shortfall = minColumnWidth.path - rawPath;\n          const nameReduction = Math.min(shortfall, scaledName - minColumnWidth.name);\n          scaledName -= nameReduction;\n          const remaining = shortfall - nameReduction;\n          if (remaining > 0) {\n            scaledSize -= Math.min(remaining, scaledSize - minColumnWidth.size);\n          }\n          rawPath = width - saved.modified - scaledName - scaledSize;\n        }\n        const scaledPath = Math.max(minColumnWidth.path, rawPath);\n        colWidths = { name: scaledName, path: scaledPath, size: scaledSize, modified: saved.modified };\n      } else {\n        colWidths = saved;\n      }\n    } else {\n      const fixedModified = minColumnWidth.modified;\n      const rest = width - fixedModified;\n      const ratioSum = defaultColumnRatios.name + defaultColumnRatios.path + defaultColumnRatios.size;\n      colWidths = {\n        name: Math.max(minColumnWidth.name, Math.round(rest * defaultColumnRatios.name / ratioSum)),\n        path: Math.max(minColumnWidth.path, Math.round(rest * defaultColumnRatios.path / ratioSum)),\n        size: Math.max(minColumnWidth.size, Math.round(rest * defaultColumnRatios.size / ratioSum)),\n        modified: fixedModified\n      };\n    }\n    lastTableWidth = width;\n  }\n\n  function loadColWidths() {\n    try {\n      const raw = localStorage.getItem(COL_WIDTHS_KEY);\n      if (!raw) return null;\n      const parsed = JSON.parse(raw);\n      for (const key of columnKeys) {\n        if (typeof parsed[key] !== 'number' || parsed[key] < (minColumnWidth[key] || 0)) return null;\n      }\n      return parsed;\n    } catch {\n      return null;\n    }\n  }\n\n  function saveColWidths() {\n    localStorage.setItem(COL_WIDTHS_KEY, JSON.stringify(colWidths));\n  }\n\n  function updateViewportHeight() {\n    viewportHeight = tableContainer?.clientHeight || 520;\n    syncColumnWidthsToContainer();\n  }\n\n  function scheduleViewportHeightUpdate() {\n    if (viewportResizeRaf !== null) {\n      return;\n    }\n    viewportResizeRaf = requestAnimationFrame(() => {\n      viewportResizeRaf = null;\n      updateViewportHeight();\n    });\n  }\n\n  function startColumnResize(event, leftKey) {\n    event.preventDefault();\n    event.stopPropagation();\n\n    const index = columnKeys.indexOf(leftKey);\n    if (index < 0 || index >= columnKeys.length - 1) {\n      return;\n    }\n\n    const startX = event.clientX;\n    const startLeft = colWidths[leftKey];\n    const rightKey = columnKeys[index + 1];\n    const startRight = colWidths[rightKey];\n\n    resizeCleanup?.();\n    resizingColumn = leftKey;\n\n    const onMove = (moveEvent) => {\n      const delta = Math.round(moveEvent.clientX - startX);\n      if (leftKey === 'name') {\n        // Two-column trade: name and path swap space, each respects its minimum\n        const nextLeft = Math.max(\n          minColumnWidth[leftKey],\n          Math.min(startLeft + delta, startLeft + startRight - minColumnWidth[rightKey])\n        );\n        const nextRight = startLeft + startRight - nextLeft;\n        colWidths = { ...colWidths, [leftKey]: nextLeft, [rightKey]: nextRight };\n      } else {\n        // path splitter: path grows unconstrained (allows horizontal scroll on right drag)\n        const nextLeft = Math.max(minColumnWidth[leftKey], startLeft + delta);\n        colWidths = { ...colWidths, [leftKey]: nextLeft };\n      }\n    };\n\n    const onUp = () => {\n      cleanup();\n    };\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      document.body.style.cursor = '';\n      document.body.style.userSelect = '';\n      resizingColumn = '';\n      saveColWidths();\n      if (resizeCleanup === cleanup) {\n        resizeCleanup = null;\n      }\n    };\n\n    resizeCleanup = cleanup;\n    document.body.style.cursor = 'col-resize';\n    document.body.style.userSelect = 'none';\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  function selectedPaths() {\n    const sorted = [...selectedIndices].sort((a, b) => a - b);\n    return sorted.map((idx) => results[idx]).filter(Boolean).map((entry) => entry.path);\n  }\n\n  function clearSelection() {\n    selectedIndices = new Set();\n    selectionAnchor = -1;\n    lastSelectedIndex = -1;\n  }\n\n  function selectSingle(index) {\n    selectedIndices = new Set([index]);\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectToggle(index) {\n    const next = new Set(selectedIndices);\n    if (next.has(index)) {\n      next.delete(index);\n    } else {\n      next.add(index);\n    }\n    selectedIndices = next;\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectRange(index) {\n    const anchor = selectionAnchor >= 0 ? selectionAnchor : index;\n    const [from, to] = [Math.min(anchor, index), Math.max(anchor, index)];\n    const next = new Set();\n    for (let i = from; i <= to; i += 1) {\n      next.add(i);\n    }\n    selectedIndices = next;\n    lastSelectedIndex = index;\n  }\n\n  function primaryEntry() {\n    const idx = lastSelectedIndex >= 0 ? lastSelectedIndex : -1;\n    return idx >= 0 ? results[idx] : null;\n  }\n\n  async function refreshStatus() {\n    if (statusRefreshInFlight) {\n      return;\n    }\n    statusRefreshInFlight = true;\n    try {\n      const status = await invoke('get_index_status');\n      const prevState = indexStatus.state;\n      indexStatus = {\n        state: status.state,\n        entriesCount: status.entriesCount,\n        lastUpdated: status.lastUpdated,\n        permissionErrors: status.permissionErrors ?? 0,\n        message: status.message\n      };\n      if (status.state === 'Indexing' && prevState !== 'Indexing') {\n        startElapsedTimer();\n      } else if (status.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n      if (typeof status.scanned === 'number') {\n        scanned = status.scanned;\n      }\n      if (status.state === 'Ready' && prevState !== 'Ready') {\n        scheduleSearch();\n      }\n    } catch (err) {\n      showToast(`Failed to get status: ${String(err)}`);\n    } finally {\n      statusRefreshInFlight = false;\n    }\n  }\n\n  function scheduleSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const scheduledGen = searchGeneration;\n    clearTimeout(searchTimer);\n\n    const now = performance.now();\n    if (now - lastSearchFiredAt >= 200) {\n      // Leading edge: fire immediately if enough time has passed\n      lastSearchFiredAt = now;\n      void runSearch(preserveScroll);\n    } else {\n      // Trailing edge: debounce\n      searchTimer = setTimeout(() => {\n        if (scheduledGen !== searchGeneration) {\n          return;\n        }\n        lastSearchFiredAt = performance.now();\n        void runSearch(preserveScroll);\n      }, 200);\n    }\n  }\n\n  async function runSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const gen = searchGeneration;\n    const searchQuery = query;\n    const searchSortBy = sortBy;\n    const searchSortDir = sortDir;\n    const startedAt = performance.now();\n    try {\n      const keepPaths = new Set(selectedPaths());\n      const next = await invoke('search', {\n        query: searchQuery,\n        limit: PAGE_SIZE,\n        offset: 0,\n        sortBy: searchSortBy,\n        sortDir: searchSortDir\n      });\n\n      if (gen !== searchGeneration) return;\n\n      dbLatencyMs = Math.round(performance.now() - startedAt);\n      dbLastQuery = searchQuery;\n      const entries = Array.isArray(next.entries) ? next.entries : [];\n      searchModeLabel = next.modeLabel || '';\n      results = entries;\n      if (next.totalCount > 0) {\n        totalResults = next.totalCount;\n        totalResultsKnown = true;\n      } else {\n        totalResults = entries.length;\n        totalResultsKnown = false;\n      }\n      hasMore = totalResultsKnown ? results.length < totalResults : entries.length >= PAGE_SIZE;\n      if (!preserveScroll && tableContainer) tableContainer.scrollTop = 0;\n\n      const restored = new Set();\n      for (let i = 0; i < results.length; i += 1) {\n        if (keepPaths.has(results[i].path)) {\n          restored.add(i);\n        }\n      }\n      selectedIndices = restored;\n\n      updateViewportHeight();\n    } catch (err) {\n      if (gen !== searchGeneration) return;\n      showToast(`Search failed: ${String(err)}`);\n    }\n  }\n\n  async function loadMore() {\n    if (!hasMore || loadingMore) return;\n    const gen = searchGeneration;\n    loadingMore = true;\n    try {\n      const batch = await invoke('search', {\n        query,\n        limit: PAGE_SIZE,\n        offset: results.length,\n        sortBy: sortBy,\n        sortDir: sortDir\n      });\n      if (gen !== searchGeneration) return;\n      const arr = Array.isArray(batch.entries) ? batch.entries : [];\n      if (arr.length > 0) results = [...results, ...arr];\n      hasMore = totalResultsKnown ? results.length < totalResults : arr.length >= PAGE_SIZE;\n    } catch (err) {\n      showToast(`Failed to load more: ${String(err)}`);\n    } finally {\n      loadingMore = false;\n    }\n  }\n\n  function moveSelection(delta, withRange = false) {\n    if (results.length === 0) {\n      return;\n    }\n\n    const current = lastSelectedIndex >= 0 ? lastSelectedIndex : 0;\n    const next = Math.max(0, Math.min(results.length - 1, current + delta));\n\n    if (withRange) {\n      selectRange(next);\n    } else {\n      selectSingle(next);\n    }\n\n    const top = next * rowHeight;\n    const bottom = top + rowHeight;\n    if (top < scrollTop) {\n      tableContainer.scrollTop = top;\n    } else if (bottom > scrollTop + viewportHeight) {\n      tableContainer.scrollTop = bottom - viewportHeight;\n    }\n  }\n\n  function handleHeaderSort(column) {\n    if (sortBy === column) {\n      sortDir = sortDir === 'asc' ? 'desc' : 'asc';\n    } else {\n      sortBy = column;\n      sortDir = 'asc';\n    }\n    if (tableContainer) tableContainer.scrollTop = 0;\n    void runSearch();\n  }\n\n  function handleRowClick(event, index) {\n    contextMenu.visible = false;\n\n    if (event.shiftKey) {\n      selectRange(index);\n      return;\n    }\n\n    if (event.metaKey || event.ctrlKey) {\n      selectToggle(index);\n      return;\n    }\n\n    selectSingle(index);\n  }\n\n  function handleRowContextMenu(event, index) {\n    event.preventDefault();\n\n    if (!selectedIndices.has(index)) {\n      selectSingle(index);\n    }\n\n    if (platform === 'windows' || platform === 'macos') {\n      contextMenu.visible = false;\n      const paths = selectedPaths();\n      if (paths.length > 0) {\n        invoke('show_context_menu', {\n          paths,\n          x: event.clientX,\n          y: event.clientY,\n          singleSelection: selectedIndices.size === 1\n        });\n      }\n      return;\n    }\n\n    contextMenu = {\n      visible: true,\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n\n  function handleRowA11yKeydown(event, index) {\n    if (event.key === ' ' || event.key === 'Enter') {\n      event.preventDefault();\n      handleRowClick(event, index);\n    }\n  }\n\n  const DRAG_THRESHOLD = 5;\n  let dragCleanup = null;\n  const dragImgCache = new Map();\n\n  function dragPathsForIndex(index) {\n    const entry = results[index];\n    if (!entry) {\n      return [];\n    }\n\n    if (selectedIndices.has(index) && selectedIndices.size > 0) {\n      return selectedPaths();\n    }\n\n    return [entry.path];\n  }\n\n  function getDragIconEl(entry) {\n    const src = iconFor(entry);\n    let img = dragImgCache.get(src);\n    if (!img) {\n      img = new Image();\n      img.src = src;\n      dragImgCache.set(src, img);\n    }\n    return img.complete && img.naturalWidth > 0 ? img : null;\n  }\n\n  function fillRoundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function buildDragPreview(index) {\n    const entry = results[index];\n    if (!entry) return null;\n\n    const count = selectedIndices.has(index) ? selectedIndices.size : 1;\n    const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\n\n    const w = 260;\n    const h = 28;\n    const stackGap = count > 1 ? 4 : 0;\n\n    const canvas = document.createElement('canvas');\n    canvas.width = w;\n    canvas.height = h + stackGap;\n    const ctx = canvas.getContext('2d');\n\n    if (count > 1) {\n      ctx.globalAlpha = 0.35;\n      ctx.fillStyle = isDark ? '#5a6070' : '#b0c4de';\n      fillRoundRect(ctx, 3, 0, w - 3, h, 5);\n      ctx.globalAlpha = 1.0;\n    }\n\n    const ry = stackGap;\n    ctx.fillStyle = isDark ? 'rgba(58, 64, 74, 0.94)' : 'rgba(214, 231, 255, 0.94)';\n    fillRoundRect(ctx, 0, ry, w, h, 5);\n\n    ctx.strokeStyle = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';\n    ctx.lineWidth = 0.5;\n    ctx.beginPath();\n    ctx.moveTo(5, ry);\n    ctx.arcTo(w, ry, w, ry + h, 5);\n    ctx.arcTo(w, ry + h, 0, ry + h, 5);\n    ctx.arcTo(0, ry + h, 0, ry, 5);\n    ctx.arcTo(0, ry, w, ry, 5);\n    ctx.closePath();\n    ctx.stroke();\n\n    const iconEl = getDragIconEl(entry);\n    if (iconEl) {\n      ctx.drawImage(iconEl, 6, ry + 6, 16, 16);\n    } else {\n      ctx.fillStyle = entry.isDir ? '#d9b34f' : '#8d98a5';\n      fillRoundRect(ctx, 6, ry + 6, 16, 16, 2);\n    }\n\n    ctx.fillStyle = isDark ? '#e6e6e8' : '#1a1a1a';\n    ctx.font = '12px -apple-system, \"SF Pro Text\", system-ui, sans-serif';\n    ctx.textBaseline = 'middle';\n\n    let nameMaxW = w - 34;\n    if (count > 1) nameMaxW -= 34;\n\n    let name = entry.name;\n    if (ctx.measureText(name).width > nameMaxW) {\n      while (name.length > 4 && ctx.measureText(name + '\\u2026').width > nameMaxW) {\n        name = name.slice(0, -1);\n      }\n      name += '\\u2026';\n    }\n    ctx.fillText(name, 28, ry + h / 2 + 1);\n\n    if (count > 1) {\n      const badge = String(count);\n      ctx.font = 'bold 10px -apple-system, system-ui, sans-serif';\n      const tw = ctx.measureText(badge).width;\n      const bw = Math.max(20, tw + 10);\n      const bx = w - bw - 6;\n      const by = ry + (h - 18) / 2;\n\n      ctx.fillStyle = isDark ? '#5b8bd9' : '#007aff';\n      fillRoundRect(ctx, bx, by, bw, 18, 9);\n\n      ctx.fillStyle = '#ffffff';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(badge, bx + bw / 2, by + 9);\n    }\n\n    return canvas.toDataURL('image/png');\n  }\n\n  function handleRowMouseDown(event, index) {\n    if (event.button !== 0) return;\n    if (event.metaKey || event.ctrlKey || event.shiftKey) return;\n    if (editing.active) return;\n\n    const startX = event.clientX;\n    const startY = event.clientY;\n    let dragging = false;\n\n    dragCleanup?.();\n\n    const onMove = (e) => {\n      if (dragging) return;\n      const dx = e.clientX - startX;\n      const dy = e.clientY - startY;\n      if (dx * dx + dy * dy < DRAG_THRESHOLD * DRAG_THRESHOLD) return;\n\n      dragging = true;\n      cleanup();\n\n      if (!selectedIndices.has(index)) {\n        selectSingle(index);\n      }\n\n      const paths = dragPathsForIndex(index);\n      if (paths.length > 0) {\n        const icon = buildDragPreview(index);\n        startDrag({ item: paths, icon }).catch(() => {});\n      }\n    };\n\n    const onUp = () => cleanup();\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      if (dragCleanup === cleanup) dragCleanup = null;\n    };\n\n    dragCleanup = cleanup;\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  async function handleRowDoubleClick(index) {\n    if (!selectedIndices.has(index) || selectedIndices.size > 1) {\n      selectSingle(index);\n      await tick();\n    }\n    await invoke('open', { paths: [results[index].path] }).catch((err) => {\n      showToast(`Failed to open: ${String(err)}`);\n    });\n  }\n\n  function closeContextMenu() {\n    contextMenu = {\n      ...contextMenu,\n      visible: false\n    };\n  }\n\n  async function openSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('open', { paths });\n    } catch (err) {\n      showToast(`Failed to open: ${String(err)}`);\n    }\n  }\n\n  async function openWithFallback() {\n    const target = primaryEntry();\n    if (!target) {\n      return;\n    }\n\n    try {\n      await invoke('open_with', { path: target.path });\n    } catch (err) {\n      showToast(`Open With failed: ${String(err)}`);\n    }\n  }\n\n  async function revealSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('reveal_in_finder', { paths });\n    } catch (err) {\n      showToast(`Failed to reveal in Finder: ${String(err)}`);\n    }\n  }\n\n  async function copySelectedPaths() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_paths', { paths });\n      showToast(`Copied ${paths.length} path(s)`);\n    } catch (err) {\n      showToast(`Failed to copy path: ${String(err)}`);\n    }\n  }\n\n  async function copyFiles() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_files', { paths });\n      showToast(`Copied ${paths.length} item(s)`);\n    } catch (err) {\n      showToast(`Failed to copy: ${String(err)}`);\n    }\n  }\n\n  async function trashSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    const message =\n      paths.length === 1\n        ? 'Move selected item to Trash?'\n        : `Move ${paths.length} items to Trash?`;\n\n    if (!window.confirm(message)) {\n      return;\n    }\n\n    try {\n      await invoke('move_to_trash', { paths });\n      showToast('Moved to Trash.');\n      clearSelection();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to move to Trash: ${String(err)}`);\n    }\n  }\n\n  async function resetIndex() {\n    if (indexStatus.state === 'Indexing') {\n      showToast('Indexing in progress. Please try again after it completes.');\n      return;\n    }\n\n    results = [];\n    totalResults = 0;\n    totalResultsKnown = false;\n    clearSelection();\n    scanned = 0;\n    dbLatencyMs = null;\n    dbLastQuery = '';\n    indexStatus = { ...indexStatus, state: 'Indexing', entriesCount: 0, message: null };\n    indexingStartTime = Date.now();\n    indexingElapsed = '';\n    indexingFinishedAt = '';\n\n    try {\n      await invoke('reset_index');\n    } catch (err) {\n      showToast(`Failed to reset index: ${String(err)}`);\n      await refreshStatus();\n    }\n  }\n\n  function isMultiSelected() {\n    return selectedIndices.size > 1;\n  }\n\n  function autoResizeRenameInput() {\n    if (!renameInputEl) return;\n    renameInputEl.style.height = '0';\n    renameInputEl.style.height = renameInputEl.scrollHeight + 'px';\n  }\n\n  async function startRename() {\n    if (isMultiSelected()) {\n      return;\n    }\n\n    const idx = lastSelectedIndex;\n    if (idx < 0 || !results[idx]) {\n      return;\n    }\n\n    const entry = results[idx];\n\n    // Calculate overlay position mathematically.\n    // Name cell text starts at: padding-left(16) + icon(16) + gap(6) = 38px from cell left.\n    // Textarea has padding-left: 0 and border: 1.5px, so text starts ~2px from overlay left.\n    if (tableContainer) {\n      const rect = tableContainer.getBoundingClientRect();\n      const cellLeft = rect.left - tableContainer.scrollLeft;\n      const textLeft = cellLeft + 38;\n      const cellRight = cellLeft + colWidths.name;\n      const rowTop = rect.top + idx * rowHeight - tableContainer.scrollTop;\n      renameOverlay = {\n        top: rowTop,\n        left: textLeft - 2,\n        width: cellRight - textLeft + 2 - 4\n      };\n    }\n\n    editing = {\n      active: true,\n      path: entry.path,\n      index: idx,\n      draftName: entry.name\n    };\n\n    await tick();\n\n    if (renameInputEl) {\n      autoResizeRenameInput();\n      renameInputEl.focus();\n      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n      renameInputEl.setSelectionRange(0, selectionEnd);\n    }\n  }\n\n  function cancelRename() {\n    editing = {\n      active: false,\n      path: '',\n      index: -1,\n      draftName: ''\n    };\n  }\n\n  async function commitRename() {\n    if (!editing.active || editing.index < 0 || !results[editing.index]) {\n      return;\n    }\n\n    const current = results[editing.index];\n    const nextName = editing.draftName;\n\n    try {\n      await invoke('rename', {\n        path: current.path,\n        newName: nextName\n      });\n      cancelRename();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to rename: ${String(err)}`);\n      await tick();\n      renameInputEl?.focus();\n    }\n  }\n\n  function onGlobalClick() {\n    closeContextMenu();\n  }\n\n  function onTitleBarMouseDown(event) {\n    if (event.button !== 0) {\n      return;\n    }\n\n    const activeElement = document.activeElement;\n    if (activeElement instanceof HTMLElement && isTextInputTarget(activeElement)) {\n      activeElement.blur();\n    }\n  }\n\n  async function focusSearch() {\n    await getCurrentWindow().show();\n    await getCurrentWindow().setFocus();\n    searchInputEl?.focus();\n    searchInputEl?.select();\n  }\n\n  function isTextInputTarget(target) {\n    return (\n      target instanceof HTMLInputElement ||\n      target instanceof HTMLTextAreaElement ||\n      target?.isContentEditable\n    );\n  }\n\n  async function handleKeydown(event) {\n    const isMetaSelectAll = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'a';\n    const isMetaCopy = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c';\n    const target = event.target;\n    const isTextInput = isTextInputTarget(target);\n\n    if (isMetaCopy && isTextInput) {\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      if (isTextInput) {\n        event.preventDefault();\n        if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n          target.select();\n        }\n        return;\n      }\n    }\n\n    if (editing.active) {\n      if (event.key === 'Enter') {\n        event.preventDefault();\n        await commitRename();\n        return;\n      }\n\n      if (event.key === 'Escape') {\n        event.preventDefault();\n        const idx = editing.index;\n        cancelRename();\n        selectSingle(idx);\n        await tick();\n        tableContainer?.querySelector('.row.selected')?.focus();\n        return;\n      }\n      return;\n    }\n\n    if (event.key === 'Escape') {\n      event.preventDefault();\n      clearSelection();\n      return;\n    }\n\n    if (event.key === 'ArrowDown') {\n      event.preventDefault();\n      moveSelection(1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'ArrowUp') {\n      event.preventDefault();\n      moveSelection(-1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageDown') {\n      event.preventDefault();\n      moveSelection(Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageUp') {\n      event.preventDefault();\n      moveSelection(-Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'Enter') {\n      event.preventDefault();\n      if (platform === 'windows') {\n        await openSelected();\n      } else {\n        await startRename();\n      }\n      return;\n    }\n\n    if (event.key === 'F2') {\n      event.preventDefault();\n      await startRename();\n      return;\n    }\n\n    if (event.key === ' ' && !isTextInput) {\n      event.preventDefault();\n      const entry = primaryEntry();\n      if (entry) {\n        await invoke('quick_look', { path: entry.path });\n      }\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'f') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      searchInputEl?.select();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'o') {\n      event.preventDefault();\n      await openSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {\n      event.preventDefault();\n      await revealSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c') {\n      event.preventDefault();\n      await copySelectedPaths();\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      event.preventDefault();\n      selectedIndices = new Set(Array.from({ length: results.length }, (_, i) => i));\n      return;\n    }\n\n    if (event.key === 'Delete' || ((event.metaKey || event.ctrlKey) && event.key === 'Backspace')) {\n      if (!isTextInput) {\n        event.preventDefault();\n        await trashSelected();\n      }\n      return;\n    }\n  }\n\n  function formatSize(entry) {\n    if (entry.isDir || entry.size == null) return '';\n    const bytes = entry.size;\n    if (bytes < 1024) return `${bytes} B`;\n    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n    return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n  }\n\n  function formatModified(entry) {\n    if (!entry.mtime) {\n      return '';\n    }\n\n    const d = new Date(entry.mtime * 1000);\n    const pad = (n) => String(n).padStart(2, '0');\n    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;\n  }\n\n  function formatLastUpdated(timestamp) {\n    if (!timestamp) {\n      return '-';\n    }\n\n    return new Date(timestamp * 1000).toLocaleString();\n  }\n\n  function formatElapsed(ms) {\n    const totalSec = Math.floor(ms / 1000);\n    const min = Math.floor(totalSec / 60);\n    const sec = totalSec % 60;\n    return min > 0 ? `${min}m ${sec}s` : `${sec}s`;\n  }\n\n  function updateElapsed() {\n    if (indexingStartTime && indexStatus.state === 'Indexing') {\n      indexingElapsed = formatElapsed(Date.now() - indexingStartTime);\n    }\n  }\n\n  function startElapsedTimer() {\n    clearInterval(elapsedTimer);\n    indexingStartTime = Date.now();\n    indexingElapsed = '0s';\n    indexingFinishedAt = '';\n    elapsedTimer = setInterval(updateElapsed, 1000);\n  }\n\n  function stopElapsedTimer() {\n    clearInterval(elapsedTimer);\n    if (indexingStartTime) {\n      const elapsed = Date.now() - indexingStartTime;\n      indexingFinishedAt = `${formatElapsed(elapsed)}`;\n    }\n    indexingStartTime = null;\n    indexingElapsed = '';\n  }\n\n  function displayPath(path) {\n    if (!path) {\n      return path;\n    }\n\n    if (!homePrefix) {\n      return path;\n    }\n\n    if (path === homePrefix) {\n      return '~';\n    }\n\n    if (path.startsWith(`${homePrefix}/`)) {\n      return `~${path.slice(homePrefix.length)}`;\n    }\n\n    return path;\n  }\n\n  let unlistenFns = [];\n\n  onMount(async () => {\n    const t0 = performance.now();\n    const ms = () => Math.round(performance.now() - t0);\n    const DEBUG_STARTUP = false;\n    const flog = DEBUG_STARTUP ? (msg) => invoke('frontend_log', { msg }).catch(() => {}) : () => {};\n\n    flog(`[startup/fe] onMount entered`);\n\n    updateViewportHeight();\n    flog(`[startup/fe] +${ms()}ms updateViewportHeight done`);\n\n    invoke('set_native_theme', { theme });\n\n    platform = await invoke('get_platform');\n    flog(`[startup/fe] +${ms()}ms get_platform done`);\n\n    const unlistenProgress = await listen('index_progress', (event) => {\n      scanned = event.payload.scanned;\n      if (indexStatus.state !== 'Indexing') {\n        indexStatus = {\n          ...indexStatus,\n          state: 'Indexing'\n        };\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_progress) registered`);\n\n    const unlistenState = await listen('index_state', (event) => {\n      flog(`[startup/fe] index_state event received: ${event.payload.state} at +${ms()}ms`);\n      const prevState = indexStatus.state;\n      indexStatus = {\n        ...indexStatus,\n        state: event.payload.state,\n        message: event.payload.message ?? null,\n        isCatchup: event.payload.isCatchup ?? false\n      };\n\n      if (event.payload.state === 'Indexing' && prevState !== 'Indexing') {\n        if (prevState === 'Ready') {\n          lastReadyCount = indexStatus.entriesCount;\n        }\n        startElapsedTimer();\n      } else if (event.payload.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n\n      if (event.payload.state === 'Ready') {\n        scheduleSearch();\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_state) registered`);\n\n    const unlistenUpdated = await listen('index_updated', (event) => {\n      indexStatus = {\n        ...indexStatus,\n        entriesCount: event.payload.entriesCount,\n        lastUpdated: event.payload.lastUpdated,\n        permissionErrors: event.payload.permissionErrors ?? indexStatus.permissionErrors\n      };\n\n      scheduleSearch(true);\n    });\n\n    const unlistenFocus = await listen('focus_search', () => {\n      void focusSearch();\n    });\n\n    const unlistenCtxMenuAction = await listen('context_menu_action', (event) => {\n      switch (event.payload) {\n        case 'open': void openSelected(); break;\n        case 'quick_look': {\n          const e = primaryEntry();\n          if (e) void invoke('quick_look', { path: e.path });\n          break;\n        }\n        case 'open_with': void openWithFallback(); break;\n        case 'reveal': void revealSelected(); break;\n        case 'copy_files': void copyFiles(); break;\n        case 'copy_path': void copySelectedPaths(); break;\n        case 'trash': void trashSelected(); break;\n        case 'rename': void startRename(); break;\n      }\n    });\n\n    unlistenFns = [unlistenProgress, unlistenState, unlistenUpdated, unlistenFocus, unlistenCtxMenuAction];\n    flog(`[startup/fe] +${ms()}ms all listeners registered`);\n\n    // Fetch backend state IMMEDIATELY after listeners are registered.\n    // Events emitted before listener registration are lost, so this\n    // is the only reliable way to get the current state.\n    await refreshStatus();\n    flog(`[startup/fe] +${ms()}ms refreshStatus done (state=${indexStatus.state})`);\n\n    // Show Svelte UI: remove skeleton, focus search input.\n    await tick();\n    document.getElementById('skeleton')?.remove();\n    await focusSearch();\n    flog(`[startup/fe] +${ms()}ms WINDOW VISIBLE â€” skeleton removed`);\n\n    try {\n      homePrefix = await invoke('get_home_dir');\n    } catch {\n      homePrefix = '';\n    }\n    flog(`[startup/fe] +${ms()}ms get_home_dir done`);\n\n    if (!localStorage.getItem('everything-fda-notice-v1')) {\n      showToast('macOS Full Disk Access permission may be required for full disk search.');\n      localStorage.setItem('everything-fda-notice-v1', '1');\n    }\n    flog(`[startup/fe] +${ms()}ms calling runSearch...`);\n    await runSearch();\n    flog(`[startup/fe] +${ms()}ms runSearch done`);\n\n    if (typeof ResizeObserver !== 'undefined') {\n      tableResizeObserver = new ResizeObserver(() => {\n        scheduleViewportHeightUpdate();\n      });\n      if (tableContainer) {\n        tableResizeObserver.observe(tableContainer);\n      } else if (tableAreaEl) {\n        tableResizeObserver.observe(tableAreaEl);\n      }\n    }\n\n    window.addEventListener('resize', scheduleViewportHeightUpdate);\n    window.addEventListener('click', onGlobalClick);\n    statusRefreshTimer = setInterval(() => {\n      if (indexStatus.state === 'Indexing') {\n        void refreshStatus();\n      }\n    }, 1000);\n    console.log(`[startup/fe] +${ms()}ms onMount complete`);\n  });\n\n  onDestroy(async () => {\n    clearTimeout(searchTimer);\n    clearTimeout(toastTimer);\n    clearInterval(statusRefreshTimer);\n    clearInterval(elapsedTimer);\n    resizeCleanup?.();\n\n    for (const unlisten of unlistenFns) {\n      unlisten();\n    }\n\n    tableResizeObserver?.disconnect();\n    tableResizeObserver = null;\n    if (viewportResizeRaf !== null) {\n      cancelAnimationFrame(viewportResizeRaf);\n      viewportResizeRaf = null;\n    }\n    window.removeEventListener('resize', scheduleViewportHeightUpdate);\n    window.removeEventListener('click', onGlobalClick);\n  });\n</script>\n\n<svelte:window on:keydown={handleKeydown} />\n\n<div class=\"app-shell\" data-theme={theme}>\n  <div class=\"title-bar\" role=\"presentation\" data-tauri-drag-region on:mousedown={onTitleBarMouseDown}>\n    <div class=\"title-left\"></div>\n    <div class=\"title-center\">\n      <svg class=\"title-icon\" viewBox=\"0 0 215 205\" fill-rule=\"evenodd\" aria-hidden=\"true\">\n        <path d=\"M85 0c46.9 0 85 38.1 85 85 0 20.1-7.2 38.5-19.2 52.7l40.7 40.8c5.8 5.8 5.8 15.2 0 21-5.8 5.8-15.2 5.8-21 0l-40.7-40.7c-13.6 9.7-30.4 15.2-44.8 15.2-46.9 0-85-42.1-85-89 0-46.9 38.1-85 85-85z m0 32c-29.3 0-53 23.7-53 53 0 29.3 23.7 53 53 53 29.3 0 53-23.7 53-53 0-29.3-23.7-53-53-53z\"/>\n      </svg>\n      <span class=\"title-text\">Everything</span>\n    </div>\n    <div class=\"title-right\"></div>\n  </div>\n\n  <header class=\"search-bar\">\n    <input\n      bind:this={searchInputEl}\n      class=\"search-input\"\n      type=\"text\"\n      bind:value={query}\n      on:input={scheduleSearch}\n      on:focus={clearSelection}\n      placeholder=\"Search file/folder names\"\n      autocomplete=\"off\"\n      spellcheck=\"false\"\n    />\n  </header>\n\n  <section class=\"table-area\" bind:this={tableAreaEl} style={tableGridStyle}>\n    <div class=\"table-header\">\n      <div class=\"table-header-track\">\n        <div class=\"col name\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('name')}>\n            Name{#if sortBy === 'name'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'name'}\n            on:mousedown={(event) => startColumnResize(event, 'name')}\n            aria-label=\"Resize Name column\"\n          />\n        </div>\n\n        <div class=\"col path\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('dir')}>\n            Path{#if sortBy === 'dir'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'path'}\n            on:mousedown={(event) => startColumnResize(event, 'path')}\n            aria-label=\"Resize Path column\"\n          />\n        </div>\n\n        <div class=\"col size\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('size')}>\n            Size{#if sortBy === 'size'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n\n        <div class=\"col modified\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('mtime')}>\n            Modified{#if sortBy === 'mtime'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n      </div>\n    </div>\n\n    <div\n      class=\"table-body\"\n      bind:this={tableContainer}\n      on:scroll={() => {\n        scrollTop = tableContainer.scrollTop;\n        headerScrollLeft = tableContainer.scrollLeft;\n        if (editing.active) cancelRename();\n        const scrollBottom = scrollTop + tableContainer.clientHeight;\n        if (scrollBottom >= totalHeight - rowHeight * 10) {\n          void loadMore();\n        }\n      }}\n    >\n      <div class=\"spacer\" style={`height:${totalHeight}px`}>\n        <div class=\"rows\" style={`transform: translateY(${translateY}px);`}>\n          {#each visibleRows as entry, localIndex}\n            {@const index = startIndex + localIndex}\n            <div\n              class=\"row {selectedIndices.has(index) ? 'selected' : ''}\"\n              on:mousedown={(event) => handleRowMouseDown(event, index)}\n              on:click={(event) => handleRowClick(event, index)}\n              on:keydown={(event) => handleRowA11yKeydown(event, index)}\n              on:dblclick={() => handleRowDoubleClick(index)}\n              on:contextmenu={(event) => handleRowContextMenu(event, index)}\n              role=\"row\"\n              tabindex=\"0\"\n            >\n              <div class=\"cell name\">\n                <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n                <span class=\"ellipsis\" class:name-editing={editing.active && editing.index === index}>{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n              </div>\n              <div class=\"cell path\"><span class=\"ellipsis\">{displayPath(entry.dir)}</span></div>\n              <div class=\"cell size\">{formatSize(entry)}</div>\n              <div class=\"cell modified\">{formatModified(entry)}</div>\n            </div>\n          {/each}\n        </div>\n      </div>\n    </div>\n  </section>\n\n  <footer class=\"status-bar\">\n    <div class=\"status-left\">\n      <span class=\"status-state\">\n        <span class=\"state-dot {indexStatus.state === 'Indexing' ? 'indexing' : indexStatus.state === 'Error' ? 'error' : 'ready'}\"></span>\n        {#if indexStatus.state === 'Indexing'}\n          Indexing{#if lastReadyCount > 0} ({Math.min(99, Math.round((scanned / lastReadyCount) * 100))}%){/if}{#if indexingElapsed} Â· {indexingElapsed}{/if}\n          {#if !indexStatus.isCatchup}\n            Â· {scanned.toLocaleString()} scanned\n          {/if}\n        {:else}\n          Index: {indexStatus.state}\n        {/if}\n      </span>\n      <span>{indexStatus.entriesCount.toLocaleString()} entries</span>\n      {#if indexingFinishedAt && indexStatus.state !== 'Indexing'}\n        <span>in {indexingFinishedAt}</span>\n      {/if}\n      {#if dbLatencyMs !== null && dbLastQuery}\n        <span>\"{dbLastQuery}\" {dbLatencyMs}ms Â· {totalResults} results</span>\n      {/if}\n      {#if searchModeLabel === 'spotlight' || searchModeLabel === 'spotlight_timeout'}\n        <span class=\"status-spotlight\">Spotlight fallback{#if searchModeLabel === 'spotlight_timeout'} (partial){/if}</span>\n      {/if}\n      {#if indexStatus.permissionErrors > 0}\n        <span class=\"status-warning\">{indexStatus.permissionErrors.toLocaleString()} permission errors</span>\n      {/if}\n      {#if indexStatus.message}\n        <span class={indexStatus.isCatchup ? 'index-progress' : 'status-error'}>{indexStatus.message}</span>\n      {/if}\n    </div>\n    <div class=\"status-right\">\n      <button class=\"status-btn theme-btn\" on:click={cycleTheme} title=\"Switch theme\">\n        {theme === 'dark' ? 'â˜€ Light' : 'â—‘ Dark'}\n      </button>\n      <button\n        class=\"status-btn rebuild-btn\"\n        on:click={resetIndex}\n        disabled={indexStatus.state === 'Indexing'}\n        title={indexStatus.state === 'Indexing' ? 'Cannot reset while indexing is in progress.' : 'Reset and rebuild the index.'}\n      >\n        <svg class=\"rebuild-icon\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n          <path d=\"M23 4v6h-6\"/><path d=\"M20.49 15a9 9 0 1 1-2.12-9.36L23 10\"/>\n        </svg>\n        Rebuild Index\n      </button>\n    </div>\n  </footer>\n\n  {#if editing.active}\n    <div\n      class=\"rename-overlay\"\n      style=\"top:{renameOverlay.top}px; left:{renameOverlay.left}px; width:{renameOverlay.width}px;\"\n      role=\"presentation\"\n      on:mousedown|stopPropagation\n    >\n      <textarea\n        bind:this={renameInputEl}\n        class=\"rename-textarea\"\n        bind:value={editing.draftName}\n        on:input={autoResizeRenameInput}\n        on:click|stopPropagation\n        on:blur={commitRename}\n      />\n    </div>\n  {/if}\n\n  {#if contextMenu.visible}\n    <div class=\"context-menu\" style={`left:${contextMenu.x}px;top:${contextMenu.y}px;`}>\n      <button on:click={() => (closeContextMenu(), openSelected())}>Open</button>\n      <button on:click={async () => { closeContextMenu(); const e = primaryEntry(); if (e) await invoke('quick_look', { path: e.path }); }}>Quick Look</button>\n      <button on:click={() => (closeContextMenu(), openWithFallback())}>Open With... (Reveal in Finder)</button>\n      <button on:click={() => (closeContextMenu(), revealSelected())}>Reveal in Finder</button>\n      <button on:click={() => (closeContextMenu(), copySelectedPaths())}>Copy Path</button>\n      <button on:click={() => (closeContextMenu(), trashSelected())}>Move to Trash</button>\n      {#if selectedIndices.size === 1}\n        <button on:click={() => (closeContextMenu(), startRename())}>Rename</button>\n      {/if}\n    </div>\n  {/if}\n\n  {#if toast}\n    <div class=\"toast\">{toast}</div>\n  {/if}\n</div>\n\n<style>\n  :global(:root) {\n    color-scheme: light dark;\n    --bg-app: transparent;\n    --text-primary: #0d1826;\n    --text-muted: #48596c;\n    --bar-grad-top: rgba(255, 255, 255, 0.48);\n    --bar-grad-bottom: rgba(248, 250, 253, 0.42);\n    --surface-header: rgba(252, 252, 255, 0.40);\n    --surface: rgba(255, 255, 255, 0.22);\n    --border-soft: rgba(0, 0, 0, 0.07);\n    --border-input: rgba(0, 0, 0, 0.13);\n    --focus-ring: #6f96e6;\n    --row-border: rgba(0, 0, 0, 0.032);\n    --row-hover: rgba(0, 0, 0, 0.06);\n    --row-selected: rgba(0, 0, 0, 0.12);\n    --button-bg: rgba(255, 255, 255, 0.62);\n    --button-border: rgba(0, 0, 0, 0.10);\n    --button-text: #2c3e50;\n    --menu-bg: rgba(240, 241, 248, 0.90);\n    --menu-border: rgba(0, 0, 0, 0.06);\n    --menu-hover: rgba(255, 255, 255, 0.62);\n    --menu-text: #1a2a38;\n    --error-text: #b64545;\n    --warning-text: #8f6500;\n    --toast-bg: rgba(18, 22, 32, 0.90);\n    --toast-text: #ffffff;\n  }\n\n  @media (prefers-color-scheme: dark) {\n    :global(:root) {\n      --bg-app: transparent;\n      --text-primary: #e6e6ea;\n      --text-muted: #9494a4;\n      --bar-grad-top: rgba(38, 38, 46, 0.52);\n      --bar-grad-bottom: rgba(30, 30, 38, 0.46);\n      --surface-header: rgba(32, 32, 40, 0.46);\n      --surface: rgba(18, 18, 26, 0.32);\n      --border-soft: rgba(255, 255, 255, 0.065);\n      --border-input: rgba(255, 255, 255, 0.14);\n      --focus-ring: #5b8bd9;\n      --row-border: rgba(255, 255, 255, 0.026);\n      --row-hover: rgba(255, 255, 255, 0.08);\n      --row-selected: rgba(255, 255, 255, 0.14);\n      --button-bg: rgba(255, 255, 255, 0.072);\n      --button-border: rgba(255, 255, 255, 0.11);\n      --button-text: #d6d6e0;\n      --menu-bg: rgba(36, 36, 46, 0.90);\n      --menu-border: rgba(255, 255, 255, 0.066);\n      --menu-hover: rgba(255, 255, 255, 0.062);\n      --menu-text: #e0e0e8;\n      --error-text: #ff9d9d;\n      --warning-text: #e0c670;\n      --toast-bg: rgba(10, 10, 16, 0.93);\n      --toast-text: #f2f2f6;\n    }\n  }\n\n  /* â”€â”€ Theme: Dark â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme=\"dark\"]) {\n    color-scheme: dark;\n    --bg-app: #1E1E21;\n    --text-primary: #E2E8F0;\n    --text-muted: #94A3B8;\n    --bar-grad-top: #1E1E21;\n    --bar-grad-bottom: #1E1E21;\n    --surface-header: #1E1E21;\n    --surface: #1E1E21;\n    --bg-input: #161618;\n    --border-soft: #2A2A2D;\n    --border-input: rgba(255, 255, 255, 0.06);\n    --focus-ring: #4DA8FF;\n    --accent: #4DA8FF;\n    --row-border: rgba(255, 255, 255, 0.02);\n    --row-hover: #282828;\n    --row-selected: rgba(77, 168, 255, 0.10);\n    --button-bg: rgba(255, 255, 255, 0.05);\n    --button-border: #2A2A2D;\n    --button-text: #94A3B8;\n    --menu-bg: #252528;\n    --menu-border: #2A2A2D;\n    --menu-hover: rgba(255, 255, 255, 0.04);\n    --menu-text: #E2E8F0;\n    --error-text: #ff9d9d;\n    --warning-text: #e0c670;\n    --toast-bg: rgba(10, 10, 16, 0.93);\n    --toast-text: #f2f2f6;\n  }\n\n  /* â”€â”€ Theme: Light â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme=\"light\"]) {\n    color-scheme: light;\n    --bg-app: #F5F5F7;\n    --text-primary: #1C1C1E;\n    --text-muted: #6E6E7A;\n    --bar-grad-top: #F5F5F7;\n    --bar-grad-bottom: #F5F5F7;\n    --surface-header: #F5F5F7;\n    --surface: #F5F5F7;\n    --bg-input: #FFFFFF;\n    --border-soft: #D1D1D6;\n    --border-input: rgba(0, 0, 0, 0.10);\n    --focus-ring: #3A8BF5;\n    --accent: #3A8BF5;\n    --row-border: rgba(0, 0, 0, 0.04);\n    --row-hover: rgba(0, 0, 0, 0.04);\n    --row-selected: rgba(58, 139, 245, 0.10);\n    --button-bg: #FFFFFF;\n    --button-border: #D1D1D6;\n    --button-text: #3C3C43;\n    --menu-bg: #FFFFFF;\n    --menu-border: #D1D1D6;\n    --menu-hover: rgba(0, 0, 0, 0.05);\n    --menu-text: #1C1C1E;\n    --error-text: #D93025;\n    --warning-text: #B45309;\n    --toast-bg: rgba(255, 255, 255, 0.95);\n    --toast-text: #1C1C1E;\n  }\n\n  /* â”€â”€ Themed element overrides â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme]) {\n    background: var(--bg-app);\n  }\n\n  /* Search bar: flat, no gradient, no separator */\n  :global([data-theme]) .search-bar {\n    height: 44px;\n    padding: 0 16px;\n    background: var(--bg-app);\n    border-bottom: none;\n  }\n\n  :global([data-theme]) .search-input {\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n    font-family: 'JetBrains Mono', 'SF Mono', monospace;\n    font-size: 12px;\n    height: 34px;\n    border-radius: 8px;\n  }\n\n  /* Table header: flat bg, 16px edge padding */\n  :global([data-theme]) .table-header {\n    background: var(--bg-app);\n  }\n\n  :global([data-theme]) .col-button {\n    padding: 0 8px;\n  }\n\n  :global([data-theme]) .col.name .col-button {\n    padding-left: 16px;\n  }\n\n  /* Row cells: JetBrains Mono, 16px outer edges */\n  :global([data-theme]) .cell {\n    font-family: 'JetBrains Mono', monospace;\n  }\n\n  :global([data-theme]) .cell.name {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    padding-left: 16px;\n    font-size: 12px;\n    color: var(--text-primary);\n  }\n\n  :global([data-theme]) .cell.path {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.size {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.modified {\n    padding-right: 16px;\n    font-size: 11px;\n    white-space: nowrap;\n  }\n\n  :global([data-theme]) .row.selected {\n    box-shadow: inset 3px 0 0 var(--accent);\n  }\n\n  /* Dim path/size/date cells in themed mode */\n  :global([data-theme]) .cell.path,\n  :global([data-theme]) .cell.size,\n  :global([data-theme]) .cell.modified {\n    color: var(--text-muted);\n  }\n\n  :global(:root) {\n    background: transparent;\n  }\n\n  :global(html, body) {\n    margin: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    background: transparent;\n    color: var(--text-primary);\n    font-family: Inter, 'SF Pro Text', 'Segoe UI', Helvetica, Arial, sans-serif;\n  }\n\n  :global(#app) {\n    width: 100%;\n    height: 100%;\n  }\n\n  .app-shell {\n    display: grid;\n    grid-template-rows: auto auto 1fr auto;\n    height: 100%;\n    min-width: 0;\n  }\n\n  .title-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 44px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    cursor: default;\n    flex-shrink: 0;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-left {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-center {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-right {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-icon {\n    width: 14px;\n    height: 14px;\n    fill: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .title-text {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 13px;\n    font-weight: 500;\n    color: var(--text-primary);\n    letter-spacing: -0.01em;\n  }\n\n  .search-bar {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding: 8px;\n    background: linear-gradient(180deg, var(--bar-grad-top) 0%, var(--bar-grad-bottom) 100%);\n    border-bottom: 1px solid var(--border-soft);\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .search-input {\n    display: block;\n    box-sizing: border-box;\n    width: 100%;\n    min-width: 0;\n    flex: 1 1 auto;\n    height: 36px;\n    border: 1px solid var(--border-input);\n    border-radius: 14px;\n    padding: 0 10px;\n    font-size: 14px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    backdrop-filter: blur(12px) saturate(160%);\n    -webkit-backdrop-filter: blur(12px) saturate(160%);\n  }\n\n  .search-input::placeholder {\n    color: var(--text-muted);\n    opacity: 0.85;\n    font-size: 12px;\n  }\n\n  .search-input:focus {\n    outline: none;\n    border-color: var(--focus-ring);\n    box-shadow: 0 0 0 2px rgba(125, 169, 255, 0.25);\n  }\n\n  .table-area {\n    display: grid;\n    grid-template-rows: auto 1fr;\n    min-height: 0;\n    min-width: 0;\n  }\n\n  .table-header-track,\n  .row {\n    display: grid;\n    grid-template-columns: var(--col-name) var(--col-path) var(--col-size) var(--col-modified);\n    align-items: center;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .table-header {\n    height: 32px;\n    border-bottom: 1px solid var(--border-soft);\n    background: var(--surface-header);\n    user-select: none;\n    overflow: hidden;\n    flex-shrink: 0;\n  }\n\n  .table-header-track {\n    height: 100%;\n    transform: translateX(var(--header-offset, 0px));\n    will-change: transform;\n  }\n\n  .table-header .col {\n    position: relative;\n    min-width: 0;\n    height: 100%;\n  }\n\n  .col-button {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n    gap: 4px;\n    box-sizing: border-box;\n    padding: 0 8px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 11px;\n    font-weight: 600;\n    line-height: 1;\n    color: var(--text-muted);\n    text-align: left;\n    margin: 0;\n    border: none;\n    background: transparent;\n    cursor: pointer;\n  }\n\n  .sort-icon {\n    width: 10px;\n    height: 10px;\n    flex-shrink: 0;\n    color: var(--accent);\n  }\n\n  .col-resizer {\n    position: absolute;\n    top: 0;\n    right: -4px;\n    width: 8px;\n    height: 100%;\n    border: none;\n    padding: 0;\n    background: transparent;\n    cursor: col-resize;\n    z-index: 30;\n  }\n\n  .col-resizer::after {\n    content: '';\n    position: absolute;\n    top: 7px;\n    bottom: 7px;\n    left: 50%;\n    width: 1px;\n    transform: translateX(-50%);\n    background: var(--border-soft);\n    opacity: 0;\n    transition: opacity 0.15s ease;\n  }\n\n  .table-header .col:hover .col-resizer::after,\n  .col-resizer.active::after {\n    opacity: 1;\n  }\n\n  .table-body {\n    overflow: auto;\n    min-height: 0;\n    min-width: 0;\n    background: var(--surface);\n  }\n\n  .spacer {\n    position: relative;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .rows {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .row {\n    height: 30px;\n    border-bottom: 1px solid var(--row-border);\n    cursor: default;\n    -webkit-user-select: none;\n    user-select: none;\n    outline: none;\n  }\n\n  .row:hover {\n    background: var(--row-hover);\n  }\n\n  .row.selected {\n    background: var(--row-selected);\n  }\n\n  .cell {\n    padding: 0 8px;\n    font-size: 12px;\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    min-width: 0;\n  }\n\n  .cell.size {\n    text-align: right;\n    font-variant-numeric: tabular-nums;\n  }\n\n  .ellipsis {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n\n  .hl {\n    background: none;\n    color: inherit;\n    font-weight: 700;\n  }\n\n  .file-icon {\n    width: 16px;\n    height: 16px;\n    flex: 0 0 auto;\n  }\n\n  .name-editing {\n    opacity: 0.25;\n  }\n\n  .rename-overlay {\n    position: fixed;\n    z-index: 100;\n    min-width: 120px;\n  }\n\n  .rename-textarea {\n    display: block;\n    width: 100%;\n    box-sizing: border-box;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 12px;\n    line-height: 18px;\n    padding: 5px 4px 5px 0;\n    border: 1.5px solid var(--focus-ring);\n    border-radius: 4px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    outline: none;\n    resize: none;\n    overflow: hidden;\n    box-shadow: 0 2px 14px rgba(0, 0, 0, 0.22), 0 0 0 3px rgba(77, 168, 255, 0.13);\n  }\n\n  .status-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 32px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    border-top: 1px solid var(--border-soft);\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 11px;\n    color: var(--text-muted);\n    white-space: nowrap;\n    overflow: hidden;\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .status-left {\n    display: flex;\n    align-items: center;\n    gap: 16px;\n    overflow: hidden;\n    min-width: 0;\n  }\n\n  .status-right {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    flex-shrink: 0;\n  }\n\n  .status-btn {\n    border: 1px solid var(--button-border);\n    border-radius: 5px;\n    background: var(--button-bg);\n    color: var(--button-text);\n    font-size: 11px;\n    height: 22px;\n    padding: 0 8px;\n    cursor: pointer;\n  }\n\n  .status-btn:hover {\n    filter: brightness(1.06);\n  }\n\n  .status-btn:disabled {\n    opacity: 0.55;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .status-state {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n  }\n\n  .state-dot {\n    width: 6px;\n    height: 6px;\n    border-radius: 50%;\n    flex-shrink: 0;\n  }\n\n  .state-dot.ready { background: #28C840; }\n  .state-dot.indexing { background: #FEBC2E; }\n  .state-dot.error { background: #FF5F57; }\n\n  .rebuild-btn {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 10px;\n    font-weight: 500;\n    background: var(--button-bg);\n    border: 1px solid var(--button-border);\n    border-radius: 4px;\n    color: var(--button-text);\n    height: 22px;\n    padding: 0 10px;\n    cursor: pointer;\n  }\n\n  .rebuild-btn:hover {\n    filter: brightness(1.1);\n  }\n\n  .rebuild-btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .rebuild-icon {\n    width: 11px;\n    height: 11px;\n    color: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .status-error {\n    color: var(--error-text);\n  }\n\n  .status-warning {\n    color: var(--warning-text);\n  }\n\n  .status-spotlight {\n    color: #f59e0b;\n    font-weight: 600;\n  }\n\n  .context-menu {\n    position: fixed;\n    z-index: 200;\n    width: 220px;\n    border: 1px solid var(--menu-border);\n    border-radius: 10px;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.16), inset 0 0 0 0.5px rgba(255, 255, 255, 0.18);\n    background: var(--menu-bg);\n    backdrop-filter: blur(28px) saturate(180%);\n    -webkit-backdrop-filter: blur(28px) saturate(180%);\n    overflow: hidden;\n  }\n\n  .context-menu button {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    padding: 8px 10px;\n    font-size: 12px;\n    color: var(--menu-text);\n  }\n\n  .context-menu button:hover {\n    background: var(--menu-hover);\n  }\n\n  .toast {\n    position: fixed;\n    right: 14px;\n    bottom: 18px;\n    background: var(--toast-bg);\n    color: var(--toast-text);\n    border-radius: 10px;\n    padding: 9px 12px;\n    font-size: 12px;\n    z-index: 250;\n    backdrop-filter: blur(20px) saturate(180%);\n    -webkit-backdrop-filter: blur(20px) saturate(180%);\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);\n  }\n</style>\n","structuredPatch":[{"oldStart":674,"oldLines":7,"newStart":674,"newLines":7,"lines":["     if (!entry) return null;"," ","     const count = selectedIndices.has(index) ? selectedIndices.size : 1;","-    const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;","+    const isDark = theme === 'dark';"," ","     const w = 260;","     const h = 28;"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"8baef013-3843-4882-98e8-e431ade589d2"}
{"parentUuid":"b8fc5a41-c56a-4165-8a4e-7c9bab901911","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_0143VK3YDbCv8h3Rqe2sCPFn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JxHC4gzCb2Yeh7heVG56q7","name":"Read","input":{"file_path":"/Users/al02402336/everything/src/App.svelte","offset":1488,"limit":10},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":190,"cache_read_input_tokens":94522,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":190},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPLz9gKo2TUdrEw5CWY","type":"assistant","uuid":"7ae2bd8a-9df9-4256-aad3-f8e20d391b8e","timestamp":"2026-02-21T14:39:08.481Z"}
{"parentUuid":"7ae2bd8a-9df9-4256-aad3-f8e20d391b8e","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01JxHC4gzCb2Yeh7heVG56q7","toolUseID":"toolu_01JxHC4gzCb2Yeh7heVG56q7","timestamp":"2026-02-21T14:39:08.489Z","uuid":"695dcf07-e5e6-43bb-88e1-bf3a22cb23f8"}
{"parentUuid":"7ae2bd8a-9df9-4256-aad3-f8e20d391b8e","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JxHC4gzCb2Yeh7heVG56q7","type":"tool_result","content":"  1488â†’          </button>\n  1489â†’        </div>\n  1490â†’      </div>\n  1491â†’    </div>\n  1492â†’\n  1493â†’    <div\n  1494â†’      class=\"table-body\"\n  1495â†’      bind:this={tableContainer}\n  1496â†’      on:scroll={() => {\n  1497â†’        scrollTop = tableContainer.scrollTop;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"985b78f4-06c6-4e77-b6b4-a3ea27dc7981","timestamp":"2026-02-21T14:39:08.488Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src/App.svelte","content":"          </button>\n        </div>\n      </div>\n    </div>\n\n    <div\n      class=\"table-body\"\n      bind:this={tableContainer}\n      on:scroll={() => {\n        scrollTop = tableContainer.scrollTop;","numLines":10,"startLine":1488,"totalLines":2277}},"sourceToolAssistantUUID":"7ae2bd8a-9df9-4256-aad3-f8e20d391b8e"}
{"parentUuid":"985b78f4-06c6-4e77-b6b4-a3ea27dc7981","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01CMk9KqdVCLQRAx5UY61Sha","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01T2TmKFWf18GVBekwhVKgLM","name":"Read","input":{"file_path":"/Users/al02402336/everything/src/App.svelte","offset":1496,"limit":8},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":295,"cache_read_input_tokens":94712,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":295},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPMBPrJfccTzRzNoeFV","type":"assistant","uuid":"a72d3c04-cf72-4afd-97a1-fcd3d77c90ae","timestamp":"2026-02-21T14:39:10.885Z"}
{"parentUuid":"a72d3c04-cf72-4afd-97a1-fcd3d77c90ae","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01T2TmKFWf18GVBekwhVKgLM","toolUseID":"toolu_01T2TmKFWf18GVBekwhVKgLM","timestamp":"2026-02-21T14:39:10.901Z","uuid":"02b9a2ae-ebce-480e-9cbd-231a19494ed3"}
{"parentUuid":"a72d3c04-cf72-4afd-97a1-fcd3d77c90ae","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01T2TmKFWf18GVBekwhVKgLM","type":"tool_result","content":"  1496â†’      on:scroll={() => {\n  1497â†’        scrollTop = tableContainer.scrollTop;\n  1498â†’        headerScrollLeft = tableContainer.scrollLeft;\n  1499â†’        if (editing.active) cancelRename();\n  1500â†’        const scrollBottom = scrollTop + tableContainer.clientHeight;\n  1501â†’        if (scrollBottom >= totalHeight - rowHeight * 10) {\n  1502â†’          void loadMore();\n  1503â†’        }\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"06c9cb70-5c9e-4093-9c3b-9110840e4546","timestamp":"2026-02-21T14:39:10.900Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src/App.svelte","content":"      on:scroll={() => {\n        scrollTop = tableContainer.scrollTop;\n        headerScrollLeft = tableContainer.scrollLeft;\n        if (editing.active) cancelRename();\n        const scrollBottom = scrollTop + tableContainer.clientHeight;\n        if (scrollBottom >= totalHeight - rowHeight * 10) {\n          void loadMore();\n        }","numLines":8,"startLine":1496,"totalLines":2277}},"sourceToolAssistantUUID":"a72d3c04-cf72-4afd-97a1-fcd3d77c90ae"}
{"parentUuid":"06c9cb70-5c9e-4093-9c3b-9110840e4546","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_017PXbz5rnPvqWQiYe8vhZbP","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01H8yYGpkTGyQqu2J5t5Zgys","name":"Edit","input":{"replace_all":false,"file_path":"/Users/al02402336/everything/src/App.svelte","old_string":"        if (editing.active) cancelRename();","new_string":"        if (editing.active) void commitRename();"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":310,"cache_read_input_tokens":95007,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":310},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPMMhihLbn5YgGDT6MX","type":"assistant","uuid":"944cf29a-b74b-4058-bd23-8e54493a6eae","timestamp":"2026-02-21T14:39:14.110Z"}
{"parentUuid":"944cf29a-b74b-4058-bd23-8e54493a6eae","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01H8yYGpkTGyQqu2J5t5Zgys","toolUseID":"toolu_01H8yYGpkTGyQqu2J5t5Zgys","timestamp":"2026-02-21T14:39:14.118Z","uuid":"87b3e8f5-807b-490e-a328-7ec8793ba8c0"}
{"parentUuid":"944cf29a-b74b-4058-bd23-8e54493a6eae","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01H8yYGpkTGyQqu2J5t5Zgys","type":"tool_result","content":"The file /Users/al02402336/everything/src/App.svelte has been updated successfully."}]},"uuid":"53960ac4-565d-418b-96ca-6d97918b7beb","timestamp":"2026-02-21T14:39:14.117Z","toolUseResult":{"filePath":"/Users/al02402336/everything/src/App.svelte","oldString":"        if (editing.active) cancelRename();","newString":"        if (editing.active) void commitRename();","originalFile":"<script>\n  import { onDestroy, onMount, tick } from 'svelte';\n  import { invoke } from '@tauri-apps/api/core';\n  import { listen } from '@tauri-apps/api/event';\n  import { getCurrentWindow } from '@tauri-apps/api/window';\n  import { startDrag } from '@crabnebula/tauri-plugin-drag';\n\n  const rowHeight = 30;\n  const PAGE_SIZE = 500;\n  let homePrefix = '';\n  const COL_WIDTHS_KEY = 'REDACTED';\n  const THEME_KEY = 'everything-theme';\n  const columnKeys = ['name', 'path', 'size', 'modified'];\n  const minColumnWidth = {\n    name: 180,\n    path: 240,\n    size: 75,\n    modified: 150\n  };\n  const defaultColumnRatios = {\n    name: 0.3,\n    path: 0.45,\n    size: 0.1\n  };\n\n  const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';\n  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || systemTheme; } catch { return systemTheme; } })();\n  function cycleTheme() {\n    theme = theme === 'dark' ? 'light' : 'dark';\n    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n    invoke('set_native_theme', { theme });\n  }\n\n  let query = '';\n  let results = [];\n  let totalResults = 0;\n  let totalResultsKnown = false;\n\n  let dbLatencyMs = null;\n  let dbLastQuery = '';\n  let searchModeLabel = '';\n  let selectedIndices = new Set();\n  let selectionAnchor = -1;\n  let lastSelectedIndex = -1;\n  let editing = {\n    active: false,\n    path: '',\n    index: -1,\n    draftName: ''\n  };\n\n  let renameOverlay = { top: 0, left: 0, width: 0 };\n\n  let indexStatus = {\n    state: 'Indexing',\n    entriesCount: 0,\n    lastUpdated: null,\n    permissionErrors: 0,\n    message: null,\n    isCatchup: false\n  };\n\n  let indexingStartTime = null;\n  let indexingElapsed = '';\n  let indexingFinishedAt = '';\n\n  let sortBy = 'name';\n  let sortDir = 'asc';\n\n  let hasMore = true;\n  let loadingMore = false;\n  let searchGeneration = 0;\n\n  let scanned = 0;\n\n  let searchInputEl;\n  let renameInputEl;\n  let tableAreaEl;\n  let tableContainer;\n  let tableResizeObserver = null;\n  let viewportResizeRaf = null;\n  let scrollTop = 0;\n  let headerScrollLeft = 0;\n  let viewportHeight = 520;\n  let lastTableWidth = 0;\n  let resizingColumn = '';\n  let resizeCleanup = null;\n  let colWidths = {\n    name: 250,\n    path: 350,\n    size: 75,\n    modified: 150\n  };\n\n  let contextMenu = {\n    visible: false,\n    x: 0,\n    y: 0\n  };\n\n  let platform = '';\n  let toast = '';\n  let searchTimer;\n  let lastSearchFiredAt = 0;\n  let toastTimer;\n  let statusRefreshTimer;\n  let elapsedTimer;\n  let statusRefreshInFlight = false;\n  let lastReadyCount = 0;\n\n  const iconCache = new Map();\n  const iconLoading = new Set();\n\n  let highlightCache = new Map();\n  let highlightCacheQuery = '';\n\n  const folderFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='1' y='4' width='14' height='10' rx='2' fill='#d9b34f'/><rect x='1' y='2' width='6' height='4' rx='1' fill='#e6ca7a'/></svg>`\n    );\n  const fileFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='3' y='1' width='10' height='14' rx='1.5' fill='#b4bec9'/><rect x='5' y='5' width='6' height='1.2' fill='#8d98a5'/><rect x='5' y='8' width='6' height='1.2' fill='#8d98a5'/></svg>`\n    );\n\n  $: totalHeight = results.length * rowHeight;\n  $: startIndex = Math.max(0, Math.floor(scrollTop / rowHeight) - 10);\n  $: visibleCount = Math.ceil(viewportHeight / rowHeight) + 20;\n  $: endIndex = Math.min(results.length, startIndex + visibleCount);\n  $: visibleRows = results.slice(startIndex, endIndex);\n  $: translateY = startIndex * rowHeight;\n  $: tableMinWidth = colWidths.name + colWidths.path + colWidths.size + colWidths.modified;\n  $: tableGridStyle = `--col-name:${colWidths.name}px;--col-path:${colWidths.path}px;--col-size:${colWidths.size}px;--col-modified:${colWidths.modified}px;--table-min-width:${tableMinWidth}px;--header-offset:${-headerScrollLeft}px;`;\n\n  $: {\n    for (const entry of visibleRows) {\n      void ensureIcon(entry);\n    }\n  }\n\n  function showToast(message) {\n    toast = message;\n    clearTimeout(toastTimer);\n    toastTimer = setTimeout(() => {\n      toast = '';\n    }, 3000);\n  }\n\n  function bytesToBase64(bytes) {\n    let binary = '';\n    const chunk = 0x8000;\n    for (let i = 0; i < bytes.length; i += chunk) {\n      const part = bytes.subarray(i, i + chunk);\n      binary += String.fromCharCode(...part);\n    }\n    return btoa(binary);\n  }\n\n  function highlightSegments(name, q) {\n    q = (q || '').trim();\n    if (!q) return [{ text: name, hl: false }];\n\n    // Reset cache when query changes\n    if (q !== highlightCacheQuery) {\n      highlightCache = new Map();\n      highlightCacheQuery = q;\n    }\n\n    // Check cache\n    const cached = highlightCache.get(name);\n    if (cached) return cached;\n\n    if (q.includes('/')) q = q.slice(q.lastIndexOf('/') + 1);\n    q = q.replace(/[*?]/g, '');\n    const terms = q.split(/\\s+/).filter(Boolean);\n    if (terms.length === 0) return [{ text: name, hl: false }];\n\n    const lower = name.toLowerCase();\n    const marks = new Uint8Array(name.length);\n    for (const t of terms) {\n      const tl = t.toLowerCase();\n      let idx = lower.indexOf(tl);\n      while (idx !== -1) {\n        for (let i = idx; i < idx + tl.length; i++) marks[i] = 1;\n        idx = lower.indexOf(tl, idx + 1);\n      }\n    }\n\n    const segs = [];\n    let i = 0;\n    while (i < name.length) {\n      const m = marks[i];\n      let j = i + 1;\n      while (j < name.length && marks[j] === m) j++;\n      segs.push({ text: name.slice(i, j), hl: m === 1 });\n      i = j;\n    }\n\n    highlightCache.set(name, segs);\n    return segs;\n  }\n\n  const perFileIconExts = new Set(['exe', 'lnk', 'ico', 'url', 'scr', 'appx']);\n\n  function iconKey(entry) {\n    if (entry.isDir) return '__folder__';\n    const ext = (entry.ext || '').toLowerCase();\n    if (perFileIconExts.has(ext)) return entry.path;\n    return ext || '__file__';\n  }\n\n  function iconFor(entry) {\n    return iconCache.get(iconKey(entry)) || (entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n  }\n\n  async function ensureIcon(entry) {\n    const key = iconKey(entry);\n    if (iconCache.has(key) || iconLoading.has(key)) {\n      return;\n    }\n\n    iconLoading.add(key);\n    try {\n      const bytes = await invoke('get_file_icon', {\n        path: entry.path,\n        ext: entry.isDir ? 'folder' : entry.ext || '',\n      });\n      if (Array.isArray(bytes) && bytes.length > 0) {\n        const image = `data:image/png;base64,${bytesToBase64(Uint8Array.from(bytes))}`;\n        iconCache.set(key, image);\n      } else {\n        iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n      }\n    } catch {\n      iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n    } finally {\n      iconLoading.delete(key);\n    }\n  }\n\n  function syncColumnWidthsToContainer() {\n    const width = tableContainer?.clientWidth || tableAreaEl?.clientWidth;\n    if (!width || lastTableWidth !== 0) {\n      return;\n    }\n\n    const saved = loadColWidths();\n    if (saved) {\n      const total = columnKeys.reduce((s, k) => s + saved[k], 0);\n      if (Math.abs(total - width) > 2) {\n        const scale = (width - saved.modified) / (total - saved.modified);\n        let scaledName = Math.max(minColumnWidth.name, Math.round(saved.name * scale));\n        let scaledSize = Math.max(minColumnWidth.size, Math.round(saved.size * scale));\n        let rawPath = width - saved.modified - scaledName - scaledSize;\n        if (rawPath < minColumnWidth.path) {\n          const shortfall = minColumnWidth.path - rawPath;\n          const nameReduction = Math.min(shortfall, scaledName - minColumnWidth.name);\n          scaledName -= nameReduction;\n          const remaining = shortfall - nameReduction;\n          if (remaining > 0) {\n            scaledSize -= Math.min(remaining, scaledSize - minColumnWidth.size);\n          }\n          rawPath = width - saved.modified - scaledName - scaledSize;\n        }\n        const scaledPath = Math.max(minColumnWidth.path, rawPath);\n        colWidths = { name: scaledName, path: scaledPath, size: scaledSize, modified: saved.modified };\n      } else {\n        colWidths = saved;\n      }\n    } else {\n      const fixedModified = minColumnWidth.modified;\n      const rest = width - fixedModified;\n      const ratioSum = defaultColumnRatios.name + defaultColumnRatios.path + defaultColumnRatios.size;\n      colWidths = {\n        name: Math.max(minColumnWidth.name, Math.round(rest * defaultColumnRatios.name / ratioSum)),\n        path: Math.max(minColumnWidth.path, Math.round(rest * defaultColumnRatios.path / ratioSum)),\n        size: Math.max(minColumnWidth.size, Math.round(rest * defaultColumnRatios.size / ratioSum)),\n        modified: fixedModified\n      };\n    }\n    lastTableWidth = width;\n  }\n\n  function loadColWidths() {\n    try {\n      const raw = localStorage.getItem(COL_WIDTHS_KEY);\n      if (!raw) return null;\n      const parsed = JSON.parse(raw);\n      for (const key of columnKeys) {\n        if (typeof parsed[key] !== 'number' || parsed[key] < (minColumnWidth[key] || 0)) return null;\n      }\n      return parsed;\n    } catch {\n      return null;\n    }\n  }\n\n  function saveColWidths() {\n    localStorage.setItem(COL_WIDTHS_KEY, JSON.stringify(colWidths));\n  }\n\n  function updateViewportHeight() {\n    viewportHeight = tableContainer?.clientHeight || 520;\n    syncColumnWidthsToContainer();\n  }\n\n  function scheduleViewportHeightUpdate() {\n    if (viewportResizeRaf !== null) {\n      return;\n    }\n    viewportResizeRaf = requestAnimationFrame(() => {\n      viewportResizeRaf = null;\n      updateViewportHeight();\n    });\n  }\n\n  function startColumnResize(event, leftKey) {\n    event.preventDefault();\n    event.stopPropagation();\n\n    const index = columnKeys.indexOf(leftKey);\n    if (index < 0 || index >= columnKeys.length - 1) {\n      return;\n    }\n\n    const startX = event.clientX;\n    const startLeft = colWidths[leftKey];\n    const rightKey = columnKeys[index + 1];\n    const startRight = colWidths[rightKey];\n\n    resizeCleanup?.();\n    resizingColumn = leftKey;\n\n    const onMove = (moveEvent) => {\n      const delta = Math.round(moveEvent.clientX - startX);\n      if (leftKey === 'name') {\n        // Two-column trade: name and path swap space, each respects its minimum\n        const nextLeft = Math.max(\n          minColumnWidth[leftKey],\n          Math.min(startLeft + delta, startLeft + startRight - minColumnWidth[rightKey])\n        );\n        const nextRight = startLeft + startRight - nextLeft;\n        colWidths = { ...colWidths, [leftKey]: nextLeft, [rightKey]: nextRight };\n      } else {\n        // path splitter: path grows unconstrained (allows horizontal scroll on right drag)\n        const nextLeft = Math.max(minColumnWidth[leftKey], startLeft + delta);\n        colWidths = { ...colWidths, [leftKey]: nextLeft };\n      }\n    };\n\n    const onUp = () => {\n      cleanup();\n    };\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      document.body.style.cursor = '';\n      document.body.style.userSelect = '';\n      resizingColumn = '';\n      saveColWidths();\n      if (resizeCleanup === cleanup) {\n        resizeCleanup = null;\n      }\n    };\n\n    resizeCleanup = cleanup;\n    document.body.style.cursor = 'col-resize';\n    document.body.style.userSelect = 'none';\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  function selectedPaths() {\n    const sorted = [...selectedIndices].sort((a, b) => a - b);\n    return sorted.map((idx) => results[idx]).filter(Boolean).map((entry) => entry.path);\n  }\n\n  function clearSelection() {\n    selectedIndices = new Set();\n    selectionAnchor = -1;\n    lastSelectedIndex = -1;\n  }\n\n  function selectSingle(index) {\n    selectedIndices = new Set([index]);\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectToggle(index) {\n    const next = new Set(selectedIndices);\n    if (next.has(index)) {\n      next.delete(index);\n    } else {\n      next.add(index);\n    }\n    selectedIndices = next;\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectRange(index) {\n    const anchor = selectionAnchor >= 0 ? selectionAnchor : index;\n    const [from, to] = [Math.min(anchor, index), Math.max(anchor, index)];\n    const next = new Set();\n    for (let i = from; i <= to; i += 1) {\n      next.add(i);\n    }\n    selectedIndices = next;\n    lastSelectedIndex = index;\n  }\n\n  function primaryEntry() {\n    const idx = lastSelectedIndex >= 0 ? lastSelectedIndex : -1;\n    return idx >= 0 ? results[idx] : null;\n  }\n\n  async function refreshStatus() {\n    if (statusRefreshInFlight) {\n      return;\n    }\n    statusRefreshInFlight = true;\n    try {\n      const status = await invoke('get_index_status');\n      const prevState = indexStatus.state;\n      indexStatus = {\n        state: status.state,\n        entriesCount: status.entriesCount,\n        lastUpdated: status.lastUpdated,\n        permissionErrors: status.permissionErrors ?? 0,\n        message: status.message\n      };\n      if (status.state === 'Indexing' && prevState !== 'Indexing') {\n        startElapsedTimer();\n      } else if (status.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n      if (typeof status.scanned === 'number') {\n        scanned = status.scanned;\n      }\n      if (status.state === 'Ready' && prevState !== 'Ready') {\n        scheduleSearch();\n      }\n    } catch (err) {\n      showToast(`Failed to get status: ${String(err)}`);\n    } finally {\n      statusRefreshInFlight = false;\n    }\n  }\n\n  function scheduleSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const scheduledGen = searchGeneration;\n    clearTimeout(searchTimer);\n\n    const now = performance.now();\n    if (now - lastSearchFiredAt >= 200) {\n      // Leading edge: fire immediately if enough time has passed\n      lastSearchFiredAt = now;\n      void runSearch(preserveScroll);\n    } else {\n      // Trailing edge: debounce\n      searchTimer = setTimeout(() => {\n        if (scheduledGen !== searchGeneration) {\n          return;\n        }\n        lastSearchFiredAt = performance.now();\n        void runSearch(preserveScroll);\n      }, 200);\n    }\n  }\n\n  async function runSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const gen = searchGeneration;\n    const searchQuery = query;\n    const searchSortBy = sortBy;\n    const searchSortDir = sortDir;\n    const startedAt = performance.now();\n    try {\n      const keepPaths = new Set(selectedPaths());\n      const next = await invoke('search', {\n        query: searchQuery,\n        limit: PAGE_SIZE,\n        offset: 0,\n        sortBy: searchSortBy,\n        sortDir: searchSortDir\n      });\n\n      if (gen !== searchGeneration) return;\n\n      dbLatencyMs = Math.round(performance.now() - startedAt);\n      dbLastQuery = searchQuery;\n      const entries = Array.isArray(next.entries) ? next.entries : [];\n      searchModeLabel = next.modeLabel || '';\n      results = entries;\n      if (next.totalCount > 0) {\n        totalResults = next.totalCount;\n        totalResultsKnown = true;\n      } else {\n        totalResults = entries.length;\n        totalResultsKnown = false;\n      }\n      hasMore = totalResultsKnown ? results.length < totalResults : entries.length >= PAGE_SIZE;\n      if (!preserveScroll && tableContainer) tableContainer.scrollTop = 0;\n\n      const restored = new Set();\n      for (let i = 0; i < results.length; i += 1) {\n        if (keepPaths.has(results[i].path)) {\n          restored.add(i);\n        }\n      }\n      selectedIndices = restored;\n\n      updateViewportHeight();\n    } catch (err) {\n      if (gen !== searchGeneration) return;\n      showToast(`Search failed: ${String(err)}`);\n    }\n  }\n\n  async function loadMore() {\n    if (!hasMore || loadingMore) return;\n    const gen = searchGeneration;\n    loadingMore = true;\n    try {\n      const batch = await invoke('search', {\n        query,\n        limit: PAGE_SIZE,\n        offset: results.length,\n        sortBy: sortBy,\n        sortDir: sortDir\n      });\n      if (gen !== searchGeneration) return;\n      const arr = Array.isArray(batch.entries) ? batch.entries : [];\n      if (arr.length > 0) results = [...results, ...arr];\n      hasMore = totalResultsKnown ? results.length < totalResults : arr.length >= PAGE_SIZE;\n    } catch (err) {\n      showToast(`Failed to load more: ${String(err)}`);\n    } finally {\n      loadingMore = false;\n    }\n  }\n\n  function moveSelection(delta, withRange = false) {\n    if (results.length === 0) {\n      return;\n    }\n\n    const current = lastSelectedIndex >= 0 ? lastSelectedIndex : 0;\n    const next = Math.max(0, Math.min(results.length - 1, current + delta));\n\n    if (withRange) {\n      selectRange(next);\n    } else {\n      selectSingle(next);\n    }\n\n    const top = next * rowHeight;\n    const bottom = top + rowHeight;\n    if (top < scrollTop) {\n      tableContainer.scrollTop = top;\n    } else if (bottom > scrollTop + viewportHeight) {\n      tableContainer.scrollTop = bottom - viewportHeight;\n    }\n  }\n\n  function handleHeaderSort(column) {\n    if (sortBy === column) {\n      sortDir = sortDir === 'asc' ? 'desc' : 'asc';\n    } else {\n      sortBy = column;\n      sortDir = 'asc';\n    }\n    if (tableContainer) tableContainer.scrollTop = 0;\n    void runSearch();\n  }\n\n  function handleRowClick(event, index) {\n    contextMenu.visible = false;\n\n    if (event.shiftKey) {\n      selectRange(index);\n      return;\n    }\n\n    if (event.metaKey || event.ctrlKey) {\n      selectToggle(index);\n      return;\n    }\n\n    selectSingle(index);\n  }\n\n  function handleRowContextMenu(event, index) {\n    event.preventDefault();\n\n    if (!selectedIndices.has(index)) {\n      selectSingle(index);\n    }\n\n    if (platform === 'windows' || platform === 'macos') {\n      contextMenu.visible = false;\n      const paths = selectedPaths();\n      if (paths.length > 0) {\n        invoke('show_context_menu', {\n          paths,\n          x: event.clientX,\n          y: event.clientY,\n          singleSelection: selectedIndices.size === 1\n        });\n      }\n      return;\n    }\n\n    contextMenu = {\n      visible: true,\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n\n  function handleRowA11yKeydown(event, index) {\n    if (event.key === ' ' || event.key === 'Enter') {\n      event.preventDefault();\n      handleRowClick(event, index);\n    }\n  }\n\n  const DRAG_THRESHOLD = 5;\n  let dragCleanup = null;\n  const dragImgCache = new Map();\n\n  function dragPathsForIndex(index) {\n    const entry = results[index];\n    if (!entry) {\n      return [];\n    }\n\n    if (selectedIndices.has(index) && selectedIndices.size > 0) {\n      return selectedPaths();\n    }\n\n    return [entry.path];\n  }\n\n  function getDragIconEl(entry) {\n    const src = iconFor(entry);\n    let img = dragImgCache.get(src);\n    if (!img) {\n      img = new Image();\n      img.src = src;\n      dragImgCache.set(src, img);\n    }\n    return img.complete && img.naturalWidth > 0 ? img : null;\n  }\n\n  function fillRoundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function buildDragPreview(index) {\n    const entry = results[index];\n    if (!entry) return null;\n\n    const count = selectedIndices.has(index) ? selectedIndices.size : 1;\n    const isDark = theme === 'dark';\n\n    const w = 260;\n    const h = 28;\n    const stackGap = count > 1 ? 4 : 0;\n\n    const canvas = document.createElement('canvas');\n    canvas.width = w;\n    canvas.height = h + stackGap;\n    const ctx = canvas.getContext('2d');\n\n    if (count > 1) {\n      ctx.globalAlpha = 0.35;\n      ctx.fillStyle = isDark ? '#5a6070' : '#b0c4de';\n      fillRoundRect(ctx, 3, 0, w - 3, h, 5);\n      ctx.globalAlpha = 1.0;\n    }\n\n    const ry = stackGap;\n    ctx.fillStyle = isDark ? 'rgba(58, 64, 74, 0.94)' : 'rgba(214, 231, 255, 0.94)';\n    fillRoundRect(ctx, 0, ry, w, h, 5);\n\n    ctx.strokeStyle = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';\n    ctx.lineWidth = 0.5;\n    ctx.beginPath();\n    ctx.moveTo(5, ry);\n    ctx.arcTo(w, ry, w, ry + h, 5);\n    ctx.arcTo(w, ry + h, 0, ry + h, 5);\n    ctx.arcTo(0, ry + h, 0, ry, 5);\n    ctx.arcTo(0, ry, w, ry, 5);\n    ctx.closePath();\n    ctx.stroke();\n\n    const iconEl = getDragIconEl(entry);\n    if (iconEl) {\n      ctx.drawImage(iconEl, 6, ry + 6, 16, 16);\n    } else {\n      ctx.fillStyle = entry.isDir ? '#d9b34f' : '#8d98a5';\n      fillRoundRect(ctx, 6, ry + 6, 16, 16, 2);\n    }\n\n    ctx.fillStyle = isDark ? '#e6e6e8' : '#1a1a1a';\n    ctx.font = '12px -apple-system, \"SF Pro Text\", system-ui, sans-serif';\n    ctx.textBaseline = 'middle';\n\n    let nameMaxW = w - 34;\n    if (count > 1) nameMaxW -= 34;\n\n    let name = entry.name;\n    if (ctx.measureText(name).width > nameMaxW) {\n      while (name.length > 4 && ctx.measureText(name + '\\u2026').width > nameMaxW) {\n        name = name.slice(0, -1);\n      }\n      name += '\\u2026';\n    }\n    ctx.fillText(name, 28, ry + h / 2 + 1);\n\n    if (count > 1) {\n      const badge = String(count);\n      ctx.font = 'bold 10px -apple-system, system-ui, sans-serif';\n      const tw = ctx.measureText(badge).width;\n      const bw = Math.max(20, tw + 10);\n      const bx = w - bw - 6;\n      const by = ry + (h - 18) / 2;\n\n      ctx.fillStyle = isDark ? '#5b8bd9' : '#007aff';\n      fillRoundRect(ctx, bx, by, bw, 18, 9);\n\n      ctx.fillStyle = '#ffffff';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(badge, bx + bw / 2, by + 9);\n    }\n\n    return canvas.toDataURL('image/png');\n  }\n\n  function handleRowMouseDown(event, index) {\n    if (event.button !== 0) return;\n    if (event.metaKey || event.ctrlKey || event.shiftKey) return;\n    if (editing.active) return;\n\n    const startX = event.clientX;\n    const startY = event.clientY;\n    let dragging = false;\n\n    dragCleanup?.();\n\n    const onMove = (e) => {\n      if (dragging) return;\n      const dx = e.clientX - startX;\n      const dy = e.clientY - startY;\n      if (dx * dx + dy * dy < DRAG_THRESHOLD * DRAG_THRESHOLD) return;\n\n      dragging = true;\n      cleanup();\n\n      if (!selectedIndices.has(index)) {\n        selectSingle(index);\n      }\n\n      const paths = dragPathsForIndex(index);\n      if (paths.length > 0) {\n        const icon = buildDragPreview(index);\n        startDrag({ item: paths, icon }).catch(() => {});\n      }\n    };\n\n    const onUp = () => cleanup();\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      if (dragCleanup === cleanup) dragCleanup = null;\n    };\n\n    dragCleanup = cleanup;\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  async function handleRowDoubleClick(index) {\n    if (!selectedIndices.has(index) || selectedIndices.size > 1) {\n      selectSingle(index);\n      await tick();\n    }\n    await invoke('open', { paths: [results[index].path] }).catch((err) => {\n      showToast(`Failed to open: ${String(err)}`);\n    });\n  }\n\n  function closeContextMenu() {\n    contextMenu = {\n      ...contextMenu,\n      visible: false\n    };\n  }\n\n  async function openSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('open', { paths });\n    } catch (err) {\n      showToast(`Failed to open: ${String(err)}`);\n    }\n  }\n\n  async function openWithFallback() {\n    const target = primaryEntry();\n    if (!target) {\n      return;\n    }\n\n    try {\n      await invoke('open_with', { path: target.path });\n    } catch (err) {\n      showToast(`Open With failed: ${String(err)}`);\n    }\n  }\n\n  async function revealSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('reveal_in_finder', { paths });\n    } catch (err) {\n      showToast(`Failed to reveal in Finder: ${String(err)}`);\n    }\n  }\n\n  async function copySelectedPaths() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_paths', { paths });\n      showToast(`Copied ${paths.length} path(s)`);\n    } catch (err) {\n      showToast(`Failed to copy path: ${String(err)}`);\n    }\n  }\n\n  async function copyFiles() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_files', { paths });\n      showToast(`Copied ${paths.length} item(s)`);\n    } catch (err) {\n      showToast(`Failed to copy: ${String(err)}`);\n    }\n  }\n\n  async function trashSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    const message =\n      paths.length === 1\n        ? 'Move selected item to Trash?'\n        : `Move ${paths.length} items to Trash?`;\n\n    if (!window.confirm(message)) {\n      return;\n    }\n\n    try {\n      await invoke('move_to_trash', { paths });\n      showToast('Moved to Trash.');\n      clearSelection();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to move to Trash: ${String(err)}`);\n    }\n  }\n\n  async function resetIndex() {\n    if (indexStatus.state === 'Indexing') {\n      showToast('Indexing in progress. Please try again after it completes.');\n      return;\n    }\n\n    results = [];\n    totalResults = 0;\n    totalResultsKnown = false;\n    clearSelection();\n    scanned = 0;\n    dbLatencyMs = null;\n    dbLastQuery = '';\n    indexStatus = { ...indexStatus, state: 'Indexing', entriesCount: 0, message: null };\n    indexingStartTime = Date.now();\n    indexingElapsed = '';\n    indexingFinishedAt = '';\n\n    try {\n      await invoke('reset_index');\n    } catch (err) {\n      showToast(`Failed to reset index: ${String(err)}`);\n      await refreshStatus();\n    }\n  }\n\n  function isMultiSelected() {\n    return selectedIndices.size > 1;\n  }\n\n  function autoResizeRenameInput() {\n    if (!renameInputEl) return;\n    renameInputEl.style.height = '0';\n    renameInputEl.style.height = renameInputEl.scrollHeight + 'px';\n  }\n\n  async function startRename() {\n    if (isMultiSelected()) {\n      return;\n    }\n\n    const idx = lastSelectedIndex;\n    if (idx < 0 || !results[idx]) {\n      return;\n    }\n\n    const entry = results[idx];\n\n    // Calculate overlay position mathematically.\n    // Name cell text starts at: padding-left(16) + icon(16) + gap(6) = 38px from cell left.\n    // Textarea has padding-left: 0 and border: 1.5px, so text starts ~2px from overlay left.\n    if (tableContainer) {\n      const rect = tableContainer.getBoundingClientRect();\n      const cellLeft = rect.left - tableContainer.scrollLeft;\n      const textLeft = cellLeft + 38;\n      const cellRight = cellLeft + colWidths.name;\n      const rowTop = rect.top + idx * rowHeight - tableContainer.scrollTop;\n      renameOverlay = {\n        top: rowTop,\n        left: textLeft - 2,\n        width: cellRight - textLeft + 2 - 4\n      };\n    }\n\n    editing = {\n      active: true,\n      path: entry.path,\n      index: idx,\n      draftName: entry.name\n    };\n\n    await tick();\n\n    if (renameInputEl) {\n      autoResizeRenameInput();\n      renameInputEl.focus();\n      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n      renameInputEl.setSelectionRange(0, selectionEnd);\n    }\n  }\n\n  function cancelRename() {\n    editing = {\n      active: false,\n      path: '',\n      index: -1,\n      draftName: ''\n    };\n  }\n\n  async function commitRename() {\n    if (!editing.active || editing.index < 0 || !results[editing.index]) {\n      return;\n    }\n\n    const current = results[editing.index];\n    const nextName = editing.draftName;\n\n    try {\n      await invoke('rename', {\n        path: current.path,\n        newName: nextName\n      });\n      cancelRename();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to rename: ${String(err)}`);\n      await tick();\n      renameInputEl?.focus();\n    }\n  }\n\n  function onGlobalClick() {\n    closeContextMenu();\n  }\n\n  function onTitleBarMouseDown(event) {\n    if (event.button !== 0) {\n      return;\n    }\n\n    const activeElement = document.activeElement;\n    if (activeElement instanceof HTMLElement && isTextInputTarget(activeElement)) {\n      activeElement.blur();\n    }\n  }\n\n  async function focusSearch() {\n    await getCurrentWindow().show();\n    await getCurrentWindow().setFocus();\n    searchInputEl?.focus();\n    searchInputEl?.select();\n  }\n\n  function isTextInputTarget(target) {\n    return (\n      target instanceof HTMLInputElement ||\n      target instanceof HTMLTextAreaElement ||\n      target?.isContentEditable\n    );\n  }\n\n  async function handleKeydown(event) {\n    const isMetaSelectAll = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'a';\n    const isMetaCopy = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c';\n    const target = event.target;\n    const isTextInput = isTextInputTarget(target);\n\n    if (isMetaCopy && isTextInput) {\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      if (isTextInput) {\n        event.preventDefault();\n        if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n          target.select();\n        }\n        return;\n      }\n    }\n\n    if (editing.active) {\n      if (event.key === 'Enter') {\n        event.preventDefault();\n        await commitRename();\n        return;\n      }\n\n      if (event.key === 'Escape') {\n        event.preventDefault();\n        const idx = editing.index;\n        cancelRename();\n        selectSingle(idx);\n        await tick();\n        tableContainer?.querySelector('.row.selected')?.focus();\n        return;\n      }\n      return;\n    }\n\n    if (event.key === 'Escape') {\n      event.preventDefault();\n      clearSelection();\n      return;\n    }\n\n    if (event.key === 'ArrowDown') {\n      event.preventDefault();\n      moveSelection(1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'ArrowUp') {\n      event.preventDefault();\n      moveSelection(-1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageDown') {\n      event.preventDefault();\n      moveSelection(Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageUp') {\n      event.preventDefault();\n      moveSelection(-Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'Enter') {\n      event.preventDefault();\n      if (platform === 'windows') {\n        await openSelected();\n      } else {\n        await startRename();\n      }\n      return;\n    }\n\n    if (event.key === 'F2') {\n      event.preventDefault();\n      await startRename();\n      return;\n    }\n\n    if (event.key === ' ' && !isTextInput) {\n      event.preventDefault();\n      const entry = primaryEntry();\n      if (entry) {\n        await invoke('quick_look', { path: entry.path });\n      }\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'f') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      searchInputEl?.select();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'o') {\n      event.preventDefault();\n      await openSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {\n      event.preventDefault();\n      await revealSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c') {\n      event.preventDefault();\n      await copySelectedPaths();\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      event.preventDefault();\n      selectedIndices = new Set(Array.from({ length: results.length }, (_, i) => i));\n      return;\n    }\n\n    if (event.key === 'Delete' || ((event.metaKey || event.ctrlKey) && event.key === 'Backspace')) {\n      if (!isTextInput) {\n        event.preventDefault();\n        await trashSelected();\n      }\n      return;\n    }\n  }\n\n  function formatSize(entry) {\n    if (entry.isDir || entry.size == null) return '';\n    const bytes = entry.size;\n    if (bytes < 1024) return `${bytes} B`;\n    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n    return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n  }\n\n  function formatModified(entry) {\n    if (!entry.mtime) {\n      return '';\n    }\n\n    const d = new Date(entry.mtime * 1000);\n    const pad = (n) => String(n).padStart(2, '0');\n    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;\n  }\n\n  function formatLastUpdated(timestamp) {\n    if (!timestamp) {\n      return '-';\n    }\n\n    return new Date(timestamp * 1000).toLocaleString();\n  }\n\n  function formatElapsed(ms) {\n    const totalSec = Math.floor(ms / 1000);\n    const min = Math.floor(totalSec / 60);\n    const sec = totalSec % 60;\n    return min > 0 ? `${min}m ${sec}s` : `${sec}s`;\n  }\n\n  function updateElapsed() {\n    if (indexingStartTime && indexStatus.state === 'Indexing') {\n      indexingElapsed = formatElapsed(Date.now() - indexingStartTime);\n    }\n  }\n\n  function startElapsedTimer() {\n    clearInterval(elapsedTimer);\n    indexingStartTime = Date.now();\n    indexingElapsed = '0s';\n    indexingFinishedAt = '';\n    elapsedTimer = setInterval(updateElapsed, 1000);\n  }\n\n  function stopElapsedTimer() {\n    clearInterval(elapsedTimer);\n    if (indexingStartTime) {\n      const elapsed = Date.now() - indexingStartTime;\n      indexingFinishedAt = `${formatElapsed(elapsed)}`;\n    }\n    indexingStartTime = null;\n    indexingElapsed = '';\n  }\n\n  function displayPath(path) {\n    if (!path) {\n      return path;\n    }\n\n    if (!homePrefix) {\n      return path;\n    }\n\n    if (path === homePrefix) {\n      return '~';\n    }\n\n    if (path.startsWith(`${homePrefix}/`)) {\n      return `~${path.slice(homePrefix.length)}`;\n    }\n\n    return path;\n  }\n\n  let unlistenFns = [];\n\n  onMount(async () => {\n    const t0 = performance.now();\n    const ms = () => Math.round(performance.now() - t0);\n    const DEBUG_STARTUP = false;\n    const flog = DEBUG_STARTUP ? (msg) => invoke('frontend_log', { msg }).catch(() => {}) : () => {};\n\n    flog(`[startup/fe] onMount entered`);\n\n    updateViewportHeight();\n    flog(`[startup/fe] +${ms()}ms updateViewportHeight done`);\n\n    invoke('set_native_theme', { theme });\n\n    platform = await invoke('get_platform');\n    flog(`[startup/fe] +${ms()}ms get_platform done`);\n\n    const unlistenProgress = await listen('index_progress', (event) => {\n      scanned = event.payload.scanned;\n      if (indexStatus.state !== 'Indexing') {\n        indexStatus = {\n          ...indexStatus,\n          state: 'Indexing'\n        };\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_progress) registered`);\n\n    const unlistenState = await listen('index_state', (event) => {\n      flog(`[startup/fe] index_state event received: ${event.payload.state} at +${ms()}ms`);\n      const prevState = indexStatus.state;\n      indexStatus = {\n        ...indexStatus,\n        state: event.payload.state,\n        message: event.payload.message ?? null,\n        isCatchup: event.payload.isCatchup ?? false\n      };\n\n      if (event.payload.state === 'Indexing' && prevState !== 'Indexing') {\n        if (prevState === 'Ready') {\n          lastReadyCount = indexStatus.entriesCount;\n        }\n        startElapsedTimer();\n      } else if (event.payload.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n\n      if (event.payload.state === 'Ready') {\n        scheduleSearch();\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_state) registered`);\n\n    const unlistenUpdated = await listen('index_updated', (event) => {\n      indexStatus = {\n        ...indexStatus,\n        entriesCount: event.payload.entriesCount,\n        lastUpdated: event.payload.lastUpdated,\n        permissionErrors: event.payload.permissionErrors ?? indexStatus.permissionErrors\n      };\n\n      scheduleSearch(true);\n    });\n\n    const unlistenFocus = await listen('focus_search', () => {\n      void focusSearch();\n    });\n\n    const unlistenCtxMenuAction = await listen('context_menu_action', (event) => {\n      switch (event.payload) {\n        case 'open': void openSelected(); break;\n        case 'quick_look': {\n          const e = primaryEntry();\n          if (e) void invoke('quick_look', { path: e.path });\n          break;\n        }\n        case 'open_with': void openWithFallback(); break;\n        case 'reveal': void revealSelected(); break;\n        case 'copy_files': void copyFiles(); break;\n        case 'copy_path': void copySelectedPaths(); break;\n        case 'trash': void trashSelected(); break;\n        case 'rename': void startRename(); break;\n      }\n    });\n\n    unlistenFns = [unlistenProgress, unlistenState, unlistenUpdated, unlistenFocus, unlistenCtxMenuAction];\n    flog(`[startup/fe] +${ms()}ms all listeners registered`);\n\n    // Fetch backend state IMMEDIATELY after listeners are registered.\n    // Events emitted before listener registration are lost, so this\n    // is the only reliable way to get the current state.\n    await refreshStatus();\n    flog(`[startup/fe] +${ms()}ms refreshStatus done (state=${indexStatus.state})`);\n\n    // Show Svelte UI: remove skeleton, focus search input.\n    await tick();\n    document.getElementById('skeleton')?.remove();\n    await focusSearch();\n    flog(`[startup/fe] +${ms()}ms WINDOW VISIBLE â€” skeleton removed`);\n\n    try {\n      homePrefix = await invoke('get_home_dir');\n    } catch {\n      homePrefix = '';\n    }\n    flog(`[startup/fe] +${ms()}ms get_home_dir done`);\n\n    if (!localStorage.getItem('everything-fda-notice-v1')) {\n      showToast('macOS Full Disk Access permission may be required for full disk search.');\n      localStorage.setItem('everything-fda-notice-v1', '1');\n    }\n    flog(`[startup/fe] +${ms()}ms calling runSearch...`);\n    await runSearch();\n    flog(`[startup/fe] +${ms()}ms runSearch done`);\n\n    if (typeof ResizeObserver !== 'undefined') {\n      tableResizeObserver = new ResizeObserver(() => {\n        scheduleViewportHeightUpdate();\n      });\n      if (tableContainer) {\n        tableResizeObserver.observe(tableContainer);\n      } else if (tableAreaEl) {\n        tableResizeObserver.observe(tableAreaEl);\n      }\n    }\n\n    window.addEventListener('resize', scheduleViewportHeightUpdate);\n    window.addEventListener('click', onGlobalClick);\n    statusRefreshTimer = setInterval(() => {\n      if (indexStatus.state === 'Indexing') {\n        void refreshStatus();\n      }\n    }, 1000);\n    console.log(`[startup/fe] +${ms()}ms onMount complete`);\n  });\n\n  onDestroy(async () => {\n    clearTimeout(searchTimer);\n    clearTimeout(toastTimer);\n    clearInterval(statusRefreshTimer);\n    clearInterval(elapsedTimer);\n    resizeCleanup?.();\n\n    for (const unlisten of unlistenFns) {\n      unlisten();\n    }\n\n    tableResizeObserver?.disconnect();\n    tableResizeObserver = null;\n    if (viewportResizeRaf !== null) {\n      cancelAnimationFrame(viewportResizeRaf);\n      viewportResizeRaf = null;\n    }\n    window.removeEventListener('resize', scheduleViewportHeightUpdate);\n    window.removeEventListener('click', onGlobalClick);\n  });\n</script>\n\n<svelte:window on:keydown={handleKeydown} />\n\n<div class=\"app-shell\" data-theme={theme}>\n  <div class=\"title-bar\" role=\"presentation\" data-tauri-drag-region on:mousedown={onTitleBarMouseDown}>\n    <div class=\"title-left\"></div>\n    <div class=\"title-center\">\n      <svg class=\"title-icon\" viewBox=\"0 0 215 205\" fill-rule=\"evenodd\" aria-hidden=\"true\">\n        <path d=\"M85 0c46.9 0 85 38.1 85 85 0 20.1-7.2 38.5-19.2 52.7l40.7 40.8c5.8 5.8 5.8 15.2 0 21-5.8 5.8-15.2 5.8-21 0l-40.7-40.7c-13.6 9.7-30.4 15.2-44.8 15.2-46.9 0-85-42.1-85-89 0-46.9 38.1-85 85-85z m0 32c-29.3 0-53 23.7-53 53 0 29.3 23.7 53 53 53 29.3 0 53-23.7 53-53 0-29.3-23.7-53-53-53z\"/>\n      </svg>\n      <span class=\"title-text\">Everything</span>\n    </div>\n    <div class=\"title-right\"></div>\n  </div>\n\n  <header class=\"search-bar\">\n    <input\n      bind:this={searchInputEl}\n      class=\"search-input\"\n      type=\"text\"\n      bind:value={query}\n      on:input={scheduleSearch}\n      on:focus={clearSelection}\n      placeholder=\"Search file/folder names\"\n      autocomplete=\"off\"\n      spellcheck=\"false\"\n    />\n  </header>\n\n  <section class=\"table-area\" bind:this={tableAreaEl} style={tableGridStyle}>\n    <div class=\"table-header\">\n      <div class=\"table-header-track\">\n        <div class=\"col name\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('name')}>\n            Name{#if sortBy === 'name'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'name'}\n            on:mousedown={(event) => startColumnResize(event, 'name')}\n            aria-label=\"Resize Name column\"\n          />\n        </div>\n\n        <div class=\"col path\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('dir')}>\n            Path{#if sortBy === 'dir'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'path'}\n            on:mousedown={(event) => startColumnResize(event, 'path')}\n            aria-label=\"Resize Path column\"\n          />\n        </div>\n\n        <div class=\"col size\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('size')}>\n            Size{#if sortBy === 'size'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n\n        <div class=\"col modified\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('mtime')}>\n            Modified{#if sortBy === 'mtime'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n      </div>\n    </div>\n\n    <div\n      class=\"table-body\"\n      bind:this={tableContainer}\n      on:scroll={() => {\n        scrollTop = tableContainer.scrollTop;\n        headerScrollLeft = tableContainer.scrollLeft;\n        if (editing.active) cancelRename();\n        const scrollBottom = scrollTop + tableContainer.clientHeight;\n        if (scrollBottom >= totalHeight - rowHeight * 10) {\n          void loadMore();\n        }\n      }}\n    >\n      <div class=\"spacer\" style={`height:${totalHeight}px`}>\n        <div class=\"rows\" style={`transform: translateY(${translateY}px);`}>\n          {#each visibleRows as entry, localIndex}\n            {@const index = startIndex + localIndex}\n            <div\n              class=\"row {selectedIndices.has(index) ? 'selected' : ''}\"\n              on:mousedown={(event) => handleRowMouseDown(event, index)}\n              on:click={(event) => handleRowClick(event, index)}\n              on:keydown={(event) => handleRowA11yKeydown(event, index)}\n              on:dblclick={() => handleRowDoubleClick(index)}\n              on:contextmenu={(event) => handleRowContextMenu(event, index)}\n              role=\"row\"\n              tabindex=\"0\"\n            >\n              <div class=\"cell name\">\n                <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n                <span class=\"ellipsis\" class:name-editing={editing.active && editing.index === index}>{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n              </div>\n              <div class=\"cell path\"><span class=\"ellipsis\">{displayPath(entry.dir)}</span></div>\n              <div class=\"cell size\">{formatSize(entry)}</div>\n              <div class=\"cell modified\">{formatModified(entry)}</div>\n            </div>\n          {/each}\n        </div>\n      </div>\n    </div>\n  </section>\n\n  <footer class=\"status-bar\">\n    <div class=\"status-left\">\n      <span class=\"status-state\">\n        <span class=\"state-dot {indexStatus.state === 'Indexing' ? 'indexing' : indexStatus.state === 'Error' ? 'error' : 'ready'}\"></span>\n        {#if indexStatus.state === 'Indexing'}\n          Indexing{#if lastReadyCount > 0} ({Math.min(99, Math.round((scanned / lastReadyCount) * 100))}%){/if}{#if indexingElapsed} Â· {indexingElapsed}{/if}\n          {#if !indexStatus.isCatchup}\n            Â· {scanned.toLocaleString()} scanned\n          {/if}\n        {:else}\n          Index: {indexStatus.state}\n        {/if}\n      </span>\n      <span>{indexStatus.entriesCount.toLocaleString()} entries</span>\n      {#if indexingFinishedAt && indexStatus.state !== 'Indexing'}\n        <span>in {indexingFinishedAt}</span>\n      {/if}\n      {#if dbLatencyMs !== null && dbLastQuery}\n        <span>\"{dbLastQuery}\" {dbLatencyMs}ms Â· {totalResults} results</span>\n      {/if}\n      {#if searchModeLabel === 'spotlight' || searchModeLabel === 'spotlight_timeout'}\n        <span class=\"status-spotlight\">Spotlight fallback{#if searchModeLabel === 'spotlight_timeout'} (partial){/if}</span>\n      {/if}\n      {#if indexStatus.permissionErrors > 0}\n        <span class=\"status-warning\">{indexStatus.permissionErrors.toLocaleString()} permission errors</span>\n      {/if}\n      {#if indexStatus.message}\n        <span class={indexStatus.isCatchup ? 'index-progress' : 'status-error'}>{indexStatus.message}</span>\n      {/if}\n    </div>\n    <div class=\"status-right\">\n      <button class=\"status-btn theme-btn\" on:click={cycleTheme} title=\"Switch theme\">\n        {theme === 'dark' ? 'â˜€ Light' : 'â—‘ Dark'}\n      </button>\n      <button\n        class=\"status-btn rebuild-btn\"\n        on:click={resetIndex}\n        disabled={indexStatus.state === 'Indexing'}\n        title={indexStatus.state === 'Indexing' ? 'Cannot reset while indexing is in progress.' : 'Reset and rebuild the index.'}\n      >\n        <svg class=\"rebuild-icon\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n          <path d=\"M23 4v6h-6\"/><path d=\"M20.49 15a9 9 0 1 1-2.12-9.36L23 10\"/>\n        </svg>\n        Rebuild Index\n      </button>\n    </div>\n  </footer>\n\n  {#if editing.active}\n    <div\n      class=\"rename-overlay\"\n      style=\"top:{renameOverlay.top}px; left:{renameOverlay.left}px; width:{renameOverlay.width}px;\"\n      role=\"presentation\"\n      on:mousedown|stopPropagation\n    >\n      <textarea\n        bind:this={renameInputEl}\n        class=\"rename-textarea\"\n        bind:value={editing.draftName}\n        on:input={autoResizeRenameInput}\n        on:click|stopPropagation\n        on:blur={commitRename}\n      />\n    </div>\n  {/if}\n\n  {#if contextMenu.visible}\n    <div class=\"context-menu\" style={`left:${contextMenu.x}px;top:${contextMenu.y}px;`}>\n      <button on:click={() => (closeContextMenu(), openSelected())}>Open</button>\n      <button on:click={async () => { closeContextMenu(); const e = primaryEntry(); if (e) await invoke('quick_look', { path: e.path }); }}>Quick Look</button>\n      <button on:click={() => (closeContextMenu(), openWithFallback())}>Open With... (Reveal in Finder)</button>\n      <button on:click={() => (closeContextMenu(), revealSelected())}>Reveal in Finder</button>\n      <button on:click={() => (closeContextMenu(), copySelectedPaths())}>Copy Path</button>\n      <button on:click={() => (closeContextMenu(), trashSelected())}>Move to Trash</button>\n      {#if selectedIndices.size === 1}\n        <button on:click={() => (closeContextMenu(), startRename())}>Rename</button>\n      {/if}\n    </div>\n  {/if}\n\n  {#if toast}\n    <div class=\"toast\">{toast}</div>\n  {/if}\n</div>\n\n<style>\n  :global(:root) {\n    color-scheme: light dark;\n    --bg-app: transparent;\n    --text-primary: #0d1826;\n    --text-muted: #48596c;\n    --bar-grad-top: rgba(255, 255, 255, 0.48);\n    --bar-grad-bottom: rgba(248, 250, 253, 0.42);\n    --surface-header: rgba(252, 252, 255, 0.40);\n    --surface: rgba(255, 255, 255, 0.22);\n    --border-soft: rgba(0, 0, 0, 0.07);\n    --border-input: rgba(0, 0, 0, 0.13);\n    --focus-ring: #6f96e6;\n    --row-border: rgba(0, 0, 0, 0.032);\n    --row-hover: rgba(0, 0, 0, 0.06);\n    --row-selected: rgba(0, 0, 0, 0.12);\n    --button-bg: rgba(255, 255, 255, 0.62);\n    --button-border: rgba(0, 0, 0, 0.10);\n    --button-text: #2c3e50;\n    --menu-bg: rgba(240, 241, 248, 0.90);\n    --menu-border: rgba(0, 0, 0, 0.06);\n    --menu-hover: rgba(255, 255, 255, 0.62);\n    --menu-text: #1a2a38;\n    --error-text: #b64545;\n    --warning-text: #8f6500;\n    --toast-bg: rgba(18, 22, 32, 0.90);\n    --toast-text: #ffffff;\n  }\n\n  @media (prefers-color-scheme: dark) {\n    :global(:root) {\n      --bg-app: transparent;\n      --text-primary: #e6e6ea;\n      --text-muted: #9494a4;\n      --bar-grad-top: rgba(38, 38, 46, 0.52);\n      --bar-grad-bottom: rgba(30, 30, 38, 0.46);\n      --surface-header: rgba(32, 32, 40, 0.46);\n      --surface: rgba(18, 18, 26, 0.32);\n      --border-soft: rgba(255, 255, 255, 0.065);\n      --border-input: rgba(255, 255, 255, 0.14);\n      --focus-ring: #5b8bd9;\n      --row-border: rgba(255, 255, 255, 0.026);\n      --row-hover: rgba(255, 255, 255, 0.08);\n      --row-selected: rgba(255, 255, 255, 0.14);\n      --button-bg: rgba(255, 255, 255, 0.072);\n      --button-border: rgba(255, 255, 255, 0.11);\n      --button-text: #d6d6e0;\n      --menu-bg: rgba(36, 36, 46, 0.90);\n      --menu-border: rgba(255, 255, 255, 0.066);\n      --menu-hover: rgba(255, 255, 255, 0.062);\n      --menu-text: #e0e0e8;\n      --error-text: #ff9d9d;\n      --warning-text: #e0c670;\n      --toast-bg: rgba(10, 10, 16, 0.93);\n      --toast-text: #f2f2f6;\n    }\n  }\n\n  /* â”€â”€ Theme: Dark â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme=\"dark\"]) {\n    color-scheme: dark;\n    --bg-app: #1E1E21;\n    --text-primary: #E2E8F0;\n    --text-muted: #94A3B8;\n    --bar-grad-top: #1E1E21;\n    --bar-grad-bottom: #1E1E21;\n    --surface-header: #1E1E21;\n    --surface: #1E1E21;\n    --bg-input: #161618;\n    --border-soft: #2A2A2D;\n    --border-input: rgba(255, 255, 255, 0.06);\n    --focus-ring: #4DA8FF;\n    --accent: #4DA8FF;\n    --row-border: rgba(255, 255, 255, 0.02);\n    --row-hover: #282828;\n    --row-selected: rgba(77, 168, 255, 0.10);\n    --button-bg: rgba(255, 255, 255, 0.05);\n    --button-border: #2A2A2D;\n    --button-text: #94A3B8;\n    --menu-bg: #252528;\n    --menu-border: #2A2A2D;\n    --menu-hover: rgba(255, 255, 255, 0.04);\n    --menu-text: #E2E8F0;\n    --error-text: #ff9d9d;\n    --warning-text: #e0c670;\n    --toast-bg: rgba(10, 10, 16, 0.93);\n    --toast-text: #f2f2f6;\n  }\n\n  /* â”€â”€ Theme: Light â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme=\"light\"]) {\n    color-scheme: light;\n    --bg-app: #F5F5F7;\n    --text-primary: #1C1C1E;\n    --text-muted: #6E6E7A;\n    --bar-grad-top: #F5F5F7;\n    --bar-grad-bottom: #F5F5F7;\n    --surface-header: #F5F5F7;\n    --surface: #F5F5F7;\n    --bg-input: #FFFFFF;\n    --border-soft: #D1D1D6;\n    --border-input: rgba(0, 0, 0, 0.10);\n    --focus-ring: #3A8BF5;\n    --accent: #3A8BF5;\n    --row-border: rgba(0, 0, 0, 0.04);\n    --row-hover: rgba(0, 0, 0, 0.04);\n    --row-selected: rgba(58, 139, 245, 0.10);\n    --button-bg: #FFFFFF;\n    --button-border: #D1D1D6;\n    --button-text: #3C3C43;\n    --menu-bg: #FFFFFF;\n    --menu-border: #D1D1D6;\n    --menu-hover: rgba(0, 0, 0, 0.05);\n    --menu-text: #1C1C1E;\n    --error-text: #D93025;\n    --warning-text: #B45309;\n    --toast-bg: rgba(255, 255, 255, 0.95);\n    --toast-text: #1C1C1E;\n  }\n\n  /* â”€â”€ Themed element overrides â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme]) {\n    background: var(--bg-app);\n  }\n\n  /* Search bar: flat, no gradient, no separator */\n  :global([data-theme]) .search-bar {\n    height: 44px;\n    padding: 0 16px;\n    background: var(--bg-app);\n    border-bottom: none;\n  }\n\n  :global([data-theme]) .search-input {\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n    font-family: 'JetBrains Mono', 'SF Mono', monospace;\n    font-size: 12px;\n    height: 34px;\n    border-radius: 8px;\n  }\n\n  /* Table header: flat bg, 16px edge padding */\n  :global([data-theme]) .table-header {\n    background: var(--bg-app);\n  }\n\n  :global([data-theme]) .col-button {\n    padding: 0 8px;\n  }\n\n  :global([data-theme]) .col.name .col-button {\n    padding-left: 16px;\n  }\n\n  /* Row cells: JetBrains Mono, 16px outer edges */\n  :global([data-theme]) .cell {\n    font-family: 'JetBrains Mono', monospace;\n  }\n\n  :global([data-theme]) .cell.name {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    padding-left: 16px;\n    font-size: 12px;\n    color: var(--text-primary);\n  }\n\n  :global([data-theme]) .cell.path {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.size {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.modified {\n    padding-right: 16px;\n    font-size: 11px;\n    white-space: nowrap;\n  }\n\n  :global([data-theme]) .row.selected {\n    box-shadow: inset 3px 0 0 var(--accent);\n  }\n\n  /* Dim path/size/date cells in themed mode */\n  :global([data-theme]) .cell.path,\n  :global([data-theme]) .cell.size,\n  :global([data-theme]) .cell.modified {\n    color: var(--text-muted);\n  }\n\n  :global(:root) {\n    background: transparent;\n  }\n\n  :global(html, body) {\n    margin: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    background: transparent;\n    color: var(--text-primary);\n    font-family: Inter, 'SF Pro Text', 'Segoe UI', Helvetica, Arial, sans-serif;\n  }\n\n  :global(#app) {\n    width: 100%;\n    height: 100%;\n  }\n\n  .app-shell {\n    display: grid;\n    grid-template-rows: auto auto 1fr auto;\n    height: 100%;\n    min-width: 0;\n  }\n\n  .title-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 44px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    cursor: default;\n    flex-shrink: 0;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-left {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-center {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-right {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-icon {\n    width: 14px;\n    height: 14px;\n    fill: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .title-text {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 13px;\n    font-weight: 500;\n    color: var(--text-primary);\n    letter-spacing: -0.01em;\n  }\n\n  .search-bar {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding: 8px;\n    background: linear-gradient(180deg, var(--bar-grad-top) 0%, var(--bar-grad-bottom) 100%);\n    border-bottom: 1px solid var(--border-soft);\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .search-input {\n    display: block;\n    box-sizing: border-box;\n    width: 100%;\n    min-width: 0;\n    flex: 1 1 auto;\n    height: 36px;\n    border: 1px solid var(--border-input);\n    border-radius: 14px;\n    padding: 0 10px;\n    font-size: 14px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    backdrop-filter: blur(12px) saturate(160%);\n    -webkit-backdrop-filter: blur(12px) saturate(160%);\n  }\n\n  .search-input::placeholder {\n    color: var(--text-muted);\n    opacity: 0.85;\n    font-size: 12px;\n  }\n\n  .search-input:focus {\n    outline: none;\n    border-color: var(--focus-ring);\n    box-shadow: 0 0 0 2px rgba(125, 169, 255, 0.25);\n  }\n\n  .table-area {\n    display: grid;\n    grid-template-rows: auto 1fr;\n    min-height: 0;\n    min-width: 0;\n  }\n\n  .table-header-track,\n  .row {\n    display: grid;\n    grid-template-columns: var(--col-name) var(--col-path) var(--col-size) var(--col-modified);\n    align-items: center;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .table-header {\n    height: 32px;\n    border-bottom: 1px solid var(--border-soft);\n    background: var(--surface-header);\n    user-select: none;\n    overflow: hidden;\n    flex-shrink: 0;\n  }\n\n  .table-header-track {\n    height: 100%;\n    transform: translateX(var(--header-offset, 0px));\n    will-change: transform;\n  }\n\n  .table-header .col {\n    position: relative;\n    min-width: 0;\n    height: 100%;\n  }\n\n  .col-button {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n    gap: 4px;\n    box-sizing: border-box;\n    padding: 0 8px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 11px;\n    font-weight: 600;\n    line-height: 1;\n    color: var(--text-muted);\n    text-align: left;\n    margin: 0;\n    border: none;\n    background: transparent;\n    cursor: pointer;\n  }\n\n  .sort-icon {\n    width: 10px;\n    height: 10px;\n    flex-shrink: 0;\n    color: var(--accent);\n  }\n\n  .col-resizer {\n    position: absolute;\n    top: 0;\n    right: -4px;\n    width: 8px;\n    height: 100%;\n    border: none;\n    padding: 0;\n    background: transparent;\n    cursor: col-resize;\n    z-index: 30;\n  }\n\n  .col-resizer::after {\n    content: '';\n    position: absolute;\n    top: 7px;\n    bottom: 7px;\n    left: 50%;\n    width: 1px;\n    transform: translateX(-50%);\n    background: var(--border-soft);\n    opacity: 0;\n    transition: opacity 0.15s ease;\n  }\n\n  .table-header .col:hover .col-resizer::after,\n  .col-resizer.active::after {\n    opacity: 1;\n  }\n\n  .table-body {\n    overflow: auto;\n    min-height: 0;\n    min-width: 0;\n    background: var(--surface);\n  }\n\n  .spacer {\n    position: relative;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .rows {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .row {\n    height: 30px;\n    border-bottom: 1px solid var(--row-border);\n    cursor: default;\n    -webkit-user-select: none;\n    user-select: none;\n    outline: none;\n  }\n\n  .row:hover {\n    background: var(--row-hover);\n  }\n\n  .row.selected {\n    background: var(--row-selected);\n  }\n\n  .cell {\n    padding: 0 8px;\n    font-size: 12px;\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    min-width: 0;\n  }\n\n  .cell.size {\n    text-align: right;\n    font-variant-numeric: tabular-nums;\n  }\n\n  .ellipsis {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n\n  .hl {\n    background: none;\n    color: inherit;\n    font-weight: 700;\n  }\n\n  .file-icon {\n    width: 16px;\n    height: 16px;\n    flex: 0 0 auto;\n  }\n\n  .name-editing {\n    opacity: 0.25;\n  }\n\n  .rename-overlay {\n    position: fixed;\n    z-index: 100;\n    min-width: 120px;\n  }\n\n  .rename-textarea {\n    display: block;\n    width: 100%;\n    box-sizing: border-box;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 12px;\n    line-height: 18px;\n    padding: 5px 4px 5px 0;\n    border: 1.5px solid var(--focus-ring);\n    border-radius: 4px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    outline: none;\n    resize: none;\n    overflow: hidden;\n    box-shadow: 0 2px 14px rgba(0, 0, 0, 0.22), 0 0 0 3px rgba(77, 168, 255, 0.13);\n  }\n\n  .status-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 32px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    border-top: 1px solid var(--border-soft);\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 11px;\n    color: var(--text-muted);\n    white-space: nowrap;\n    overflow: hidden;\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .status-left {\n    display: flex;\n    align-items: center;\n    gap: 16px;\n    overflow: hidden;\n    min-width: 0;\n  }\n\n  .status-right {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    flex-shrink: 0;\n  }\n\n  .status-btn {\n    border: 1px solid var(--button-border);\n    border-radius: 5px;\n    background: var(--button-bg);\n    color: var(--button-text);\n    font-size: 11px;\n    height: 22px;\n    padding: 0 8px;\n    cursor: pointer;\n  }\n\n  .status-btn:hover {\n    filter: brightness(1.06);\n  }\n\n  .status-btn:disabled {\n    opacity: 0.55;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .status-state {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n  }\n\n  .state-dot {\n    width: 6px;\n    height: 6px;\n    border-radius: 50%;\n    flex-shrink: 0;\n  }\n\n  .state-dot.ready { background: #28C840; }\n  .state-dot.indexing { background: #FEBC2E; }\n  .state-dot.error { background: #FF5F57; }\n\n  .rebuild-btn {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 10px;\n    font-weight: 500;\n    background: var(--button-bg);\n    border: 1px solid var(--button-border);\n    border-radius: 4px;\n    color: var(--button-text);\n    height: 22px;\n    padding: 0 10px;\n    cursor: pointer;\n  }\n\n  .rebuild-btn:hover {\n    filter: brightness(1.1);\n  }\n\n  .rebuild-btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .rebuild-icon {\n    width: 11px;\n    height: 11px;\n    color: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .status-error {\n    color: var(--error-text);\n  }\n\n  .status-warning {\n    color: var(--warning-text);\n  }\n\n  .status-spotlight {\n    color: #f59e0b;\n    font-weight: 600;\n  }\n\n  .context-menu {\n    position: fixed;\n    z-index: 200;\n    width: 220px;\n    border: 1px solid var(--menu-border);\n    border-radius: 10px;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.16), inset 0 0 0 0.5px rgba(255, 255, 255, 0.18);\n    background: var(--menu-bg);\n    backdrop-filter: blur(28px) saturate(180%);\n    -webkit-backdrop-filter: blur(28px) saturate(180%);\n    overflow: hidden;\n  }\n\n  .context-menu button {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    padding: 8px 10px;\n    font-size: 12px;\n    color: var(--menu-text);\n  }\n\n  .context-menu button:hover {\n    background: var(--menu-hover);\n  }\n\n  .toast {\n    position: fixed;\n    right: 14px;\n    bottom: 18px;\n    background: var(--toast-bg);\n    color: var(--toast-text);\n    border-radius: 10px;\n    padding: 9px 12px;\n    font-size: 12px;\n    z-index: 250;\n    backdrop-filter: blur(20px) saturate(180%);\n    -webkit-backdrop-filter: blur(20px) saturate(180%);\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);\n  }\n</style>\n","structuredPatch":[{"oldStart":1496,"oldLines":7,"newStart":1496,"newLines":7,"lines":["       on:scroll={() => {","         scrollTop = tableContainer.scrollTop;","         headerScrollLeft = tableContainer.scrollLeft;","-        if (editing.active) cancelRename();","+        if (editing.active) void commitRename();","         const scrollBottom = scrollTop + tableContainer.clientHeight;","         if (scrollBottom >= totalHeight - rowHeight * 10) {","           void loadMore();"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"944cf29a-b74b-4058-bd23-8e54493a6eae"}
{"parentUuid":"53960ac4-565d-418b-96ca-6d97918b7beb","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_018jRYmmdjXVysS5xkUb5qXF","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Fr3Rh7GHnK4Wh2USGqRK7i","name":"Read","input":{"file_path":"/Users/al02402336/everything/src/App.svelte","offset":1556,"limit":6},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":180,"cache_read_input_tokens":95317,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":180},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPMbbPTWY7RKU9ZwxGM","type":"assistant","uuid":"2c8f465b-fb01-4dd5-acd1-7dc347bb04e2","timestamp":"2026-02-21T14:39:17.033Z"}
{"parentUuid":"2c8f465b-fb01-4dd5-acd1-7dc347bb04e2","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01Fr3Rh7GHnK4Wh2USGqRK7i","toolUseID":"toolu_01Fr3Rh7GHnK4Wh2USGqRK7i","timestamp":"2026-02-21T14:39:17.052Z","uuid":"ebe8931f-e411-4bdd-a962-68a68866d210"}
{"parentUuid":"2c8f465b-fb01-4dd5-acd1-7dc347bb04e2","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Fr3Rh7GHnK4Wh2USGqRK7i","type":"tool_result","content":"  1556â†’      {/if}\n  1557â†’      {#if indexStatus.permissionErrors > 0}\n  1558â†’        <span class=\"status-warning\">{indexStatus.permissionErrors.toLocaleString()} permission errors</span>\n  1559â†’      {/if}\n  1560â†’      {#if indexStatus.message}\n  1561â†’        <span class={indexStatus.isCatchup ? 'index-progress' : 'status-error'}>{indexStatus.message}</span>\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"7d7457db-dd7c-4bf6-8f7c-23156449f84b","timestamp":"2026-02-21T14:39:17.051Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src/App.svelte","content":"      {/if}\n      {#if indexStatus.permissionErrors > 0}\n        <span class=\"status-warning\">{indexStatus.permissionErrors.toLocaleString()} permission errors</span>\n      {/if}\n      {#if indexStatus.message}\n        <span class={indexStatus.isCatchup ? 'index-progress' : 'status-error'}>{indexStatus.message}</span>","numLines":6,"startLine":1556,"totalLines":2277}},"sourceToolAssistantUUID":"2c8f465b-fb01-4dd5-acd1-7dc347bb04e2"}
{"parentUuid":"7d7457db-dd7c-4bf6-8f7c-23156449f84b","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01HSEDTtp8hdsxS5YKAXiKfN","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DzgJtU4YBfZFfiPYKvhv6S","name":"Read","input":{"file_path":"/Users/al02402336/everything/src/App.svelte","offset":1563,"limit":6},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":319,"cache_read_input_tokens":95497,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":319},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPMp1ktcPvkjE4m4Ewb","type":"assistant","uuid":"4a7617a8-86ba-48e3-aaf5-b3cd6a3caeee","timestamp":"2026-02-21T14:39:19.776Z"}
{"parentUuid":"4a7617a8-86ba-48e3-aaf5-b3cd6a3caeee","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01DzgJtU4YBfZFfiPYKvhv6S","toolUseID":"toolu_01DzgJtU4YBfZFfiPYKvhv6S","timestamp":"2026-02-21T14:39:19.783Z","uuid":"00922c5f-156f-42c6-b39f-064aaa6ed693"}
{"parentUuid":"4a7617a8-86ba-48e3-aaf5-b3cd6a3caeee","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DzgJtU4YBfZFfiPYKvhv6S","type":"tool_result","content":"  1563â†’    </div>\n  1564â†’    <div class=\"status-right\">\n  1565â†’      <button class=\"status-btn theme-btn\" on:click={cycleTheme} title=\"Switch theme\">\n  1566â†’        {theme === 'dark' ? 'â˜€ Light' : 'â—‘ Dark'}\n  1567â†’      </button>\n  1568â†’      <button\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"f9cdf32e-f139-43c3-b210-7fa04317bf5b","timestamp":"2026-02-21T14:39:19.782Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src/App.svelte","content":"    </div>\n    <div class=\"status-right\">\n      <button class=\"status-btn theme-btn\" on:click={cycleTheme} title=\"Switch theme\">\n        {theme === 'dark' ? 'â˜€ Light' : 'â—‘ Dark'}\n      </button>\n      <button","numLines":6,"startLine":1563,"totalLines":2277}},"sourceToolAssistantUUID":"4a7617a8-86ba-48e3-aaf5-b3cd6a3caeee"}
{"parentUuid":"f9cdf32e-f139-43c3-b210-7fa04317bf5b","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01T2DmdiwQydRDG24MtU79u6","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KFXY9DhG5tgWWyoHadhS75","name":"Edit","input":{"replace_all":false,"file_path":"/Users/al02402336/everything/src/App.svelte","old_string":"      <button class=\"status-btn theme-btn\" on:click={cycleTheme} title=\"Switch theme\">","new_string":"      <button class=\"status-btn\" on:click={cycleTheme} title=\"Switch theme\">"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":292,"cache_read_input_tokens":95816,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":292},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPN2TceJZ8BjoUtyZA7","type":"assistant","uuid":"ba852004-4461-4dc4-b70d-af38b492c147","timestamp":"2026-02-21T14:39:22.678Z"}
{"parentUuid":"ba852004-4461-4dc4-b70d-af38b492c147","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01KFXY9DhG5tgWWyoHadhS75","toolUseID":"toolu_01KFXY9DhG5tgWWyoHadhS75","timestamp":"2026-02-21T14:39:22.683Z","uuid":"01fd2cfa-8059-4147-bb79-0e04c85ae64e"}
{"parentUuid":"ba852004-4461-4dc4-b70d-af38b492c147","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KFXY9DhG5tgWWyoHadhS75","type":"tool_result","content":"The file /Users/al02402336/everything/src/App.svelte has been updated successfully."}]},"uuid":"defd8358-40e2-46db-a3d7-ec9964108c9b","timestamp":"2026-02-21T14:39:22.683Z","toolUseResult":{"filePath":"/Users/al02402336/everything/src/App.svelte","oldString":"      <button class=\"status-btn theme-btn\" on:click={cycleTheme} title=\"Switch theme\">","newString":"      <button class=\"status-btn\" on:click={cycleTheme} title=\"Switch theme\">","originalFile":"<script>\n  import { onDestroy, onMount, tick } from 'svelte';\n  import { invoke } from '@tauri-apps/api/core';\n  import { listen } from '@tauri-apps/api/event';\n  import { getCurrentWindow } from '@tauri-apps/api/window';\n  import { startDrag } from '@crabnebula/tauri-plugin-drag';\n\n  const rowHeight = 30;\n  const PAGE_SIZE = 500;\n  let homePrefix = '';\n  const COL_WIDTHS_KEY = 'REDACTED';\n  const THEME_KEY = 'everything-theme';\n  const columnKeys = ['name', 'path', 'size', 'modified'];\n  const minColumnWidth = {\n    name: 180,\n    path: 240,\n    size: 75,\n    modified: 150\n  };\n  const defaultColumnRatios = {\n    name: 0.3,\n    path: 0.45,\n    size: 0.1\n  };\n\n  const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';\n  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || systemTheme; } catch { return systemTheme; } })();\n  function cycleTheme() {\n    theme = theme === 'dark' ? 'light' : 'dark';\n    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n    invoke('set_native_theme', { theme });\n  }\n\n  let query = '';\n  let results = [];\n  let totalResults = 0;\n  let totalResultsKnown = false;\n\n  let dbLatencyMs = null;\n  let dbLastQuery = '';\n  let searchModeLabel = '';\n  let selectedIndices = new Set();\n  let selectionAnchor = -1;\n  let lastSelectedIndex = -1;\n  let editing = {\n    active: false,\n    path: '',\n    index: -1,\n    draftName: ''\n  };\n\n  let renameOverlay = { top: 0, left: 0, width: 0 };\n\n  let indexStatus = {\n    state: 'Indexing',\n    entriesCount: 0,\n    lastUpdated: null,\n    permissionErrors: 0,\n    message: null,\n    isCatchup: false\n  };\n\n  let indexingStartTime = null;\n  let indexingElapsed = '';\n  let indexingFinishedAt = '';\n\n  let sortBy = 'name';\n  let sortDir = 'asc';\n\n  let hasMore = true;\n  let loadingMore = false;\n  let searchGeneration = 0;\n\n  let scanned = 0;\n\n  let searchInputEl;\n  let renameInputEl;\n  let tableAreaEl;\n  let tableContainer;\n  let tableResizeObserver = null;\n  let viewportResizeRaf = null;\n  let scrollTop = 0;\n  let headerScrollLeft = 0;\n  let viewportHeight = 520;\n  let lastTableWidth = 0;\n  let resizingColumn = '';\n  let resizeCleanup = null;\n  let colWidths = {\n    name: 250,\n    path: 350,\n    size: 75,\n    modified: 150\n  };\n\n  let contextMenu = {\n    visible: false,\n    x: 0,\n    y: 0\n  };\n\n  let platform = '';\n  let toast = '';\n  let searchTimer;\n  let lastSearchFiredAt = 0;\n  let toastTimer;\n  let statusRefreshTimer;\n  let elapsedTimer;\n  let statusRefreshInFlight = false;\n  let lastReadyCount = 0;\n\n  const iconCache = new Map();\n  const iconLoading = new Set();\n\n  let highlightCache = new Map();\n  let highlightCacheQuery = '';\n\n  const folderFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='1' y='4' width='14' height='10' rx='2' fill='#d9b34f'/><rect x='1' y='2' width='6' height='4' rx='1' fill='#e6ca7a'/></svg>`\n    );\n  const fileFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='3' y='1' width='10' height='14' rx='1.5' fill='#b4bec9'/><rect x='5' y='5' width='6' height='1.2' fill='#8d98a5'/><rect x='5' y='8' width='6' height='1.2' fill='#8d98a5'/></svg>`\n    );\n\n  $: totalHeight = results.length * rowHeight;\n  $: startIndex = Math.max(0, Math.floor(scrollTop / rowHeight) - 10);\n  $: visibleCount = Math.ceil(viewportHeight / rowHeight) + 20;\n  $: endIndex = Math.min(results.length, startIndex + visibleCount);\n  $: visibleRows = results.slice(startIndex, endIndex);\n  $: translateY = startIndex * rowHeight;\n  $: tableMinWidth = colWidths.name + colWidths.path + colWidths.size + colWidths.modified;\n  $: tableGridStyle = `--col-name:${colWidths.name}px;--col-path:${colWidths.path}px;--col-size:${colWidths.size}px;--col-modified:${colWidths.modified}px;--table-min-width:${tableMinWidth}px;--header-offset:${-headerScrollLeft}px;`;\n\n  $: {\n    for (const entry of visibleRows) {\n      void ensureIcon(entry);\n    }\n  }\n\n  function showToast(message) {\n    toast = message;\n    clearTimeout(toastTimer);\n    toastTimer = setTimeout(() => {\n      toast = '';\n    }, 3000);\n  }\n\n  function bytesToBase64(bytes) {\n    let binary = '';\n    const chunk = 0x8000;\n    for (let i = 0; i < bytes.length; i += chunk) {\n      const part = bytes.subarray(i, i + chunk);\n      binary += String.fromCharCode(...part);\n    }\n    return btoa(binary);\n  }\n\n  function highlightSegments(name, q) {\n    q = (q || '').trim();\n    if (!q) return [{ text: name, hl: false }];\n\n    // Reset cache when query changes\n    if (q !== highlightCacheQuery) {\n      highlightCache = new Map();\n      highlightCacheQuery = q;\n    }\n\n    // Check cache\n    const cached = highlightCache.get(name);\n    if (cached) return cached;\n\n    if (q.includes('/')) q = q.slice(q.lastIndexOf('/') + 1);\n    q = q.replace(/[*?]/g, '');\n    const terms = q.split(/\\s+/).filter(Boolean);\n    if (terms.length === 0) return [{ text: name, hl: false }];\n\n    const lower = name.toLowerCase();\n    const marks = new Uint8Array(name.length);\n    for (const t of terms) {\n      const tl = t.toLowerCase();\n      let idx = lower.indexOf(tl);\n      while (idx !== -1) {\n        for (let i = idx; i < idx + tl.length; i++) marks[i] = 1;\n        idx = lower.indexOf(tl, idx + 1);\n      }\n    }\n\n    const segs = [];\n    let i = 0;\n    while (i < name.length) {\n      const m = marks[i];\n      let j = i + 1;\n      while (j < name.length && marks[j] === m) j++;\n      segs.push({ text: name.slice(i, j), hl: m === 1 });\n      i = j;\n    }\n\n    highlightCache.set(name, segs);\n    return segs;\n  }\n\n  const perFileIconExts = new Set(['exe', 'lnk', 'ico', 'url', 'scr', 'appx']);\n\n  function iconKey(entry) {\n    if (entry.isDir) return '__folder__';\n    const ext = (entry.ext || '').toLowerCase();\n    if (perFileIconExts.has(ext)) return entry.path;\n    return ext || '__file__';\n  }\n\n  function iconFor(entry) {\n    return iconCache.get(iconKey(entry)) || (entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n  }\n\n  async function ensureIcon(entry) {\n    const key = iconKey(entry);\n    if (iconCache.has(key) || iconLoading.has(key)) {\n      return;\n    }\n\n    iconLoading.add(key);\n    try {\n      const bytes = await invoke('get_file_icon', {\n        path: entry.path,\n        ext: entry.isDir ? 'folder' : entry.ext || '',\n      });\n      if (Array.isArray(bytes) && bytes.length > 0) {\n        const image = `data:image/png;base64,${bytesToBase64(Uint8Array.from(bytes))}`;\n        iconCache.set(key, image);\n      } else {\n        iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n      }\n    } catch {\n      iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n    } finally {\n      iconLoading.delete(key);\n    }\n  }\n\n  function syncColumnWidthsToContainer() {\n    const width = tableContainer?.clientWidth || tableAreaEl?.clientWidth;\n    if (!width || lastTableWidth !== 0) {\n      return;\n    }\n\n    const saved = loadColWidths();\n    if (saved) {\n      const total = columnKeys.reduce((s, k) => s + saved[k], 0);\n      if (Math.abs(total - width) > 2) {\n        const scale = (width - saved.modified) / (total - saved.modified);\n        let scaledName = Math.max(minColumnWidth.name, Math.round(saved.name * scale));\n        let scaledSize = Math.max(minColumnWidth.size, Math.round(saved.size * scale));\n        let rawPath = width - saved.modified - scaledName - scaledSize;\n        if (rawPath < minColumnWidth.path) {\n          const shortfall = minColumnWidth.path - rawPath;\n          const nameReduction = Math.min(shortfall, scaledName - minColumnWidth.name);\n          scaledName -= nameReduction;\n          const remaining = shortfall - nameReduction;\n          if (remaining > 0) {\n            scaledSize -= Math.min(remaining, scaledSize - minColumnWidth.size);\n          }\n          rawPath = width - saved.modified - scaledName - scaledSize;\n        }\n        const scaledPath = Math.max(minColumnWidth.path, rawPath);\n        colWidths = { name: scaledName, path: scaledPath, size: scaledSize, modified: saved.modified };\n      } else {\n        colWidths = saved;\n      }\n    } else {\n      const fixedModified = minColumnWidth.modified;\n      const rest = width - fixedModified;\n      const ratioSum = defaultColumnRatios.name + defaultColumnRatios.path + defaultColumnRatios.size;\n      colWidths = {\n        name: Math.max(minColumnWidth.name, Math.round(rest * defaultColumnRatios.name / ratioSum)),\n        path: Math.max(minColumnWidth.path, Math.round(rest * defaultColumnRatios.path / ratioSum)),\n        size: Math.max(minColumnWidth.size, Math.round(rest * defaultColumnRatios.size / ratioSum)),\n        modified: fixedModified\n      };\n    }\n    lastTableWidth = width;\n  }\n\n  function loadColWidths() {\n    try {\n      const raw = localStorage.getItem(COL_WIDTHS_KEY);\n      if (!raw) return null;\n      const parsed = JSON.parse(raw);\n      for (const key of columnKeys) {\n        if (typeof parsed[key] !== 'number' || parsed[key] < (minColumnWidth[key] || 0)) return null;\n      }\n      return parsed;\n    } catch {\n      return null;\n    }\n  }\n\n  function saveColWidths() {\n    localStorage.setItem(COL_WIDTHS_KEY, JSON.stringify(colWidths));\n  }\n\n  function updateViewportHeight() {\n    viewportHeight = tableContainer?.clientHeight || 520;\n    syncColumnWidthsToContainer();\n  }\n\n  function scheduleViewportHeightUpdate() {\n    if (viewportResizeRaf !== null) {\n      return;\n    }\n    viewportResizeRaf = requestAnimationFrame(() => {\n      viewportResizeRaf = null;\n      updateViewportHeight();\n    });\n  }\n\n  function startColumnResize(event, leftKey) {\n    event.preventDefault();\n    event.stopPropagation();\n\n    const index = columnKeys.indexOf(leftKey);\n    if (index < 0 || index >= columnKeys.length - 1) {\n      return;\n    }\n\n    const startX = event.clientX;\n    const startLeft = colWidths[leftKey];\n    const rightKey = columnKeys[index + 1];\n    const startRight = colWidths[rightKey];\n\n    resizeCleanup?.();\n    resizingColumn = leftKey;\n\n    const onMove = (moveEvent) => {\n      const delta = Math.round(moveEvent.clientX - startX);\n      if (leftKey === 'name') {\n        // Two-column trade: name and path swap space, each respects its minimum\n        const nextLeft = Math.max(\n          minColumnWidth[leftKey],\n          Math.min(startLeft + delta, startLeft + startRight - minColumnWidth[rightKey])\n        );\n        const nextRight = startLeft + startRight - nextLeft;\n        colWidths = { ...colWidths, [leftKey]: nextLeft, [rightKey]: nextRight };\n      } else {\n        // path splitter: path grows unconstrained (allows horizontal scroll on right drag)\n        const nextLeft = Math.max(minColumnWidth[leftKey], startLeft + delta);\n        colWidths = { ...colWidths, [leftKey]: nextLeft };\n      }\n    };\n\n    const onUp = () => {\n      cleanup();\n    };\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      document.body.style.cursor = '';\n      document.body.style.userSelect = '';\n      resizingColumn = '';\n      saveColWidths();\n      if (resizeCleanup === cleanup) {\n        resizeCleanup = null;\n      }\n    };\n\n    resizeCleanup = cleanup;\n    document.body.style.cursor = 'col-resize';\n    document.body.style.userSelect = 'none';\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  function selectedPaths() {\n    const sorted = [...selectedIndices].sort((a, b) => a - b);\n    return sorted.map((idx) => results[idx]).filter(Boolean).map((entry) => entry.path);\n  }\n\n  function clearSelection() {\n    selectedIndices = new Set();\n    selectionAnchor = -1;\n    lastSelectedIndex = -1;\n  }\n\n  function selectSingle(index) {\n    selectedIndices = new Set([index]);\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectToggle(index) {\n    const next = new Set(selectedIndices);\n    if (next.has(index)) {\n      next.delete(index);\n    } else {\n      next.add(index);\n    }\n    selectedIndices = next;\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectRange(index) {\n    const anchor = selectionAnchor >= 0 ? selectionAnchor : index;\n    const [from, to] = [Math.min(anchor, index), Math.max(anchor, index)];\n    const next = new Set();\n    for (let i = from; i <= to; i += 1) {\n      next.add(i);\n    }\n    selectedIndices = next;\n    lastSelectedIndex = index;\n  }\n\n  function primaryEntry() {\n    const idx = lastSelectedIndex >= 0 ? lastSelectedIndex : -1;\n    return idx >= 0 ? results[idx] : null;\n  }\n\n  async function refreshStatus() {\n    if (statusRefreshInFlight) {\n      return;\n    }\n    statusRefreshInFlight = true;\n    try {\n      const status = await invoke('get_index_status');\n      const prevState = indexStatus.state;\n      indexStatus = {\n        state: status.state,\n        entriesCount: status.entriesCount,\n        lastUpdated: status.lastUpdated,\n        permissionErrors: status.permissionErrors ?? 0,\n        message: status.message\n      };\n      if (status.state === 'Indexing' && prevState !== 'Indexing') {\n        startElapsedTimer();\n      } else if (status.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n      if (typeof status.scanned === 'number') {\n        scanned = status.scanned;\n      }\n      if (status.state === 'Ready' && prevState !== 'Ready') {\n        scheduleSearch();\n      }\n    } catch (err) {\n      showToast(`Failed to get status: ${String(err)}`);\n    } finally {\n      statusRefreshInFlight = false;\n    }\n  }\n\n  function scheduleSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const scheduledGen = searchGeneration;\n    clearTimeout(searchTimer);\n\n    const now = performance.now();\n    if (now - lastSearchFiredAt >= 200) {\n      // Leading edge: fire immediately if enough time has passed\n      lastSearchFiredAt = now;\n      void runSearch(preserveScroll);\n    } else {\n      // Trailing edge: debounce\n      searchTimer = setTimeout(() => {\n        if (scheduledGen !== searchGeneration) {\n          return;\n        }\n        lastSearchFiredAt = performance.now();\n        void runSearch(preserveScroll);\n      }, 200);\n    }\n  }\n\n  async function runSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const gen = searchGeneration;\n    const searchQuery = query;\n    const searchSortBy = sortBy;\n    const searchSortDir = sortDir;\n    const startedAt = performance.now();\n    try {\n      const keepPaths = new Set(selectedPaths());\n      const next = await invoke('search', {\n        query: searchQuery,\n        limit: PAGE_SIZE,\n        offset: 0,\n        sortBy: searchSortBy,\n        sortDir: searchSortDir\n      });\n\n      if (gen !== searchGeneration) return;\n\n      dbLatencyMs = Math.round(performance.now() - startedAt);\n      dbLastQuery = searchQuery;\n      const entries = Array.isArray(next.entries) ? next.entries : [];\n      searchModeLabel = next.modeLabel || '';\n      results = entries;\n      if (next.totalCount > 0) {\n        totalResults = next.totalCount;\n        totalResultsKnown = true;\n      } else {\n        totalResults = entries.length;\n        totalResultsKnown = false;\n      }\n      hasMore = totalResultsKnown ? results.length < totalResults : entries.length >= PAGE_SIZE;\n      if (!preserveScroll && tableContainer) tableContainer.scrollTop = 0;\n\n      const restored = new Set();\n      for (let i = 0; i < results.length; i += 1) {\n        if (keepPaths.has(results[i].path)) {\n          restored.add(i);\n        }\n      }\n      selectedIndices = restored;\n\n      updateViewportHeight();\n    } catch (err) {\n      if (gen !== searchGeneration) return;\n      showToast(`Search failed: ${String(err)}`);\n    }\n  }\n\n  async function loadMore() {\n    if (!hasMore || loadingMore) return;\n    const gen = searchGeneration;\n    loadingMore = true;\n    try {\n      const batch = await invoke('search', {\n        query,\n        limit: PAGE_SIZE,\n        offset: results.length,\n        sortBy: sortBy,\n        sortDir: sortDir\n      });\n      if (gen !== searchGeneration) return;\n      const arr = Array.isArray(batch.entries) ? batch.entries : [];\n      if (arr.length > 0) results = [...results, ...arr];\n      hasMore = totalResultsKnown ? results.length < totalResults : arr.length >= PAGE_SIZE;\n    } catch (err) {\n      showToast(`Failed to load more: ${String(err)}`);\n    } finally {\n      loadingMore = false;\n    }\n  }\n\n  function moveSelection(delta, withRange = false) {\n    if (results.length === 0) {\n      return;\n    }\n\n    const current = lastSelectedIndex >= 0 ? lastSelectedIndex : 0;\n    const next = Math.max(0, Math.min(results.length - 1, current + delta));\n\n    if (withRange) {\n      selectRange(next);\n    } else {\n      selectSingle(next);\n    }\n\n    const top = next * rowHeight;\n    const bottom = top + rowHeight;\n    if (top < scrollTop) {\n      tableContainer.scrollTop = top;\n    } else if (bottom > scrollTop + viewportHeight) {\n      tableContainer.scrollTop = bottom - viewportHeight;\n    }\n  }\n\n  function handleHeaderSort(column) {\n    if (sortBy === column) {\n      sortDir = sortDir === 'asc' ? 'desc' : 'asc';\n    } else {\n      sortBy = column;\n      sortDir = 'asc';\n    }\n    if (tableContainer) tableContainer.scrollTop = 0;\n    void runSearch();\n  }\n\n  function handleRowClick(event, index) {\n    contextMenu.visible = false;\n\n    if (event.shiftKey) {\n      selectRange(index);\n      return;\n    }\n\n    if (event.metaKey || event.ctrlKey) {\n      selectToggle(index);\n      return;\n    }\n\n    selectSingle(index);\n  }\n\n  function handleRowContextMenu(event, index) {\n    event.preventDefault();\n\n    if (!selectedIndices.has(index)) {\n      selectSingle(index);\n    }\n\n    if (platform === 'windows' || platform === 'macos') {\n      contextMenu.visible = false;\n      const paths = selectedPaths();\n      if (paths.length > 0) {\n        invoke('show_context_menu', {\n          paths,\n          x: event.clientX,\n          y: event.clientY,\n          singleSelection: selectedIndices.size === 1\n        });\n      }\n      return;\n    }\n\n    contextMenu = {\n      visible: true,\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n\n  function handleRowA11yKeydown(event, index) {\n    if (event.key === ' ' || event.key === 'Enter') {\n      event.preventDefault();\n      handleRowClick(event, index);\n    }\n  }\n\n  const DRAG_THRESHOLD = 5;\n  let dragCleanup = null;\n  const dragImgCache = new Map();\n\n  function dragPathsForIndex(index) {\n    const entry = results[index];\n    if (!entry) {\n      return [];\n    }\n\n    if (selectedIndices.has(index) && selectedIndices.size > 0) {\n      return selectedPaths();\n    }\n\n    return [entry.path];\n  }\n\n  function getDragIconEl(entry) {\n    const src = iconFor(entry);\n    let img = dragImgCache.get(src);\n    if (!img) {\n      img = new Image();\n      img.src = src;\n      dragImgCache.set(src, img);\n    }\n    return img.complete && img.naturalWidth > 0 ? img : null;\n  }\n\n  function fillRoundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function buildDragPreview(index) {\n    const entry = results[index];\n    if (!entry) return null;\n\n    const count = selectedIndices.has(index) ? selectedIndices.size : 1;\n    const isDark = theme === 'dark';\n\n    const w = 260;\n    const h = 28;\n    const stackGap = count > 1 ? 4 : 0;\n\n    const canvas = document.createElement('canvas');\n    canvas.width = w;\n    canvas.height = h + stackGap;\n    const ctx = canvas.getContext('2d');\n\n    if (count > 1) {\n      ctx.globalAlpha = 0.35;\n      ctx.fillStyle = isDark ? '#5a6070' : '#b0c4de';\n      fillRoundRect(ctx, 3, 0, w - 3, h, 5);\n      ctx.globalAlpha = 1.0;\n    }\n\n    const ry = stackGap;\n    ctx.fillStyle = isDark ? 'rgba(58, 64, 74, 0.94)' : 'rgba(214, 231, 255, 0.94)';\n    fillRoundRect(ctx, 0, ry, w, h, 5);\n\n    ctx.strokeStyle = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';\n    ctx.lineWidth = 0.5;\n    ctx.beginPath();\n    ctx.moveTo(5, ry);\n    ctx.arcTo(w, ry, w, ry + h, 5);\n    ctx.arcTo(w, ry + h, 0, ry + h, 5);\n    ctx.arcTo(0, ry + h, 0, ry, 5);\n    ctx.arcTo(0, ry, w, ry, 5);\n    ctx.closePath();\n    ctx.stroke();\n\n    const iconEl = getDragIconEl(entry);\n    if (iconEl) {\n      ctx.drawImage(iconEl, 6, ry + 6, 16, 16);\n    } else {\n      ctx.fillStyle = entry.isDir ? '#d9b34f' : '#8d98a5';\n      fillRoundRect(ctx, 6, ry + 6, 16, 16, 2);\n    }\n\n    ctx.fillStyle = isDark ? '#e6e6e8' : '#1a1a1a';\n    ctx.font = '12px -apple-system, \"SF Pro Text\", system-ui, sans-serif';\n    ctx.textBaseline = 'middle';\n\n    let nameMaxW = w - 34;\n    if (count > 1) nameMaxW -= 34;\n\n    let name = entry.name;\n    if (ctx.measureText(name).width > nameMaxW) {\n      while (name.length > 4 && ctx.measureText(name + '\\u2026').width > nameMaxW) {\n        name = name.slice(0, -1);\n      }\n      name += '\\u2026';\n    }\n    ctx.fillText(name, 28, ry + h / 2 + 1);\n\n    if (count > 1) {\n      const badge = String(count);\n      ctx.font = 'bold 10px -apple-system, system-ui, sans-serif';\n      const tw = ctx.measureText(badge).width;\n      const bw = Math.max(20, tw + 10);\n      const bx = w - bw - 6;\n      const by = ry + (h - 18) / 2;\n\n      ctx.fillStyle = isDark ? '#5b8bd9' : '#007aff';\n      fillRoundRect(ctx, bx, by, bw, 18, 9);\n\n      ctx.fillStyle = '#ffffff';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(badge, bx + bw / 2, by + 9);\n    }\n\n    return canvas.toDataURL('image/png');\n  }\n\n  function handleRowMouseDown(event, index) {\n    if (event.button !== 0) return;\n    if (event.metaKey || event.ctrlKey || event.shiftKey) return;\n    if (editing.active) return;\n\n    const startX = event.clientX;\n    const startY = event.clientY;\n    let dragging = false;\n\n    dragCleanup?.();\n\n    const onMove = (e) => {\n      if (dragging) return;\n      const dx = e.clientX - startX;\n      const dy = e.clientY - startY;\n      if (dx * dx + dy * dy < DRAG_THRESHOLD * DRAG_THRESHOLD) return;\n\n      dragging = true;\n      cleanup();\n\n      if (!selectedIndices.has(index)) {\n        selectSingle(index);\n      }\n\n      const paths = dragPathsForIndex(index);\n      if (paths.length > 0) {\n        const icon = buildDragPreview(index);\n        startDrag({ item: paths, icon }).catch(() => {});\n      }\n    };\n\n    const onUp = () => cleanup();\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      if (dragCleanup === cleanup) dragCleanup = null;\n    };\n\n    dragCleanup = cleanup;\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  async function handleRowDoubleClick(index) {\n    if (!selectedIndices.has(index) || selectedIndices.size > 1) {\n      selectSingle(index);\n      await tick();\n    }\n    await invoke('open', { paths: [results[index].path] }).catch((err) => {\n      showToast(`Failed to open: ${String(err)}`);\n    });\n  }\n\n  function closeContextMenu() {\n    contextMenu = {\n      ...contextMenu,\n      visible: false\n    };\n  }\n\n  async function openSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('open', { paths });\n    } catch (err) {\n      showToast(`Failed to open: ${String(err)}`);\n    }\n  }\n\n  async function openWithFallback() {\n    const target = primaryEntry();\n    if (!target) {\n      return;\n    }\n\n    try {\n      await invoke('open_with', { path: target.path });\n    } catch (err) {\n      showToast(`Open With failed: ${String(err)}`);\n    }\n  }\n\n  async function revealSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('reveal_in_finder', { paths });\n    } catch (err) {\n      showToast(`Failed to reveal in Finder: ${String(err)}`);\n    }\n  }\n\n  async function copySelectedPaths() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_paths', { paths });\n      showToast(`Copied ${paths.length} path(s)`);\n    } catch (err) {\n      showToast(`Failed to copy path: ${String(err)}`);\n    }\n  }\n\n  async function copyFiles() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_files', { paths });\n      showToast(`Copied ${paths.length} item(s)`);\n    } catch (err) {\n      showToast(`Failed to copy: ${String(err)}`);\n    }\n  }\n\n  async function trashSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    const message =\n      paths.length === 1\n        ? 'Move selected item to Trash?'\n        : `Move ${paths.length} items to Trash?`;\n\n    if (!window.confirm(message)) {\n      return;\n    }\n\n    try {\n      await invoke('move_to_trash', { paths });\n      showToast('Moved to Trash.');\n      clearSelection();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to move to Trash: ${String(err)}`);\n    }\n  }\n\n  async function resetIndex() {\n    if (indexStatus.state === 'Indexing') {\n      showToast('Indexing in progress. Please try again after it completes.');\n      return;\n    }\n\n    results = [];\n    totalResults = 0;\n    totalResultsKnown = false;\n    clearSelection();\n    scanned = 0;\n    dbLatencyMs = null;\n    dbLastQuery = '';\n    indexStatus = { ...indexStatus, state: 'Indexing', entriesCount: 0, message: null };\n    indexingStartTime = Date.now();\n    indexingElapsed = '';\n    indexingFinishedAt = '';\n\n    try {\n      await invoke('reset_index');\n    } catch (err) {\n      showToast(`Failed to reset index: ${String(err)}`);\n      await refreshStatus();\n    }\n  }\n\n  function isMultiSelected() {\n    return selectedIndices.size > 1;\n  }\n\n  function autoResizeRenameInput() {\n    if (!renameInputEl) return;\n    renameInputEl.style.height = '0';\n    renameInputEl.style.height = renameInputEl.scrollHeight + 'px';\n  }\n\n  async function startRename() {\n    if (isMultiSelected()) {\n      return;\n    }\n\n    const idx = lastSelectedIndex;\n    if (idx < 0 || !results[idx]) {\n      return;\n    }\n\n    const entry = results[idx];\n\n    // Calculate overlay position mathematically.\n    // Name cell text starts at: padding-left(16) + icon(16) + gap(6) = 38px from cell left.\n    // Textarea has padding-left: 0 and border: 1.5px, so text starts ~2px from overlay left.\n    if (tableContainer) {\n      const rect = tableContainer.getBoundingClientRect();\n      const cellLeft = rect.left - tableContainer.scrollLeft;\n      const textLeft = cellLeft + 38;\n      const cellRight = cellLeft + colWidths.name;\n      const rowTop = rect.top + idx * rowHeight - tableContainer.scrollTop;\n      renameOverlay = {\n        top: rowTop,\n        left: textLeft - 2,\n        width: cellRight - textLeft + 2 - 4\n      };\n    }\n\n    editing = {\n      active: true,\n      path: entry.path,\n      index: idx,\n      draftName: entry.name\n    };\n\n    await tick();\n\n    if (renameInputEl) {\n      autoResizeRenameInput();\n      renameInputEl.focus();\n      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n      renameInputEl.setSelectionRange(0, selectionEnd);\n    }\n  }\n\n  function cancelRename() {\n    editing = {\n      active: false,\n      path: '',\n      index: -1,\n      draftName: ''\n    };\n  }\n\n  async function commitRename() {\n    if (!editing.active || editing.index < 0 || !results[editing.index]) {\n      return;\n    }\n\n    const current = results[editing.index];\n    const nextName = editing.draftName;\n\n    try {\n      await invoke('rename', {\n        path: current.path,\n        newName: nextName\n      });\n      cancelRename();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to rename: ${String(err)}`);\n      await tick();\n      renameInputEl?.focus();\n    }\n  }\n\n  function onGlobalClick() {\n    closeContextMenu();\n  }\n\n  function onTitleBarMouseDown(event) {\n    if (event.button !== 0) {\n      return;\n    }\n\n    const activeElement = document.activeElement;\n    if (activeElement instanceof HTMLElement && isTextInputTarget(activeElement)) {\n      activeElement.blur();\n    }\n  }\n\n  async function focusSearch() {\n    await getCurrentWindow().show();\n    await getCurrentWindow().setFocus();\n    searchInputEl?.focus();\n    searchInputEl?.select();\n  }\n\n  function isTextInputTarget(target) {\n    return (\n      target instanceof HTMLInputElement ||\n      target instanceof HTMLTextAreaElement ||\n      target?.isContentEditable\n    );\n  }\n\n  async function handleKeydown(event) {\n    const isMetaSelectAll = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'a';\n    const isMetaCopy = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c';\n    const target = event.target;\n    const isTextInput = isTextInputTarget(target);\n\n    if (isMetaCopy && isTextInput) {\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      if (isTextInput) {\n        event.preventDefault();\n        if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n          target.select();\n        }\n        return;\n      }\n    }\n\n    if (editing.active) {\n      if (event.key === 'Enter') {\n        event.preventDefault();\n        await commitRename();\n        return;\n      }\n\n      if (event.key === 'Escape') {\n        event.preventDefault();\n        const idx = editing.index;\n        cancelRename();\n        selectSingle(idx);\n        await tick();\n        tableContainer?.querySelector('.row.selected')?.focus();\n        return;\n      }\n      return;\n    }\n\n    if (event.key === 'Escape') {\n      event.preventDefault();\n      clearSelection();\n      return;\n    }\n\n    if (event.key === 'ArrowDown') {\n      event.preventDefault();\n      moveSelection(1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'ArrowUp') {\n      event.preventDefault();\n      moveSelection(-1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageDown') {\n      event.preventDefault();\n      moveSelection(Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageUp') {\n      event.preventDefault();\n      moveSelection(-Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'Enter') {\n      event.preventDefault();\n      if (platform === 'windows') {\n        await openSelected();\n      } else {\n        await startRename();\n      }\n      return;\n    }\n\n    if (event.key === 'F2') {\n      event.preventDefault();\n      await startRename();\n      return;\n    }\n\n    if (event.key === ' ' && !isTextInput) {\n      event.preventDefault();\n      const entry = primaryEntry();\n      if (entry) {\n        await invoke('quick_look', { path: entry.path });\n      }\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'f') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      searchInputEl?.select();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'o') {\n      event.preventDefault();\n      await openSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {\n      event.preventDefault();\n      await revealSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c') {\n      event.preventDefault();\n      await copySelectedPaths();\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      event.preventDefault();\n      selectedIndices = new Set(Array.from({ length: results.length }, (_, i) => i));\n      return;\n    }\n\n    if (event.key === 'Delete' || ((event.metaKey || event.ctrlKey) && event.key === 'Backspace')) {\n      if (!isTextInput) {\n        event.preventDefault();\n        await trashSelected();\n      }\n      return;\n    }\n  }\n\n  function formatSize(entry) {\n    if (entry.isDir || entry.size == null) return '';\n    const bytes = entry.size;\n    if (bytes < 1024) return `${bytes} B`;\n    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n    return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n  }\n\n  function formatModified(entry) {\n    if (!entry.mtime) {\n      return '';\n    }\n\n    const d = new Date(entry.mtime * 1000);\n    const pad = (n) => String(n).padStart(2, '0');\n    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;\n  }\n\n  function formatLastUpdated(timestamp) {\n    if (!timestamp) {\n      return '-';\n    }\n\n    return new Date(timestamp * 1000).toLocaleString();\n  }\n\n  function formatElapsed(ms) {\n    const totalSec = Math.floor(ms / 1000);\n    const min = Math.floor(totalSec / 60);\n    const sec = totalSec % 60;\n    return min > 0 ? `${min}m ${sec}s` : `${sec}s`;\n  }\n\n  function updateElapsed() {\n    if (indexingStartTime && indexStatus.state === 'Indexing') {\n      indexingElapsed = formatElapsed(Date.now() - indexingStartTime);\n    }\n  }\n\n  function startElapsedTimer() {\n    clearInterval(elapsedTimer);\n    indexingStartTime = Date.now();\n    indexingElapsed = '0s';\n    indexingFinishedAt = '';\n    elapsedTimer = setInterval(updateElapsed, 1000);\n  }\n\n  function stopElapsedTimer() {\n    clearInterval(elapsedTimer);\n    if (indexingStartTime) {\n      const elapsed = Date.now() - indexingStartTime;\n      indexingFinishedAt = `${formatElapsed(elapsed)}`;\n    }\n    indexingStartTime = null;\n    indexingElapsed = '';\n  }\n\n  function displayPath(path) {\n    if (!path) {\n      return path;\n    }\n\n    if (!homePrefix) {\n      return path;\n    }\n\n    if (path === homePrefix) {\n      return '~';\n    }\n\n    if (path.startsWith(`${homePrefix}/`)) {\n      return `~${path.slice(homePrefix.length)}`;\n    }\n\n    return path;\n  }\n\n  let unlistenFns = [];\n\n  onMount(async () => {\n    const t0 = performance.now();\n    const ms = () => Math.round(performance.now() - t0);\n    const DEBUG_STARTUP = false;\n    const flog = DEBUG_STARTUP ? (msg) => invoke('frontend_log', { msg }).catch(() => {}) : () => {};\n\n    flog(`[startup/fe] onMount entered`);\n\n    updateViewportHeight();\n    flog(`[startup/fe] +${ms()}ms updateViewportHeight done`);\n\n    invoke('set_native_theme', { theme });\n\n    platform = await invoke('get_platform');\n    flog(`[startup/fe] +${ms()}ms get_platform done`);\n\n    const unlistenProgress = await listen('index_progress', (event) => {\n      scanned = event.payload.scanned;\n      if (indexStatus.state !== 'Indexing') {\n        indexStatus = {\n          ...indexStatus,\n          state: 'Indexing'\n        };\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_progress) registered`);\n\n    const unlistenState = await listen('index_state', (event) => {\n      flog(`[startup/fe] index_state event received: ${event.payload.state} at +${ms()}ms`);\n      const prevState = indexStatus.state;\n      indexStatus = {\n        ...indexStatus,\n        state: event.payload.state,\n        message: event.payload.message ?? null,\n        isCatchup: event.payload.isCatchup ?? false\n      };\n\n      if (event.payload.state === 'Indexing' && prevState !== 'Indexing') {\n        if (prevState === 'Ready') {\n          lastReadyCount = indexStatus.entriesCount;\n        }\n        startElapsedTimer();\n      } else if (event.payload.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n\n      if (event.payload.state === 'Ready') {\n        scheduleSearch();\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_state) registered`);\n\n    const unlistenUpdated = await listen('index_updated', (event) => {\n      indexStatus = {\n        ...indexStatus,\n        entriesCount: event.payload.entriesCount,\n        lastUpdated: event.payload.lastUpdated,\n        permissionErrors: event.payload.permissionErrors ?? indexStatus.permissionErrors\n      };\n\n      scheduleSearch(true);\n    });\n\n    const unlistenFocus = await listen('focus_search', () => {\n      void focusSearch();\n    });\n\n    const unlistenCtxMenuAction = await listen('context_menu_action', (event) => {\n      switch (event.payload) {\n        case 'open': void openSelected(); break;\n        case 'quick_look': {\n          const e = primaryEntry();\n          if (e) void invoke('quick_look', { path: e.path });\n          break;\n        }\n        case 'open_with': void openWithFallback(); break;\n        case 'reveal': void revealSelected(); break;\n        case 'copy_files': void copyFiles(); break;\n        case 'copy_path': void copySelectedPaths(); break;\n        case 'trash': void trashSelected(); break;\n        case 'rename': void startRename(); break;\n      }\n    });\n\n    unlistenFns = [unlistenProgress, unlistenState, unlistenUpdated, unlistenFocus, unlistenCtxMenuAction];\n    flog(`[startup/fe] +${ms()}ms all listeners registered`);\n\n    // Fetch backend state IMMEDIATELY after listeners are registered.\n    // Events emitted before listener registration are lost, so this\n    // is the only reliable way to get the current state.\n    await refreshStatus();\n    flog(`[startup/fe] +${ms()}ms refreshStatus done (state=${indexStatus.state})`);\n\n    // Show Svelte UI: remove skeleton, focus search input.\n    await tick();\n    document.getElementById('skeleton')?.remove();\n    await focusSearch();\n    flog(`[startup/fe] +${ms()}ms WINDOW VISIBLE â€” skeleton removed`);\n\n    try {\n      homePrefix = await invoke('get_home_dir');\n    } catch {\n      homePrefix = '';\n    }\n    flog(`[startup/fe] +${ms()}ms get_home_dir done`);\n\n    if (!localStorage.getItem('everything-fda-notice-v1')) {\n      showToast('macOS Full Disk Access permission may be required for full disk search.');\n      localStorage.setItem('everything-fda-notice-v1', '1');\n    }\n    flog(`[startup/fe] +${ms()}ms calling runSearch...`);\n    await runSearch();\n    flog(`[startup/fe] +${ms()}ms runSearch done`);\n\n    if (typeof ResizeObserver !== 'undefined') {\n      tableResizeObserver = new ResizeObserver(() => {\n        scheduleViewportHeightUpdate();\n      });\n      if (tableContainer) {\n        tableResizeObserver.observe(tableContainer);\n      } else if (tableAreaEl) {\n        tableResizeObserver.observe(tableAreaEl);\n      }\n    }\n\n    window.addEventListener('resize', scheduleViewportHeightUpdate);\n    window.addEventListener('click', onGlobalClick);\n    statusRefreshTimer = setInterval(() => {\n      if (indexStatus.state === 'Indexing') {\n        void refreshStatus();\n      }\n    }, 1000);\n    console.log(`[startup/fe] +${ms()}ms onMount complete`);\n  });\n\n  onDestroy(async () => {\n    clearTimeout(searchTimer);\n    clearTimeout(toastTimer);\n    clearInterval(statusRefreshTimer);\n    clearInterval(elapsedTimer);\n    resizeCleanup?.();\n\n    for (const unlisten of unlistenFns) {\n      unlisten();\n    }\n\n    tableResizeObserver?.disconnect();\n    tableResizeObserver = null;\n    if (viewportResizeRaf !== null) {\n      cancelAnimationFrame(viewportResizeRaf);\n      viewportResizeRaf = null;\n    }\n    window.removeEventListener('resize', scheduleViewportHeightUpdate);\n    window.removeEventListener('click', onGlobalClick);\n  });\n</script>\n\n<svelte:window on:keydown={handleKeydown} />\n\n<div class=\"app-shell\" data-theme={theme}>\n  <div class=\"title-bar\" role=\"presentation\" data-tauri-drag-region on:mousedown={onTitleBarMouseDown}>\n    <div class=\"title-left\"></div>\n    <div class=\"title-center\">\n      <svg class=\"title-icon\" viewBox=\"0 0 215 205\" fill-rule=\"evenodd\" aria-hidden=\"true\">\n        <path d=\"M85 0c46.9 0 85 38.1 85 85 0 20.1-7.2 38.5-19.2 52.7l40.7 40.8c5.8 5.8 5.8 15.2 0 21-5.8 5.8-15.2 5.8-21 0l-40.7-40.7c-13.6 9.7-30.4 15.2-44.8 15.2-46.9 0-85-42.1-85-89 0-46.9 38.1-85 85-85z m0 32c-29.3 0-53 23.7-53 53 0 29.3 23.7 53 53 53 29.3 0 53-23.7 53-53 0-29.3-23.7-53-53-53z\"/>\n      </svg>\n      <span class=\"title-text\">Everything</span>\n    </div>\n    <div class=\"title-right\"></div>\n  </div>\n\n  <header class=\"search-bar\">\n    <input\n      bind:this={searchInputEl}\n      class=\"search-input\"\n      type=\"text\"\n      bind:value={query}\n      on:input={scheduleSearch}\n      on:focus={clearSelection}\n      placeholder=\"Search file/folder names\"\n      autocomplete=\"off\"\n      spellcheck=\"false\"\n    />\n  </header>\n\n  <section class=\"table-area\" bind:this={tableAreaEl} style={tableGridStyle}>\n    <div class=\"table-header\">\n      <div class=\"table-header-track\">\n        <div class=\"col name\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('name')}>\n            Name{#if sortBy === 'name'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'name'}\n            on:mousedown={(event) => startColumnResize(event, 'name')}\n            aria-label=\"Resize Name column\"\n          />\n        </div>\n\n        <div class=\"col path\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('dir')}>\n            Path{#if sortBy === 'dir'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'path'}\n            on:mousedown={(event) => startColumnResize(event, 'path')}\n            aria-label=\"Resize Path column\"\n          />\n        </div>\n\n        <div class=\"col size\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('size')}>\n            Size{#if sortBy === 'size'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n\n        <div class=\"col modified\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('mtime')}>\n            Modified{#if sortBy === 'mtime'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n      </div>\n    </div>\n\n    <div\n      class=\"table-body\"\n      bind:this={tableContainer}\n      on:scroll={() => {\n        scrollTop = tableContainer.scrollTop;\n        headerScrollLeft = tableContainer.scrollLeft;\n        if (editing.active) void commitRename();\n        const scrollBottom = scrollTop + tableContainer.clientHeight;\n        if (scrollBottom >= totalHeight - rowHeight * 10) {\n          void loadMore();\n        }\n      }}\n    >\n      <div class=\"spacer\" style={`height:${totalHeight}px`}>\n        <div class=\"rows\" style={`transform: translateY(${translateY}px);`}>\n          {#each visibleRows as entry, localIndex}\n            {@const index = startIndex + localIndex}\n            <div\n              class=\"row {selectedIndices.has(index) ? 'selected' : ''}\"\n              on:mousedown={(event) => handleRowMouseDown(event, index)}\n              on:click={(event) => handleRowClick(event, index)}\n              on:keydown={(event) => handleRowA11yKeydown(event, index)}\n              on:dblclick={() => handleRowDoubleClick(index)}\n              on:contextmenu={(event) => handleRowContextMenu(event, index)}\n              role=\"row\"\n              tabindex=\"0\"\n            >\n              <div class=\"cell name\">\n                <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n                <span class=\"ellipsis\" class:name-editing={editing.active && editing.index === index}>{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n              </div>\n              <div class=\"cell path\"><span class=\"ellipsis\">{displayPath(entry.dir)}</span></div>\n              <div class=\"cell size\">{formatSize(entry)}</div>\n              <div class=\"cell modified\">{formatModified(entry)}</div>\n            </div>\n          {/each}\n        </div>\n      </div>\n    </div>\n  </section>\n\n  <footer class=\"status-bar\">\n    <div class=\"status-left\">\n      <span class=\"status-state\">\n        <span class=\"state-dot {indexStatus.state === 'Indexing' ? 'indexing' : indexStatus.state === 'Error' ? 'error' : 'ready'}\"></span>\n        {#if indexStatus.state === 'Indexing'}\n          Indexing{#if lastReadyCount > 0} ({Math.min(99, Math.round((scanned / lastReadyCount) * 100))}%){/if}{#if indexingElapsed} Â· {indexingElapsed}{/if}\n          {#if !indexStatus.isCatchup}\n            Â· {scanned.toLocaleString()} scanned\n          {/if}\n        {:else}\n          Index: {indexStatus.state}\n        {/if}\n      </span>\n      <span>{indexStatus.entriesCount.toLocaleString()} entries</span>\n      {#if indexingFinishedAt && indexStatus.state !== 'Indexing'}\n        <span>in {indexingFinishedAt}</span>\n      {/if}\n      {#if dbLatencyMs !== null && dbLastQuery}\n        <span>\"{dbLastQuery}\" {dbLatencyMs}ms Â· {totalResults} results</span>\n      {/if}\n      {#if searchModeLabel === 'spotlight' || searchModeLabel === 'spotlight_timeout'}\n        <span class=\"status-spotlight\">Spotlight fallback{#if searchModeLabel === 'spotlight_timeout'} (partial){/if}</span>\n      {/if}\n      {#if indexStatus.permissionErrors > 0}\n        <span class=\"status-warning\">{indexStatus.permissionErrors.toLocaleString()} permission errors</span>\n      {/if}\n      {#if indexStatus.message}\n        <span class={indexStatus.isCatchup ? 'index-progress' : 'status-error'}>{indexStatus.message}</span>\n      {/if}\n    </div>\n    <div class=\"status-right\">\n      <button class=\"status-btn theme-btn\" on:click={cycleTheme} title=\"Switch theme\">\n        {theme === 'dark' ? 'â˜€ Light' : 'â—‘ Dark'}\n      </button>\n      <button\n        class=\"status-btn rebuild-btn\"\n        on:click={resetIndex}\n        disabled={indexStatus.state === 'Indexing'}\n        title={indexStatus.state === 'Indexing' ? 'Cannot reset while indexing is in progress.' : 'Reset and rebuild the index.'}\n      >\n        <svg class=\"rebuild-icon\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n          <path d=\"M23 4v6h-6\"/><path d=\"M20.49 15a9 9 0 1 1-2.12-9.36L23 10\"/>\n        </svg>\n        Rebuild Index\n      </button>\n    </div>\n  </footer>\n\n  {#if editing.active}\n    <div\n      class=\"rename-overlay\"\n      style=\"top:{renameOverlay.top}px; left:{renameOverlay.left}px; width:{renameOverlay.width}px;\"\n      role=\"presentation\"\n      on:mousedown|stopPropagation\n    >\n      <textarea\n        bind:this={renameInputEl}\n        class=\"rename-textarea\"\n        bind:value={editing.draftName}\n        on:input={autoResizeRenameInput}\n        on:click|stopPropagation\n        on:blur={commitRename}\n      />\n    </div>\n  {/if}\n\n  {#if contextMenu.visible}\n    <div class=\"context-menu\" style={`left:${contextMenu.x}px;top:${contextMenu.y}px;`}>\n      <button on:click={() => (closeContextMenu(), openSelected())}>Open</button>\n      <button on:click={async () => { closeContextMenu(); const e = primaryEntry(); if (e) await invoke('quick_look', { path: e.path }); }}>Quick Look</button>\n      <button on:click={() => (closeContextMenu(), openWithFallback())}>Open With... (Reveal in Finder)</button>\n      <button on:click={() => (closeContextMenu(), revealSelected())}>Reveal in Finder</button>\n      <button on:click={() => (closeContextMenu(), copySelectedPaths())}>Copy Path</button>\n      <button on:click={() => (closeContextMenu(), trashSelected())}>Move to Trash</button>\n      {#if selectedIndices.size === 1}\n        <button on:click={() => (closeContextMenu(), startRename())}>Rename</button>\n      {/if}\n    </div>\n  {/if}\n\n  {#if toast}\n    <div class=\"toast\">{toast}</div>\n  {/if}\n</div>\n\n<style>\n  :global(:root) {\n    color-scheme: light dark;\n    --bg-app: transparent;\n    --text-primary: #0d1826;\n    --text-muted: #48596c;\n    --bar-grad-top: rgba(255, 255, 255, 0.48);\n    --bar-grad-bottom: rgba(248, 250, 253, 0.42);\n    --surface-header: rgba(252, 252, 255, 0.40);\n    --surface: rgba(255, 255, 255, 0.22);\n    --border-soft: rgba(0, 0, 0, 0.07);\n    --border-input: rgba(0, 0, 0, 0.13);\n    --focus-ring: #6f96e6;\n    --row-border: rgba(0, 0, 0, 0.032);\n    --row-hover: rgba(0, 0, 0, 0.06);\n    --row-selected: rgba(0, 0, 0, 0.12);\n    --button-bg: rgba(255, 255, 255, 0.62);\n    --button-border: rgba(0, 0, 0, 0.10);\n    --button-text: #2c3e50;\n    --menu-bg: rgba(240, 241, 248, 0.90);\n    --menu-border: rgba(0, 0, 0, 0.06);\n    --menu-hover: rgba(255, 255, 255, 0.62);\n    --menu-text: #1a2a38;\n    --error-text: #b64545;\n    --warning-text: #8f6500;\n    --toast-bg: rgba(18, 22, 32, 0.90);\n    --toast-text: #ffffff;\n  }\n\n  @media (prefers-color-scheme: dark) {\n    :global(:root) {\n      --bg-app: transparent;\n      --text-primary: #e6e6ea;\n      --text-muted: #9494a4;\n      --bar-grad-top: rgba(38, 38, 46, 0.52);\n      --bar-grad-bottom: rgba(30, 30, 38, 0.46);\n      --surface-header: rgba(32, 32, 40, 0.46);\n      --surface: rgba(18, 18, 26, 0.32);\n      --border-soft: rgba(255, 255, 255, 0.065);\n      --border-input: rgba(255, 255, 255, 0.14);\n      --focus-ring: #5b8bd9;\n      --row-border: rgba(255, 255, 255, 0.026);\n      --row-hover: rgba(255, 255, 255, 0.08);\n      --row-selected: rgba(255, 255, 255, 0.14);\n      --button-bg: rgba(255, 255, 255, 0.072);\n      --button-border: rgba(255, 255, 255, 0.11);\n      --button-text: #d6d6e0;\n      --menu-bg: rgba(36, 36, 46, 0.90);\n      --menu-border: rgba(255, 255, 255, 0.066);\n      --menu-hover: rgba(255, 255, 255, 0.062);\n      --menu-text: #e0e0e8;\n      --error-text: #ff9d9d;\n      --warning-text: #e0c670;\n      --toast-bg: rgba(10, 10, 16, 0.93);\n      --toast-text: #f2f2f6;\n    }\n  }\n\n  /* â”€â”€ Theme: Dark â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme=\"dark\"]) {\n    color-scheme: dark;\n    --bg-app: #1E1E21;\n    --text-primary: #E2E8F0;\n    --text-muted: #94A3B8;\n    --bar-grad-top: #1E1E21;\n    --bar-grad-bottom: #1E1E21;\n    --surface-header: #1E1E21;\n    --surface: #1E1E21;\n    --bg-input: #161618;\n    --border-soft: #2A2A2D;\n    --border-input: rgba(255, 255, 255, 0.06);\n    --focus-ring: #4DA8FF;\n    --accent: #4DA8FF;\n    --row-border: rgba(255, 255, 255, 0.02);\n    --row-hover: #282828;\n    --row-selected: rgba(77, 168, 255, 0.10);\n    --button-bg: rgba(255, 255, 255, 0.05);\n    --button-border: #2A2A2D;\n    --button-text: #94A3B8;\n    --menu-bg: #252528;\n    --menu-border: #2A2A2D;\n    --menu-hover: rgba(255, 255, 255, 0.04);\n    --menu-text: #E2E8F0;\n    --error-text: #ff9d9d;\n    --warning-text: #e0c670;\n    --toast-bg: rgba(10, 10, 16, 0.93);\n    --toast-text: #f2f2f6;\n  }\n\n  /* â”€â”€ Theme: Light â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme=\"light\"]) {\n    color-scheme: light;\n    --bg-app: #F5F5F7;\n    --text-primary: #1C1C1E;\n    --text-muted: #6E6E7A;\n    --bar-grad-top: #F5F5F7;\n    --bar-grad-bottom: #F5F5F7;\n    --surface-header: #F5F5F7;\n    --surface: #F5F5F7;\n    --bg-input: #FFFFFF;\n    --border-soft: #D1D1D6;\n    --border-input: rgba(0, 0, 0, 0.10);\n    --focus-ring: #3A8BF5;\n    --accent: #3A8BF5;\n    --row-border: rgba(0, 0, 0, 0.04);\n    --row-hover: rgba(0, 0, 0, 0.04);\n    --row-selected: rgba(58, 139, 245, 0.10);\n    --button-bg: #FFFFFF;\n    --button-border: #D1D1D6;\n    --button-text: #3C3C43;\n    --menu-bg: #FFFFFF;\n    --menu-border: #D1D1D6;\n    --menu-hover: rgba(0, 0, 0, 0.05);\n    --menu-text: #1C1C1E;\n    --error-text: #D93025;\n    --warning-text: #B45309;\n    --toast-bg: rgba(255, 255, 255, 0.95);\n    --toast-text: #1C1C1E;\n  }\n\n  /* â”€â”€ Themed element overrides â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme]) {\n    background: var(--bg-app);\n  }\n\n  /* Search bar: flat, no gradient, no separator */\n  :global([data-theme]) .search-bar {\n    height: 44px;\n    padding: 0 16px;\n    background: var(--bg-app);\n    border-bottom: none;\n  }\n\n  :global([data-theme]) .search-input {\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n    font-family: 'JetBrains Mono', 'SF Mono', monospace;\n    font-size: 12px;\n    height: 34px;\n    border-radius: 8px;\n  }\n\n  /* Table header: flat bg, 16px edge padding */\n  :global([data-theme]) .table-header {\n    background: var(--bg-app);\n  }\n\n  :global([data-theme]) .col-button {\n    padding: 0 8px;\n  }\n\n  :global([data-theme]) .col.name .col-button {\n    padding-left: 16px;\n  }\n\n  /* Row cells: JetBrains Mono, 16px outer edges */\n  :global([data-theme]) .cell {\n    font-family: 'JetBrains Mono', monospace;\n  }\n\n  :global([data-theme]) .cell.name {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    padding-left: 16px;\n    font-size: 12px;\n    color: var(--text-primary);\n  }\n\n  :global([data-theme]) .cell.path {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.size {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.modified {\n    padding-right: 16px;\n    font-size: 11px;\n    white-space: nowrap;\n  }\n\n  :global([data-theme]) .row.selected {\n    box-shadow: inset 3px 0 0 var(--accent);\n  }\n\n  /* Dim path/size/date cells in themed mode */\n  :global([data-theme]) .cell.path,\n  :global([data-theme]) .cell.size,\n  :global([data-theme]) .cell.modified {\n    color: var(--text-muted);\n  }\n\n  :global(:root) {\n    background: transparent;\n  }\n\n  :global(html, body) {\n    margin: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    background: transparent;\n    color: var(--text-primary);\n    font-family: Inter, 'SF Pro Text', 'Segoe UI', Helvetica, Arial, sans-serif;\n  }\n\n  :global(#app) {\n    width: 100%;\n    height: 100%;\n  }\n\n  .app-shell {\n    display: grid;\n    grid-template-rows: auto auto 1fr auto;\n    height: 100%;\n    min-width: 0;\n  }\n\n  .title-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 44px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    cursor: default;\n    flex-shrink: 0;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-left {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-center {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-right {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-icon {\n    width: 14px;\n    height: 14px;\n    fill: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .title-text {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 13px;\n    font-weight: 500;\n    color: var(--text-primary);\n    letter-spacing: -0.01em;\n  }\n\n  .search-bar {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding: 8px;\n    background: linear-gradient(180deg, var(--bar-grad-top) 0%, var(--bar-grad-bottom) 100%);\n    border-bottom: 1px solid var(--border-soft);\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .search-input {\n    display: block;\n    box-sizing: border-box;\n    width: 100%;\n    min-width: 0;\n    flex: 1 1 auto;\n    height: 36px;\n    border: 1px solid var(--border-input);\n    border-radius: 14px;\n    padding: 0 10px;\n    font-size: 14px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    backdrop-filter: blur(12px) saturate(160%);\n    -webkit-backdrop-filter: blur(12px) saturate(160%);\n  }\n\n  .search-input::placeholder {\n    color: var(--text-muted);\n    opacity: 0.85;\n    font-size: 12px;\n  }\n\n  .search-input:focus {\n    outline: none;\n    border-color: var(--focus-ring);\n    box-shadow: 0 0 0 2px rgba(125, 169, 255, 0.25);\n  }\n\n  .table-area {\n    display: grid;\n    grid-template-rows: auto 1fr;\n    min-height: 0;\n    min-width: 0;\n  }\n\n  .table-header-track,\n  .row {\n    display: grid;\n    grid-template-columns: var(--col-name) var(--col-path) var(--col-size) var(--col-modified);\n    align-items: center;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .table-header {\n    height: 32px;\n    border-bottom: 1px solid var(--border-soft);\n    background: var(--surface-header);\n    user-select: none;\n    overflow: hidden;\n    flex-shrink: 0;\n  }\n\n  .table-header-track {\n    height: 100%;\n    transform: translateX(var(--header-offset, 0px));\n    will-change: transform;\n  }\n\n  .table-header .col {\n    position: relative;\n    min-width: 0;\n    height: 100%;\n  }\n\n  .col-button {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n    gap: 4px;\n    box-sizing: border-box;\n    padding: 0 8px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 11px;\n    font-weight: 600;\n    line-height: 1;\n    color: var(--text-muted);\n    text-align: left;\n    margin: 0;\n    border: none;\n    background: transparent;\n    cursor: pointer;\n  }\n\n  .sort-icon {\n    width: 10px;\n    height: 10px;\n    flex-shrink: 0;\n    color: var(--accent);\n  }\n\n  .col-resizer {\n    position: absolute;\n    top: 0;\n    right: -4px;\n    width: 8px;\n    height: 100%;\n    border: none;\n    padding: 0;\n    background: transparent;\n    cursor: col-resize;\n    z-index: 30;\n  }\n\n  .col-resizer::after {\n    content: '';\n    position: absolute;\n    top: 7px;\n    bottom: 7px;\n    left: 50%;\n    width: 1px;\n    transform: translateX(-50%);\n    background: var(--border-soft);\n    opacity: 0;\n    transition: opacity 0.15s ease;\n  }\n\n  .table-header .col:hover .col-resizer::after,\n  .col-resizer.active::after {\n    opacity: 1;\n  }\n\n  .table-body {\n    overflow: auto;\n    min-height: 0;\n    min-width: 0;\n    background: var(--surface);\n  }\n\n  .spacer {\n    position: relative;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .rows {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .row {\n    height: 30px;\n    border-bottom: 1px solid var(--row-border);\n    cursor: default;\n    -webkit-user-select: none;\n    user-select: none;\n    outline: none;\n  }\n\n  .row:hover {\n    background: var(--row-hover);\n  }\n\n  .row.selected {\n    background: var(--row-selected);\n  }\n\n  .cell {\n    padding: 0 8px;\n    font-size: 12px;\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    min-width: 0;\n  }\n\n  .cell.size {\n    text-align: right;\n    font-variant-numeric: tabular-nums;\n  }\n\n  .ellipsis {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n\n  .hl {\n    background: none;\n    color: inherit;\n    font-weight: 700;\n  }\n\n  .file-icon {\n    width: 16px;\n    height: 16px;\n    flex: 0 0 auto;\n  }\n\n  .name-editing {\n    opacity: 0.25;\n  }\n\n  .rename-overlay {\n    position: fixed;\n    z-index: 100;\n    min-width: 120px;\n  }\n\n  .rename-textarea {\n    display: block;\n    width: 100%;\n    box-sizing: border-box;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 12px;\n    line-height: 18px;\n    padding: 5px 4px 5px 0;\n    border: 1.5px solid var(--focus-ring);\n    border-radius: 4px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    outline: none;\n    resize: none;\n    overflow: hidden;\n    box-shadow: 0 2px 14px rgba(0, 0, 0, 0.22), 0 0 0 3px rgba(77, 168, 255, 0.13);\n  }\n\n  .status-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 32px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    border-top: 1px solid var(--border-soft);\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 11px;\n    color: var(--text-muted);\n    white-space: nowrap;\n    overflow: hidden;\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .status-left {\n    display: flex;\n    align-items: center;\n    gap: 16px;\n    overflow: hidden;\n    min-width: 0;\n  }\n\n  .status-right {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    flex-shrink: 0;\n  }\n\n  .status-btn {\n    border: 1px solid var(--button-border);\n    border-radius: 5px;\n    background: var(--button-bg);\n    color: var(--button-text);\n    font-size: 11px;\n    height: 22px;\n    padding: 0 8px;\n    cursor: pointer;\n  }\n\n  .status-btn:hover {\n    filter: brightness(1.06);\n  }\n\n  .status-btn:disabled {\n    opacity: 0.55;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .status-state {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n  }\n\n  .state-dot {\n    width: 6px;\n    height: 6px;\n    border-radius: 50%;\n    flex-shrink: 0;\n  }\n\n  .state-dot.ready { background: #28C840; }\n  .state-dot.indexing { background: #FEBC2E; }\n  .state-dot.error { background: #FF5F57; }\n\n  .rebuild-btn {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 10px;\n    font-weight: 500;\n    background: var(--button-bg);\n    border: 1px solid var(--button-border);\n    border-radius: 4px;\n    color: var(--button-text);\n    height: 22px;\n    padding: 0 10px;\n    cursor: pointer;\n  }\n\n  .rebuild-btn:hover {\n    filter: brightness(1.1);\n  }\n\n  .rebuild-btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .rebuild-icon {\n    width: 11px;\n    height: 11px;\n    color: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .status-error {\n    color: var(--error-text);\n  }\n\n  .status-warning {\n    color: var(--warning-text);\n  }\n\n  .status-spotlight {\n    color: #f59e0b;\n    font-weight: 600;\n  }\n\n  .context-menu {\n    position: fixed;\n    z-index: 200;\n    width: 220px;\n    border: 1px solid var(--menu-border);\n    border-radius: 10px;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.16), inset 0 0 0 0.5px rgba(255, 255, 255, 0.18);\n    background: var(--menu-bg);\n    backdrop-filter: blur(28px) saturate(180%);\n    -webkit-backdrop-filter: blur(28px) saturate(180%);\n    overflow: hidden;\n  }\n\n  .context-menu button {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    padding: 8px 10px;\n    font-size: 12px;\n    color: var(--menu-text);\n  }\n\n  .context-menu button:hover {\n    background: var(--menu-hover);\n  }\n\n  .toast {\n    position: fixed;\n    right: 14px;\n    bottom: 18px;\n    background: var(--toast-bg);\n    color: var(--toast-text);\n    border-radius: 10px;\n    padding: 9px 12px;\n    font-size: 12px;\n    z-index: 250;\n    backdrop-filter: blur(20px) saturate(180%);\n    -webkit-backdrop-filter: blur(20px) saturate(180%);\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);\n  }\n</style>\n","structuredPatch":[{"oldStart":1562,"oldLines":7,"newStart":1562,"newLines":7,"lines":["       {/if}","     </div>","     <div class=\"status-right\">","-      <button class=\"status-btn theme-btn\" on:click={cycleTheme} title=\"Switch theme\">","+      <button class=\"status-btn\" on:click={cycleTheme} title=\"Switch theme\">","         {theme === 'dark' ? 'â˜€ Light' : 'â—‘ Dark'}","       </button>","       <button"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"ba852004-4461-4dc4-b70d-af38b492c147"}
{"parentUuid":"defd8358-40e2-46db-a3d7-ec9964108c9b","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01QLYphvxzmCCLuZgnnb1wub","type":"message","role":"assistant","content":[{"type":"text","text":"ì´ì œ sort icon ì¤‘ë³µ ì œê±°ë¥¼ ìœ„í•œ í—¬í¼ í•¨ìˆ˜ ì¶”ê°€ ë° í…œí”Œë¦¿ êµì²´ë¥¼ í•©ë‹ˆë‹¤."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":341,"cache_read_input_tokens":96108,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":341},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPNEFXkfxM6uNm81U4D","type":"assistant","uuid":"b08ea3aa-b147-4651-baa5-bea96ce9f387","timestamp":"2026-02-21T14:39:25.752Z"}
{"parentUuid":"b08ea3aa-b147-4651-baa5-bea96ce9f387","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01QLYphvxzmCCLuZgnnb1wub","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MghHh8ShfRNbB3TqC6KD6C","name":"Edit","input":{"replace_all":false,"file_path":"/Users/al02402336/everything/src/App.svelte","old_string":"  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || 'dark'; } catch { return 'dark'; } })();\n  function cycleTheme() {\n    theme = theme === 'dark' ? 'light' : 'dark';\n    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n  }","new_string":"  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || 'dark'; } catch { return 'dark'; } })();\n  function cycleTheme() {\n    theme = theme === 'dark' ? 'light' : 'dark';\n    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n  }\n\n  function sortIconHtml(dir) {\n    const d = dir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5';\n    return `<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"${d}\"/></svg>`;\n  }"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":341,"cache_read_input_tokens":96108,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":341},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPNEFXkfxM6uNm81U4D","type":"assistant","uuid":"f7465ab6-f97a-41a3-be55-b7233de28308","timestamp":"2026-02-21T14:39:30.036Z"}
{"parentUuid":"f7465ab6-f97a-41a3-be55-b7233de28308","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>String to replace not found in file.\nString:   let theme = (() => { try { return localStorage.getItem(THEME_KEY) || 'dark'; } catch { return 'dark'; } })();\n  function cycleTheme() {\n    theme = theme === 'dark' ? 'light' : 'dark';\n    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n  }</tool_use_error>","is_error":true,"tool_use_id":"toolu_01MghHh8ShfRNbB3TqC6KD6C"}]},"uuid":"f555ac3b-8021-47c3-9844-0281c048ba85","timestamp":"2026-02-21T14:39:30.036Z","toolUseResult":"Error: String to replace not found in file.\nString:   let theme = (() => { try { return localStorage.getItem(THEME_KEY) || 'dark'; } catch { return 'dark'; } })();\n  function cycleTheme() {\n    theme = theme === 'dark' ? 'light' : 'dark';\n    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n  }","sourceToolAssistantUUID":"f7465ab6-f97a-41a3-be55-b7233de28308"}
{"parentUuid":"f555ac3b-8021-47c3-9844-0281c048ba85","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_0148etfEssfFK4waqk8D9xz7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01McoASLGga2qDzzUtMJ5Gcm","name":"Read","input":{"file_path":"/Users/al02402336/everything/src/App.svelte","offset":26,"limit":8},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":618,"cache_read_input_tokens":96449,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":618},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPNmGqB3LwVDXyk9ckF","type":"assistant","uuid":"61f7e024-4dbb-45cc-a5a8-18ea7e7c2cbf","timestamp":"2026-02-21T14:39:32.358Z"}
{"parentUuid":"61f7e024-4dbb-45cc-a5a8-18ea7e7c2cbf","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01McoASLGga2qDzzUtMJ5Gcm","toolUseID":"toolu_01McoASLGga2qDzzUtMJ5Gcm","timestamp":"2026-02-21T14:39:32.365Z","uuid":"9b81df38-c3d3-4e82-b291-5d998f83c47e"}
{"parentUuid":"61f7e024-4dbb-45cc-a5a8-18ea7e7c2cbf","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01McoASLGga2qDzzUtMJ5Gcm","type":"tool_result","content":"    26â†’  const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';\n    27â†’  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || systemTheme; } catch { return systemTheme; } })();\n    28â†’  function cycleTheme() {\n    29â†’    theme = theme === 'dark' ? 'light' : 'dark';\n    30â†’    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n    31â†’    invoke('set_native_theme', { theme });\n    32â†’  }\n    33â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"b9212728-cf7e-4479-a70b-79ce43957e80","timestamp":"2026-02-21T14:39:32.365Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src/App.svelte","content":"  const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';\n  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || systemTheme; } catch { return systemTheme; } })();\n  function cycleTheme() {\n    theme = theme === 'dark' ? 'light' : 'dark';\n    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n    invoke('set_native_theme', { theme });\n  }\n","numLines":8,"startLine":26,"totalLines":2277}},"sourceToolAssistantUUID":"61f7e024-4dbb-45cc-a5a8-18ea7e7c2cbf"}
{"parentUuid":"b9212728-cf7e-4479-a70b-79ce43957e80","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01CAG7KccoX9Cf35hzmrZirh","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The file has been modified since I last read it. Let me read the full current state first.","signature":"EoICCkYICxgCKkA0JCRmFOd/WHgB4uXsPZnXWyVpb2zF8ZYo8Yy9aBg15BufTE/UMU+bSbzxjUmWgrbRBFoeG6QiuFhkl6n3SPmkEgw/LT4RKDZIIFMGWjYaDKyb3iWnotd3f9NSZCIwvF5WZph3mzAM9YdLJrC95x5zVdvhNfkkacLuDL7L2eifPbkDh+YoEZ8nYVo9obBUKmo4QaYQQI6Hu8Tfq9FEvyyGdkHqok6SgsVZeH4+TWNoVIvzTR8KM3eE+eCcrvPIB2XAmsS5XJn2Jfex8ID2VE/W/6GWfaM8XhaVcwx7F0wYY4/dnzU/pWb8rfBmtzPJ3HkhRutrItuvFXofGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":354,"cache_read_input_tokens":97067,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":354},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPNwh9NAQAKc9soAvuG","type":"assistant","uuid":"680ae75e-6be5-4002-8bf5-866cef2b41de","timestamp":"2026-02-21T14:39:34.556Z"}
{"parentUuid":"680ae75e-6be5-4002-8bf5-866cef2b41de","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01CAG7KccoX9Cf35hzmrZirh","type":"message","role":"assistant","content":[{"type":"text","text":"íŒŒì¼ì´ ì¤‘ê°„ì— ë³€ê²½ë˜ì—ˆë„¤ìš”. ì „ì²´ë¥¼ ë‹¤ì‹œ ì½ê² ìŠµë‹ˆë‹¤."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":354,"cache_read_input_tokens":97067,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":354},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPNwh9NAQAKc9soAvuG","type":"assistant","uuid":"f0e48127-8deb-4376-86e4-a0723aaa9642","timestamp":"2026-02-21T14:39:35.252Z"}
{"parentUuid":"f0e48127-8deb-4376-86e4-a0723aaa9642","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01CAG7KccoX9Cf35hzmrZirh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016eeNhVjfUBFAiCsZv1LBa1","name":"Read","input":{"file_path":"/Users/al02402336/everything/src/App.svelte","offset":26,"limit":15},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":354,"cache_read_input_tokens":97067,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":354},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPNwh9NAQAKc9soAvuG","type":"assistant","uuid":"96d0096c-6301-4ad3-84cc-dae5a033fd90","timestamp":"2026-02-21T14:39:35.825Z"}
{"parentUuid":"96d0096c-6301-4ad3-84cc-dae5a033fd90","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_016eeNhVjfUBFAiCsZv1LBa1","toolUseID":"toolu_016eeNhVjfUBFAiCsZv1LBa1","timestamp":"2026-02-21T14:39:35.832Z","uuid":"552cd4bd-bf9b-45cc-ad0c-ab42c7c8ef41"}
{"parentUuid":"96d0096c-6301-4ad3-84cc-dae5a033fd90","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016eeNhVjfUBFAiCsZv1LBa1","type":"tool_result","content":"    26â†’  const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';\n    27â†’  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || systemTheme; } catch { return systemTheme; } })();\n    28â†’  function cycleTheme() {\n    29â†’    theme = theme === 'dark' ? 'light' : 'dark';\n    30â†’    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n    31â†’    invoke('set_native_theme', { theme });\n    32â†’  }\n    33â†’\n    34â†’  let query = '';\n    35â†’  let results = [];\n    36â†’  let totalResults = 0;\n    37â†’  let totalResultsKnown = false;\n    38â†’\n    39â†’  let dbLatencyMs = null;\n    40â†’  let dbLastQuery = '';\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"1b8689c8-9d05-4a3a-8b72-f241d2921cde","timestamp":"2026-02-21T14:39:35.831Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src/App.svelte","content":"  const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';\n  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || systemTheme; } catch { return systemTheme; } })();\n  function cycleTheme() {\n    theme = theme === 'dark' ? 'light' : 'dark';\n    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n    invoke('set_native_theme', { theme });\n  }\n\n  let query = '';\n  let results = [];\n  let totalResults = 0;\n  let totalResultsKnown = false;\n\n  let dbLatencyMs = null;\n  let dbLastQuery = '';","numLines":15,"startLine":26,"totalLines":2277}},"sourceToolAssistantUUID":"96d0096c-6301-4ad3-84cc-dae5a033fd90"}
{"parentUuid":"1b8689c8-9d05-4a3a-8b72-f241d2921cde","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_015SaASrc23fxv1qUua8gTPb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Uq8Qt3cz8p3AqmyDbSL2rL","name":"Read","input":{"file_path":"/Users/al02402336/everything/src/App.svelte","offset":670,"limit":8},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":494,"cache_read_input_tokens":97421,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":494},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPPCAnoNhYzndqHu8ZX","type":"assistant","uuid":"dd0d1513-4dcf-43ba-bbe3-237431c99b56","timestamp":"2026-02-21T14:39:38.387Z"}
{"parentUuid":"dd0d1513-4dcf-43ba-bbe3-237431c99b56","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01Uq8Qt3cz8p3AqmyDbSL2rL","toolUseID":"toolu_01Uq8Qt3cz8p3AqmyDbSL2rL","timestamp":"2026-02-21T14:39:38.403Z","uuid":"c0b051a8-4cac-4d70-9685-437451f7a7aa"}
{"parentUuid":"dd0d1513-4dcf-43ba-bbe3-237431c99b56","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Uq8Qt3cz8p3AqmyDbSL2rL","type":"tool_result","content":"   670â†’  }\n   671â†’\n   672â†’  function buildDragPreview(index) {\n   673â†’    const entry = results[index];\n   674â†’    if (!entry) return null;\n   675â†’\n   676â†’    const count = selectedIndices.has(index) ? selectedIndices.size : 1;\n   677â†’    const isDark = theme === 'dark';\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"b5967d4e-91ac-472f-ab82-03c175a5f7cf","timestamp":"2026-02-21T14:39:38.402Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src/App.svelte","content":"  }\n\n  function buildDragPreview(index) {\n    const entry = results[index];\n    if (!entry) return null;\n\n    const count = selectedIndices.has(index) ? selectedIndices.size : 1;\n    const isDark = theme === 'dark';","numLines":8,"startLine":670,"totalLines":2277}},"sourceToolAssistantUUID":"dd0d1513-4dcf-43ba-bbe3-237431c99b56"}
{"parentUuid":"b5967d4e-91ac-472f-ab82-03c175a5f7cf","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01FzSPAEXbNANTZtuv584nVi","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Good, the isDark fix is already in the file. Now let me also check: the `systemTheme` added at line 26 uses `window.matchMedia(...)`. Since the `isDark` fix was already applied (line 677 uses `theme === 'dark'`), the `systemTheme` initialization at line 26 still uses `window.matchMedia`. That's fine because `systemTheme` is used as the initial theme value (to start with the OS preference when localStorage is empty), which is correct.\n\nNow let me add the `sortIconHtml` function after `cycleTheme` on line 32.\n\n\nLet me review the current state of the file more carefully to make sure I'm working with the latest version.","signature":"Eq0GCkYICxgCKkAWdUUs7VB9/mJYO6f4m0J/DC2CV6D13XJWFw3FbZvyhIhdjLBnlO6gCUuGD69bZMfzyp0tEugTtGnvqd6NbO+aEgzzCJWM0dbQoMNz1a8aDO+P0adyKy1gUNJU5CIwv5E8AJx0z6HffqfAdr7cgfIiVSS8/KCVtKWRxjY3Rv9ARrBPi/CFRgwyc8Ab3u/zKpQFih2aQfzUUPEum8viaMojujDzJLIAdmRRObjxOArT0A8e3/yMHF1G2Rgudufabw/2KSPwgsBmk4vOXg74vl5p+eS//D9quZt86IDeyJYLx9gaxaQhbunO1EehAXbz4KZPUJWAsOhJP17sa7UNAh+BpvezLpeshKSVAX27S/r+JpDvEvmoCF3iaqkPyNm3zCpbk8FwlEbOSV9AfowDbJjjRto1z0hGdntrrjOm98oXW3b84Nx9JHq+0gT54k4oAhKKWnk31erzOkd7HqdJAd072Ww46VVt3SdT/AWwNr7SWAVSDAhmZbBm0158J1zA+CG7zUucLybyjyvyRIIEdXBu9YseW3+1u1NJJ3uKvuDxWlbfwXU9R+OX3KYfpf+wLv7gjpndBz9R/O1LqlPx4VJFVBBSpNtpaY+u623MH2H8e3ILIZ7F2mVp9mu/P/2Ut9sIX8y3UZHwQUfzqTc8TAwdK4G0VmEQWJ8O98UT9y96EGpKb9AqCJm4Q494kJR+r3HqXhnLRVwYXbEabz9dtomkr/JaohSVv5VjCW7hB4g2fxGvwQ7o0iFl805W/NNlMQlDVujOPz5/fsgHTf8eKXLGtuOpfzgpAhaO5sJRFoqNAJt7rG5ECBGs7xRgvkGlPLG7vgAwIfUqIRKDBL8b05lzUuATbBdX/fuKZd7dIDTNGTXGK94yF/1+c7uou/wPdLB2TTXDmfauSiaxj8pngBA5HXp9Bkc7Eft6s3hB0a4LK4sZ1tdHMk4fLIGhMgcbr+qjYt9mteaPOcYk3VrCV+qdWreqOtsm7V8PBajwmHaREZP4iDHPemBFVTujtx+FlGNmmIdMt61jRckfZmluTH0y72b9AExMksTyVvrLfcgyxKKZ8W/YGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":287,"cache_read_input_tokens":97915,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":287},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPPPEoTa8agkJ5EHZUB","type":"assistant","uuid":"8054b880-18fc-4d94-8fdf-104e91c77e17","timestamp":"2026-02-21T14:39:45.778Z"}
{"parentUuid":"8054b880-18fc-4d94-8fdf-104e91c77e17","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01FzSPAEXbNANTZtuv584nVi","type":"message","role":"assistant","content":[{"type":"text","text":"`isDark` ìˆ˜ì •ì€ ì´ë¯¸ ë°˜ì˜ë˜ì—ˆìŠµë‹ˆë‹¤. sort icon í—¬í¼ì™€ CSS ìˆ˜ì •ì„ ê³„ì†í•©ë‹ˆë‹¤."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":287,"cache_read_input_tokens":97915,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":287},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPPPEoTa8agkJ5EHZUB","type":"assistant","uuid":"1a7cfaa1-4664-479a-b75f-079665922386","timestamp":"2026-02-21T14:39:45.789Z"}
{"parentUuid":"1a7cfaa1-4664-479a-b75f-079665922386","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01FzSPAEXbNANTZtuv584nVi","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BAdTxvoGsovR71sdQF7Xz6","name":"Edit","input":{"replace_all":false,"file_path":"/Users/al02402336/everything/src/App.svelte","old_string":"    invoke('set_native_theme', { theme });\n  }\n\n  let query = '';","new_string":"    invoke('set_native_theme', { theme });\n  }\n\n  function sortIconHtml(dir) {\n    const d = dir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5';\n    return `<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"${d}\"/></svg>`;\n  }\n\n  let query = '';"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":287,"cache_read_input_tokens":97915,"output_tokens":534,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":287,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYMPPPEoTa8agkJ5EHZUB","type":"assistant","uuid":"d824e066-f0fb-4f09-8e84-239fdaca9b3c","timestamp":"2026-02-21T14:39:47.797Z"}
{"parentUuid":"d824e066-f0fb-4f09-8e84-239fdaca9b3c","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01BAdTxvoGsovR71sdQF7Xz6","toolUseID":"toolu_01BAdTxvoGsovR71sdQF7Xz6","timestamp":"2026-02-21T14:39:47.812Z","uuid":"e72a639b-5c5c-4115-9bd9-57bc010db280"}
{"parentUuid":"d824e066-f0fb-4f09-8e84-239fdaca9b3c","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BAdTxvoGsovR71sdQF7Xz6","type":"tool_result","content":"The file /Users/al02402336/everything/src/App.svelte has been updated successfully."}]},"uuid":"924f6ed6-b88d-4f62-abb0-cc7e4d782cb4","timestamp":"2026-02-21T14:39:47.811Z","toolUseResult":{"filePath":"/Users/al02402336/everything/src/App.svelte","oldString":"    invoke('set_native_theme', { theme });\n  }\n\n  let query = '';","newString":"    invoke('set_native_theme', { theme });\n  }\n\n  function sortIconHtml(dir) {\n    const d = dir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5';\n    return `<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"${d}\"/></svg>`;\n  }\n\n  let query = '';","originalFile":"<script>\n  import { onDestroy, onMount, tick } from 'svelte';\n  import { invoke } from '@tauri-apps/api/core';\n  import { listen } from '@tauri-apps/api/event';\n  import { getCurrentWindow } from '@tauri-apps/api/window';\n  import { startDrag } from '@crabnebula/tauri-plugin-drag';\n\n  const rowHeight = 30;\n  const PAGE_SIZE = 500;\n  let homePrefix = '';\n  const COL_WIDTHS_KEY = 'REDACTED';\n  const THEME_KEY = 'everything-theme';\n  const columnKeys = ['name', 'path', 'size', 'modified'];\n  const minColumnWidth = {\n    name: 180,\n    path: 240,\n    size: 75,\n    modified: 150\n  };\n  const defaultColumnRatios = {\n    name: 0.3,\n    path: 0.45,\n    size: 0.1\n  };\n\n  const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';\n  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || systemTheme; } catch { return systemTheme; } })();\n  function cycleTheme() {\n    theme = theme === 'dark' ? 'light' : 'dark';\n    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n    invoke('set_native_theme', { theme });\n  }\n\n  let query = '';\n  let results = [];\n  let totalResults = 0;\n  let totalResultsKnown = false;\n\n  let dbLatencyMs = null;\n  let dbLastQuery = '';\n  let searchModeLabel = '';\n  let selectedIndices = new Set();\n  let selectionAnchor = -1;\n  let lastSelectedIndex = -1;\n  let editing = {\n    active: false,\n    path: '',\n    index: -1,\n    draftName: ''\n  };\n\n  let renameOverlay = { top: 0, left: 0, width: 0 };\n\n  let indexStatus = {\n    state: 'Indexing',\n    entriesCount: 0,\n    lastUpdated: null,\n    permissionErrors: 0,\n    message: null,\n    isCatchup: false\n  };\n\n  let indexingStartTime = null;\n  let indexingElapsed = '';\n  let indexingFinishedAt = '';\n\n  let sortBy = 'name';\n  let sortDir = 'asc';\n\n  let hasMore = true;\n  let loadingMore = false;\n  let searchGeneration = 0;\n\n  let scanned = 0;\n\n  let searchInputEl;\n  let renameInputEl;\n  let tableAreaEl;\n  let tableContainer;\n  let tableResizeObserver = null;\n  let viewportResizeRaf = null;\n  let scrollTop = 0;\n  let headerScrollLeft = 0;\n  let viewportHeight = 520;\n  let lastTableWidth = 0;\n  let resizingColumn = '';\n  let resizeCleanup = null;\n  let colWidths = {\n    name: 250,\n    path: 350,\n    size: 75,\n    modified: 150\n  };\n\n  let contextMenu = {\n    visible: false,\n    x: 0,\n    y: 0\n  };\n\n  let platform = '';\n  let toast = '';\n  let searchTimer;\n  let lastSearchFiredAt = 0;\n  let toastTimer;\n  let statusRefreshTimer;\n  let elapsedTimer;\n  let statusRefreshInFlight = false;\n  let lastReadyCount = 0;\n\n  const iconCache = new Map();\n  const iconLoading = new Set();\n\n  let highlightCache = new Map();\n  let highlightCacheQuery = '';\n\n  const folderFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='1' y='4' width='14' height='10' rx='2' fill='#d9b34f'/><rect x='1' y='2' width='6' height='4' rx='1' fill='#e6ca7a'/></svg>`\n    );\n  const fileFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='3' y='1' width='10' height='14' rx='1.5' fill='#b4bec9'/><rect x='5' y='5' width='6' height='1.2' fill='#8d98a5'/><rect x='5' y='8' width='6' height='1.2' fill='#8d98a5'/></svg>`\n    );\n\n  $: totalHeight = results.length * rowHeight;\n  $: startIndex = Math.max(0, Math.floor(scrollTop / rowHeight) - 10);\n  $: visibleCount = Math.ceil(viewportHeight / rowHeight) + 20;\n  $: endIndex = Math.min(results.length, startIndex + visibleCount);\n  $: visibleRows = results.slice(startIndex, endIndex);\n  $: translateY = startIndex * rowHeight;\n  $: tableMinWidth = colWidths.name + colWidths.path + colWidths.size + colWidths.modified;\n  $: tableGridStyle = `--col-name:${colWidths.name}px;--col-path:${colWidths.path}px;--col-size:${colWidths.size}px;--col-modified:${colWidths.modified}px;--table-min-width:${tableMinWidth}px;--header-offset:${-headerScrollLeft}px;`;\n\n  $: {\n    for (const entry of visibleRows) {\n      void ensureIcon(entry);\n    }\n  }\n\n  function showToast(message) {\n    toast = message;\n    clearTimeout(toastTimer);\n    toastTimer = setTimeout(() => {\n      toast = '';\n    }, 3000);\n  }\n\n  function bytesToBase64(bytes) {\n    let binary = '';\n    const chunk = 0x8000;\n    for (let i = 0; i < bytes.length; i += chunk) {\n      const part = bytes.subarray(i, i + chunk);\n      binary += String.fromCharCode(...part);\n    }\n    return btoa(binary);\n  }\n\n  function highlightSegments(name, q) {\n    q = (q || '').trim();\n    if (!q) return [{ text: name, hl: false }];\n\n    // Reset cache when query changes\n    if (q !== highlightCacheQuery) {\n      highlightCache = new Map();\n      highlightCacheQuery = q;\n    }\n\n    // Check cache\n    const cached = highlightCache.get(name);\n    if (cached) return cached;\n\n    if (q.includes('/')) q = q.slice(q.lastIndexOf('/') + 1);\n    q = q.replace(/[*?]/g, '');\n    const terms = q.split(/\\s+/).filter(Boolean);\n    if (terms.length === 0) return [{ text: name, hl: false }];\n\n    const lower = name.toLowerCase();\n    const marks = new Uint8Array(name.length);\n    for (const t of terms) {\n      const tl = t.toLowerCase();\n      let idx = lower.indexOf(tl);\n      while (idx !== -1) {\n        for (let i = idx; i < idx + tl.length; i++) marks[i] = 1;\n        idx = lower.indexOf(tl, idx + 1);\n      }\n    }\n\n    const segs = [];\n    let i = 0;\n    while (i < name.length) {\n      const m = marks[i];\n      let j = i + 1;\n      while (j < name.length && marks[j] === m) j++;\n      segs.push({ text: name.slice(i, j), hl: m === 1 });\n      i = j;\n    }\n\n    highlightCache.set(name, segs);\n    return segs;\n  }\n\n  const perFileIconExts = new Set(['exe', 'lnk', 'ico', 'url', 'scr', 'appx']);\n\n  function iconKey(entry) {\n    if (entry.isDir) return '__folder__';\n    const ext = (entry.ext || '').toLowerCase();\n    if (perFileIconExts.has(ext)) return entry.path;\n    return ext || '__file__';\n  }\n\n  function iconFor(entry) {\n    return iconCache.get(iconKey(entry)) || (entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n  }\n\n  async function ensureIcon(entry) {\n    const key = iconKey(entry);\n    if (iconCache.has(key) || iconLoading.has(key)) {\n      return;\n    }\n\n    iconLoading.add(key);\n    try {\n      const bytes = await invoke('get_file_icon', {\n        path: entry.path,\n        ext: entry.isDir ? 'folder' : entry.ext || '',\n      });\n      if (Array.isArray(bytes) && bytes.length > 0) {\n        const image = `data:image/png;base64,${bytesToBase64(Uint8Array.from(bytes))}`;\n        iconCache.set(key, image);\n      } else {\n        iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n      }\n    } catch {\n      iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n    } finally {\n      iconLoading.delete(key);\n    }\n  }\n\n  function syncColumnWidthsToContainer() {\n    const width = tableContainer?.clientWidth || tableAreaEl?.clientWidth;\n    if (!width || lastTableWidth !== 0) {\n      return;\n    }\n\n    const saved = loadColWidths();\n    if (saved) {\n      const total = columnKeys.reduce((s, k) => s + saved[k], 0);\n      if (Math.abs(total - width) > 2) {\n        const scale = (width - saved.modified) / (total - saved.modified);\n        let scaledName = Math.max(minColumnWidth.name, Math.round(saved.name * scale));\n        let scaledSize = Math.max(minColumnWidth.size, Math.round(saved.size * scale));\n        let rawPath = width - saved.modified - scaledName - scaledSize;\n        if (rawPath < minColumnWidth.path) {\n          const shortfall = minColumnWidth.path - rawPath;\n          const nameReduction = Math.min(shortfall, scaledName - minColumnWidth.name);\n          scaledName -= nameReduction;\n          const remaining = shortfall - nameReduction;\n          if (remaining > 0) {\n            scaledSize -= Math.min(remaining, scaledSize - minColumnWidth.size);\n          }\n          rawPath = width - saved.modified - scaledName - scaledSize;\n        }\n        const scaledPath = Math.max(minColumnWidth.path, rawPath);\n        colWidths = { name: scaledName, path: scaledPath, size: scaledSize, modified: saved.modified };\n      } else {\n        colWidths = saved;\n      }\n    } else {\n      const fixedModified = minColumnWidth.modified;\n      const rest = width - fixedModified;\n      const ratioSum = defaultColumnRatios.name + defaultColumnRatios.path + defaultColumnRatios.size;\n      colWidths = {\n        name: Math.max(minColumnWidth.name, Math.round(rest * defaultColumnRatios.name / ratioSum)),\n        path: Math.max(minColumnWidth.path, Math.round(rest * defaultColumnRatios.path / ratioSum)),\n        size: Math.max(minColumnWidth.size, Math.round(rest * defaultColumnRatios.size / ratioSum)),\n        modified: fixedModified\n      };\n    }\n    lastTableWidth = width;\n  }\n\n  function loadColWidths() {\n    try {\n      const raw = localStorage.getItem(COL_WIDTHS_KEY);\n      if (!raw) return null;\n      const parsed = JSON.parse(raw);\n      for (const key of columnKeys) {\n        if (typeof parsed[key] !== 'number' || parsed[key] < (minColumnWidth[key] || 0)) return null;\n      }\n      return parsed;\n    } catch {\n      return null;\n    }\n  }\n\n  function saveColWidths() {\n    localStorage.setItem(COL_WIDTHS_KEY, JSON.stringify(colWidths));\n  }\n\n  function updateViewportHeight() {\n    viewportHeight = tableContainer?.clientHeight || 520;\n    syncColumnWidthsToContainer();\n  }\n\n  function scheduleViewportHeightUpdate() {\n    if (viewportResizeRaf !== null) {\n      return;\n    }\n    viewportResizeRaf = requestAnimationFrame(() => {\n      viewportResizeRaf = null;\n      updateViewportHeight();\n    });\n  }\n\n  function startColumnResize(event, leftKey) {\n    event.preventDefault();\n    event.stopPropagation();\n\n    const index = columnKeys.indexOf(leftKey);\n    if (index < 0 || index >= columnKeys.length - 1) {\n      return;\n    }\n\n    const startX = event.clientX;\n    const startLeft = colWidths[leftKey];\n    const rightKey = columnKeys[index + 1];\n    const startRight = colWidths[rightKey];\n\n    resizeCleanup?.();\n    resizingColumn = leftKey;\n\n    const onMove = (moveEvent) => {\n      const delta = Math.round(moveEvent.clientX - startX);\n      if (leftKey === 'name') {\n        // Two-column trade: name and path swap space, each respects its minimum\n        const nextLeft = Math.max(\n          minColumnWidth[leftKey],\n          Math.min(startLeft + delta, startLeft + startRight - minColumnWidth[rightKey])\n        );\n        const nextRight = startLeft + startRight - nextLeft;\n        colWidths = { ...colWidths, [leftKey]: nextLeft, [rightKey]: nextRight };\n      } else {\n        // path splitter: path grows unconstrained (allows horizontal scroll on right drag)\n        const nextLeft = Math.max(minColumnWidth[leftKey], startLeft + delta);\n        colWidths = { ...colWidths, [leftKey]: nextLeft };\n      }\n    };\n\n    const onUp = () => {\n      cleanup();\n    };\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      document.body.style.cursor = '';\n      document.body.style.userSelect = '';\n      resizingColumn = '';\n      saveColWidths();\n      if (resizeCleanup === cleanup) {\n        resizeCleanup = null;\n      }\n    };\n\n    resizeCleanup = cleanup;\n    document.body.style.cursor = 'col-resize';\n    document.body.style.userSelect = 'none';\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  function selectedPaths() {\n    const sorted = [...selectedIndices].sort((a, b) => a - b);\n    return sorted.map((idx) => results[idx]).filter(Boolean).map((entry) => entry.path);\n  }\n\n  function clearSelection() {\n    selectedIndices = new Set();\n    selectionAnchor = -1;\n    lastSelectedIndex = -1;\n  }\n\n  function selectSingle(index) {\n    selectedIndices = new Set([index]);\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectToggle(index) {\n    const next = new Set(selectedIndices);\n    if (next.has(index)) {\n      next.delete(index);\n    } else {\n      next.add(index);\n    }\n    selectedIndices = next;\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectRange(index) {\n    const anchor = selectionAnchor >= 0 ? selectionAnchor : index;\n    const [from, to] = [Math.min(anchor, index), Math.max(anchor, index)];\n    const next = new Set();\n    for (let i = from; i <= to; i += 1) {\n      next.add(i);\n    }\n    selectedIndices = next;\n    lastSelectedIndex = index;\n  }\n\n  function primaryEntry() {\n    const idx = lastSelectedIndex >= 0 ? lastSelectedIndex : -1;\n    return idx >= 0 ? results[idx] : null;\n  }\n\n  async function refreshStatus() {\n    if (statusRefreshInFlight) {\n      return;\n    }\n    statusRefreshInFlight = true;\n    try {\n      const status = await invoke('get_index_status');\n      const prevState = indexStatus.state;\n      indexStatus = {\n        state: status.state,\n        entriesCount: status.entriesCount,\n        lastUpdated: status.lastUpdated,\n        permissionErrors: status.permissionErrors ?? 0,\n        message: status.message\n      };\n      if (status.state === 'Indexing' && prevState !== 'Indexing') {\n        startElapsedTimer();\n      } else if (status.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n      if (typeof status.scanned === 'number') {\n        scanned = status.scanned;\n      }\n      if (status.state === 'Ready' && prevState !== 'Ready') {\n        scheduleSearch();\n      }\n    } catch (err) {\n      showToast(`Failed to get status: ${String(err)}`);\n    } finally {\n      statusRefreshInFlight = false;\n    }\n  }\n\n  function scheduleSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const scheduledGen = searchGeneration;\n    clearTimeout(searchTimer);\n\n    const now = performance.now();\n    if (now - lastSearchFiredAt >= 200) {\n      // Leading edge: fire immediately if enough time has passed\n      lastSearchFiredAt = now;\n      void runSearch(preserveScroll);\n    } else {\n      // Trailing edge: debounce\n      searchTimer = setTimeout(() => {\n        if (scheduledGen !== searchGeneration) {\n          return;\n        }\n        lastSearchFiredAt = performance.now();\n        void runSearch(preserveScroll);\n      }, 200);\n    }\n  }\n\n  async function runSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const gen = searchGeneration;\n    const searchQuery = query;\n    const searchSortBy = sortBy;\n    const searchSortDir = sortDir;\n    const startedAt = performance.now();\n    try {\n      const keepPaths = new Set(selectedPaths());\n      const next = await invoke('search', {\n        query: searchQuery,\n        limit: PAGE_SIZE,\n        offset: 0,\n        sortBy: searchSortBy,\n        sortDir: searchSortDir\n      });\n\n      if (gen !== searchGeneration) return;\n\n      dbLatencyMs = Math.round(performance.now() - startedAt);\n      dbLastQuery = searchQuery;\n      const entries = Array.isArray(next.entries) ? next.entries : [];\n      searchModeLabel = next.modeLabel || '';\n      results = entries;\n      if (next.totalCount > 0) {\n        totalResults = next.totalCount;\n        totalResultsKnown = true;\n      } else {\n        totalResults = entries.length;\n        totalResultsKnown = false;\n      }\n      hasMore = totalResultsKnown ? results.length < totalResults : entries.length >= PAGE_SIZE;\n      if (!preserveScroll && tableContainer) tableContainer.scrollTop = 0;\n\n      const restored = new Set();\n      for (let i = 0; i < results.length; i += 1) {\n        if (keepPaths.has(results[i].path)) {\n          restored.add(i);\n        }\n      }\n      selectedIndices = restored;\n\n      updateViewportHeight();\n    } catch (err) {\n      if (gen !== searchGeneration) return;\n      showToast(`Search failed: ${String(err)}`);\n    }\n  }\n\n  async function loadMore() {\n    if (!hasMore || loadingMore) return;\n    const gen = searchGeneration;\n    loadingMore = true;\n    try {\n      const batch = await invoke('search', {\n        query,\n        limit: PAGE_SIZE,\n        offset: results.length,\n        sortBy: sortBy,\n        sortDir: sortDir\n      });\n      if (gen !== searchGeneration) return;\n      const arr = Array.isArray(batch.entries) ? batch.entries : [];\n      if (arr.length > 0) results = [...results, ...arr];\n      hasMore = totalResultsKnown ? results.length < totalResults : arr.length >= PAGE_SIZE;\n    } catch (err) {\n      showToast(`Failed to load more: ${String(err)}`);\n    } finally {\n      loadingMore = false;\n    }\n  }\n\n  function moveSelection(delta, withRange = false) {\n    if (results.length === 0) {\n      return;\n    }\n\n    const current = lastSelectedIndex >= 0 ? lastSelectedIndex : 0;\n    const next = Math.max(0, Math.min(results.length - 1, current + delta));\n\n    if (withRange) {\n      selectRange(next);\n    } else {\n      selectSingle(next);\n    }\n\n    const top = next * rowHeight;\n    const bottom = top + rowHeight;\n    if (top < scrollTop) {\n      tableContainer.scrollTop = top;\n    } else if (bottom > scrollTop + viewportHeight) {\n      tableContainer.scrollTop = bottom - viewportHeight;\n    }\n  }\n\n  function handleHeaderSort(column) {\n    if (sortBy === column) {\n      sortDir = sortDir === 'asc' ? 'desc' : 'asc';\n    } else {\n      sortBy = column;\n      sortDir = 'asc';\n    }\n    if (tableContainer) tableContainer.scrollTop = 0;\n    void runSearch();\n  }\n\n  function handleRowClick(event, index) {\n    contextMenu.visible = false;\n\n    if (event.shiftKey) {\n      selectRange(index);\n      return;\n    }\n\n    if (event.metaKey || event.ctrlKey) {\n      selectToggle(index);\n      return;\n    }\n\n    selectSingle(index);\n  }\n\n  function handleRowContextMenu(event, index) {\n    event.preventDefault();\n\n    if (!selectedIndices.has(index)) {\n      selectSingle(index);\n    }\n\n    if (platform === 'windows' || platform === 'macos') {\n      contextMenu.visible = false;\n      const paths = selectedPaths();\n      if (paths.length > 0) {\n        invoke('show_context_menu', {\n          paths,\n          x: event.clientX,\n          y: event.clientY,\n          singleSelection: selectedIndices.size === 1\n        });\n      }\n      return;\n    }\n\n    contextMenu = {\n      visible: true,\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n\n  function handleRowA11yKeydown(event, index) {\n    if (event.key === ' ' || event.key === 'Enter') {\n      event.preventDefault();\n      handleRowClick(event, index);\n    }\n  }\n\n  const DRAG_THRESHOLD = 5;\n  let dragCleanup = null;\n  const dragImgCache = new Map();\n\n  function dragPathsForIndex(index) {\n    const entry = results[index];\n    if (!entry) {\n      return [];\n    }\n\n    if (selectedIndices.has(index) && selectedIndices.size > 0) {\n      return selectedPaths();\n    }\n\n    return [entry.path];\n  }\n\n  function getDragIconEl(entry) {\n    const src = iconFor(entry);\n    let img = dragImgCache.get(src);\n    if (!img) {\n      img = new Image();\n      img.src = src;\n      dragImgCache.set(src, img);\n    }\n    return img.complete && img.naturalWidth > 0 ? img : null;\n  }\n\n  function fillRoundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function buildDragPreview(index) {\n    const entry = results[index];\n    if (!entry) return null;\n\n    const count = selectedIndices.has(index) ? selectedIndices.size : 1;\n    const isDark = theme === 'dark';\n\n    const w = 260;\n    const h = 28;\n    const stackGap = count > 1 ? 4 : 0;\n\n    const canvas = document.createElement('canvas');\n    canvas.width = w;\n    canvas.height = h + stackGap;\n    const ctx = canvas.getContext('2d');\n\n    if (count > 1) {\n      ctx.globalAlpha = 0.35;\n      ctx.fillStyle = isDark ? '#5a6070' : '#b0c4de';\n      fillRoundRect(ctx, 3, 0, w - 3, h, 5);\n      ctx.globalAlpha = 1.0;\n    }\n\n    const ry = stackGap;\n    ctx.fillStyle = isDark ? 'rgba(58, 64, 74, 0.94)' : 'rgba(214, 231, 255, 0.94)';\n    fillRoundRect(ctx, 0, ry, w, h, 5);\n\n    ctx.strokeStyle = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';\n    ctx.lineWidth = 0.5;\n    ctx.beginPath();\n    ctx.moveTo(5, ry);\n    ctx.arcTo(w, ry, w, ry + h, 5);\n    ctx.arcTo(w, ry + h, 0, ry + h, 5);\n    ctx.arcTo(0, ry + h, 0, ry, 5);\n    ctx.arcTo(0, ry, w, ry, 5);\n    ctx.closePath();\n    ctx.stroke();\n\n    const iconEl = getDragIconEl(entry);\n    if (iconEl) {\n      ctx.drawImage(iconEl, 6, ry + 6, 16, 16);\n    } else {\n      ctx.fillStyle = entry.isDir ? '#d9b34f' : '#8d98a5';\n      fillRoundRect(ctx, 6, ry + 6, 16, 16, 2);\n    }\n\n    ctx.fillStyle = isDark ? '#e6e6e8' : '#1a1a1a';\n    ctx.font = '12px -apple-system, \"SF Pro Text\", system-ui, sans-serif';\n    ctx.textBaseline = 'middle';\n\n    let nameMaxW = w - 34;\n    if (count > 1) nameMaxW -= 34;\n\n    let name = entry.name;\n    if (ctx.measureText(name).width > nameMaxW) {\n      while (name.length > 4 && ctx.measureText(name + '\\u2026').width > nameMaxW) {\n        name = name.slice(0, -1);\n      }\n      name += '\\u2026';\n    }\n    ctx.fillText(name, 28, ry + h / 2 + 1);\n\n    if (count > 1) {\n      const badge = String(count);\n      ctx.font = 'bold 10px -apple-system, system-ui, sans-serif';\n      const tw = ctx.measureText(badge).width;\n      const bw = Math.max(20, tw + 10);\n      const bx = w - bw - 6;\n      const by = ry + (h - 18) / 2;\n\n      ctx.fillStyle = isDark ? '#5b8bd9' : '#007aff';\n      fillRoundRect(ctx, bx, by, bw, 18, 9);\n\n      ctx.fillStyle = '#ffffff';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(badge, bx + bw / 2, by + 9);\n    }\n\n    return canvas.toDataURL('image/png');\n  }\n\n  function handleRowMouseDown(event, index) {\n    if (event.button !== 0) return;\n    if (event.metaKey || event.ctrlKey || event.shiftKey) return;\n    if (editing.active) return;\n\n    const startX = event.clientX;\n    const startY = event.clientY;\n    let dragging = false;\n\n    dragCleanup?.();\n\n    const onMove = (e) => {\n      if (dragging) return;\n      const dx = e.clientX - startX;\n      const dy = e.clientY - startY;\n      if (dx * dx + dy * dy < DRAG_THRESHOLD * DRAG_THRESHOLD) return;\n\n      dragging = true;\n      cleanup();\n\n      if (!selectedIndices.has(index)) {\n        selectSingle(index);\n      }\n\n      const paths = dragPathsForIndex(index);\n      if (paths.length > 0) {\n        const icon = buildDragPreview(index);\n        startDrag({ item: paths, icon }).catch(() => {});\n      }\n    };\n\n    const onUp = () => cleanup();\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      if (dragCleanup === cleanup) dragCleanup = null;\n    };\n\n    dragCleanup = cleanup;\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  async function handleRowDoubleClick(index) {\n    if (!selectedIndices.has(index) || selectedIndices.size > 1) {\n      selectSingle(index);\n      await tick();\n    }\n    await invoke('open', { paths: [results[index].path] }).catch((err) => {\n      showToast(`Failed to open: ${String(err)}`);\n    });\n  }\n\n  function closeContextMenu() {\n    contextMenu = {\n      ...contextMenu,\n      visible: false\n    };\n  }\n\n  async function openSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('open', { paths });\n    } catch (err) {\n      showToast(`Failed to open: ${String(err)}`);\n    }\n  }\n\n  async function openWithFallback() {\n    const target = primaryEntry();\n    if (!target) {\n      return;\n    }\n\n    try {\n      await invoke('open_with', { path: target.path });\n    } catch (err) {\n      showToast(`Open With failed: ${String(err)}`);\n    }\n  }\n\n  async function revealSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('reveal_in_finder', { paths });\n    } catch (err) {\n      showToast(`Failed to reveal in Finder: ${String(err)}`);\n    }\n  }\n\n  async function copySelectedPaths() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_paths', { paths });\n      showToast(`Copied ${paths.length} path(s)`);\n    } catch (err) {\n      showToast(`Failed to copy path: ${String(err)}`);\n    }\n  }\n\n  async function copyFiles() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_files', { paths });\n      showToast(`Copied ${paths.length} item(s)`);\n    } catch (err) {\n      showToast(`Failed to copy: ${String(err)}`);\n    }\n  }\n\n  async function trashSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    const message =\n      paths.length === 1\n        ? 'Move selected item to Trash?'\n        : `Move ${paths.length} items to Trash?`;\n\n    if (!window.confirm(message)) {\n      return;\n    }\n\n    try {\n      await invoke('move_to_trash', { paths });\n      showToast('Moved to Trash.');\n      clearSelection();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to move to Trash: ${String(err)}`);\n    }\n  }\n\n  async function resetIndex() {\n    if (indexStatus.state === 'Indexing') {\n      showToast('Indexing in progress. Please try again after it completes.');\n      return;\n    }\n\n    results = [];\n    totalResults = 0;\n    totalResultsKnown = false;\n    clearSelection();\n    scanned = 0;\n    dbLatencyMs = null;\n    dbLastQuery = '';\n    indexStatus = { ...indexStatus, state: 'Indexing', entriesCount: 0, message: null };\n    indexingStartTime = Date.now();\n    indexingElapsed = '';\n    indexingFinishedAt = '';\n\n    try {\n      await invoke('reset_index');\n    } catch (err) {\n      showToast(`Failed to reset index: ${String(err)}`);\n      await refreshStatus();\n    }\n  }\n\n  function isMultiSelected() {\n    return selectedIndices.size > 1;\n  }\n\n  function autoResizeRenameInput() {\n    if (!renameInputEl) return;\n    renameInputEl.style.height = '0';\n    renameInputEl.style.height = renameInputEl.scrollHeight + 'px';\n  }\n\n  async function startRename() {\n    if (isMultiSelected()) {\n      return;\n    }\n\n    const idx = lastSelectedIndex;\n    if (idx < 0 || !results[idx]) {\n      return;\n    }\n\n    const entry = results[idx];\n\n    // Calculate overlay position mathematically.\n    // Name cell text starts at: padding-left(16) + icon(16) + gap(6) = 38px from cell left.\n    // Textarea has padding-left: 0 and border: 1.5px, so text starts ~2px from overlay left.\n    if (tableContainer) {\n      const rect = tableContainer.getBoundingClientRect();\n      const cellLeft = rect.left - tableContainer.scrollLeft;\n      const textLeft = cellLeft + 38;\n      const cellRight = cellLeft + colWidths.name;\n      const rowTop = rect.top + idx * rowHeight - tableContainer.scrollTop;\n      renameOverlay = {\n        top: rowTop,\n        left: textLeft - 2,\n        width: cellRight - textLeft + 2 - 4\n      };\n    }\n\n    editing = {\n      active: true,\n      path: entry.path,\n      index: idx,\n      draftName: entry.name\n    };\n\n    await tick();\n\n    if (renameInputEl) {\n      autoResizeRenameInput();\n      renameInputEl.focus();\n      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n      renameInputEl.setSelectionRange(0, selectionEnd);\n    }\n  }\n\n  function cancelRename() {\n    editing = {\n      active: false,\n      path: '',\n      index: -1,\n      draftName: ''\n    };\n  }\n\n  async function commitRename() {\n    if (!editing.active || editing.index < 0 || !results[editing.index]) {\n      return;\n    }\n\n    const current = results[editing.index];\n    const nextName = editing.draftName;\n\n    try {\n      await invoke('rename', {\n        path: current.path,\n        newName: nextName\n      });\n      cancelRename();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to rename: ${String(err)}`);\n      await tick();\n      renameInputEl?.focus();\n    }\n  }\n\n  function onGlobalClick() {\n    closeContextMenu();\n  }\n\n  function onTitleBarMouseDown(event) {\n    if (event.button !== 0) {\n      return;\n    }\n\n    const activeElement = document.activeElement;\n    if (activeElement instanceof HTMLElement && isTextInputTarget(activeElement)) {\n      activeElement.blur();\n    }\n  }\n\n  async function focusSearch() {\n    await getCurrentWindow().show();\n    await getCurrentWindow().setFocus();\n    searchInputEl?.focus();\n    searchInputEl?.select();\n  }\n\n  function isTextInputTarget(target) {\n    return (\n      target instanceof HTMLInputElement ||\n      target instanceof HTMLTextAreaElement ||\n      target?.isContentEditable\n    );\n  }\n\n  async function handleKeydown(event) {\n    const isMetaSelectAll = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'a';\n    const isMetaCopy = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c';\n    const target = event.target;\n    const isTextInput = isTextInputTarget(target);\n\n    if (isMetaCopy && isTextInput) {\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      if (isTextInput) {\n        event.preventDefault();\n        if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n          target.select();\n        }\n        return;\n      }\n    }\n\n    if (editing.active) {\n      if (event.key === 'Enter') {\n        event.preventDefault();\n        await commitRename();\n        return;\n      }\n\n      if (event.key === 'Escape') {\n        event.preventDefault();\n        const idx = editing.index;\n        cancelRename();\n        selectSingle(idx);\n        await tick();\n        tableContainer?.querySelector('.row.selected')?.focus();\n        return;\n      }\n      return;\n    }\n\n    if (event.key === 'Escape') {\n      event.preventDefault();\n      clearSelection();\n      return;\n    }\n\n    if (event.key === 'ArrowDown') {\n      event.preventDefault();\n      moveSelection(1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'ArrowUp') {\n      event.preventDefault();\n      moveSelection(-1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageDown') {\n      event.preventDefault();\n      moveSelection(Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageUp') {\n      event.preventDefault();\n      moveSelection(-Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'Enter') {\n      event.preventDefault();\n      if (platform === 'windows') {\n        await openSelected();\n      } else {\n        await startRename();\n      }\n      return;\n    }\n\n    if (event.key === 'F2') {\n      event.preventDefault();\n      await startRename();\n      return;\n    }\n\n    if (event.key === ' ' && !isTextInput) {\n      event.preventDefault();\n      const entry = primaryEntry();\n      if (entry) {\n        await invoke('quick_look', { path: entry.path });\n      }\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'f') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      searchInputEl?.select();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'o') {\n      event.preventDefault();\n      await openSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {\n      event.preventDefault();\n      await revealSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c') {\n      event.preventDefault();\n      await copySelectedPaths();\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      event.preventDefault();\n      selectedIndices = new Set(Array.from({ length: results.length }, (_, i) => i));\n      return;\n    }\n\n    if (event.key === 'Delete' || ((event.metaKey || event.ctrlKey) && event.key === 'Backspace')) {\n      if (!isTextInput) {\n        event.preventDefault();\n        await trashSelected();\n      }\n      return;\n    }\n  }\n\n  function formatSize(entry) {\n    if (entry.isDir || entry.size == null) return '';\n    const bytes = entry.size;\n    if (bytes < 1024) return `${bytes} B`;\n    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n    return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n  }\n\n  function formatModified(entry) {\n    if (!entry.mtime) {\n      return '';\n    }\n\n    const d = new Date(entry.mtime * 1000);\n    const pad = (n) => String(n).padStart(2, '0');\n    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;\n  }\n\n  function formatLastUpdated(timestamp) {\n    if (!timestamp) {\n      return '-';\n    }\n\n    return new Date(timestamp * 1000).toLocaleString();\n  }\n\n  function formatElapsed(ms) {\n    const totalSec = Math.floor(ms / 1000);\n    const min = Math.floor(totalSec / 60);\n    const sec = totalSec % 60;\n    return min > 0 ? `${min}m ${sec}s` : `${sec}s`;\n  }\n\n  function updateElapsed() {\n    if (indexingStartTime && indexStatus.state === 'Indexing') {\n      indexingElapsed = formatElapsed(Date.now() - indexingStartTime);\n    }\n  }\n\n  function startElapsedTimer() {\n    clearInterval(elapsedTimer);\n    indexingStartTime = Date.now();\n    indexingElapsed = '0s';\n    indexingFinishedAt = '';\n    elapsedTimer = setInterval(updateElapsed, 1000);\n  }\n\n  function stopElapsedTimer() {\n    clearInterval(elapsedTimer);\n    if (indexingStartTime) {\n      const elapsed = Date.now() - indexingStartTime;\n      indexingFinishedAt = `${formatElapsed(elapsed)}`;\n    }\n    indexingStartTime = null;\n    indexingElapsed = '';\n  }\n\n  function displayPath(path) {\n    if (!path) {\n      return path;\n    }\n\n    if (!homePrefix) {\n      return path;\n    }\n\n    if (path === homePrefix) {\n      return '~';\n    }\n\n    if (path.startsWith(`${homePrefix}/`)) {\n      return `~${path.slice(homePrefix.length)}`;\n    }\n\n    return path;\n  }\n\n  let unlistenFns = [];\n\n  onMount(async () => {\n    const t0 = performance.now();\n    const ms = () => Math.round(performance.now() - t0);\n    const DEBUG_STARTUP = false;\n    const flog = DEBUG_STARTUP ? (msg) => invoke('frontend_log', { msg }).catch(() => {}) : () => {};\n\n    flog(`[startup/fe] onMount entered`);\n\n    updateViewportHeight();\n    flog(`[startup/fe] +${ms()}ms updateViewportHeight done`);\n\n    invoke('set_native_theme', { theme });\n\n    platform = await invoke('get_platform');\n    flog(`[startup/fe] +${ms()}ms get_platform done`);\n\n    const unlistenProgress = await listen('index_progress', (event) => {\n      scanned = event.payload.scanned;\n      if (indexStatus.state !== 'Indexing') {\n        indexStatus = {\n          ...indexStatus,\n          state: 'Indexing'\n        };\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_progress) registered`);\n\n    const unlistenState = await listen('index_state', (event) => {\n      flog(`[startup/fe] index_state event received: ${event.payload.state} at +${ms()}ms`);\n      const prevState = indexStatus.state;\n      indexStatus = {\n        ...indexStatus,\n        state: event.payload.state,\n        message: event.payload.message ?? null,\n        isCatchup: event.payload.isCatchup ?? false\n      };\n\n      if (event.payload.state === 'Indexing' && prevState !== 'Indexing') {\n        if (prevState === 'Ready') {\n          lastReadyCount = indexStatus.entriesCount;\n        }\n        startElapsedTimer();\n      } else if (event.payload.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n\n      if (event.payload.state === 'Ready') {\n        scheduleSearch();\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_state) registered`);\n\n    const unlistenUpdated = await listen('index_updated', (event) => {\n      indexStatus = {\n        ...indexStatus,\n        entriesCount: event.payload.entriesCount,\n        lastUpdated: event.payload.lastUpdated,\n        permissionErrors: event.payload.permissionErrors ?? indexStatus.permissionErrors\n      };\n\n      scheduleSearch(true);\n    });\n\n    const unlistenFocus = await listen('focus_search', () => {\n      void focusSearch();\n    });\n\n    const unlistenCtxMenuAction = await listen('context_menu_action', (event) => {\n      switch (event.payload) {\n        case 'open': void openSelected(); break;\n        case 'quick_look': {\n          const e = primaryEntry();\n          if (e) void invoke('quick_look', { path: e.path });\n          break;\n        }\n        case 'open_with': void openWithFallback(); break;\n        case 'reveal': void revealSelected(); break;\n        case 'copy_files': void copyFiles(); break;\n        case 'copy_path': void copySelectedPaths(); break;\n        case 'trash': void trashSelected(); break;\n        case 'rename': void startRename(); break;\n      }\n    });\n\n    unlistenFns = [unlistenProgress, unlistenState, unlistenUpdated, unlistenFocus, unlistenCtxMenuAction];\n    flog(`[startup/fe] +${ms()}ms all listeners registered`);\n\n    // Fetch backend state IMMEDIATELY after listeners are registered.\n    // Events emitted before listener registration are lost, so this\n    // is the only reliable way to get the current state.\n    await refreshStatus();\n    flog(`[startup/fe] +${ms()}ms refreshStatus done (state=${indexStatus.state})`);\n\n    // Show Svelte UI: remove skeleton, focus search input.\n    await tick();\n    document.getElementById('skeleton')?.remove();\n    await focusSearch();\n    flog(`[startup/fe] +${ms()}ms WINDOW VISIBLE â€” skeleton removed`);\n\n    try {\n      homePrefix = await invoke('get_home_dir');\n    } catch {\n      homePrefix = '';\n    }\n    flog(`[startup/fe] +${ms()}ms get_home_dir done`);\n\n    if (!localStorage.getItem('everything-fda-notice-v1')) {\n      showToast('macOS Full Disk Access permission may be required for full disk search.');\n      localStorage.setItem('everything-fda-notice-v1', '1');\n    }\n    flog(`[startup/fe] +${ms()}ms calling runSearch...`);\n    await runSearch();\n    flog(`[startup/fe] +${ms()}ms runSearch done`);\n\n    if (typeof ResizeObserver !== 'undefined') {\n      tableResizeObserver = new ResizeObserver(() => {\n        scheduleViewportHeightUpdate();\n      });\n      if (tableContainer) {\n        tableResizeObserver.observe(tableContainer);\n      } else if (tableAreaEl) {\n        tableResizeObserver.observe(tableAreaEl);\n      }\n    }\n\n    window.addEventListener('resize', scheduleViewportHeightUpdate);\n    window.addEventListener('click', onGlobalClick);\n    statusRefreshTimer = setInterval(() => {\n      if (indexStatus.state === 'Indexing') {\n        void refreshStatus();\n      }\n    }, 1000);\n    console.log(`[startup/fe] +${ms()}ms onMount complete`);\n  });\n\n  onDestroy(async () => {\n    clearTimeout(searchTimer);\n    clearTimeout(toastTimer);\n    clearInterval(statusRefreshTimer);\n    clearInterval(elapsedTimer);\n    resizeCleanup?.();\n\n    for (const unlisten of unlistenFns) {\n      unlisten();\n    }\n\n    tableResizeObserver?.disconnect();\n    tableResizeObserver = null;\n    if (viewportResizeRaf !== null) {\n      cancelAnimationFrame(viewportResizeRaf);\n      viewportResizeRaf = null;\n    }\n    window.removeEventListener('resize', scheduleViewportHeightUpdate);\n    window.removeEventListener('click', onGlobalClick);\n  });\n</script>\n\n<svelte:window on:keydown={handleKeydown} />\n\n<div class=\"app-shell\" data-theme={theme}>\n  <div class=\"title-bar\" role=\"presentation\" data-tauri-drag-region on:mousedown={onTitleBarMouseDown}>\n    <div class=\"title-left\"></div>\n    <div class=\"title-center\">\n      <svg class=\"title-icon\" viewBox=\"0 0 215 205\" fill-rule=\"evenodd\" aria-hidden=\"true\">\n        <path d=\"M85 0c46.9 0 85 38.1 85 85 0 20.1-7.2 38.5-19.2 52.7l40.7 40.8c5.8 5.8 5.8 15.2 0 21-5.8 5.8-15.2 5.8-21 0l-40.7-40.7c-13.6 9.7-30.4 15.2-44.8 15.2-46.9 0-85-42.1-85-89 0-46.9 38.1-85 85-85z m0 32c-29.3 0-53 23.7-53 53 0 29.3 23.7 53 53 53 29.3 0 53-23.7 53-53 0-29.3-23.7-53-53-53z\"/>\n      </svg>\n      <span class=\"title-text\">Everything</span>\n    </div>\n    <div class=\"title-right\"></div>\n  </div>\n\n  <header class=\"search-bar\">\n    <input\n      bind:this={searchInputEl}\n      class=\"search-input\"\n      type=\"text\"\n      bind:value={query}\n      on:input={scheduleSearch}\n      on:focus={clearSelection}\n      placeholder=\"Search file/folder names\"\n      autocomplete=\"off\"\n      spellcheck=\"false\"\n    />\n  </header>\n\n  <section class=\"table-area\" bind:this={tableAreaEl} style={tableGridStyle}>\n    <div class=\"table-header\">\n      <div class=\"table-header-track\">\n        <div class=\"col name\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('name')}>\n            Name{#if sortBy === 'name'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'name'}\n            on:mousedown={(event) => startColumnResize(event, 'name')}\n            aria-label=\"Resize Name column\"\n          />\n        </div>\n\n        <div class=\"col path\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('dir')}>\n            Path{#if sortBy === 'dir'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'path'}\n            on:mousedown={(event) => startColumnResize(event, 'path')}\n            aria-label=\"Resize Path column\"\n          />\n        </div>\n\n        <div class=\"col size\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('size')}>\n            Size{#if sortBy === 'size'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n\n        <div class=\"col modified\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('mtime')}>\n            Modified{#if sortBy === 'mtime'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n      </div>\n    </div>\n\n    <div\n      class=\"table-body\"\n      bind:this={tableContainer}\n      on:scroll={() => {\n        scrollTop = tableContainer.scrollTop;\n        headerScrollLeft = tableContainer.scrollLeft;\n        if (editing.active) void commitRename();\n        const scrollBottom = scrollTop + tableContainer.clientHeight;\n        if (scrollBottom >= totalHeight - rowHeight * 10) {\n          void loadMore();\n        }\n      }}\n    >\n      <div class=\"spacer\" style={`height:${totalHeight}px`}>\n        <div class=\"rows\" style={`transform: translateY(${translateY}px);`}>\n          {#each visibleRows as entry, localIndex}\n            {@const index = startIndex + localIndex}\n            <div\n              class=\"row {selectedIndices.has(index) ? 'selected' : ''}\"\n              on:mousedown={(event) => handleRowMouseDown(event, index)}\n              on:click={(event) => handleRowClick(event, index)}\n              on:keydown={(event) => handleRowA11yKeydown(event, index)}\n              on:dblclick={() => handleRowDoubleClick(index)}\n              on:contextmenu={(event) => handleRowContextMenu(event, index)}\n              role=\"row\"\n              tabindex=\"0\"\n            >\n              <div class=\"cell name\">\n                <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n                <span class=\"ellipsis\" class:name-editing={editing.active && editing.index === index}>{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n              </div>\n              <div class=\"cell path\"><span class=\"ellipsis\">{displayPath(entry.dir)}</span></div>\n              <div class=\"cell size\">{formatSize(entry)}</div>\n              <div class=\"cell modified\">{formatModified(entry)}</div>\n            </div>\n          {/each}\n        </div>\n      </div>\n    </div>\n  </section>\n\n  <footer class=\"status-bar\">\n    <div class=\"status-left\">\n      <span class=\"status-state\">\n        <span class=\"state-dot {indexStatus.state === 'Indexing' ? 'indexing' : indexStatus.state === 'Error' ? 'error' : 'ready'}\"></span>\n        {#if indexStatus.state === 'Indexing'}\n          Indexing{#if lastReadyCount > 0} ({Math.min(99, Math.round((scanned / lastReadyCount) * 100))}%){/if}{#if indexingElapsed} Â· {indexingElapsed}{/if}\n          {#if !indexStatus.isCatchup}\n            Â· {scanned.toLocaleString()} scanned\n          {/if}\n        {:else}\n          Index: {indexStatus.state}\n        {/if}\n      </span>\n      <span>{indexStatus.entriesCount.toLocaleString()} entries</span>\n      {#if indexingFinishedAt && indexStatus.state !== 'Indexing'}\n        <span>in {indexingFinishedAt}</span>\n      {/if}\n      {#if dbLatencyMs !== null && dbLastQuery}\n        <span>\"{dbLastQuery}\" {dbLatencyMs}ms Â· {totalResults} results</span>\n      {/if}\n      {#if searchModeLabel === 'spotlight' || searchModeLabel === 'spotlight_timeout'}\n        <span class=\"status-spotlight\">Spotlight fallback{#if searchModeLabel === 'spotlight_timeout'} (partial){/if}</span>\n      {/if}\n      {#if indexStatus.permissionErrors > 0}\n        <span class=\"status-warning\">{indexStatus.permissionErrors.toLocaleString()} permission errors</span>\n      {/if}\n      {#if indexStatus.message}\n        <span class={indexStatus.isCatchup ? 'index-progress' : 'status-error'}>{indexStatus.message}</span>\n      {/if}\n    </div>\n    <div class=\"status-right\">\n      <button class=\"status-btn\" on:click={cycleTheme} title=\"Switch theme\">\n        {theme === 'dark' ? 'â˜€ Light' : 'â—‘ Dark'}\n      </button>\n      <button\n        class=\"status-btn rebuild-btn\"\n        on:click={resetIndex}\n        disabled={indexStatus.state === 'Indexing'}\n        title={indexStatus.state === 'Indexing' ? 'Cannot reset while indexing is in progress.' : 'Reset and rebuild the index.'}\n      >\n        <svg class=\"rebuild-icon\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n          <path d=\"M23 4v6h-6\"/><path d=\"M20.49 15a9 9 0 1 1-2.12-9.36L23 10\"/>\n        </svg>\n        Rebuild Index\n      </button>\n    </div>\n  </footer>\n\n  {#if editing.active}\n    <div\n      class=\"rename-overlay\"\n      style=\"top:{renameOverlay.top}px; left:{renameOverlay.left}px; width:{renameOverlay.width}px;\"\n      role=\"presentation\"\n      on:mousedown|stopPropagation\n    >\n      <textarea\n        bind:this={renameInputEl}\n        class=\"rename-textarea\"\n        bind:value={editing.draftName}\n        on:input={autoResizeRenameInput}\n        on:click|stopPropagation\n        on:blur={commitRename}\n      />\n    </div>\n  {/if}\n\n  {#if contextMenu.visible}\n    <div class=\"context-menu\" style={`left:${contextMenu.x}px;top:${contextMenu.y}px;`}>\n      <button on:click={() => (closeContextMenu(), openSelected())}>Open</button>\n      <button on:click={async () => { closeContextMenu(); const e = primaryEntry(); if (e) await invoke('quick_look', { path: e.path }); }}>Quick Look</button>\n      <button on:click={() => (closeContextMenu(), openWithFallback())}>Open With... (Reveal in Finder)</button>\n      <button on:click={() => (closeContextMenu(), revealSelected())}>Reveal in Finder</button>\n      <button on:click={() => (closeContextMenu(), copySelectedPaths())}>Copy Path</button>\n      <button on:click={() => (closeContextMenu(), trashSelected())}>Move to Trash</button>\n      {#if selectedIndices.size === 1}\n        <button on:click={() => (closeContextMenu(), startRename())}>Rename</button>\n      {/if}\n    </div>\n  {/if}\n\n  {#if toast}\n    <div class=\"toast\">{toast}</div>\n  {/if}\n</div>\n\n<style>\n  :global(:root) {\n    color-scheme: light dark;\n    --bg-app: transparent;\n    --text-primary: #0d1826;\n    --text-muted: #48596c;\n    --bar-grad-top: rgba(255, 255, 255, 0.48);\n    --bar-grad-bottom: rgba(248, 250, 253, 0.42);\n    --surface-header: rgba(252, 252, 255, 0.40);\n    --surface: rgba(255, 255, 255, 0.22);\n    --border-soft: rgba(0, 0, 0, 0.07);\n    --border-input: rgba(0, 0, 0, 0.13);\n    --focus-ring: #6f96e6;\n    --row-border: rgba(0, 0, 0, 0.032);\n    --row-hover: rgba(0, 0, 0, 0.06);\n    --row-selected: rgba(0, 0, 0, 0.12);\n    --button-bg: rgba(255, 255, 255, 0.62);\n    --button-border: rgba(0, 0, 0, 0.10);\n    --button-text: #2c3e50;\n    --menu-bg: rgba(240, 241, 248, 0.90);\n    --menu-border: rgba(0, 0, 0, 0.06);\n    --menu-hover: rgba(255, 255, 255, 0.62);\n    --menu-text: #1a2a38;\n    --error-text: #b64545;\n    --warning-text: #8f6500;\n    --toast-bg: rgba(18, 22, 32, 0.90);\n    --toast-text: #ffffff;\n  }\n\n  @media (prefers-color-scheme: dark) {\n    :global(:root) {\n      --bg-app: transparent;\n      --text-primary: #e6e6ea;\n      --text-muted: #9494a4;\n      --bar-grad-top: rgba(38, 38, 46, 0.52);\n      --bar-grad-bottom: rgba(30, 30, 38, 0.46);\n      --surface-header: rgba(32, 32, 40, 0.46);\n      --surface: rgba(18, 18, 26, 0.32);\n      --border-soft: rgba(255, 255, 255, 0.065);\n      --border-input: rgba(255, 255, 255, 0.14);\n      --focus-ring: #5b8bd9;\n      --row-border: rgba(255, 255, 255, 0.026);\n      --row-hover: rgba(255, 255, 255, 0.08);\n      --row-selected: rgba(255, 255, 255, 0.14);\n      --button-bg: rgba(255, 255, 255, 0.072);\n      --button-border: rgba(255, 255, 255, 0.11);\n      --button-text: #d6d6e0;\n      --menu-bg: rgba(36, 36, 46, 0.90);\n      --menu-border: rgba(255, 255, 255, 0.066);\n      --menu-hover: rgba(255, 255, 255, 0.062);\n      --menu-text: #e0e0e8;\n      --error-text: #ff9d9d;\n      --warning-text: #e0c670;\n      --toast-bg: rgba(10, 10, 16, 0.93);\n      --toast-text: #f2f2f6;\n    }\n  }\n\n  /* â”€â”€ Theme: Dark â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme=\"dark\"]) {\n    color-scheme: dark;\n    --bg-app: #1E1E21;\n    --text-primary: #E2E8F0;\n    --text-muted: #94A3B8;\n    --bar-grad-top: #1E1E21;\n    --bar-grad-bottom: #1E1E21;\n    --surface-header: #1E1E21;\n    --surface: #1E1E21;\n    --bg-input: #161618;\n    --border-soft: #2A2A2D;\n    --border-input: rgba(255, 255, 255, 0.06);\n    --focus-ring: #4DA8FF;\n    --accent: #4DA8FF;\n    --row-border: rgba(255, 255, 255, 0.02);\n    --row-hover: #282828;\n    --row-selected: rgba(77, 168, 255, 0.10);\n    --button-bg: rgba(255, 255, 255, 0.05);\n    --button-border: #2A2A2D;\n    --button-text: #94A3B8;\n    --menu-bg: #252528;\n    --menu-border: #2A2A2D;\n    --menu-hover: rgba(255, 255, 255, 0.04);\n    --menu-text: #E2E8F0;\n    --error-text: #ff9d9d;\n    --warning-text: #e0c670;\n    --toast-bg: rgba(10, 10, 16, 0.93);\n    --toast-text: #f2f2f6;\n  }\n\n  /* â”€â”€ Theme: Light â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme=\"light\"]) {\n    color-scheme: light;\n    --bg-app: #F5F5F7;\n    --text-primary: #1C1C1E;\n    --text-muted: #6E6E7A;\n    --bar-grad-top: #F5F5F7;\n    --bar-grad-bottom: #F5F5F7;\n    --surface-header: #F5F5F7;\n    --surface: #F5F5F7;\n    --bg-input: #FFFFFF;\n    --border-soft: #D1D1D6;\n    --border-input: rgba(0, 0, 0, 0.10);\n    --focus-ring: #3A8BF5;\n    --accent: #3A8BF5;\n    --row-border: rgba(0, 0, 0, 0.04);\n    --row-hover: rgba(0, 0, 0, 0.04);\n    --row-selected: rgba(58, 139, 245, 0.10);\n    --button-bg: #FFFFFF;\n    --button-border: #D1D1D6;\n    --button-text: #3C3C43;\n    --menu-bg: #FFFFFF;\n    --menu-border: #D1D1D6;\n    --menu-hover: rgba(0, 0, 0, 0.05);\n    --menu-text: #1C1C1E;\n    --error-text: #D93025;\n    --warning-text: #B45309;\n    --toast-bg: rgba(255, 255, 255, 0.95);\n    --toast-text: #1C1C1E;\n  }\n\n  /* â”€â”€ Themed element overrides â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme]) {\n    background: var(--bg-app);\n  }\n\n  /* Search bar: flat, no gradient, no separator */\n  :global([data-theme]) .search-bar {\n    height: 44px;\n    padding: 0 16px;\n    background: var(--bg-app);\n    border-bottom: none;\n  }\n\n  :global([data-theme]) .search-input {\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n    font-family: 'JetBrains Mono', 'SF Mono', monospace;\n    font-size: 12px;\n    height: 34px;\n    border-radius: 8px;\n  }\n\n  /* Table header: flat bg, 16px edge padding */\n  :global([data-theme]) .table-header {\n    background: var(--bg-app);\n  }\n\n  :global([data-theme]) .col-button {\n    padding: 0 8px;\n  }\n\n  :global([data-theme]) .col.name .col-button {\n    padding-left: 16px;\n  }\n\n  /* Row cells: JetBrains Mono, 16px outer edges */\n  :global([data-theme]) .cell {\n    font-family: 'JetBrains Mono', monospace;\n  }\n\n  :global([data-theme]) .cell.name {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    padding-left: 16px;\n    font-size: 12px;\n    color: var(--text-primary);\n  }\n\n  :global([data-theme]) .cell.path {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.size {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.modified {\n    padding-right: 16px;\n    font-size: 11px;\n    white-space: nowrap;\n  }\n\n  :global([data-theme]) .row.selected {\n    box-shadow: inset 3px 0 0 var(--accent);\n  }\n\n  /* Dim path/size/date cells in themed mode */\n  :global([data-theme]) .cell.path,\n  :global([data-theme]) .cell.size,\n  :global([data-theme]) .cell.modified {\n    color: var(--text-muted);\n  }\n\n  :global(:root) {\n    background: transparent;\n  }\n\n  :global(html, body) {\n    margin: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    background: transparent;\n    color: var(--text-primary);\n    font-family: Inter, 'SF Pro Text', 'Segoe UI', Helvetica, Arial, sans-serif;\n  }\n\n  :global(#app) {\n    width: 100%;\n    height: 100%;\n  }\n\n  .app-shell {\n    display: grid;\n    grid-template-rows: auto auto 1fr auto;\n    height: 100%;\n    min-width: 0;\n  }\n\n  .title-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 44px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    cursor: default;\n    flex-shrink: 0;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-left {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-center {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-right {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-icon {\n    width: 14px;\n    height: 14px;\n    fill: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .title-text {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 13px;\n    font-weight: 500;\n    color: var(--text-primary);\n    letter-spacing: -0.01em;\n  }\n\n  .search-bar {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding: 8px;\n    background: linear-gradient(180deg, var(--bar-grad-top) 0%, var(--bar-grad-bottom) 100%);\n    border-bottom: 1px solid var(--border-soft);\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .search-input {\n    display: block;\n    box-sizing: border-box;\n    width: 100%;\n    min-width: 0;\n    flex: 1 1 auto;\n    height: 36px;\n    border: 1px solid var(--border-input);\n    border-radius: 14px;\n    padding: 0 10px;\n    font-size: 14px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    backdrop-filter: blur(12px) saturate(160%);\n    -webkit-backdrop-filter: blur(12px) saturate(160%);\n  }\n\n  .search-input::placeholder {\n    color: var(--text-muted);\n    opacity: 0.85;\n    font-size: 12px;\n  }\n\n  .search-input:focus {\n    outline: none;\n    border-color: var(--focus-ring);\n    box-shadow: 0 0 0 2px rgba(125, 169, 255, 0.25);\n  }\n\n  .table-area {\n    display: grid;\n    grid-template-rows: auto 1fr;\n    min-height: 0;\n    min-width: 0;\n  }\n\n  .table-header-track,\n  .row {\n    display: grid;\n    grid-template-columns: var(--col-name) var(--col-path) var(--col-size) var(--col-modified);\n    align-items: center;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .table-header {\n    height: 32px;\n    border-bottom: 1px solid var(--border-soft);\n    background: var(--surface-header);\n    user-select: none;\n    overflow: hidden;\n    flex-shrink: 0;\n  }\n\n  .table-header-track {\n    height: 100%;\n    transform: translateX(var(--header-offset, 0px));\n    will-change: transform;\n  }\n\n  .table-header .col {\n    position: relative;\n    min-width: 0;\n    height: 100%;\n  }\n\n  .col-button {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n    gap: 4px;\n    box-sizing: border-box;\n    padding: 0 8px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 11px;\n    font-weight: 600;\n    line-height: 1;\n    color: var(--text-muted);\n    text-align: left;\n    margin: 0;\n    border: none;\n    background: transparent;\n    cursor: pointer;\n  }\n\n  .sort-icon {\n    width: 10px;\n    height: 10px;\n    flex-shrink: 0;\n    color: var(--accent);\n  }\n\n  .col-resizer {\n    position: absolute;\n    top: 0;\n    right: -4px;\n    width: 8px;\n    height: 100%;\n    border: none;\n    padding: 0;\n    background: transparent;\n    cursor: col-resize;\n    z-index: 30;\n  }\n\n  .col-resizer::after {\n    content: '';\n    position: absolute;\n    top: 7px;\n    bottom: 7px;\n    left: 50%;\n    width: 1px;\n    transform: translateX(-50%);\n    background: var(--border-soft);\n    opacity: 0;\n    transition: opacity 0.15s ease;\n  }\n\n  .table-header .col:hover .col-resizer::after,\n  .col-resizer.active::after {\n    opacity: 1;\n  }\n\n  .table-body {\n    overflow: auto;\n    min-height: 0;\n    min-width: 0;\n    background: var(--surface);\n  }\n\n  .spacer {\n    position: relative;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .rows {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .row {\n    height: 30px;\n    border-bottom: 1px solid var(--row-border);\n    cursor: default;\n    -webkit-user-select: none;\n    user-select: none;\n    outline: none;\n  }\n\n  .row:hover {\n    background: var(--row-hover);\n  }\n\n  .row.selected {\n    background: var(--row-selected);\n  }\n\n  .cell {\n    padding: 0 8px;\n    font-size: 12px;\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    min-width: 0;\n  }\n\n  .cell.size {\n    text-align: right;\n    font-variant-numeric: tabular-nums;\n  }\n\n  .ellipsis {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n\n  .hl {\n    background: none;\n    color: inherit;\n    font-weight: 700;\n  }\n\n  .file-icon {\n    width: 16px;\n    height: 16px;\n    flex: 0 0 auto;\n  }\n\n  .name-editing {\n    opacity: 0.25;\n  }\n\n  .rename-overlay {\n    position: fixed;\n    z-index: 100;\n    min-width: 120px;\n  }\n\n  .rename-textarea {\n    display: block;\n    width: 100%;\n    box-sizing: border-box;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 12px;\n    line-height: 18px;\n    padding: 5px 4px 5px 0;\n    border: 1.5px solid var(--focus-ring);\n    border-radius: 4px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    outline: none;\n    resize: none;\n    overflow: hidden;\n    box-shadow: 0 2px 14px rgba(0, 0, 0, 0.22), 0 0 0 3px rgba(77, 168, 255, 0.13);\n  }\n\n  .status-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 32px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    border-top: 1px solid var(--border-soft);\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 11px;\n    color: var(--text-muted);\n    white-space: nowrap;\n    overflow: hidden;\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .status-left {\n    display: flex;\n    align-items: center;\n    gap: 16px;\n    overflow: hidden;\n    min-width: 0;\n  }\n\n  .status-right {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    flex-shrink: 0;\n  }\n\n  .status-btn {\n    border: 1px solid var(--button-border);\n    border-radius: 5px;\n    background: var(--button-bg);\n    color: var(--button-text);\n    font-size: 11px;\n    height: 22px;\n    padding: 0 8px;\n    cursor: pointer;\n  }\n\n  .status-btn:hover {\n    filter: brightness(1.06);\n  }\n\n  .status-btn:disabled {\n    opacity: 0.55;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .status-state {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n  }\n\n  .state-dot {\n    width: 6px;\n    height: 6px;\n    border-radius: 50%;\n    flex-shrink: 0;\n  }\n\n  .state-dot.ready { background: #28C840; }\n  .state-dot.indexing { background: #FEBC2E; }\n  .state-dot.error { background: #FF5F57; }\n\n  .rebuild-btn {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 10px;\n    font-weight: 500;\n    background: var(--button-bg);\n    border: 1px solid var(--button-border);\n    border-radius: 4px;\n    color: var(--button-text);\n    height: 22px;\n    padding: 0 10px;\n    cursor: pointer;\n  }\n\n  .rebuild-btn:hover {\n    filter: brightness(1.1);\n  }\n\n  .rebuild-btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .rebuild-icon {\n    width: 11px;\n    height: 11px;\n    color: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .status-error {\n    color: var(--error-text);\n  }\n\n  .status-warning {\n    color: var(--warning-text);\n  }\n\n  .status-spotlight {\n    color: #f59e0b;\n    font-weight: 600;\n  }\n\n  .context-menu {\n    position: fixed;\n    z-index: 200;\n    width: 220px;\n    border: 1px solid var(--menu-border);\n    border-radius: 10px;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.16), inset 0 0 0 0.5px rgba(255, 255, 255, 0.18);\n    background: var(--menu-bg);\n    backdrop-filter: blur(28px) saturate(180%);\n    -webkit-backdrop-filter: blur(28px) saturate(180%);\n    overflow: hidden;\n  }\n\n  .context-menu button {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    padding: 8px 10px;\n    font-size: 12px;\n    color: var(--menu-text);\n  }\n\n  .context-menu button:hover {\n    background: var(--menu-hover);\n  }\n\n  .toast {\n    position: fixed;\n    right: 14px;\n    bottom: 18px;\n    background: var(--toast-bg);\n    color: var(--toast-text);\n    border-radius: 10px;\n    padding: 9px 12px;\n    font-size: 12px;\n    z-index: 250;\n    backdrop-filter: blur(20px) saturate(180%);\n    -webkit-backdrop-filter: blur(20px) saturate(180%);\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);\n  }\n</style>\n","structuredPatch":[{"oldStart":31,"oldLines":6,"newStart":31,"newLines":11,"lines":["     invoke('set_native_theme', { theme });","   }"," ","+  function sortIconHtml(dir) {","+    const d = dir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5';","+    return `<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"${d}\"/></svg>`;","+  }","+","   let query = '';","   let results = [];","   let totalResults = 0;"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"d824e066-f0fb-4f09-8e84-239fdaca9b3c"}
{"parentUuid":"924f6ed6-b88d-4f62-abb0-cc7e4d782cb4","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01EW74dmGkjxgkgbGG4LMUK4","type":"message","role":"assistant","content":[{"type":"text","text":"ì´ì œ í…œí”Œë¦¿ì˜ 4ê°œ sort icon SVGë¥¼ `{@html}` í˜¸ì¶œë¡œ êµì²´í•©ë‹ˆë‹¤."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":568,"cache_read_input_tokens":98202,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":568},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPQ5HaiJ4HuaLAvcF8e","type":"assistant","uuid":"15e8a2ab-7b7e-4fb0-a822-aa3428c57335","timestamp":"2026-02-21T14:39:50.831Z"}
{"parentUuid":"15e8a2ab-7b7e-4fb0-a822-aa3428c57335","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01EW74dmGkjxgkgbGG4LMUK4","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SZEumr9fKdyYDJt1ARZ3NR","name":"Read","input":{"file_path":"/Users/al02402336/everything/src/App.svelte","offset":1455,"limit":40},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":568,"cache_read_input_tokens":98202,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":568},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPQ5HaiJ4HuaLAvcF8e","type":"assistant","uuid":"08a8b385-c8e6-41fc-bfd9-315bd197d9c6","timestamp":"2026-02-21T14:39:51.336Z"}
{"parentUuid":"08a8b385-c8e6-41fc-bfd9-315bd197d9c6","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01SZEumr9fKdyYDJt1ARZ3NR","toolUseID":"toolu_01SZEumr9fKdyYDJt1ARZ3NR","timestamp":"2026-02-21T14:39:51.365Z","uuid":"111a29ca-0b07-4a2c-852e-cdae5dfc39e4"}
{"parentUuid":"08a8b385-c8e6-41fc-bfd9-315bd197d9c6","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SZEumr9fKdyYDJt1ARZ3NR","type":"tool_result","content":"  1455â†’  <section class=\"table-area\" bind:this={tableAreaEl} style={tableGridStyle}>\n  1456â†’    <div class=\"table-header\">\n  1457â†’      <div class=\"table-header-track\">\n  1458â†’        <div class=\"col name\">\n  1459â†’          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('name')}>\n  1460â†’            Name{#if sortBy === 'name'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n  1461â†’          </button>\n  1462â†’          <button\n  1463â†’            type=\"button\"\n  1464â†’            class=\"col-resizer\"\n  1465â†’            class:active={resizingColumn === 'name'}\n  1466â†’            on:mousedown={(event) => startColumnResize(event, 'name')}\n  1467â†’            aria-label=\"Resize Name column\"\n  1468â†’          />\n  1469â†’        </div>\n  1470â†’\n  1471â†’        <div class=\"col path\">\n  1472â†’          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('dir')}>\n  1473â†’            Path{#if sortBy === 'dir'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n  1474â†’          </button>\n  1475â†’          <button\n  1476â†’            type=\"button\"\n  1477â†’            class=\"col-resizer\"\n  1478â†’            class:active={resizingColumn === 'path'}\n  1479â†’            on:mousedown={(event) => startColumnResize(event, 'path')}\n  1480â†’            aria-label=\"Resize Path column\"\n  1481â†’          />\n  1482â†’        </div>\n  1483â†’\n  1484â†’        <div class=\"col size\">\n  1485â†’          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('size')}>\n  1486â†’            Size{#if sortBy === 'size'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n  1487â†’          </button>\n  1488â†’        </div>\n  1489â†’\n  1490â†’        <div class=\"col modified\">\n  1491â†’          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('mtime')}>\n  1492â†’            Modified{#if sortBy === 'mtime'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n  1493â†’          </button>\n  1494â†’        </div>\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"7e72f974-4ae8-4b72-a2c4-02a55e545ceb","timestamp":"2026-02-21T14:39:51.363Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src/App.svelte","content":"  <section class=\"table-area\" bind:this={tableAreaEl} style={tableGridStyle}>\n    <div class=\"table-header\">\n      <div class=\"table-header-track\">\n        <div class=\"col name\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('name')}>\n            Name{#if sortBy === 'name'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'name'}\n            on:mousedown={(event) => startColumnResize(event, 'name')}\n            aria-label=\"Resize Name column\"\n          />\n        </div>\n\n        <div class=\"col path\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('dir')}>\n            Path{#if sortBy === 'dir'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'path'}\n            on:mousedown={(event) => startColumnResize(event, 'path')}\n            aria-label=\"Resize Path column\"\n          />\n        </div>\n\n        <div class=\"col size\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('size')}>\n            Size{#if sortBy === 'size'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n\n        <div class=\"col modified\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('mtime')}>\n            Modified{#if sortBy === 'mtime'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>","numLines":40,"startLine":1455,"totalLines":2282}},"sourceToolAssistantUUID":"08a8b385-c8e6-41fc-bfd9-315bd197d9c6"}
{"parentUuid":"7e72f974-4ae8-4b72-a2c4-02a55e545ceb","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01NPYsULnAda7vpGEEVAGjhy","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BacV41sSnBPJAXtz7JN3Li","name":"Edit","input":{"replace_all":false,"file_path":"/Users/al02402336/everything/src/App.svelte","old_string":"            Name{#if sortBy === 'name'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}","new_string":"            Name{#if sortBy === 'name'}{@html sortIconHtml(sortDir)}{/if}"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1435,"cache_read_input_tokens":98770,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1435},"output_tokens":18,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPQLnVDZCzGuW7t68jL","type":"assistant","uuid":"35e77e68-fd1f-4210-aa25-bd25781f9ebc","timestamp":"2026-02-21T14:39:55.518Z"}
{"parentUuid":"35e77e68-fd1f-4210-aa25-bd25781f9ebc","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01BacV41sSnBPJAXtz7JN3Li","toolUseID":"toolu_01BacV41sSnBPJAXtz7JN3Li","timestamp":"2026-02-21T14:39:55.524Z","uuid":"fe2c38b4-9152-4e3c-83c6-32180de85a45"}
{"parentUuid":"35e77e68-fd1f-4210-aa25-bd25781f9ebc","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BacV41sSnBPJAXtz7JN3Li","type":"tool_result","content":"The file /Users/al02402336/everything/src/App.svelte has been updated successfully."}]},"uuid":"91a3ab9a-2bb1-423d-af4f-00cf07186447","timestamp":"2026-02-21T14:39:55.524Z","toolUseResult":{"filePath":"/Users/al02402336/everything/src/App.svelte","oldString":"            Name{#if sortBy === 'name'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}","newString":"            Name{#if sortBy === 'name'}{@html sortIconHtml(sortDir)}{/if}","originalFile":"<script>\n  import { onDestroy, onMount, tick } from 'svelte';\n  import { invoke } from '@tauri-apps/api/core';\n  import { listen } from '@tauri-apps/api/event';\n  import { getCurrentWindow } from '@tauri-apps/api/window';\n  import { startDrag } from '@crabnebula/tauri-plugin-drag';\n\n  const rowHeight = 30;\n  const PAGE_SIZE = 500;\n  let homePrefix = '';\n  const COL_WIDTHS_KEY = 'REDACTED';\n  const THEME_KEY = 'everything-theme';\n  const columnKeys = ['name', 'path', 'size', 'modified'];\n  const minColumnWidth = {\n    name: 180,\n    path: 240,\n    size: 75,\n    modified: 150\n  };\n  const defaultColumnRatios = {\n    name: 0.3,\n    path: 0.45,\n    size: 0.1\n  };\n\n  const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';\n  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || systemTheme; } catch { return systemTheme; } })();\n  function cycleTheme() {\n    theme = theme === 'dark' ? 'light' : 'dark';\n    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n    invoke('set_native_theme', { theme });\n  }\n\n  function sortIconHtml(dir) {\n    const d = dir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5';\n    return `<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"${d}\"/></svg>`;\n  }\n\n  let query = '';\n  let results = [];\n  let totalResults = 0;\n  let totalResultsKnown = false;\n\n  let dbLatencyMs = null;\n  let dbLastQuery = '';\n  let searchModeLabel = '';\n  let selectedIndices = new Set();\n  let selectionAnchor = -1;\n  let lastSelectedIndex = -1;\n  let editing = {\n    active: false,\n    path: '',\n    index: -1,\n    draftName: ''\n  };\n\n  let renameOverlay = { top: 0, left: 0, width: 0 };\n\n  let indexStatus = {\n    state: 'Indexing',\n    entriesCount: 0,\n    lastUpdated: null,\n    permissionErrors: 0,\n    message: null,\n    isCatchup: false\n  };\n\n  let indexingStartTime = null;\n  let indexingElapsed = '';\n  let indexingFinishedAt = '';\n\n  let sortBy = 'name';\n  let sortDir = 'asc';\n\n  let hasMore = true;\n  let loadingMore = false;\n  let searchGeneration = 0;\n\n  let scanned = 0;\n\n  let searchInputEl;\n  let renameInputEl;\n  let tableAreaEl;\n  let tableContainer;\n  let tableResizeObserver = null;\n  let viewportResizeRaf = null;\n  let scrollTop = 0;\n  let headerScrollLeft = 0;\n  let viewportHeight = 520;\n  let lastTableWidth = 0;\n  let resizingColumn = '';\n  let resizeCleanup = null;\n  let colWidths = {\n    name: 250,\n    path: 350,\n    size: 75,\n    modified: 150\n  };\n\n  let contextMenu = {\n    visible: false,\n    x: 0,\n    y: 0\n  };\n\n  let platform = '';\n  let toast = '';\n  let searchTimer;\n  let lastSearchFiredAt = 0;\n  let toastTimer;\n  let statusRefreshTimer;\n  let elapsedTimer;\n  let statusRefreshInFlight = false;\n  let lastReadyCount = 0;\n\n  const iconCache = new Map();\n  const iconLoading = new Set();\n\n  let highlightCache = new Map();\n  let highlightCacheQuery = '';\n\n  const folderFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='1' y='4' width='14' height='10' rx='2' fill='#d9b34f'/><rect x='1' y='2' width='6' height='4' rx='1' fill='#e6ca7a'/></svg>`\n    );\n  const fileFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='3' y='1' width='10' height='14' rx='1.5' fill='#b4bec9'/><rect x='5' y='5' width='6' height='1.2' fill='#8d98a5'/><rect x='5' y='8' width='6' height='1.2' fill='#8d98a5'/></svg>`\n    );\n\n  $: totalHeight = results.length * rowHeight;\n  $: startIndex = Math.max(0, Math.floor(scrollTop / rowHeight) - 10);\n  $: visibleCount = Math.ceil(viewportHeight / rowHeight) + 20;\n  $: endIndex = Math.min(results.length, startIndex + visibleCount);\n  $: visibleRows = results.slice(startIndex, endIndex);\n  $: translateY = startIndex * rowHeight;\n  $: tableMinWidth = colWidths.name + colWidths.path + colWidths.size + colWidths.modified;\n  $: tableGridStyle = `--col-name:${colWidths.name}px;--col-path:${colWidths.path}px;--col-size:${colWidths.size}px;--col-modified:${colWidths.modified}px;--table-min-width:${tableMinWidth}px;--header-offset:${-headerScrollLeft}px;`;\n\n  $: {\n    for (const entry of visibleRows) {\n      void ensureIcon(entry);\n    }\n  }\n\n  function showToast(message) {\n    toast = message;\n    clearTimeout(toastTimer);\n    toastTimer = setTimeout(() => {\n      toast = '';\n    }, 3000);\n  }\n\n  function bytesToBase64(bytes) {\n    let binary = '';\n    const chunk = 0x8000;\n    for (let i = 0; i < bytes.length; i += chunk) {\n      const part = bytes.subarray(i, i + chunk);\n      binary += String.fromCharCode(...part);\n    }\n    return btoa(binary);\n  }\n\n  function highlightSegments(name, q) {\n    q = (q || '').trim();\n    if (!q) return [{ text: name, hl: false }];\n\n    // Reset cache when query changes\n    if (q !== highlightCacheQuery) {\n      highlightCache = new Map();\n      highlightCacheQuery = q;\n    }\n\n    // Check cache\n    const cached = highlightCache.get(name);\n    if (cached) return cached;\n\n    if (q.includes('/')) q = q.slice(q.lastIndexOf('/') + 1);\n    q = q.replace(/[*?]/g, '');\n    const terms = q.split(/\\s+/).filter(Boolean);\n    if (terms.length === 0) return [{ text: name, hl: false }];\n\n    const lower = name.toLowerCase();\n    const marks = new Uint8Array(name.length);\n    for (const t of terms) {\n      const tl = t.toLowerCase();\n      let idx = lower.indexOf(tl);\n      while (idx !== -1) {\n        for (let i = idx; i < idx + tl.length; i++) marks[i] = 1;\n        idx = lower.indexOf(tl, idx + 1);\n      }\n    }\n\n    const segs = [];\n    let i = 0;\n    while (i < name.length) {\n      const m = marks[i];\n      let j = i + 1;\n      while (j < name.length && marks[j] === m) j++;\n      segs.push({ text: name.slice(i, j), hl: m === 1 });\n      i = j;\n    }\n\n    highlightCache.set(name, segs);\n    return segs;\n  }\n\n  const perFileIconExts = new Set(['exe', 'lnk', 'ico', 'url', 'scr', 'appx']);\n\n  function iconKey(entry) {\n    if (entry.isDir) return '__folder__';\n    const ext = (entry.ext || '').toLowerCase();\n    if (perFileIconExts.has(ext)) return entry.path;\n    return ext || '__file__';\n  }\n\n  function iconFor(entry) {\n    return iconCache.get(iconKey(entry)) || (entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n  }\n\n  async function ensureIcon(entry) {\n    const key = iconKey(entry);\n    if (iconCache.has(key) || iconLoading.has(key)) {\n      return;\n    }\n\n    iconLoading.add(key);\n    try {\n      const bytes = await invoke('get_file_icon', {\n        path: entry.path,\n        ext: entry.isDir ? 'folder' : entry.ext || '',\n      });\n      if (Array.isArray(bytes) && bytes.length > 0) {\n        const image = `data:image/png;base64,${bytesToBase64(Uint8Array.from(bytes))}`;\n        iconCache.set(key, image);\n      } else {\n        iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n      }\n    } catch {\n      iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n    } finally {\n      iconLoading.delete(key);\n    }\n  }\n\n  function syncColumnWidthsToContainer() {\n    const width = tableContainer?.clientWidth || tableAreaEl?.clientWidth;\n    if (!width || lastTableWidth !== 0) {\n      return;\n    }\n\n    const saved = loadColWidths();\n    if (saved) {\n      const total = columnKeys.reduce((s, k) => s + saved[k], 0);\n      if (Math.abs(total - width) > 2) {\n        const scale = (width - saved.modified) / (total - saved.modified);\n        let scaledName = Math.max(minColumnWidth.name, Math.round(saved.name * scale));\n        let scaledSize = Math.max(minColumnWidth.size, Math.round(saved.size * scale));\n        let rawPath = width - saved.modified - scaledName - scaledSize;\n        if (rawPath < minColumnWidth.path) {\n          const shortfall = minColumnWidth.path - rawPath;\n          const nameReduction = Math.min(shortfall, scaledName - minColumnWidth.name);\n          scaledName -= nameReduction;\n          const remaining = shortfall - nameReduction;\n          if (remaining > 0) {\n            scaledSize -= Math.min(remaining, scaledSize - minColumnWidth.size);\n          }\n          rawPath = width - saved.modified - scaledName - scaledSize;\n        }\n        const scaledPath = Math.max(minColumnWidth.path, rawPath);\n        colWidths = { name: scaledName, path: scaledPath, size: scaledSize, modified: saved.modified };\n      } else {\n        colWidths = saved;\n      }\n    } else {\n      const fixedModified = minColumnWidth.modified;\n      const rest = width - fixedModified;\n      const ratioSum = defaultColumnRatios.name + defaultColumnRatios.path + defaultColumnRatios.size;\n      colWidths = {\n        name: Math.max(minColumnWidth.name, Math.round(rest * defaultColumnRatios.name / ratioSum)),\n        path: Math.max(minColumnWidth.path, Math.round(rest * defaultColumnRatios.path / ratioSum)),\n        size: Math.max(minColumnWidth.size, Math.round(rest * defaultColumnRatios.size / ratioSum)),\n        modified: fixedModified\n      };\n    }\n    lastTableWidth = width;\n  }\n\n  function loadColWidths() {\n    try {\n      const raw = localStorage.getItem(COL_WIDTHS_KEY);\n      if (!raw) return null;\n      const parsed = JSON.parse(raw);\n      for (const key of columnKeys) {\n        if (typeof parsed[key] !== 'number' || parsed[key] < (minColumnWidth[key] || 0)) return null;\n      }\n      return parsed;\n    } catch {\n      return null;\n    }\n  }\n\n  function saveColWidths() {\n    localStorage.setItem(COL_WIDTHS_KEY, JSON.stringify(colWidths));\n  }\n\n  function updateViewportHeight() {\n    viewportHeight = tableContainer?.clientHeight || 520;\n    syncColumnWidthsToContainer();\n  }\n\n  function scheduleViewportHeightUpdate() {\n    if (viewportResizeRaf !== null) {\n      return;\n    }\n    viewportResizeRaf = requestAnimationFrame(() => {\n      viewportResizeRaf = null;\n      updateViewportHeight();\n    });\n  }\n\n  function startColumnResize(event, leftKey) {\n    event.preventDefault();\n    event.stopPropagation();\n\n    const index = columnKeys.indexOf(leftKey);\n    if (index < 0 || index >= columnKeys.length - 1) {\n      return;\n    }\n\n    const startX = event.clientX;\n    const startLeft = colWidths[leftKey];\n    const rightKey = columnKeys[index + 1];\n    const startRight = colWidths[rightKey];\n\n    resizeCleanup?.();\n    resizingColumn = leftKey;\n\n    const onMove = (moveEvent) => {\n      const delta = Math.round(moveEvent.clientX - startX);\n      if (leftKey === 'name') {\n        // Two-column trade: name and path swap space, each respects its minimum\n        const nextLeft = Math.max(\n          minColumnWidth[leftKey],\n          Math.min(startLeft + delta, startLeft + startRight - minColumnWidth[rightKey])\n        );\n        const nextRight = startLeft + startRight - nextLeft;\n        colWidths = { ...colWidths, [leftKey]: nextLeft, [rightKey]: nextRight };\n      } else {\n        // path splitter: path grows unconstrained (allows horizontal scroll on right drag)\n        const nextLeft = Math.max(minColumnWidth[leftKey], startLeft + delta);\n        colWidths = { ...colWidths, [leftKey]: nextLeft };\n      }\n    };\n\n    const onUp = () => {\n      cleanup();\n    };\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      document.body.style.cursor = '';\n      document.body.style.userSelect = '';\n      resizingColumn = '';\n      saveColWidths();\n      if (resizeCleanup === cleanup) {\n        resizeCleanup = null;\n      }\n    };\n\n    resizeCleanup = cleanup;\n    document.body.style.cursor = 'col-resize';\n    document.body.style.userSelect = 'none';\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  function selectedPaths() {\n    const sorted = [...selectedIndices].sort((a, b) => a - b);\n    return sorted.map((idx) => results[idx]).filter(Boolean).map((entry) => entry.path);\n  }\n\n  function clearSelection() {\n    selectedIndices = new Set();\n    selectionAnchor = -1;\n    lastSelectedIndex = -1;\n  }\n\n  function selectSingle(index) {\n    selectedIndices = new Set([index]);\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectToggle(index) {\n    const next = new Set(selectedIndices);\n    if (next.has(index)) {\n      next.delete(index);\n    } else {\n      next.add(index);\n    }\n    selectedIndices = next;\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectRange(index) {\n    const anchor = selectionAnchor >= 0 ? selectionAnchor : index;\n    const [from, to] = [Math.min(anchor, index), Math.max(anchor, index)];\n    const next = new Set();\n    for (let i = from; i <= to; i += 1) {\n      next.add(i);\n    }\n    selectedIndices = next;\n    lastSelectedIndex = index;\n  }\n\n  function primaryEntry() {\n    const idx = lastSelectedIndex >= 0 ? lastSelectedIndex : -1;\n    return idx >= 0 ? results[idx] : null;\n  }\n\n  async function refreshStatus() {\n    if (statusRefreshInFlight) {\n      return;\n    }\n    statusRefreshInFlight = true;\n    try {\n      const status = await invoke('get_index_status');\n      const prevState = indexStatus.state;\n      indexStatus = {\n        state: status.state,\n        entriesCount: status.entriesCount,\n        lastUpdated: status.lastUpdated,\n        permissionErrors: status.permissionErrors ?? 0,\n        message: status.message\n      };\n      if (status.state === 'Indexing' && prevState !== 'Indexing') {\n        startElapsedTimer();\n      } else if (status.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n      if (typeof status.scanned === 'number') {\n        scanned = status.scanned;\n      }\n      if (status.state === 'Ready' && prevState !== 'Ready') {\n        scheduleSearch();\n      }\n    } catch (err) {\n      showToast(`Failed to get status: ${String(err)}`);\n    } finally {\n      statusRefreshInFlight = false;\n    }\n  }\n\n  function scheduleSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const scheduledGen = searchGeneration;\n    clearTimeout(searchTimer);\n\n    const now = performance.now();\n    if (now - lastSearchFiredAt >= 200) {\n      // Leading edge: fire immediately if enough time has passed\n      lastSearchFiredAt = now;\n      void runSearch(preserveScroll);\n    } else {\n      // Trailing edge: debounce\n      searchTimer = setTimeout(() => {\n        if (scheduledGen !== searchGeneration) {\n          return;\n        }\n        lastSearchFiredAt = performance.now();\n        void runSearch(preserveScroll);\n      }, 200);\n    }\n  }\n\n  async function runSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const gen = searchGeneration;\n    const searchQuery = query;\n    const searchSortBy = sortBy;\n    const searchSortDir = sortDir;\n    const startedAt = performance.now();\n    try {\n      const keepPaths = new Set(selectedPaths());\n      const next = await invoke('search', {\n        query: searchQuery,\n        limit: PAGE_SIZE,\n        offset: 0,\n        sortBy: searchSortBy,\n        sortDir: searchSortDir\n      });\n\n      if (gen !== searchGeneration) return;\n\n      dbLatencyMs = Math.round(performance.now() - startedAt);\n      dbLastQuery = searchQuery;\n      const entries = Array.isArray(next.entries) ? next.entries : [];\n      searchModeLabel = next.modeLabel || '';\n      results = entries;\n      if (next.totalCount > 0) {\n        totalResults = next.totalCount;\n        totalResultsKnown = true;\n      } else {\n        totalResults = entries.length;\n        totalResultsKnown = false;\n      }\n      hasMore = totalResultsKnown ? results.length < totalResults : entries.length >= PAGE_SIZE;\n      if (!preserveScroll && tableContainer) tableContainer.scrollTop = 0;\n\n      const restored = new Set();\n      for (let i = 0; i < results.length; i += 1) {\n        if (keepPaths.has(results[i].path)) {\n          restored.add(i);\n        }\n      }\n      selectedIndices = restored;\n\n      updateViewportHeight();\n    } catch (err) {\n      if (gen !== searchGeneration) return;\n      showToast(`Search failed: ${String(err)}`);\n    }\n  }\n\n  async function loadMore() {\n    if (!hasMore || loadingMore) return;\n    const gen = searchGeneration;\n    loadingMore = true;\n    try {\n      const batch = await invoke('search', {\n        query,\n        limit: PAGE_SIZE,\n        offset: results.length,\n        sortBy: sortBy,\n        sortDir: sortDir\n      });\n      if (gen !== searchGeneration) return;\n      const arr = Array.isArray(batch.entries) ? batch.entries : [];\n      if (arr.length > 0) results = [...results, ...arr];\n      hasMore = totalResultsKnown ? results.length < totalResults : arr.length >= PAGE_SIZE;\n    } catch (err) {\n      showToast(`Failed to load more: ${String(err)}`);\n    } finally {\n      loadingMore = false;\n    }\n  }\n\n  function moveSelection(delta, withRange = false) {\n    if (results.length === 0) {\n      return;\n    }\n\n    const current = lastSelectedIndex >= 0 ? lastSelectedIndex : 0;\n    const next = Math.max(0, Math.min(results.length - 1, current + delta));\n\n    if (withRange) {\n      selectRange(next);\n    } else {\n      selectSingle(next);\n    }\n\n    const top = next * rowHeight;\n    const bottom = top + rowHeight;\n    if (top < scrollTop) {\n      tableContainer.scrollTop = top;\n    } else if (bottom > scrollTop + viewportHeight) {\n      tableContainer.scrollTop = bottom - viewportHeight;\n    }\n  }\n\n  function handleHeaderSort(column) {\n    if (sortBy === column) {\n      sortDir = sortDir === 'asc' ? 'desc' : 'asc';\n    } else {\n      sortBy = column;\n      sortDir = 'asc';\n    }\n    if (tableContainer) tableContainer.scrollTop = 0;\n    void runSearch();\n  }\n\n  function handleRowClick(event, index) {\n    contextMenu.visible = false;\n\n    if (event.shiftKey) {\n      selectRange(index);\n      return;\n    }\n\n    if (event.metaKey || event.ctrlKey) {\n      selectToggle(index);\n      return;\n    }\n\n    selectSingle(index);\n  }\n\n  function handleRowContextMenu(event, index) {\n    event.preventDefault();\n\n    if (!selectedIndices.has(index)) {\n      selectSingle(index);\n    }\n\n    if (platform === 'windows' || platform === 'macos') {\n      contextMenu.visible = false;\n      const paths = selectedPaths();\n      if (paths.length > 0) {\n        invoke('show_context_menu', {\n          paths,\n          x: event.clientX,\n          y: event.clientY,\n          singleSelection: selectedIndices.size === 1\n        });\n      }\n      return;\n    }\n\n    contextMenu = {\n      visible: true,\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n\n  function handleRowA11yKeydown(event, index) {\n    if (event.key === ' ' || event.key === 'Enter') {\n      event.preventDefault();\n      handleRowClick(event, index);\n    }\n  }\n\n  const DRAG_THRESHOLD = 5;\n  let dragCleanup = null;\n  const dragImgCache = new Map();\n\n  function dragPathsForIndex(index) {\n    const entry = results[index];\n    if (!entry) {\n      return [];\n    }\n\n    if (selectedIndices.has(index) && selectedIndices.size > 0) {\n      return selectedPaths();\n    }\n\n    return [entry.path];\n  }\n\n  function getDragIconEl(entry) {\n    const src = iconFor(entry);\n    let img = dragImgCache.get(src);\n    if (!img) {\n      img = new Image();\n      img.src = src;\n      dragImgCache.set(src, img);\n    }\n    return img.complete && img.naturalWidth > 0 ? img : null;\n  }\n\n  function fillRoundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function buildDragPreview(index) {\n    const entry = results[index];\n    if (!entry) return null;\n\n    const count = selectedIndices.has(index) ? selectedIndices.size : 1;\n    const isDark = theme === 'dark';\n\n    const w = 260;\n    const h = 28;\n    const stackGap = count > 1 ? 4 : 0;\n\n    const canvas = document.createElement('canvas');\n    canvas.width = w;\n    canvas.height = h + stackGap;\n    const ctx = canvas.getContext('2d');\n\n    if (count > 1) {\n      ctx.globalAlpha = 0.35;\n      ctx.fillStyle = isDark ? '#5a6070' : '#b0c4de';\n      fillRoundRect(ctx, 3, 0, w - 3, h, 5);\n      ctx.globalAlpha = 1.0;\n    }\n\n    const ry = stackGap;\n    ctx.fillStyle = isDark ? 'rgba(58, 64, 74, 0.94)' : 'rgba(214, 231, 255, 0.94)';\n    fillRoundRect(ctx, 0, ry, w, h, 5);\n\n    ctx.strokeStyle = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';\n    ctx.lineWidth = 0.5;\n    ctx.beginPath();\n    ctx.moveTo(5, ry);\n    ctx.arcTo(w, ry, w, ry + h, 5);\n    ctx.arcTo(w, ry + h, 0, ry + h, 5);\n    ctx.arcTo(0, ry + h, 0, ry, 5);\n    ctx.arcTo(0, ry, w, ry, 5);\n    ctx.closePath();\n    ctx.stroke();\n\n    const iconEl = getDragIconEl(entry);\n    if (iconEl) {\n      ctx.drawImage(iconEl, 6, ry + 6, 16, 16);\n    } else {\n      ctx.fillStyle = entry.isDir ? '#d9b34f' : '#8d98a5';\n      fillRoundRect(ctx, 6, ry + 6, 16, 16, 2);\n    }\n\n    ctx.fillStyle = isDark ? '#e6e6e8' : '#1a1a1a';\n    ctx.font = '12px -apple-system, \"SF Pro Text\", system-ui, sans-serif';\n    ctx.textBaseline = 'middle';\n\n    let nameMaxW = w - 34;\n    if (count > 1) nameMaxW -= 34;\n\n    let name = entry.name;\n    if (ctx.measureText(name).width > nameMaxW) {\n      while (name.length > 4 && ctx.measureText(name + '\\u2026').width > nameMaxW) {\n        name = name.slice(0, -1);\n      }\n      name += '\\u2026';\n    }\n    ctx.fillText(name, 28, ry + h / 2 + 1);\n\n    if (count > 1) {\n      const badge = String(count);\n      ctx.font = 'bold 10px -apple-system, system-ui, sans-serif';\n      const tw = ctx.measureText(badge).width;\n      const bw = Math.max(20, tw + 10);\n      const bx = w - bw - 6;\n      const by = ry + (h - 18) / 2;\n\n      ctx.fillStyle = isDark ? '#5b8bd9' : '#007aff';\n      fillRoundRect(ctx, bx, by, bw, 18, 9);\n\n      ctx.fillStyle = '#ffffff';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(badge, bx + bw / 2, by + 9);\n    }\n\n    return canvas.toDataURL('image/png');\n  }\n\n  function handleRowMouseDown(event, index) {\n    if (event.button !== 0) return;\n    if (event.metaKey || event.ctrlKey || event.shiftKey) return;\n    if (editing.active) return;\n\n    const startX = event.clientX;\n    const startY = event.clientY;\n    let dragging = false;\n\n    dragCleanup?.();\n\n    const onMove = (e) => {\n      if (dragging) return;\n      const dx = e.clientX - startX;\n      const dy = e.clientY - startY;\n      if (dx * dx + dy * dy < DRAG_THRESHOLD * DRAG_THRESHOLD) return;\n\n      dragging = true;\n      cleanup();\n\n      if (!selectedIndices.has(index)) {\n        selectSingle(index);\n      }\n\n      const paths = dragPathsForIndex(index);\n      if (paths.length > 0) {\n        const icon = buildDragPreview(index);\n        startDrag({ item: paths, icon }).catch(() => {});\n      }\n    };\n\n    const onUp = () => cleanup();\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      if (dragCleanup === cleanup) dragCleanup = null;\n    };\n\n    dragCleanup = cleanup;\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  async function handleRowDoubleClick(index) {\n    if (!selectedIndices.has(index) || selectedIndices.size > 1) {\n      selectSingle(index);\n      await tick();\n    }\n    await invoke('open', { paths: [results[index].path] }).catch((err) => {\n      showToast(`Failed to open: ${String(err)}`);\n    });\n  }\n\n  function closeContextMenu() {\n    contextMenu = {\n      ...contextMenu,\n      visible: false\n    };\n  }\n\n  async function openSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('open', { paths });\n    } catch (err) {\n      showToast(`Failed to open: ${String(err)}`);\n    }\n  }\n\n  async function openWithFallback() {\n    const target = primaryEntry();\n    if (!target) {\n      return;\n    }\n\n    try {\n      await invoke('open_with', { path: target.path });\n    } catch (err) {\n      showToast(`Open With failed: ${String(err)}`);\n    }\n  }\n\n  async function revealSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('reveal_in_finder', { paths });\n    } catch (err) {\n      showToast(`Failed to reveal in Finder: ${String(err)}`);\n    }\n  }\n\n  async function copySelectedPaths() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_paths', { paths });\n      showToast(`Copied ${paths.length} path(s)`);\n    } catch (err) {\n      showToast(`Failed to copy path: ${String(err)}`);\n    }\n  }\n\n  async function copyFiles() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_files', { paths });\n      showToast(`Copied ${paths.length} item(s)`);\n    } catch (err) {\n      showToast(`Failed to copy: ${String(err)}`);\n    }\n  }\n\n  async function trashSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    const message =\n      paths.length === 1\n        ? 'Move selected item to Trash?'\n        : `Move ${paths.length} items to Trash?`;\n\n    if (!window.confirm(message)) {\n      return;\n    }\n\n    try {\n      await invoke('move_to_trash', { paths });\n      showToast('Moved to Trash.');\n      clearSelection();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to move to Trash: ${String(err)}`);\n    }\n  }\n\n  async function resetIndex() {\n    if (indexStatus.state === 'Indexing') {\n      showToast('Indexing in progress. Please try again after it completes.');\n      return;\n    }\n\n    results = [];\n    totalResults = 0;\n    totalResultsKnown = false;\n    clearSelection();\n    scanned = 0;\n    dbLatencyMs = null;\n    dbLastQuery = '';\n    indexStatus = { ...indexStatus, state: 'Indexing', entriesCount: 0, message: null };\n    indexingStartTime = Date.now();\n    indexingElapsed = '';\n    indexingFinishedAt = '';\n\n    try {\n      await invoke('reset_index');\n    } catch (err) {\n      showToast(`Failed to reset index: ${String(err)}`);\n      await refreshStatus();\n    }\n  }\n\n  function isMultiSelected() {\n    return selectedIndices.size > 1;\n  }\n\n  function autoResizeRenameInput() {\n    if (!renameInputEl) return;\n    renameInputEl.style.height = '0';\n    renameInputEl.style.height = renameInputEl.scrollHeight + 'px';\n  }\n\n  async function startRename() {\n    if (isMultiSelected()) {\n      return;\n    }\n\n    const idx = lastSelectedIndex;\n    if (idx < 0 || !results[idx]) {\n      return;\n    }\n\n    const entry = results[idx];\n\n    // Calculate overlay position mathematically.\n    // Name cell text starts at: padding-left(16) + icon(16) + gap(6) = 38px from cell left.\n    // Textarea has padding-left: 0 and border: 1.5px, so text starts ~2px from overlay left.\n    if (tableContainer) {\n      const rect = tableContainer.getBoundingClientRect();\n      const cellLeft = rect.left - tableContainer.scrollLeft;\n      const textLeft = cellLeft + 38;\n      const cellRight = cellLeft + colWidths.name;\n      const rowTop = rect.top + idx * rowHeight - tableContainer.scrollTop;\n      renameOverlay = {\n        top: rowTop,\n        left: textLeft - 2,\n        width: cellRight - textLeft + 2 - 4\n      };\n    }\n\n    editing = {\n      active: true,\n      path: entry.path,\n      index: idx,\n      draftName: entry.name\n    };\n\n    await tick();\n\n    if (renameInputEl) {\n      autoResizeRenameInput();\n      renameInputEl.focus();\n      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n      renameInputEl.setSelectionRange(0, selectionEnd);\n    }\n  }\n\n  function cancelRename() {\n    editing = {\n      active: false,\n      path: '',\n      index: -1,\n      draftName: ''\n    };\n  }\n\n  async function commitRename() {\n    if (!editing.active || editing.index < 0 || !results[editing.index]) {\n      return;\n    }\n\n    const current = results[editing.index];\n    const nextName = editing.draftName;\n\n    try {\n      await invoke('rename', {\n        path: current.path,\n        newName: nextName\n      });\n      cancelRename();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to rename: ${String(err)}`);\n      await tick();\n      renameInputEl?.focus();\n    }\n  }\n\n  function onGlobalClick() {\n    closeContextMenu();\n  }\n\n  function onTitleBarMouseDown(event) {\n    if (event.button !== 0) {\n      return;\n    }\n\n    const activeElement = document.activeElement;\n    if (activeElement instanceof HTMLElement && isTextInputTarget(activeElement)) {\n      activeElement.blur();\n    }\n  }\n\n  async function focusSearch() {\n    await getCurrentWindow().show();\n    await getCurrentWindow().setFocus();\n    searchInputEl?.focus();\n    searchInputEl?.select();\n  }\n\n  function isTextInputTarget(target) {\n    return (\n      target instanceof HTMLInputElement ||\n      target instanceof HTMLTextAreaElement ||\n      target?.isContentEditable\n    );\n  }\n\n  async function handleKeydown(event) {\n    const isMetaSelectAll = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'a';\n    const isMetaCopy = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c';\n    const target = event.target;\n    const isTextInput = isTextInputTarget(target);\n\n    if (isMetaCopy && isTextInput) {\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      if (isTextInput) {\n        event.preventDefault();\n        if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n          target.select();\n        }\n        return;\n      }\n    }\n\n    if (editing.active) {\n      if (event.key === 'Enter') {\n        event.preventDefault();\n        await commitRename();\n        return;\n      }\n\n      if (event.key === 'Escape') {\n        event.preventDefault();\n        const idx = editing.index;\n        cancelRename();\n        selectSingle(idx);\n        await tick();\n        tableContainer?.querySelector('.row.selected')?.focus();\n        return;\n      }\n      return;\n    }\n\n    if (event.key === 'Escape') {\n      event.preventDefault();\n      clearSelection();\n      return;\n    }\n\n    if (event.key === 'ArrowDown') {\n      event.preventDefault();\n      moveSelection(1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'ArrowUp') {\n      event.preventDefault();\n      moveSelection(-1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageDown') {\n      event.preventDefault();\n      moveSelection(Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageUp') {\n      event.preventDefault();\n      moveSelection(-Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'Enter') {\n      event.preventDefault();\n      if (platform === 'windows') {\n        await openSelected();\n      } else {\n        await startRename();\n      }\n      return;\n    }\n\n    if (event.key === 'F2') {\n      event.preventDefault();\n      await startRename();\n      return;\n    }\n\n    if (event.key === ' ' && !isTextInput) {\n      event.preventDefault();\n      const entry = primaryEntry();\n      if (entry) {\n        await invoke('quick_look', { path: entry.path });\n      }\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'f') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      searchInputEl?.select();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'o') {\n      event.preventDefault();\n      await openSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {\n      event.preventDefault();\n      await revealSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c') {\n      event.preventDefault();\n      await copySelectedPaths();\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      event.preventDefault();\n      selectedIndices = new Set(Array.from({ length: results.length }, (_, i) => i));\n      return;\n    }\n\n    if (event.key === 'Delete' || ((event.metaKey || event.ctrlKey) && event.key === 'Backspace')) {\n      if (!isTextInput) {\n        event.preventDefault();\n        await trashSelected();\n      }\n      return;\n    }\n  }\n\n  function formatSize(entry) {\n    if (entry.isDir || entry.size == null) return '';\n    const bytes = entry.size;\n    if (bytes < 1024) return `${bytes} B`;\n    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n    return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n  }\n\n  function formatModified(entry) {\n    if (!entry.mtime) {\n      return '';\n    }\n\n    const d = new Date(entry.mtime * 1000);\n    const pad = (n) => String(n).padStart(2, '0');\n    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;\n  }\n\n  function formatLastUpdated(timestamp) {\n    if (!timestamp) {\n      return '-';\n    }\n\n    return new Date(timestamp * 1000).toLocaleString();\n  }\n\n  function formatElapsed(ms) {\n    const totalSec = Math.floor(ms / 1000);\n    const min = Math.floor(totalSec / 60);\n    const sec = totalSec % 60;\n    return min > 0 ? `${min}m ${sec}s` : `${sec}s`;\n  }\n\n  function updateElapsed() {\n    if (indexingStartTime && indexStatus.state === 'Indexing') {\n      indexingElapsed = formatElapsed(Date.now() - indexingStartTime);\n    }\n  }\n\n  function startElapsedTimer() {\n    clearInterval(elapsedTimer);\n    indexingStartTime = Date.now();\n    indexingElapsed = '0s';\n    indexingFinishedAt = '';\n    elapsedTimer = setInterval(updateElapsed, 1000);\n  }\n\n  function stopElapsedTimer() {\n    clearInterval(elapsedTimer);\n    if (indexingStartTime) {\n      const elapsed = Date.now() - indexingStartTime;\n      indexingFinishedAt = `${formatElapsed(elapsed)}`;\n    }\n    indexingStartTime = null;\n    indexingElapsed = '';\n  }\n\n  function displayPath(path) {\n    if (!path) {\n      return path;\n    }\n\n    if (!homePrefix) {\n      return path;\n    }\n\n    if (path === homePrefix) {\n      return '~';\n    }\n\n    if (path.startsWith(`${homePrefix}/`)) {\n      return `~${path.slice(homePrefix.length)}`;\n    }\n\n    return path;\n  }\n\n  let unlistenFns = [];\n\n  onMount(async () => {\n    const t0 = performance.now();\n    const ms = () => Math.round(performance.now() - t0);\n    const DEBUG_STARTUP = false;\n    const flog = DEBUG_STARTUP ? (msg) => invoke('frontend_log', { msg }).catch(() => {}) : () => {};\n\n    flog(`[startup/fe] onMount entered`);\n\n    updateViewportHeight();\n    flog(`[startup/fe] +${ms()}ms updateViewportHeight done`);\n\n    invoke('set_native_theme', { theme });\n\n    platform = await invoke('get_platform');\n    flog(`[startup/fe] +${ms()}ms get_platform done`);\n\n    const unlistenProgress = await listen('index_progress', (event) => {\n      scanned = event.payload.scanned;\n      if (indexStatus.state !== 'Indexing') {\n        indexStatus = {\n          ...indexStatus,\n          state: 'Indexing'\n        };\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_progress) registered`);\n\n    const unlistenState = await listen('index_state', (event) => {\n      flog(`[startup/fe] index_state event received: ${event.payload.state} at +${ms()}ms`);\n      const prevState = indexStatus.state;\n      indexStatus = {\n        ...indexStatus,\n        state: event.payload.state,\n        message: event.payload.message ?? null,\n        isCatchup: event.payload.isCatchup ?? false\n      };\n\n      if (event.payload.state === 'Indexing' && prevState !== 'Indexing') {\n        if (prevState === 'Ready') {\n          lastReadyCount = indexStatus.entriesCount;\n        }\n        startElapsedTimer();\n      } else if (event.payload.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n\n      if (event.payload.state === 'Ready') {\n        scheduleSearch();\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_state) registered`);\n\n    const unlistenUpdated = await listen('index_updated', (event) => {\n      indexStatus = {\n        ...indexStatus,\n        entriesCount: event.payload.entriesCount,\n        lastUpdated: event.payload.lastUpdated,\n        permissionErrors: event.payload.permissionErrors ?? indexStatus.permissionErrors\n      };\n\n      scheduleSearch(true);\n    });\n\n    const unlistenFocus = await listen('focus_search', () => {\n      void focusSearch();\n    });\n\n    const unlistenCtxMenuAction = await listen('context_menu_action', (event) => {\n      switch (event.payload) {\n        case 'open': void openSelected(); break;\n        case 'quick_look': {\n          const e = primaryEntry();\n          if (e) void invoke('quick_look', { path: e.path });\n          break;\n        }\n        case 'open_with': void openWithFallback(); break;\n        case 'reveal': void revealSelected(); break;\n        case 'copy_files': void copyFiles(); break;\n        case 'copy_path': void copySelectedPaths(); break;\n        case 'trash': void trashSelected(); break;\n        case 'rename': void startRename(); break;\n      }\n    });\n\n    unlistenFns = [unlistenProgress, unlistenState, unlistenUpdated, unlistenFocus, unlistenCtxMenuAction];\n    flog(`[startup/fe] +${ms()}ms all listeners registered`);\n\n    // Fetch backend state IMMEDIATELY after listeners are registered.\n    // Events emitted before listener registration are lost, so this\n    // is the only reliable way to get the current state.\n    await refreshStatus();\n    flog(`[startup/fe] +${ms()}ms refreshStatus done (state=${indexStatus.state})`);\n\n    // Show Svelte UI: remove skeleton, focus search input.\n    await tick();\n    document.getElementById('skeleton')?.remove();\n    await focusSearch();\n    flog(`[startup/fe] +${ms()}ms WINDOW VISIBLE â€” skeleton removed`);\n\n    try {\n      homePrefix = await invoke('get_home_dir');\n    } catch {\n      homePrefix = '';\n    }\n    flog(`[startup/fe] +${ms()}ms get_home_dir done`);\n\n    if (!localStorage.getItem('everything-fda-notice-v1')) {\n      showToast('macOS Full Disk Access permission may be required for full disk search.');\n      localStorage.setItem('everything-fda-notice-v1', '1');\n    }\n    flog(`[startup/fe] +${ms()}ms calling runSearch...`);\n    await runSearch();\n    flog(`[startup/fe] +${ms()}ms runSearch done`);\n\n    if (typeof ResizeObserver !== 'undefined') {\n      tableResizeObserver = new ResizeObserver(() => {\n        scheduleViewportHeightUpdate();\n      });\n      if (tableContainer) {\n        tableResizeObserver.observe(tableContainer);\n      } else if (tableAreaEl) {\n        tableResizeObserver.observe(tableAreaEl);\n      }\n    }\n\n    window.addEventListener('resize', scheduleViewportHeightUpdate);\n    window.addEventListener('click', onGlobalClick);\n    statusRefreshTimer = setInterval(() => {\n      if (indexStatus.state === 'Indexing') {\n        void refreshStatus();\n      }\n    }, 1000);\n    console.log(`[startup/fe] +${ms()}ms onMount complete`);\n  });\n\n  onDestroy(async () => {\n    clearTimeout(searchTimer);\n    clearTimeout(toastTimer);\n    clearInterval(statusRefreshTimer);\n    clearInterval(elapsedTimer);\n    resizeCleanup?.();\n\n    for (const unlisten of unlistenFns) {\n      unlisten();\n    }\n\n    tableResizeObserver?.disconnect();\n    tableResizeObserver = null;\n    if (viewportResizeRaf !== null) {\n      cancelAnimationFrame(viewportResizeRaf);\n      viewportResizeRaf = null;\n    }\n    window.removeEventListener('resize', scheduleViewportHeightUpdate);\n    window.removeEventListener('click', onGlobalClick);\n  });\n</script>\n\n<svelte:window on:keydown={handleKeydown} />\n\n<div class=\"app-shell\" data-theme={theme}>\n  <div class=\"title-bar\" role=\"presentation\" data-tauri-drag-region on:mousedown={onTitleBarMouseDown}>\n    <div class=\"title-left\"></div>\n    <div class=\"title-center\">\n      <svg class=\"title-icon\" viewBox=\"0 0 215 205\" fill-rule=\"evenodd\" aria-hidden=\"true\">\n        <path d=\"M85 0c46.9 0 85 38.1 85 85 0 20.1-7.2 38.5-19.2 52.7l40.7 40.8c5.8 5.8 5.8 15.2 0 21-5.8 5.8-15.2 5.8-21 0l-40.7-40.7c-13.6 9.7-30.4 15.2-44.8 15.2-46.9 0-85-42.1-85-89 0-46.9 38.1-85 85-85z m0 32c-29.3 0-53 23.7-53 53 0 29.3 23.7 53 53 53 29.3 0 53-23.7 53-53 0-29.3-23.7-53-53-53z\"/>\n      </svg>\n      <span class=\"title-text\">Everything</span>\n    </div>\n    <div class=\"title-right\"></div>\n  </div>\n\n  <header class=\"search-bar\">\n    <input\n      bind:this={searchInputEl}\n      class=\"search-input\"\n      type=\"text\"\n      bind:value={query}\n      on:input={scheduleSearch}\n      on:focus={clearSelection}\n      placeholder=\"Search file/folder names\"\n      autocomplete=\"off\"\n      spellcheck=\"false\"\n    />\n  </header>\n\n  <section class=\"table-area\" bind:this={tableAreaEl} style={tableGridStyle}>\n    <div class=\"table-header\">\n      <div class=\"table-header-track\">\n        <div class=\"col name\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('name')}>\n            Name{#if sortBy === 'name'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'name'}\n            on:mousedown={(event) => startColumnResize(event, 'name')}\n            aria-label=\"Resize Name column\"\n          />\n        </div>\n\n        <div class=\"col path\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('dir')}>\n            Path{#if sortBy === 'dir'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'path'}\n            on:mousedown={(event) => startColumnResize(event, 'path')}\n            aria-label=\"Resize Path column\"\n          />\n        </div>\n\n        <div class=\"col size\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('size')}>\n            Size{#if sortBy === 'size'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n\n        <div class=\"col modified\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('mtime')}>\n            Modified{#if sortBy === 'mtime'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n      </div>\n    </div>\n\n    <div\n      class=\"table-body\"\n      bind:this={tableContainer}\n      on:scroll={() => {\n        scrollTop = tableContainer.scrollTop;\n        headerScrollLeft = tableContainer.scrollLeft;\n        if (editing.active) void commitRename();\n        const scrollBottom = scrollTop + tableContainer.clientHeight;\n        if (scrollBottom >= totalHeight - rowHeight * 10) {\n          void loadMore();\n        }\n      }}\n    >\n      <div class=\"spacer\" style={`height:${totalHeight}px`}>\n        <div class=\"rows\" style={`transform: translateY(${translateY}px);`}>\n          {#each visibleRows as entry, localIndex}\n            {@const index = startIndex + localIndex}\n            <div\n              class=\"row {selectedIndices.has(index) ? 'selected' : ''}\"\n              on:mousedown={(event) => handleRowMouseDown(event, index)}\n              on:click={(event) => handleRowClick(event, index)}\n              on:keydown={(event) => handleRowA11yKeydown(event, index)}\n              on:dblclick={() => handleRowDoubleClick(index)}\n              on:contextmenu={(event) => handleRowContextMenu(event, index)}\n              role=\"row\"\n              tabindex=\"0\"\n            >\n              <div class=\"cell name\">\n                <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n                <span class=\"ellipsis\" class:name-editing={editing.active && editing.index === index}>{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n              </div>\n              <div class=\"cell path\"><span class=\"ellipsis\">{displayPath(entry.dir)}</span></div>\n              <div class=\"cell size\">{formatSize(entry)}</div>\n              <div class=\"cell modified\">{formatModified(entry)}</div>\n            </div>\n          {/each}\n        </div>\n      </div>\n    </div>\n  </section>\n\n  <footer class=\"status-bar\">\n    <div class=\"status-left\">\n      <span class=\"status-state\">\n        <span class=\"state-dot {indexStatus.state === 'Indexing' ? 'indexing' : indexStatus.state === 'Error' ? 'error' : 'ready'}\"></span>\n        {#if indexStatus.state === 'Indexing'}\n          Indexing{#if lastReadyCount > 0} ({Math.min(99, Math.round((scanned / lastReadyCount) * 100))}%){/if}{#if indexingElapsed} Â· {indexingElapsed}{/if}\n          {#if !indexStatus.isCatchup}\n            Â· {scanned.toLocaleString()} scanned\n          {/if}\n        {:else}\n          Index: {indexStatus.state}\n        {/if}\n      </span>\n      <span>{indexStatus.entriesCount.toLocaleString()} entries</span>\n      {#if indexingFinishedAt && indexStatus.state !== 'Indexing'}\n        <span>in {indexingFinishedAt}</span>\n      {/if}\n      {#if dbLatencyMs !== null && dbLastQuery}\n        <span>\"{dbLastQuery}\" {dbLatencyMs}ms Â· {totalResults} results</span>\n      {/if}\n      {#if searchModeLabel === 'spotlight' || searchModeLabel === 'spotlight_timeout'}\n        <span class=\"status-spotlight\">Spotlight fallback{#if searchModeLabel === 'spotlight_timeout'} (partial){/if}</span>\n      {/if}\n      {#if indexStatus.permissionErrors > 0}\n        <span class=\"status-warning\">{indexStatus.permissionErrors.toLocaleString()} permission errors</span>\n      {/if}\n      {#if indexStatus.message}\n        <span class={indexStatus.isCatchup ? 'index-progress' : 'status-error'}>{indexStatus.message}</span>\n      {/if}\n    </div>\n    <div class=\"status-right\">\n      <button class=\"status-btn\" on:click={cycleTheme} title=\"Switch theme\">\n        {theme === 'dark' ? 'â˜€ Light' : 'â—‘ Dark'}\n      </button>\n      <button\n        class=\"status-btn rebuild-btn\"\n        on:click={resetIndex}\n        disabled={indexStatus.state === 'Indexing'}\n        title={indexStatus.state === 'Indexing' ? 'Cannot reset while indexing is in progress.' : 'Reset and rebuild the index.'}\n      >\n        <svg class=\"rebuild-icon\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n          <path d=\"M23 4v6h-6\"/><path d=\"M20.49 15a9 9 0 1 1-2.12-9.36L23 10\"/>\n        </svg>\n        Rebuild Index\n      </button>\n    </div>\n  </footer>\n\n  {#if editing.active}\n    <div\n      class=\"rename-overlay\"\n      style=\"top:{renameOverlay.top}px; left:{renameOverlay.left}px; width:{renameOverlay.width}px;\"\n      role=\"presentation\"\n      on:mousedown|stopPropagation\n    >\n      <textarea\n        bind:this={renameInputEl}\n        class=\"rename-textarea\"\n        bind:value={editing.draftName}\n        on:input={autoResizeRenameInput}\n        on:click|stopPropagation\n        on:blur={commitRename}\n      />\n    </div>\n  {/if}\n\n  {#if contextMenu.visible}\n    <div class=\"context-menu\" style={`left:${contextMenu.x}px;top:${contextMenu.y}px;`}>\n      <button on:click={() => (closeContextMenu(), openSelected())}>Open</button>\n      <button on:click={async () => { closeContextMenu(); const e = primaryEntry(); if (e) await invoke('quick_look', { path: e.path }); }}>Quick Look</button>\n      <button on:click={() => (closeContextMenu(), openWithFallback())}>Open With... (Reveal in Finder)</button>\n      <button on:click={() => (closeContextMenu(), revealSelected())}>Reveal in Finder</button>\n      <button on:click={() => (closeContextMenu(), copySelectedPaths())}>Copy Path</button>\n      <button on:click={() => (closeContextMenu(), trashSelected())}>Move to Trash</button>\n      {#if selectedIndices.size === 1}\n        <button on:click={() => (closeContextMenu(), startRename())}>Rename</button>\n      {/if}\n    </div>\n  {/if}\n\n  {#if toast}\n    <div class=\"toast\">{toast}</div>\n  {/if}\n</div>\n\n<style>\n  :global(:root) {\n    color-scheme: light dark;\n    --bg-app: transparent;\n    --text-primary: #0d1826;\n    --text-muted: #48596c;\n    --bar-grad-top: rgba(255, 255, 255, 0.48);\n    --bar-grad-bottom: rgba(248, 250, 253, 0.42);\n    --surface-header: rgba(252, 252, 255, 0.40);\n    --surface: rgba(255, 255, 255, 0.22);\n    --border-soft: rgba(0, 0, 0, 0.07);\n    --border-input: rgba(0, 0, 0, 0.13);\n    --focus-ring: #6f96e6;\n    --row-border: rgba(0, 0, 0, 0.032);\n    --row-hover: rgba(0, 0, 0, 0.06);\n    --row-selected: rgba(0, 0, 0, 0.12);\n    --button-bg: rgba(255, 255, 255, 0.62);\n    --button-border: rgba(0, 0, 0, 0.10);\n    --button-text: #2c3e50;\n    --menu-bg: rgba(240, 241, 248, 0.90);\n    --menu-border: rgba(0, 0, 0, 0.06);\n    --menu-hover: rgba(255, 255, 255, 0.62);\n    --menu-text: #1a2a38;\n    --error-text: #b64545;\n    --warning-text: #8f6500;\n    --toast-bg: rgba(18, 22, 32, 0.90);\n    --toast-text: #ffffff;\n  }\n\n  @media (prefers-color-scheme: dark) {\n    :global(:root) {\n      --bg-app: transparent;\n      --text-primary: #e6e6ea;\n      --text-muted: #9494a4;\n      --bar-grad-top: rgba(38, 38, 46, 0.52);\n      --bar-grad-bottom: rgba(30, 30, 38, 0.46);\n      --surface-header: rgba(32, 32, 40, 0.46);\n      --surface: rgba(18, 18, 26, 0.32);\n      --border-soft: rgba(255, 255, 255, 0.065);\n      --border-input: rgba(255, 255, 255, 0.14);\n      --focus-ring: #5b8bd9;\n      --row-border: rgba(255, 255, 255, 0.026);\n      --row-hover: rgba(255, 255, 255, 0.08);\n      --row-selected: rgba(255, 255, 255, 0.14);\n      --button-bg: rgba(255, 255, 255, 0.072);\n      --button-border: rgba(255, 255, 255, 0.11);\n      --button-text: #d6d6e0;\n      --menu-bg: rgba(36, 36, 46, 0.90);\n      --menu-border: rgba(255, 255, 255, 0.066);\n      --menu-hover: rgba(255, 255, 255, 0.062);\n      --menu-text: #e0e0e8;\n      --error-text: #ff9d9d;\n      --warning-text: #e0c670;\n      --toast-bg: rgba(10, 10, 16, 0.93);\n      --toast-text: #f2f2f6;\n    }\n  }\n\n  /* â”€â”€ Theme: Dark â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme=\"dark\"]) {\n    color-scheme: dark;\n    --bg-app: #1E1E21;\n    --text-primary: #E2E8F0;\n    --text-muted: #94A3B8;\n    --bar-grad-top: #1E1E21;\n    --bar-grad-bottom: #1E1E21;\n    --surface-header: #1E1E21;\n    --surface: #1E1E21;\n    --bg-input: #161618;\n    --border-soft: #2A2A2D;\n    --border-input: rgba(255, 255, 255, 0.06);\n    --focus-ring: #4DA8FF;\n    --accent: #4DA8FF;\n    --row-border: rgba(255, 255, 255, 0.02);\n    --row-hover: #282828;\n    --row-selected: rgba(77, 168, 255, 0.10);\n    --button-bg: rgba(255, 255, 255, 0.05);\n    --button-border: #2A2A2D;\n    --button-text: #94A3B8;\n    --menu-bg: #252528;\n    --menu-border: #2A2A2D;\n    --menu-hover: rgba(255, 255, 255, 0.04);\n    --menu-text: #E2E8F0;\n    --error-text: #ff9d9d;\n    --warning-text: #e0c670;\n    --toast-bg: rgba(10, 10, 16, 0.93);\n    --toast-text: #f2f2f6;\n  }\n\n  /* â”€â”€ Theme: Light â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme=\"light\"]) {\n    color-scheme: light;\n    --bg-app: #F5F5F7;\n    --text-primary: #1C1C1E;\n    --text-muted: #6E6E7A;\n    --bar-grad-top: #F5F5F7;\n    --bar-grad-bottom: #F5F5F7;\n    --surface-header: #F5F5F7;\n    --surface: #F5F5F7;\n    --bg-input: #FFFFFF;\n    --border-soft: #D1D1D6;\n    --border-input: rgba(0, 0, 0, 0.10);\n    --focus-ring: #3A8BF5;\n    --accent: #3A8BF5;\n    --row-border: rgba(0, 0, 0, 0.04);\n    --row-hover: rgba(0, 0, 0, 0.04);\n    --row-selected: rgba(58, 139, 245, 0.10);\n    --button-bg: #FFFFFF;\n    --button-border: #D1D1D6;\n    --button-text: #3C3C43;\n    --menu-bg: #FFFFFF;\n    --menu-border: #D1D1D6;\n    --menu-hover: rgba(0, 0, 0, 0.05);\n    --menu-text: #1C1C1E;\n    --error-text: #D93025;\n    --warning-text: #B45309;\n    --toast-bg: rgba(255, 255, 255, 0.95);\n    --toast-text: #1C1C1E;\n  }\n\n  /* â”€â”€ Themed element overrides â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme]) {\n    background: var(--bg-app);\n  }\n\n  /* Search bar: flat, no gradient, no separator */\n  :global([data-theme]) .search-bar {\n    height: 44px;\n    padding: 0 16px;\n    background: var(--bg-app);\n    border-bottom: none;\n  }\n\n  :global([data-theme]) .search-input {\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n    font-family: 'JetBrains Mono', 'SF Mono', monospace;\n    font-size: 12px;\n    height: 34px;\n    border-radius: 8px;\n  }\n\n  /* Table header: flat bg, 16px edge padding */\n  :global([data-theme]) .table-header {\n    background: var(--bg-app);\n  }\n\n  :global([data-theme]) .col-button {\n    padding: 0 8px;\n  }\n\n  :global([data-theme]) .col.name .col-button {\n    padding-left: 16px;\n  }\n\n  /* Row cells: JetBrains Mono, 16px outer edges */\n  :global([data-theme]) .cell {\n    font-family: 'JetBrains Mono', monospace;\n  }\n\n  :global([data-theme]) .cell.name {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    padding-left: 16px;\n    font-size: 12px;\n    color: var(--text-primary);\n  }\n\n  :global([data-theme]) .cell.path {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.size {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.modified {\n    padding-right: 16px;\n    font-size: 11px;\n    white-space: nowrap;\n  }\n\n  :global([data-theme]) .row.selected {\n    box-shadow: inset 3px 0 0 var(--accent);\n  }\n\n  /* Dim path/size/date cells in themed mode */\n  :global([data-theme]) .cell.path,\n  :global([data-theme]) .cell.size,\n  :global([data-theme]) .cell.modified {\n    color: var(--text-muted);\n  }\n\n  :global(:root) {\n    background: transparent;\n  }\n\n  :global(html, body) {\n    margin: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    background: transparent;\n    color: var(--text-primary);\n    font-family: Inter, 'SF Pro Text', 'Segoe UI', Helvetica, Arial, sans-serif;\n  }\n\n  :global(#app) {\n    width: 100%;\n    height: 100%;\n  }\n\n  .app-shell {\n    display: grid;\n    grid-template-rows: auto auto 1fr auto;\n    height: 100%;\n    min-width: 0;\n  }\n\n  .title-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 44px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    cursor: default;\n    flex-shrink: 0;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-left {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-center {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-right {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-icon {\n    width: 14px;\n    height: 14px;\n    fill: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .title-text {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 13px;\n    font-weight: 500;\n    color: var(--text-primary);\n    letter-spacing: -0.01em;\n  }\n\n  .search-bar {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding: 8px;\n    background: linear-gradient(180deg, var(--bar-grad-top) 0%, var(--bar-grad-bottom) 100%);\n    border-bottom: 1px solid var(--border-soft);\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .search-input {\n    display: block;\n    box-sizing: border-box;\n    width: 100%;\n    min-width: 0;\n    flex: 1 1 auto;\n    height: 36px;\n    border: 1px solid var(--border-input);\n    border-radius: 14px;\n    padding: 0 10px;\n    font-size: 14px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    backdrop-filter: blur(12px) saturate(160%);\n    -webkit-backdrop-filter: blur(12px) saturate(160%);\n  }\n\n  .search-input::placeholder {\n    color: var(--text-muted);\n    opacity: 0.85;\n    font-size: 12px;\n  }\n\n  .search-input:focus {\n    outline: none;\n    border-color: var(--focus-ring);\n    box-shadow: 0 0 0 2px rgba(125, 169, 255, 0.25);\n  }\n\n  .table-area {\n    display: grid;\n    grid-template-rows: auto 1fr;\n    min-height: 0;\n    min-width: 0;\n  }\n\n  .table-header-track,\n  .row {\n    display: grid;\n    grid-template-columns: var(--col-name) var(--col-path) var(--col-size) var(--col-modified);\n    align-items: center;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .table-header {\n    height: 32px;\n    border-bottom: 1px solid var(--border-soft);\n    background: var(--surface-header);\n    user-select: none;\n    overflow: hidden;\n    flex-shrink: 0;\n  }\n\n  .table-header-track {\n    height: 100%;\n    transform: translateX(var(--header-offset, 0px));\n    will-change: transform;\n  }\n\n  .table-header .col {\n    position: relative;\n    min-width: 0;\n    height: 100%;\n  }\n\n  .col-button {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n    gap: 4px;\n    box-sizing: border-box;\n    padding: 0 8px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 11px;\n    font-weight: 600;\n    line-height: 1;\n    color: var(--text-muted);\n    text-align: left;\n    margin: 0;\n    border: none;\n    background: transparent;\n    cursor: pointer;\n  }\n\n  .sort-icon {\n    width: 10px;\n    height: 10px;\n    flex-shrink: 0;\n    color: var(--accent);\n  }\n\n  .col-resizer {\n    position: absolute;\n    top: 0;\n    right: -4px;\n    width: 8px;\n    height: 100%;\n    border: none;\n    padding: 0;\n    background: transparent;\n    cursor: col-resize;\n    z-index: 30;\n  }\n\n  .col-resizer::after {\n    content: '';\n    position: absolute;\n    top: 7px;\n    bottom: 7px;\n    left: 50%;\n    width: 1px;\n    transform: translateX(-50%);\n    background: var(--border-soft);\n    opacity: 0;\n    transition: opacity 0.15s ease;\n  }\n\n  .table-header .col:hover .col-resizer::after,\n  .col-resizer.active::after {\n    opacity: 1;\n  }\n\n  .table-body {\n    overflow: auto;\n    min-height: 0;\n    min-width: 0;\n    background: var(--surface);\n  }\n\n  .spacer {\n    position: relative;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .rows {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .row {\n    height: 30px;\n    border-bottom: 1px solid var(--row-border);\n    cursor: default;\n    -webkit-user-select: none;\n    user-select: none;\n    outline: none;\n  }\n\n  .row:hover {\n    background: var(--row-hover);\n  }\n\n  .row.selected {\n    background: var(--row-selected);\n  }\n\n  .cell {\n    padding: 0 8px;\n    font-size: 12px;\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    min-width: 0;\n  }\n\n  .cell.size {\n    text-align: right;\n    font-variant-numeric: tabular-nums;\n  }\n\n  .ellipsis {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n\n  .hl {\n    background: none;\n    color: inherit;\n    font-weight: 700;\n  }\n\n  .file-icon {\n    width: 16px;\n    height: 16px;\n    flex: 0 0 auto;\n  }\n\n  .name-editing {\n    opacity: 0.25;\n  }\n\n  .rename-overlay {\n    position: fixed;\n    z-index: 100;\n    min-width: 120px;\n  }\n\n  .rename-textarea {\n    display: block;\n    width: 100%;\n    box-sizing: border-box;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 12px;\n    line-height: 18px;\n    padding: 5px 4px 5px 0;\n    border: 1.5px solid var(--focus-ring);\n    border-radius: 4px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    outline: none;\n    resize: none;\n    overflow: hidden;\n    box-shadow: 0 2px 14px rgba(0, 0, 0, 0.22), 0 0 0 3px rgba(77, 168, 255, 0.13);\n  }\n\n  .status-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 32px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    border-top: 1px solid var(--border-soft);\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 11px;\n    color: var(--text-muted);\n    white-space: nowrap;\n    overflow: hidden;\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .status-left {\n    display: flex;\n    align-items: center;\n    gap: 16px;\n    overflow: hidden;\n    min-width: 0;\n  }\n\n  .status-right {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    flex-shrink: 0;\n  }\n\n  .status-btn {\n    border: 1px solid var(--button-border);\n    border-radius: 5px;\n    background: var(--button-bg);\n    color: var(--button-text);\n    font-size: 11px;\n    height: 22px;\n    padding: 0 8px;\n    cursor: pointer;\n  }\n\n  .status-btn:hover {\n    filter: brightness(1.06);\n  }\n\n  .status-btn:disabled {\n    opacity: 0.55;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .status-state {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n  }\n\n  .state-dot {\n    width: 6px;\n    height: 6px;\n    border-radius: 50%;\n    flex-shrink: 0;\n  }\n\n  .state-dot.ready { background: #28C840; }\n  .state-dot.indexing { background: #FEBC2E; }\n  .state-dot.error { background: #FF5F57; }\n\n  .rebuild-btn {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 10px;\n    font-weight: 500;\n    background: var(--button-bg);\n    border: 1px solid var(--button-border);\n    border-radius: 4px;\n    color: var(--button-text);\n    height: 22px;\n    padding: 0 10px;\n    cursor: pointer;\n  }\n\n  .rebuild-btn:hover {\n    filter: brightness(1.1);\n  }\n\n  .rebuild-btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .rebuild-icon {\n    width: 11px;\n    height: 11px;\n    color: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .status-error {\n    color: var(--error-text);\n  }\n\n  .status-warning {\n    color: var(--warning-text);\n  }\n\n  .status-spotlight {\n    color: #f59e0b;\n    font-weight: 600;\n  }\n\n  .context-menu {\n    position: fixed;\n    z-index: 200;\n    width: 220px;\n    border: 1px solid var(--menu-border);\n    border-radius: 10px;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.16), inset 0 0 0 0.5px rgba(255, 255, 255, 0.18);\n    background: var(--menu-bg);\n    backdrop-filter: blur(28px) saturate(180%);\n    -webkit-backdrop-filter: blur(28px) saturate(180%);\n    overflow: hidden;\n  }\n\n  .context-menu button {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    padding: 8px 10px;\n    font-size: 12px;\n    color: var(--menu-text);\n  }\n\n  .context-menu button:hover {\n    background: var(--menu-hover);\n  }\n\n  .toast {\n    position: fixed;\n    right: 14px;\n    bottom: 18px;\n    background: var(--toast-bg);\n    color: var(--toast-text);\n    border-radius: 10px;\n    padding: 9px 12px;\n    font-size: 12px;\n    z-index: 250;\n    backdrop-filter: blur(20px) saturate(180%);\n    -webkit-backdrop-filter: blur(20px) saturate(180%);\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);\n  }\n</style>\n","structuredPatch":[{"oldStart":1457,"oldLines":7,"newStart":1457,"newLines":7,"lines":["       <div class=\"table-header-track\">","         <div class=\"col name\">","           <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('name')}>","-            Name{#if sortBy === 'name'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}","+            Name{#if sortBy === 'name'}{@html sortIconHtml(sortDir)}{/if}","           </button>","           <button","             type=\"button\""]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"35e77e68-fd1f-4210-aa25-bd25781f9ebc"}
{"parentUuid":"91a3ab9a-2bb1-423d-af4f-00cf07186447","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01NHXmwfvQ3L7wUf1PthkAu7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013ZScsiTm3J8z2Jm7D1u6HF","name":"Edit","input":{"replace_all":false,"file_path":"/Users/al02402336/everything/src/App.svelte","old_string":"            Path{#if sortBy === 'dir'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}","new_string":"            Path{#if sortBy === 'dir'}{@html sortIconHtml(sortDir)}{/if}"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":316,"cache_read_input_tokens":100205,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":316},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPQesvBbaDkmJTqgDdQ","type":"assistant","uuid":"5c81ebff-1bd8-4271-ba47-7aff2ad2b2de","timestamp":"2026-02-21T14:39:59.654Z"}
{"parentUuid":"5c81ebff-1bd8-4271-ba47-7aff2ad2b2de","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_013ZScsiTm3J8z2Jm7D1u6HF","toolUseID":"toolu_013ZScsiTm3J8z2Jm7D1u6HF","timestamp":"2026-02-21T14:39:59.664Z","uuid":"1e2df77d-52bd-4610-919b-36dc7216c6f1"}
{"parentUuid":"5c81ebff-1bd8-4271-ba47-7aff2ad2b2de","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013ZScsiTm3J8z2Jm7D1u6HF","type":"tool_result","content":"The file /Users/al02402336/everything/src/App.svelte has been updated successfully."}]},"uuid":"ce88a12a-2ca0-4805-9f25-bdfaf85f040b","timestamp":"2026-02-21T14:39:59.663Z","toolUseResult":{"filePath":"/Users/al02402336/everything/src/App.svelte","oldString":"            Path{#if sortBy === 'dir'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}","newString":"            Path{#if sortBy === 'dir'}{@html sortIconHtml(sortDir)}{/if}","originalFile":"<script>\n  import { onDestroy, onMount, tick } from 'svelte';\n  import { invoke } from '@tauri-apps/api/core';\n  import { listen } from '@tauri-apps/api/event';\n  import { getCurrentWindow } from '@tauri-apps/api/window';\n  import { startDrag } from '@crabnebula/tauri-plugin-drag';\n\n  const rowHeight = 30;\n  const PAGE_SIZE = 500;\n  let homePrefix = '';\n  const COL_WIDTHS_KEY = 'REDACTED';\n  const THEME_KEY = 'everything-theme';\n  const columnKeys = ['name', 'path', 'size', 'modified'];\n  const minColumnWidth = {\n    name: 180,\n    path: 240,\n    size: 75,\n    modified: 150\n  };\n  const defaultColumnRatios = {\n    name: 0.3,\n    path: 0.45,\n    size: 0.1\n  };\n\n  const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';\n  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || systemTheme; } catch { return systemTheme; } })();\n  function cycleTheme() {\n    theme = theme === 'dark' ? 'light' : 'dark';\n    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n    invoke('set_native_theme', { theme });\n  }\n\n  function sortIconHtml(dir) {\n    const d = dir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5';\n    return `<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"${d}\"/></svg>`;\n  }\n\n  let query = '';\n  let results = [];\n  let totalResults = 0;\n  let totalResultsKnown = false;\n\n  let dbLatencyMs = null;\n  let dbLastQuery = '';\n  let searchModeLabel = '';\n  let selectedIndices = new Set();\n  let selectionAnchor = -1;\n  let lastSelectedIndex = -1;\n  let editing = {\n    active: false,\n    path: '',\n    index: -1,\n    draftName: ''\n  };\n\n  let renameOverlay = { top: 0, left: 0, width: 0 };\n\n  let indexStatus = {\n    state: 'Indexing',\n    entriesCount: 0,\n    lastUpdated: null,\n    permissionErrors: 0,\n    message: null,\n    isCatchup: false\n  };\n\n  let indexingStartTime = null;\n  let indexingElapsed = '';\n  let indexingFinishedAt = '';\n\n  let sortBy = 'name';\n  let sortDir = 'asc';\n\n  let hasMore = true;\n  let loadingMore = false;\n  let searchGeneration = 0;\n\n  let scanned = 0;\n\n  let searchInputEl;\n  let renameInputEl;\n  let tableAreaEl;\n  let tableContainer;\n  let tableResizeObserver = null;\n  let viewportResizeRaf = null;\n  let scrollTop = 0;\n  let headerScrollLeft = 0;\n  let viewportHeight = 520;\n  let lastTableWidth = 0;\n  let resizingColumn = '';\n  let resizeCleanup = null;\n  let colWidths = {\n    name: 250,\n    path: 350,\n    size: 75,\n    modified: 150\n  };\n\n  let contextMenu = {\n    visible: false,\n    x: 0,\n    y: 0\n  };\n\n  let platform = '';\n  let toast = '';\n  let searchTimer;\n  let lastSearchFiredAt = 0;\n  let toastTimer;\n  let statusRefreshTimer;\n  let elapsedTimer;\n  let statusRefreshInFlight = false;\n  let lastReadyCount = 0;\n\n  const iconCache = new Map();\n  const iconLoading = new Set();\n\n  let highlightCache = new Map();\n  let highlightCacheQuery = '';\n\n  const folderFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='1' y='4' width='14' height='10' rx='2' fill='#d9b34f'/><rect x='1' y='2' width='6' height='4' rx='1' fill='#e6ca7a'/></svg>`\n    );\n  const fileFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='3' y='1' width='10' height='14' rx='1.5' fill='#b4bec9'/><rect x='5' y='5' width='6' height='1.2' fill='#8d98a5'/><rect x='5' y='8' width='6' height='1.2' fill='#8d98a5'/></svg>`\n    );\n\n  $: totalHeight = results.length * rowHeight;\n  $: startIndex = Math.max(0, Math.floor(scrollTop / rowHeight) - 10);\n  $: visibleCount = Math.ceil(viewportHeight / rowHeight) + 20;\n  $: endIndex = Math.min(results.length, startIndex + visibleCount);\n  $: visibleRows = results.slice(startIndex, endIndex);\n  $: translateY = startIndex * rowHeight;\n  $: tableMinWidth = colWidths.name + colWidths.path + colWidths.size + colWidths.modified;\n  $: tableGridStyle = `--col-name:${colWidths.name}px;--col-path:${colWidths.path}px;--col-size:${colWidths.size}px;--col-modified:${colWidths.modified}px;--table-min-width:${tableMinWidth}px;--header-offset:${-headerScrollLeft}px;`;\n\n  $: {\n    for (const entry of visibleRows) {\n      void ensureIcon(entry);\n    }\n  }\n\n  function showToast(message) {\n    toast = message;\n    clearTimeout(toastTimer);\n    toastTimer = setTimeout(() => {\n      toast = '';\n    }, 3000);\n  }\n\n  function bytesToBase64(bytes) {\n    let binary = '';\n    const chunk = 0x8000;\n    for (let i = 0; i < bytes.length; i += chunk) {\n      const part = bytes.subarray(i, i + chunk);\n      binary += String.fromCharCode(...part);\n    }\n    return btoa(binary);\n  }\n\n  function highlightSegments(name, q) {\n    q = (q || '').trim();\n    if (!q) return [{ text: name, hl: false }];\n\n    // Reset cache when query changes\n    if (q !== highlightCacheQuery) {\n      highlightCache = new Map();\n      highlightCacheQuery = q;\n    }\n\n    // Check cache\n    const cached = highlightCache.get(name);\n    if (cached) return cached;\n\n    if (q.includes('/')) q = q.slice(q.lastIndexOf('/') + 1);\n    q = q.replace(/[*?]/g, '');\n    const terms = q.split(/\\s+/).filter(Boolean);\n    if (terms.length === 0) return [{ text: name, hl: false }];\n\n    const lower = name.toLowerCase();\n    const marks = new Uint8Array(name.length);\n    for (const t of terms) {\n      const tl = t.toLowerCase();\n      let idx = lower.indexOf(tl);\n      while (idx !== -1) {\n        for (let i = idx; i < idx + tl.length; i++) marks[i] = 1;\n        idx = lower.indexOf(tl, idx + 1);\n      }\n    }\n\n    const segs = [];\n    let i = 0;\n    while (i < name.length) {\n      const m = marks[i];\n      let j = i + 1;\n      while (j < name.length && marks[j] === m) j++;\n      segs.push({ text: name.slice(i, j), hl: m === 1 });\n      i = j;\n    }\n\n    highlightCache.set(name, segs);\n    return segs;\n  }\n\n  const perFileIconExts = new Set(['exe', 'lnk', 'ico', 'url', 'scr', 'appx']);\n\n  function iconKey(entry) {\n    if (entry.isDir) return '__folder__';\n    const ext = (entry.ext || '').toLowerCase();\n    if (perFileIconExts.has(ext)) return entry.path;\n    return ext || '__file__';\n  }\n\n  function iconFor(entry) {\n    return iconCache.get(iconKey(entry)) || (entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n  }\n\n  async function ensureIcon(entry) {\n    const key = iconKey(entry);\n    if (iconCache.has(key) || iconLoading.has(key)) {\n      return;\n    }\n\n    iconLoading.add(key);\n    try {\n      const bytes = await invoke('get_file_icon', {\n        path: entry.path,\n        ext: entry.isDir ? 'folder' : entry.ext || '',\n      });\n      if (Array.isArray(bytes) && bytes.length > 0) {\n        const image = `data:image/png;base64,${bytesToBase64(Uint8Array.from(bytes))}`;\n        iconCache.set(key, image);\n      } else {\n        iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n      }\n    } catch {\n      iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n    } finally {\n      iconLoading.delete(key);\n    }\n  }\n\n  function syncColumnWidthsToContainer() {\n    const width = tableContainer?.clientWidth || tableAreaEl?.clientWidth;\n    if (!width || lastTableWidth !== 0) {\n      return;\n    }\n\n    const saved = loadColWidths();\n    if (saved) {\n      const total = columnKeys.reduce((s, k) => s + saved[k], 0);\n      if (Math.abs(total - width) > 2) {\n        const scale = (width - saved.modified) / (total - saved.modified);\n        let scaledName = Math.max(minColumnWidth.name, Math.round(saved.name * scale));\n        let scaledSize = Math.max(minColumnWidth.size, Math.round(saved.size * scale));\n        let rawPath = width - saved.modified - scaledName - scaledSize;\n        if (rawPath < minColumnWidth.path) {\n          const shortfall = minColumnWidth.path - rawPath;\n          const nameReduction = Math.min(shortfall, scaledName - minColumnWidth.name);\n          scaledName -= nameReduction;\n          const remaining = shortfall - nameReduction;\n          if (remaining > 0) {\n            scaledSize -= Math.min(remaining, scaledSize - minColumnWidth.size);\n          }\n          rawPath = width - saved.modified - scaledName - scaledSize;\n        }\n        const scaledPath = Math.max(minColumnWidth.path, rawPath);\n        colWidths = { name: scaledName, path: scaledPath, size: scaledSize, modified: saved.modified };\n      } else {\n        colWidths = saved;\n      }\n    } else {\n      const fixedModified = minColumnWidth.modified;\n      const rest = width - fixedModified;\n      const ratioSum = defaultColumnRatios.name + defaultColumnRatios.path + defaultColumnRatios.size;\n      colWidths = {\n        name: Math.max(minColumnWidth.name, Math.round(rest * defaultColumnRatios.name / ratioSum)),\n        path: Math.max(minColumnWidth.path, Math.round(rest * defaultColumnRatios.path / ratioSum)),\n        size: Math.max(minColumnWidth.size, Math.round(rest * defaultColumnRatios.size / ratioSum)),\n        modified: fixedModified\n      };\n    }\n    lastTableWidth = width;\n  }\n\n  function loadColWidths() {\n    try {\n      const raw = localStorage.getItem(COL_WIDTHS_KEY);\n      if (!raw) return null;\n      const parsed = JSON.parse(raw);\n      for (const key of columnKeys) {\n        if (typeof parsed[key] !== 'number' || parsed[key] < (minColumnWidth[key] || 0)) return null;\n      }\n      return parsed;\n    } catch {\n      return null;\n    }\n  }\n\n  function saveColWidths() {\n    localStorage.setItem(COL_WIDTHS_KEY, JSON.stringify(colWidths));\n  }\n\n  function updateViewportHeight() {\n    viewportHeight = tableContainer?.clientHeight || 520;\n    syncColumnWidthsToContainer();\n  }\n\n  function scheduleViewportHeightUpdate() {\n    if (viewportResizeRaf !== null) {\n      return;\n    }\n    viewportResizeRaf = requestAnimationFrame(() => {\n      viewportResizeRaf = null;\n      updateViewportHeight();\n    });\n  }\n\n  function startColumnResize(event, leftKey) {\n    event.preventDefault();\n    event.stopPropagation();\n\n    const index = columnKeys.indexOf(leftKey);\n    if (index < 0 || index >= columnKeys.length - 1) {\n      return;\n    }\n\n    const startX = event.clientX;\n    const startLeft = colWidths[leftKey];\n    const rightKey = columnKeys[index + 1];\n    const startRight = colWidths[rightKey];\n\n    resizeCleanup?.();\n    resizingColumn = leftKey;\n\n    const onMove = (moveEvent) => {\n      const delta = Math.round(moveEvent.clientX - startX);\n      if (leftKey === 'name') {\n        // Two-column trade: name and path swap space, each respects its minimum\n        const nextLeft = Math.max(\n          minColumnWidth[leftKey],\n          Math.min(startLeft + delta, startLeft + startRight - minColumnWidth[rightKey])\n        );\n        const nextRight = startLeft + startRight - nextLeft;\n        colWidths = { ...colWidths, [leftKey]: nextLeft, [rightKey]: nextRight };\n      } else {\n        // path splitter: path grows unconstrained (allows horizontal scroll on right drag)\n        const nextLeft = Math.max(minColumnWidth[leftKey], startLeft + delta);\n        colWidths = { ...colWidths, [leftKey]: nextLeft };\n      }\n    };\n\n    const onUp = () => {\n      cleanup();\n    };\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      document.body.style.cursor = '';\n      document.body.style.userSelect = '';\n      resizingColumn = '';\n      saveColWidths();\n      if (resizeCleanup === cleanup) {\n        resizeCleanup = null;\n      }\n    };\n\n    resizeCleanup = cleanup;\n    document.body.style.cursor = 'col-resize';\n    document.body.style.userSelect = 'none';\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  function selectedPaths() {\n    const sorted = [...selectedIndices].sort((a, b) => a - b);\n    return sorted.map((idx) => results[idx]).filter(Boolean).map((entry) => entry.path);\n  }\n\n  function clearSelection() {\n    selectedIndices = new Set();\n    selectionAnchor = -1;\n    lastSelectedIndex = -1;\n  }\n\n  function selectSingle(index) {\n    selectedIndices = new Set([index]);\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectToggle(index) {\n    const next = new Set(selectedIndices);\n    if (next.has(index)) {\n      next.delete(index);\n    } else {\n      next.add(index);\n    }\n    selectedIndices = next;\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectRange(index) {\n    const anchor = selectionAnchor >= 0 ? selectionAnchor : index;\n    const [from, to] = [Math.min(anchor, index), Math.max(anchor, index)];\n    const next = new Set();\n    for (let i = from; i <= to; i += 1) {\n      next.add(i);\n    }\n    selectedIndices = next;\n    lastSelectedIndex = index;\n  }\n\n  function primaryEntry() {\n    const idx = lastSelectedIndex >= 0 ? lastSelectedIndex : -1;\n    return idx >= 0 ? results[idx] : null;\n  }\n\n  async function refreshStatus() {\n    if (statusRefreshInFlight) {\n      return;\n    }\n    statusRefreshInFlight = true;\n    try {\n      const status = await invoke('get_index_status');\n      const prevState = indexStatus.state;\n      indexStatus = {\n        state: status.state,\n        entriesCount: status.entriesCount,\n        lastUpdated: status.lastUpdated,\n        permissionErrors: status.permissionErrors ?? 0,\n        message: status.message\n      };\n      if (status.state === 'Indexing' && prevState !== 'Indexing') {\n        startElapsedTimer();\n      } else if (status.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n      if (typeof status.scanned === 'number') {\n        scanned = status.scanned;\n      }\n      if (status.state === 'Ready' && prevState !== 'Ready') {\n        scheduleSearch();\n      }\n    } catch (err) {\n      showToast(`Failed to get status: ${String(err)}`);\n    } finally {\n      statusRefreshInFlight = false;\n    }\n  }\n\n  function scheduleSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const scheduledGen = searchGeneration;\n    clearTimeout(searchTimer);\n\n    const now = performance.now();\n    if (now - lastSearchFiredAt >= 200) {\n      // Leading edge: fire immediately if enough time has passed\n      lastSearchFiredAt = now;\n      void runSearch(preserveScroll);\n    } else {\n      // Trailing edge: debounce\n      searchTimer = setTimeout(() => {\n        if (scheduledGen !== searchGeneration) {\n          return;\n        }\n        lastSearchFiredAt = performance.now();\n        void runSearch(preserveScroll);\n      }, 200);\n    }\n  }\n\n  async function runSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const gen = searchGeneration;\n    const searchQuery = query;\n    const searchSortBy = sortBy;\n    const searchSortDir = sortDir;\n    const startedAt = performance.now();\n    try {\n      const keepPaths = new Set(selectedPaths());\n      const next = await invoke('search', {\n        query: searchQuery,\n        limit: PAGE_SIZE,\n        offset: 0,\n        sortBy: searchSortBy,\n        sortDir: searchSortDir\n      });\n\n      if (gen !== searchGeneration) return;\n\n      dbLatencyMs = Math.round(performance.now() - startedAt);\n      dbLastQuery = searchQuery;\n      const entries = Array.isArray(next.entries) ? next.entries : [];\n      searchModeLabel = next.modeLabel || '';\n      results = entries;\n      if (next.totalCount > 0) {\n        totalResults = next.totalCount;\n        totalResultsKnown = true;\n      } else {\n        totalResults = entries.length;\n        totalResultsKnown = false;\n      }\n      hasMore = totalResultsKnown ? results.length < totalResults : entries.length >= PAGE_SIZE;\n      if (!preserveScroll && tableContainer) tableContainer.scrollTop = 0;\n\n      const restored = new Set();\n      for (let i = 0; i < results.length; i += 1) {\n        if (keepPaths.has(results[i].path)) {\n          restored.add(i);\n        }\n      }\n      selectedIndices = restored;\n\n      updateViewportHeight();\n    } catch (err) {\n      if (gen !== searchGeneration) return;\n      showToast(`Search failed: ${String(err)}`);\n    }\n  }\n\n  async function loadMore() {\n    if (!hasMore || loadingMore) return;\n    const gen = searchGeneration;\n    loadingMore = true;\n    try {\n      const batch = await invoke('search', {\n        query,\n        limit: PAGE_SIZE,\n        offset: results.length,\n        sortBy: sortBy,\n        sortDir: sortDir\n      });\n      if (gen !== searchGeneration) return;\n      const arr = Array.isArray(batch.entries) ? batch.entries : [];\n      if (arr.length > 0) results = [...results, ...arr];\n      hasMore = totalResultsKnown ? results.length < totalResults : arr.length >= PAGE_SIZE;\n    } catch (err) {\n      showToast(`Failed to load more: ${String(err)}`);\n    } finally {\n      loadingMore = false;\n    }\n  }\n\n  function moveSelection(delta, withRange = false) {\n    if (results.length === 0) {\n      return;\n    }\n\n    const current = lastSelectedIndex >= 0 ? lastSelectedIndex : 0;\n    const next = Math.max(0, Math.min(results.length - 1, current + delta));\n\n    if (withRange) {\n      selectRange(next);\n    } else {\n      selectSingle(next);\n    }\n\n    const top = next * rowHeight;\n    const bottom = top + rowHeight;\n    if (top < scrollTop) {\n      tableContainer.scrollTop = top;\n    } else if (bottom > scrollTop + viewportHeight) {\n      tableContainer.scrollTop = bottom - viewportHeight;\n    }\n  }\n\n  function handleHeaderSort(column) {\n    if (sortBy === column) {\n      sortDir = sortDir === 'asc' ? 'desc' : 'asc';\n    } else {\n      sortBy = column;\n      sortDir = 'asc';\n    }\n    if (tableContainer) tableContainer.scrollTop = 0;\n    void runSearch();\n  }\n\n  function handleRowClick(event, index) {\n    contextMenu.visible = false;\n\n    if (event.shiftKey) {\n      selectRange(index);\n      return;\n    }\n\n    if (event.metaKey || event.ctrlKey) {\n      selectToggle(index);\n      return;\n    }\n\n    selectSingle(index);\n  }\n\n  function handleRowContextMenu(event, index) {\n    event.preventDefault();\n\n    if (!selectedIndices.has(index)) {\n      selectSingle(index);\n    }\n\n    if (platform === 'windows' || platform === 'macos') {\n      contextMenu.visible = false;\n      const paths = selectedPaths();\n      if (paths.length > 0) {\n        invoke('show_context_menu', {\n          paths,\n          x: event.clientX,\n          y: event.clientY,\n          singleSelection: selectedIndices.size === 1\n        });\n      }\n      return;\n    }\n\n    contextMenu = {\n      visible: true,\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n\n  function handleRowA11yKeydown(event, index) {\n    if (event.key === ' ' || event.key === 'Enter') {\n      event.preventDefault();\n      handleRowClick(event, index);\n    }\n  }\n\n  const DRAG_THRESHOLD = 5;\n  let dragCleanup = null;\n  const dragImgCache = new Map();\n\n  function dragPathsForIndex(index) {\n    const entry = results[index];\n    if (!entry) {\n      return [];\n    }\n\n    if (selectedIndices.has(index) && selectedIndices.size > 0) {\n      return selectedPaths();\n    }\n\n    return [entry.path];\n  }\n\n  function getDragIconEl(entry) {\n    const src = iconFor(entry);\n    let img = dragImgCache.get(src);\n    if (!img) {\n      img = new Image();\n      img.src = src;\n      dragImgCache.set(src, img);\n    }\n    return img.complete && img.naturalWidth > 0 ? img : null;\n  }\n\n  function fillRoundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function buildDragPreview(index) {\n    const entry = results[index];\n    if (!entry) return null;\n\n    const count = selectedIndices.has(index) ? selectedIndices.size : 1;\n    const isDark = theme === 'dark';\n\n    const w = 260;\n    const h = 28;\n    const stackGap = count > 1 ? 4 : 0;\n\n    const canvas = document.createElement('canvas');\n    canvas.width = w;\n    canvas.height = h + stackGap;\n    const ctx = canvas.getContext('2d');\n\n    if (count > 1) {\n      ctx.globalAlpha = 0.35;\n      ctx.fillStyle = isDark ? '#5a6070' : '#b0c4de';\n      fillRoundRect(ctx, 3, 0, w - 3, h, 5);\n      ctx.globalAlpha = 1.0;\n    }\n\n    const ry = stackGap;\n    ctx.fillStyle = isDark ? 'rgba(58, 64, 74, 0.94)' : 'rgba(214, 231, 255, 0.94)';\n    fillRoundRect(ctx, 0, ry, w, h, 5);\n\n    ctx.strokeStyle = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';\n    ctx.lineWidth = 0.5;\n    ctx.beginPath();\n    ctx.moveTo(5, ry);\n    ctx.arcTo(w, ry, w, ry + h, 5);\n    ctx.arcTo(w, ry + h, 0, ry + h, 5);\n    ctx.arcTo(0, ry + h, 0, ry, 5);\n    ctx.arcTo(0, ry, w, ry, 5);\n    ctx.closePath();\n    ctx.stroke();\n\n    const iconEl = getDragIconEl(entry);\n    if (iconEl) {\n      ctx.drawImage(iconEl, 6, ry + 6, 16, 16);\n    } else {\n      ctx.fillStyle = entry.isDir ? '#d9b34f' : '#8d98a5';\n      fillRoundRect(ctx, 6, ry + 6, 16, 16, 2);\n    }\n\n    ctx.fillStyle = isDark ? '#e6e6e8' : '#1a1a1a';\n    ctx.font = '12px -apple-system, \"SF Pro Text\", system-ui, sans-serif';\n    ctx.textBaseline = 'middle';\n\n    let nameMaxW = w - 34;\n    if (count > 1) nameMaxW -= 34;\n\n    let name = entry.name;\n    if (ctx.measureText(name).width > nameMaxW) {\n      while (name.length > 4 && ctx.measureText(name + '\\u2026').width > nameMaxW) {\n        name = name.slice(0, -1);\n      }\n      name += '\\u2026';\n    }\n    ctx.fillText(name, 28, ry + h / 2 + 1);\n\n    if (count > 1) {\n      const badge = String(count);\n      ctx.font = 'bold 10px -apple-system, system-ui, sans-serif';\n      const tw = ctx.measureText(badge).width;\n      const bw = Math.max(20, tw + 10);\n      const bx = w - bw - 6;\n      const by = ry + (h - 18) / 2;\n\n      ctx.fillStyle = isDark ? '#5b8bd9' : '#007aff';\n      fillRoundRect(ctx, bx, by, bw, 18, 9);\n\n      ctx.fillStyle = '#ffffff';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(badge, bx + bw / 2, by + 9);\n    }\n\n    return canvas.toDataURL('image/png');\n  }\n\n  function handleRowMouseDown(event, index) {\n    if (event.button !== 0) return;\n    if (event.metaKey || event.ctrlKey || event.shiftKey) return;\n    if (editing.active) return;\n\n    const startX = event.clientX;\n    const startY = event.clientY;\n    let dragging = false;\n\n    dragCleanup?.();\n\n    const onMove = (e) => {\n      if (dragging) return;\n      const dx = e.clientX - startX;\n      const dy = e.clientY - startY;\n      if (dx * dx + dy * dy < DRAG_THRESHOLD * DRAG_THRESHOLD) return;\n\n      dragging = true;\n      cleanup();\n\n      if (!selectedIndices.has(index)) {\n        selectSingle(index);\n      }\n\n      const paths = dragPathsForIndex(index);\n      if (paths.length > 0) {\n        const icon = buildDragPreview(index);\n        startDrag({ item: paths, icon }).catch(() => {});\n      }\n    };\n\n    const onUp = () => cleanup();\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      if (dragCleanup === cleanup) dragCleanup = null;\n    };\n\n    dragCleanup = cleanup;\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  async function handleRowDoubleClick(index) {\n    if (!selectedIndices.has(index) || selectedIndices.size > 1) {\n      selectSingle(index);\n      await tick();\n    }\n    await invoke('open', { paths: [results[index].path] }).catch((err) => {\n      showToast(`Failed to open: ${String(err)}`);\n    });\n  }\n\n  function closeContextMenu() {\n    contextMenu = {\n      ...contextMenu,\n      visible: false\n    };\n  }\n\n  async function openSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('open', { paths });\n    } catch (err) {\n      showToast(`Failed to open: ${String(err)}`);\n    }\n  }\n\n  async function openWithFallback() {\n    const target = primaryEntry();\n    if (!target) {\n      return;\n    }\n\n    try {\n      await invoke('open_with', { path: target.path });\n    } catch (err) {\n      showToast(`Open With failed: ${String(err)}`);\n    }\n  }\n\n  async function revealSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('reveal_in_finder', { paths });\n    } catch (err) {\n      showToast(`Failed to reveal in Finder: ${String(err)}`);\n    }\n  }\n\n  async function copySelectedPaths() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_paths', { paths });\n      showToast(`Copied ${paths.length} path(s)`);\n    } catch (err) {\n      showToast(`Failed to copy path: ${String(err)}`);\n    }\n  }\n\n  async function copyFiles() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_files', { paths });\n      showToast(`Copied ${paths.length} item(s)`);\n    } catch (err) {\n      showToast(`Failed to copy: ${String(err)}`);\n    }\n  }\n\n  async function trashSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    const message =\n      paths.length === 1\n        ? 'Move selected item to Trash?'\n        : `Move ${paths.length} items to Trash?`;\n\n    if (!window.confirm(message)) {\n      return;\n    }\n\n    try {\n      await invoke('move_to_trash', { paths });\n      showToast('Moved to Trash.');\n      clearSelection();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to move to Trash: ${String(err)}`);\n    }\n  }\n\n  async function resetIndex() {\n    if (indexStatus.state === 'Indexing') {\n      showToast('Indexing in progress. Please try again after it completes.');\n      return;\n    }\n\n    results = [];\n    totalResults = 0;\n    totalResultsKnown = false;\n    clearSelection();\n    scanned = 0;\n    dbLatencyMs = null;\n    dbLastQuery = '';\n    indexStatus = { ...indexStatus, state: 'Indexing', entriesCount: 0, message: null };\n    indexingStartTime = Date.now();\n    indexingElapsed = '';\n    indexingFinishedAt = '';\n\n    try {\n      await invoke('reset_index');\n    } catch (err) {\n      showToast(`Failed to reset index: ${String(err)}`);\n      await refreshStatus();\n    }\n  }\n\n  function isMultiSelected() {\n    return selectedIndices.size > 1;\n  }\n\n  function autoResizeRenameInput() {\n    if (!renameInputEl) return;\n    renameInputEl.style.height = '0';\n    renameInputEl.style.height = renameInputEl.scrollHeight + 'px';\n  }\n\n  async function startRename() {\n    if (isMultiSelected()) {\n      return;\n    }\n\n    const idx = lastSelectedIndex;\n    if (idx < 0 || !results[idx]) {\n      return;\n    }\n\n    const entry = results[idx];\n\n    // Calculate overlay position mathematically.\n    // Name cell text starts at: padding-left(16) + icon(16) + gap(6) = 38px from cell left.\n    // Textarea has padding-left: 0 and border: 1.5px, so text starts ~2px from overlay left.\n    if (tableContainer) {\n      const rect = tableContainer.getBoundingClientRect();\n      const cellLeft = rect.left - tableContainer.scrollLeft;\n      const textLeft = cellLeft + 38;\n      const cellRight = cellLeft + colWidths.name;\n      const rowTop = rect.top + idx * rowHeight - tableContainer.scrollTop;\n      renameOverlay = {\n        top: rowTop,\n        left: textLeft - 2,\n        width: cellRight - textLeft + 2 - 4\n      };\n    }\n\n    editing = {\n      active: true,\n      path: entry.path,\n      index: idx,\n      draftName: entry.name\n    };\n\n    await tick();\n\n    if (renameInputEl) {\n      autoResizeRenameInput();\n      renameInputEl.focus();\n      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n      renameInputEl.setSelectionRange(0, selectionEnd);\n    }\n  }\n\n  function cancelRename() {\n    editing = {\n      active: false,\n      path: '',\n      index: -1,\n      draftName: ''\n    };\n  }\n\n  async function commitRename() {\n    if (!editing.active || editing.index < 0 || !results[editing.index]) {\n      return;\n    }\n\n    const current = results[editing.index];\n    const nextName = editing.draftName;\n\n    try {\n      await invoke('rename', {\n        path: current.path,\n        newName: nextName\n      });\n      cancelRename();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to rename: ${String(err)}`);\n      await tick();\n      renameInputEl?.focus();\n    }\n  }\n\n  function onGlobalClick() {\n    closeContextMenu();\n  }\n\n  function onTitleBarMouseDown(event) {\n    if (event.button !== 0) {\n      return;\n    }\n\n    const activeElement = document.activeElement;\n    if (activeElement instanceof HTMLElement && isTextInputTarget(activeElement)) {\n      activeElement.blur();\n    }\n  }\n\n  async function focusSearch() {\n    await getCurrentWindow().show();\n    await getCurrentWindow().setFocus();\n    searchInputEl?.focus();\n    searchInputEl?.select();\n  }\n\n  function isTextInputTarget(target) {\n    return (\n      target instanceof HTMLInputElement ||\n      target instanceof HTMLTextAreaElement ||\n      target?.isContentEditable\n    );\n  }\n\n  async function handleKeydown(event) {\n    const isMetaSelectAll = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'a';\n    const isMetaCopy = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c';\n    const target = event.target;\n    const isTextInput = isTextInputTarget(target);\n\n    if (isMetaCopy && isTextInput) {\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      if (isTextInput) {\n        event.preventDefault();\n        if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n          target.select();\n        }\n        return;\n      }\n    }\n\n    if (editing.active) {\n      if (event.key === 'Enter') {\n        event.preventDefault();\n        await commitRename();\n        return;\n      }\n\n      if (event.key === 'Escape') {\n        event.preventDefault();\n        const idx = editing.index;\n        cancelRename();\n        selectSingle(idx);\n        await tick();\n        tableContainer?.querySelector('.row.selected')?.focus();\n        return;\n      }\n      return;\n    }\n\n    if (event.key === 'Escape') {\n      event.preventDefault();\n      clearSelection();\n      return;\n    }\n\n    if (event.key === 'ArrowDown') {\n      event.preventDefault();\n      moveSelection(1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'ArrowUp') {\n      event.preventDefault();\n      moveSelection(-1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageDown') {\n      event.preventDefault();\n      moveSelection(Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageUp') {\n      event.preventDefault();\n      moveSelection(-Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'Enter') {\n      event.preventDefault();\n      if (platform === 'windows') {\n        await openSelected();\n      } else {\n        await startRename();\n      }\n      return;\n    }\n\n    if (event.key === 'F2') {\n      event.preventDefault();\n      await startRename();\n      return;\n    }\n\n    if (event.key === ' ' && !isTextInput) {\n      event.preventDefault();\n      const entry = primaryEntry();\n      if (entry) {\n        await invoke('quick_look', { path: entry.path });\n      }\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'f') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      searchInputEl?.select();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'o') {\n      event.preventDefault();\n      await openSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {\n      event.preventDefault();\n      await revealSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c') {\n      event.preventDefault();\n      await copySelectedPaths();\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      event.preventDefault();\n      selectedIndices = new Set(Array.from({ length: results.length }, (_, i) => i));\n      return;\n    }\n\n    if (event.key === 'Delete' || ((event.metaKey || event.ctrlKey) && event.key === 'Backspace')) {\n      if (!isTextInput) {\n        event.preventDefault();\n        await trashSelected();\n      }\n      return;\n    }\n  }\n\n  function formatSize(entry) {\n    if (entry.isDir || entry.size == null) return '';\n    const bytes = entry.size;\n    if (bytes < 1024) return `${bytes} B`;\n    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n    return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n  }\n\n  function formatModified(entry) {\n    if (!entry.mtime) {\n      return '';\n    }\n\n    const d = new Date(entry.mtime * 1000);\n    const pad = (n) => String(n).padStart(2, '0');\n    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;\n  }\n\n  function formatLastUpdated(timestamp) {\n    if (!timestamp) {\n      return '-';\n    }\n\n    return new Date(timestamp * 1000).toLocaleString();\n  }\n\n  function formatElapsed(ms) {\n    const totalSec = Math.floor(ms / 1000);\n    const min = Math.floor(totalSec / 60);\n    const sec = totalSec % 60;\n    return min > 0 ? `${min}m ${sec}s` : `${sec}s`;\n  }\n\n  function updateElapsed() {\n    if (indexingStartTime && indexStatus.state === 'Indexing') {\n      indexingElapsed = formatElapsed(Date.now() - indexingStartTime);\n    }\n  }\n\n  function startElapsedTimer() {\n    clearInterval(elapsedTimer);\n    indexingStartTime = Date.now();\n    indexingElapsed = '0s';\n    indexingFinishedAt = '';\n    elapsedTimer = setInterval(updateElapsed, 1000);\n  }\n\n  function stopElapsedTimer() {\n    clearInterval(elapsedTimer);\n    if (indexingStartTime) {\n      const elapsed = Date.now() - indexingStartTime;\n      indexingFinishedAt = `${formatElapsed(elapsed)}`;\n    }\n    indexingStartTime = null;\n    indexingElapsed = '';\n  }\n\n  function displayPath(path) {\n    if (!path) {\n      return path;\n    }\n\n    if (!homePrefix) {\n      return path;\n    }\n\n    if (path === homePrefix) {\n      return '~';\n    }\n\n    if (path.startsWith(`${homePrefix}/`)) {\n      return `~${path.slice(homePrefix.length)}`;\n    }\n\n    return path;\n  }\n\n  let unlistenFns = [];\n\n  onMount(async () => {\n    const t0 = performance.now();\n    const ms = () => Math.round(performance.now() - t0);\n    const DEBUG_STARTUP = false;\n    const flog = DEBUG_STARTUP ? (msg) => invoke('frontend_log', { msg }).catch(() => {}) : () => {};\n\n    flog(`[startup/fe] onMount entered`);\n\n    updateViewportHeight();\n    flog(`[startup/fe] +${ms()}ms updateViewportHeight done`);\n\n    invoke('set_native_theme', { theme });\n\n    platform = await invoke('get_platform');\n    flog(`[startup/fe] +${ms()}ms get_platform done`);\n\n    const unlistenProgress = await listen('index_progress', (event) => {\n      scanned = event.payload.scanned;\n      if (indexStatus.state !== 'Indexing') {\n        indexStatus = {\n          ...indexStatus,\n          state: 'Indexing'\n        };\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_progress) registered`);\n\n    const unlistenState = await listen('index_state', (event) => {\n      flog(`[startup/fe] index_state event received: ${event.payload.state} at +${ms()}ms`);\n      const prevState = indexStatus.state;\n      indexStatus = {\n        ...indexStatus,\n        state: event.payload.state,\n        message: event.payload.message ?? null,\n        isCatchup: event.payload.isCatchup ?? false\n      };\n\n      if (event.payload.state === 'Indexing' && prevState !== 'Indexing') {\n        if (prevState === 'Ready') {\n          lastReadyCount = indexStatus.entriesCount;\n        }\n        startElapsedTimer();\n      } else if (event.payload.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n\n      if (event.payload.state === 'Ready') {\n        scheduleSearch();\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_state) registered`);\n\n    const unlistenUpdated = await listen('index_updated', (event) => {\n      indexStatus = {\n        ...indexStatus,\n        entriesCount: event.payload.entriesCount,\n        lastUpdated: event.payload.lastUpdated,\n        permissionErrors: event.payload.permissionErrors ?? indexStatus.permissionErrors\n      };\n\n      scheduleSearch(true);\n    });\n\n    const unlistenFocus = await listen('focus_search', () => {\n      void focusSearch();\n    });\n\n    const unlistenCtxMenuAction = await listen('context_menu_action', (event) => {\n      switch (event.payload) {\n        case 'open': void openSelected(); break;\n        case 'quick_look': {\n          const e = primaryEntry();\n          if (e) void invoke('quick_look', { path: e.path });\n          break;\n        }\n        case 'open_with': void openWithFallback(); break;\n        case 'reveal': void revealSelected(); break;\n        case 'copy_files': void copyFiles(); break;\n        case 'copy_path': void copySelectedPaths(); break;\n        case 'trash': void trashSelected(); break;\n        case 'rename': void startRename(); break;\n      }\n    });\n\n    unlistenFns = [unlistenProgress, unlistenState, unlistenUpdated, unlistenFocus, unlistenCtxMenuAction];\n    flog(`[startup/fe] +${ms()}ms all listeners registered`);\n\n    // Fetch backend state IMMEDIATELY after listeners are registered.\n    // Events emitted before listener registration are lost, so this\n    // is the only reliable way to get the current state.\n    await refreshStatus();\n    flog(`[startup/fe] +${ms()}ms refreshStatus done (state=${indexStatus.state})`);\n\n    // Show Svelte UI: remove skeleton, focus search input.\n    await tick();\n    document.getElementById('skeleton')?.remove();\n    await focusSearch();\n    flog(`[startup/fe] +${ms()}ms WINDOW VISIBLE â€” skeleton removed`);\n\n    try {\n      homePrefix = await invoke('get_home_dir');\n    } catch {\n      homePrefix = '';\n    }\n    flog(`[startup/fe] +${ms()}ms get_home_dir done`);\n\n    if (!localStorage.getItem('everything-fda-notice-v1')) {\n      showToast('macOS Full Disk Access permission may be required for full disk search.');\n      localStorage.setItem('everything-fda-notice-v1', '1');\n    }\n    flog(`[startup/fe] +${ms()}ms calling runSearch...`);\n    await runSearch();\n    flog(`[startup/fe] +${ms()}ms runSearch done`);\n\n    if (typeof ResizeObserver !== 'undefined') {\n      tableResizeObserver = new ResizeObserver(() => {\n        scheduleViewportHeightUpdate();\n      });\n      if (tableContainer) {\n        tableResizeObserver.observe(tableContainer);\n      } else if (tableAreaEl) {\n        tableResizeObserver.observe(tableAreaEl);\n      }\n    }\n\n    window.addEventListener('resize', scheduleViewportHeightUpdate);\n    window.addEventListener('click', onGlobalClick);\n    statusRefreshTimer = setInterval(() => {\n      if (indexStatus.state === 'Indexing') {\n        void refreshStatus();\n      }\n    }, 1000);\n    console.log(`[startup/fe] +${ms()}ms onMount complete`);\n  });\n\n  onDestroy(async () => {\n    clearTimeout(searchTimer);\n    clearTimeout(toastTimer);\n    clearInterval(statusRefreshTimer);\n    clearInterval(elapsedTimer);\n    resizeCleanup?.();\n\n    for (const unlisten of unlistenFns) {\n      unlisten();\n    }\n\n    tableResizeObserver?.disconnect();\n    tableResizeObserver = null;\n    if (viewportResizeRaf !== null) {\n      cancelAnimationFrame(viewportResizeRaf);\n      viewportResizeRaf = null;\n    }\n    window.removeEventListener('resize', scheduleViewportHeightUpdate);\n    window.removeEventListener('click', onGlobalClick);\n  });\n</script>\n\n<svelte:window on:keydown={handleKeydown} />\n\n<div class=\"app-shell\" data-theme={theme}>\n  <div class=\"title-bar\" role=\"presentation\" data-tauri-drag-region on:mousedown={onTitleBarMouseDown}>\n    <div class=\"title-left\"></div>\n    <div class=\"title-center\">\n      <svg class=\"title-icon\" viewBox=\"0 0 215 205\" fill-rule=\"evenodd\" aria-hidden=\"true\">\n        <path d=\"M85 0c46.9 0 85 38.1 85 85 0 20.1-7.2 38.5-19.2 52.7l40.7 40.8c5.8 5.8 5.8 15.2 0 21-5.8 5.8-15.2 5.8-21 0l-40.7-40.7c-13.6 9.7-30.4 15.2-44.8 15.2-46.9 0-85-42.1-85-89 0-46.9 38.1-85 85-85z m0 32c-29.3 0-53 23.7-53 53 0 29.3 23.7 53 53 53 29.3 0 53-23.7 53-53 0-29.3-23.7-53-53-53z\"/>\n      </svg>\n      <span class=\"title-text\">Everything</span>\n    </div>\n    <div class=\"title-right\"></div>\n  </div>\n\n  <header class=\"search-bar\">\n    <input\n      bind:this={searchInputEl}\n      class=\"search-input\"\n      type=\"text\"\n      bind:value={query}\n      on:input={scheduleSearch}\n      on:focus={clearSelection}\n      placeholder=\"Search file/folder names\"\n      autocomplete=\"off\"\n      spellcheck=\"false\"\n    />\n  </header>\n\n  <section class=\"table-area\" bind:this={tableAreaEl} style={tableGridStyle}>\n    <div class=\"table-header\">\n      <div class=\"table-header-track\">\n        <div class=\"col name\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('name')}>\n            Name{#if sortBy === 'name'}{@html sortIconHtml(sortDir)}{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'name'}\n            on:mousedown={(event) => startColumnResize(event, 'name')}\n            aria-label=\"Resize Name column\"\n          />\n        </div>\n\n        <div class=\"col path\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('dir')}>\n            Path{#if sortBy === 'dir'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'path'}\n            on:mousedown={(event) => startColumnResize(event, 'path')}\n            aria-label=\"Resize Path column\"\n          />\n        </div>\n\n        <div class=\"col size\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('size')}>\n            Size{#if sortBy === 'size'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n\n        <div class=\"col modified\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('mtime')}>\n            Modified{#if sortBy === 'mtime'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n      </div>\n    </div>\n\n    <div\n      class=\"table-body\"\n      bind:this={tableContainer}\n      on:scroll={() => {\n        scrollTop = tableContainer.scrollTop;\n        headerScrollLeft = tableContainer.scrollLeft;\n        if (editing.active) void commitRename();\n        const scrollBottom = scrollTop + tableContainer.clientHeight;\n        if (scrollBottom >= totalHeight - rowHeight * 10) {\n          void loadMore();\n        }\n      }}\n    >\n      <div class=\"spacer\" style={`height:${totalHeight}px`}>\n        <div class=\"rows\" style={`transform: translateY(${translateY}px);`}>\n          {#each visibleRows as entry, localIndex}\n            {@const index = startIndex + localIndex}\n            <div\n              class=\"row {selectedIndices.has(index) ? 'selected' : ''}\"\n              on:mousedown={(event) => handleRowMouseDown(event, index)}\n              on:click={(event) => handleRowClick(event, index)}\n              on:keydown={(event) => handleRowA11yKeydown(event, index)}\n              on:dblclick={() => handleRowDoubleClick(index)}\n              on:contextmenu={(event) => handleRowContextMenu(event, index)}\n              role=\"row\"\n              tabindex=\"0\"\n            >\n              <div class=\"cell name\">\n                <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n                <span class=\"ellipsis\" class:name-editing={editing.active && editing.index === index}>{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n              </div>\n              <div class=\"cell path\"><span class=\"ellipsis\">{displayPath(entry.dir)}</span></div>\n              <div class=\"cell size\">{formatSize(entry)}</div>\n              <div class=\"cell modified\">{formatModified(entry)}</div>\n            </div>\n          {/each}\n        </div>\n      </div>\n    </div>\n  </section>\n\n  <footer class=\"status-bar\">\n    <div class=\"status-left\">\n      <span class=\"status-state\">\n        <span class=\"state-dot {indexStatus.state === 'Indexing' ? 'indexing' : indexStatus.state === 'Error' ? 'error' : 'ready'}\"></span>\n        {#if indexStatus.state === 'Indexing'}\n          Indexing{#if lastReadyCount > 0} ({Math.min(99, Math.round((scanned / lastReadyCount) * 100))}%){/if}{#if indexingElapsed} Â· {indexingElapsed}{/if}\n          {#if !indexStatus.isCatchup}\n            Â· {scanned.toLocaleString()} scanned\n          {/if}\n        {:else}\n          Index: {indexStatus.state}\n        {/if}\n      </span>\n      <span>{indexStatus.entriesCount.toLocaleString()} entries</span>\n      {#if indexingFinishedAt && indexStatus.state !== 'Indexing'}\n        <span>in {indexingFinishedAt}</span>\n      {/if}\n      {#if dbLatencyMs !== null && dbLastQuery}\n        <span>\"{dbLastQuery}\" {dbLatencyMs}ms Â· {totalResults} results</span>\n      {/if}\n      {#if searchModeLabel === 'spotlight' || searchModeLabel === 'spotlight_timeout'}\n        <span class=\"status-spotlight\">Spotlight fallback{#if searchModeLabel === 'spotlight_timeout'} (partial){/if}</span>\n      {/if}\n      {#if indexStatus.permissionErrors > 0}\n        <span class=\"status-warning\">{indexStatus.permissionErrors.toLocaleString()} permission errors</span>\n      {/if}\n      {#if indexStatus.message}\n        <span class={indexStatus.isCatchup ? 'index-progress' : 'status-error'}>{indexStatus.message}</span>\n      {/if}\n    </div>\n    <div class=\"status-right\">\n      <button class=\"status-btn\" on:click={cycleTheme} title=\"Switch theme\">\n        {theme === 'dark' ? 'â˜€ Light' : 'â—‘ Dark'}\n      </button>\n      <button\n        class=\"status-btn rebuild-btn\"\n        on:click={resetIndex}\n        disabled={indexStatus.state === 'Indexing'}\n        title={indexStatus.state === 'Indexing' ? 'Cannot reset while indexing is in progress.' : 'Reset and rebuild the index.'}\n      >\n        <svg class=\"rebuild-icon\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n          <path d=\"M23 4v6h-6\"/><path d=\"M20.49 15a9 9 0 1 1-2.12-9.36L23 10\"/>\n        </svg>\n        Rebuild Index\n      </button>\n    </div>\n  </footer>\n\n  {#if editing.active}\n    <div\n      class=\"rename-overlay\"\n      style=\"top:{renameOverlay.top}px; left:{renameOverlay.left}px; width:{renameOverlay.width}px;\"\n      role=\"presentation\"\n      on:mousedown|stopPropagation\n    >\n      <textarea\n        bind:this={renameInputEl}\n        class=\"rename-textarea\"\n        bind:value={editing.draftName}\n        on:input={autoResizeRenameInput}\n        on:click|stopPropagation\n        on:blur={commitRename}\n      />\n    </div>\n  {/if}\n\n  {#if contextMenu.visible}\n    <div class=\"context-menu\" style={`left:${contextMenu.x}px;top:${contextMenu.y}px;`}>\n      <button on:click={() => (closeContextMenu(), openSelected())}>Open</button>\n      <button on:click={async () => { closeContextMenu(); const e = primaryEntry(); if (e) await invoke('quick_look', { path: e.path }); }}>Quick Look</button>\n      <button on:click={() => (closeContextMenu(), openWithFallback())}>Open With... (Reveal in Finder)</button>\n      <button on:click={() => (closeContextMenu(), revealSelected())}>Reveal in Finder</button>\n      <button on:click={() => (closeContextMenu(), copySelectedPaths())}>Copy Path</button>\n      <button on:click={() => (closeContextMenu(), trashSelected())}>Move to Trash</button>\n      {#if selectedIndices.size === 1}\n        <button on:click={() => (closeContextMenu(), startRename())}>Rename</button>\n      {/if}\n    </div>\n  {/if}\n\n  {#if toast}\n    <div class=\"toast\">{toast}</div>\n  {/if}\n</div>\n\n<style>\n  :global(:root) {\n    color-scheme: light dark;\n    --bg-app: transparent;\n    --text-primary: #0d1826;\n    --text-muted: #48596c;\n    --bar-grad-top: rgba(255, 255, 255, 0.48);\n    --bar-grad-bottom: rgba(248, 250, 253, 0.42);\n    --surface-header: rgba(252, 252, 255, 0.40);\n    --surface: rgba(255, 255, 255, 0.22);\n    --border-soft: rgba(0, 0, 0, 0.07);\n    --border-input: rgba(0, 0, 0, 0.13);\n    --focus-ring: #6f96e6;\n    --row-border: rgba(0, 0, 0, 0.032);\n    --row-hover: rgba(0, 0, 0, 0.06);\n    --row-selected: rgba(0, 0, 0, 0.12);\n    --button-bg: rgba(255, 255, 255, 0.62);\n    --button-border: rgba(0, 0, 0, 0.10);\n    --button-text: #2c3e50;\n    --menu-bg: rgba(240, 241, 248, 0.90);\n    --menu-border: rgba(0, 0, 0, 0.06);\n    --menu-hover: rgba(255, 255, 255, 0.62);\n    --menu-text: #1a2a38;\n    --error-text: #b64545;\n    --warning-text: #8f6500;\n    --toast-bg: rgba(18, 22, 32, 0.90);\n    --toast-text: #ffffff;\n  }\n\n  @media (prefers-color-scheme: dark) {\n    :global(:root) {\n      --bg-app: transparent;\n      --text-primary: #e6e6ea;\n      --text-muted: #9494a4;\n      --bar-grad-top: rgba(38, 38, 46, 0.52);\n      --bar-grad-bottom: rgba(30, 30, 38, 0.46);\n      --surface-header: rgba(32, 32, 40, 0.46);\n      --surface: rgba(18, 18, 26, 0.32);\n      --border-soft: rgba(255, 255, 255, 0.065);\n      --border-input: rgba(255, 255, 255, 0.14);\n      --focus-ring: #5b8bd9;\n      --row-border: rgba(255, 255, 255, 0.026);\n      --row-hover: rgba(255, 255, 255, 0.08);\n      --row-selected: rgba(255, 255, 255, 0.14);\n      --button-bg: rgba(255, 255, 255, 0.072);\n      --button-border: rgba(255, 255, 255, 0.11);\n      --button-text: #d6d6e0;\n      --menu-bg: rgba(36, 36, 46, 0.90);\n      --menu-border: rgba(255, 255, 255, 0.066);\n      --menu-hover: rgba(255, 255, 255, 0.062);\n      --menu-text: #e0e0e8;\n      --error-text: #ff9d9d;\n      --warning-text: #e0c670;\n      --toast-bg: rgba(10, 10, 16, 0.93);\n      --toast-text: #f2f2f6;\n    }\n  }\n\n  /* â”€â”€ Theme: Dark â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme=\"dark\"]) {\n    color-scheme: dark;\n    --bg-app: #1E1E21;\n    --text-primary: #E2E8F0;\n    --text-muted: #94A3B8;\n    --bar-grad-top: #1E1E21;\n    --bar-grad-bottom: #1E1E21;\n    --surface-header: #1E1E21;\n    --surface: #1E1E21;\n    --bg-input: #161618;\n    --border-soft: #2A2A2D;\n    --border-input: rgba(255, 255, 255, 0.06);\n    --focus-ring: #4DA8FF;\n    --accent: #4DA8FF;\n    --row-border: rgba(255, 255, 255, 0.02);\n    --row-hover: #282828;\n    --row-selected: rgba(77, 168, 255, 0.10);\n    --button-bg: rgba(255, 255, 255, 0.05);\n    --button-border: #2A2A2D;\n    --button-text: #94A3B8;\n    --menu-bg: #252528;\n    --menu-border: #2A2A2D;\n    --menu-hover: rgba(255, 255, 255, 0.04);\n    --menu-text: #E2E8F0;\n    --error-text: #ff9d9d;\n    --warning-text: #e0c670;\n    --toast-bg: rgba(10, 10, 16, 0.93);\n    --toast-text: #f2f2f6;\n  }\n\n  /* â”€â”€ Theme: Light â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme=\"light\"]) {\n    color-scheme: light;\n    --bg-app: #F5F5F7;\n    --text-primary: #1C1C1E;\n    --text-muted: #6E6E7A;\n    --bar-grad-top: #F5F5F7;\n    --bar-grad-bottom: #F5F5F7;\n    --surface-header: #F5F5F7;\n    --surface: #F5F5F7;\n    --bg-input: #FFFFFF;\n    --border-soft: #D1D1D6;\n    --border-input: rgba(0, 0, 0, 0.10);\n    --focus-ring: #3A8BF5;\n    --accent: #3A8BF5;\n    --row-border: rgba(0, 0, 0, 0.04);\n    --row-hover: rgba(0, 0, 0, 0.04);\n    --row-selected: rgba(58, 139, 245, 0.10);\n    --button-bg: #FFFFFF;\n    --button-border: #D1D1D6;\n    --button-text: #3C3C43;\n    --menu-bg: #FFFFFF;\n    --menu-border: #D1D1D6;\n    --menu-hover: rgba(0, 0, 0, 0.05);\n    --menu-text: #1C1C1E;\n    --error-text: #D93025;\n    --warning-text: #B45309;\n    --toast-bg: rgba(255, 255, 255, 0.95);\n    --toast-text: #1C1C1E;\n  }\n\n  /* â”€â”€ Themed element overrides â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme]) {\n    background: var(--bg-app);\n  }\n\n  /* Search bar: flat, no gradient, no separator */\n  :global([data-theme]) .search-bar {\n    height: 44px;\n    padding: 0 16px;\n    background: var(--bg-app);\n    border-bottom: none;\n  }\n\n  :global([data-theme]) .search-input {\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n    font-family: 'JetBrains Mono', 'SF Mono', monospace;\n    font-size: 12px;\n    height: 34px;\n    border-radius: 8px;\n  }\n\n  /* Table header: flat bg, 16px edge padding */\n  :global([data-theme]) .table-header {\n    background: var(--bg-app);\n  }\n\n  :global([data-theme]) .col-button {\n    padding: 0 8px;\n  }\n\n  :global([data-theme]) .col.name .col-button {\n    padding-left: 16px;\n  }\n\n  /* Row cells: JetBrains Mono, 16px outer edges */\n  :global([data-theme]) .cell {\n    font-family: 'JetBrains Mono', monospace;\n  }\n\n  :global([data-theme]) .cell.name {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    padding-left: 16px;\n    font-size: 12px;\n    color: var(--text-primary);\n  }\n\n  :global([data-theme]) .cell.path {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.size {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.modified {\n    padding-right: 16px;\n    font-size: 11px;\n    white-space: nowrap;\n  }\n\n  :global([data-theme]) .row.selected {\n    box-shadow: inset 3px 0 0 var(--accent);\n  }\n\n  /* Dim path/size/date cells in themed mode */\n  :global([data-theme]) .cell.path,\n  :global([data-theme]) .cell.size,\n  :global([data-theme]) .cell.modified {\n    color: var(--text-muted);\n  }\n\n  :global(:root) {\n    background: transparent;\n  }\n\n  :global(html, body) {\n    margin: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    background: transparent;\n    color: var(--text-primary);\n    font-family: Inter, 'SF Pro Text', 'Segoe UI', Helvetica, Arial, sans-serif;\n  }\n\n  :global(#app) {\n    width: 100%;\n    height: 100%;\n  }\n\n  .app-shell {\n    display: grid;\n    grid-template-rows: auto auto 1fr auto;\n    height: 100%;\n    min-width: 0;\n  }\n\n  .title-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 44px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    cursor: default;\n    flex-shrink: 0;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-left {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-center {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-right {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-icon {\n    width: 14px;\n    height: 14px;\n    fill: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .title-text {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 13px;\n    font-weight: 500;\n    color: var(--text-primary);\n    letter-spacing: -0.01em;\n  }\n\n  .search-bar {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding: 8px;\n    background: linear-gradient(180deg, var(--bar-grad-top) 0%, var(--bar-grad-bottom) 100%);\n    border-bottom: 1px solid var(--border-soft);\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .search-input {\n    display: block;\n    box-sizing: border-box;\n    width: 100%;\n    min-width: 0;\n    flex: 1 1 auto;\n    height: 36px;\n    border: 1px solid var(--border-input);\n    border-radius: 14px;\n    padding: 0 10px;\n    font-size: 14px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    backdrop-filter: blur(12px) saturate(160%);\n    -webkit-backdrop-filter: blur(12px) saturate(160%);\n  }\n\n  .search-input::placeholder {\n    color: var(--text-muted);\n    opacity: 0.85;\n    font-size: 12px;\n  }\n\n  .search-input:focus {\n    outline: none;\n    border-color: var(--focus-ring);\n    box-shadow: 0 0 0 2px rgba(125, 169, 255, 0.25);\n  }\n\n  .table-area {\n    display: grid;\n    grid-template-rows: auto 1fr;\n    min-height: 0;\n    min-width: 0;\n  }\n\n  .table-header-track,\n  .row {\n    display: grid;\n    grid-template-columns: var(--col-name) var(--col-path) var(--col-size) var(--col-modified);\n    align-items: center;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .table-header {\n    height: 32px;\n    border-bottom: 1px solid var(--border-soft);\n    background: var(--surface-header);\n    user-select: none;\n    overflow: hidden;\n    flex-shrink: 0;\n  }\n\n  .table-header-track {\n    height: 100%;\n    transform: translateX(var(--header-offset, 0px));\n    will-change: transform;\n  }\n\n  .table-header .col {\n    position: relative;\n    min-width: 0;\n    height: 100%;\n  }\n\n  .col-button {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n    gap: 4px;\n    box-sizing: border-box;\n    padding: 0 8px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 11px;\n    font-weight: 600;\n    line-height: 1;\n    color: var(--text-muted);\n    text-align: left;\n    margin: 0;\n    border: none;\n    background: transparent;\n    cursor: pointer;\n  }\n\n  .sort-icon {\n    width: 10px;\n    height: 10px;\n    flex-shrink: 0;\n    color: var(--accent);\n  }\n\n  .col-resizer {\n    position: absolute;\n    top: 0;\n    right: -4px;\n    width: 8px;\n    height: 100%;\n    border: none;\n    padding: 0;\n    background: transparent;\n    cursor: col-resize;\n    z-index: 30;\n  }\n\n  .col-resizer::after {\n    content: '';\n    position: absolute;\n    top: 7px;\n    bottom: 7px;\n    left: 50%;\n    width: 1px;\n    transform: translateX(-50%);\n    background: var(--border-soft);\n    opacity: 0;\n    transition: opacity 0.15s ease;\n  }\n\n  .table-header .col:hover .col-resizer::after,\n  .col-resizer.active::after {\n    opacity: 1;\n  }\n\n  .table-body {\n    overflow: auto;\n    min-height: 0;\n    min-width: 0;\n    background: var(--surface);\n  }\n\n  .spacer {\n    position: relative;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .rows {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .row {\n    height: 30px;\n    border-bottom: 1px solid var(--row-border);\n    cursor: default;\n    -webkit-user-select: none;\n    user-select: none;\n    outline: none;\n  }\n\n  .row:hover {\n    background: var(--row-hover);\n  }\n\n  .row.selected {\n    background: var(--row-selected);\n  }\n\n  .cell {\n    padding: 0 8px;\n    font-size: 12px;\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    min-width: 0;\n  }\n\n  .cell.size {\n    text-align: right;\n    font-variant-numeric: tabular-nums;\n  }\n\n  .ellipsis {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n\n  .hl {\n    background: none;\n    color: inherit;\n    font-weight: 700;\n  }\n\n  .file-icon {\n    width: 16px;\n    height: 16px;\n    flex: 0 0 auto;\n  }\n\n  .name-editing {\n    opacity: 0.25;\n  }\n\n  .rename-overlay {\n    position: fixed;\n    z-index: 100;\n    min-width: 120px;\n  }\n\n  .rename-textarea {\n    display: block;\n    width: 100%;\n    box-sizing: border-box;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 12px;\n    line-height: 18px;\n    padding: 5px 4px 5px 0;\n    border: 1.5px solid var(--focus-ring);\n    border-radius: 4px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    outline: none;\n    resize: none;\n    overflow: hidden;\n    box-shadow: 0 2px 14px rgba(0, 0, 0, 0.22), 0 0 0 3px rgba(77, 168, 255, 0.13);\n  }\n\n  .status-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 32px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    border-top: 1px solid var(--border-soft);\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 11px;\n    color: var(--text-muted);\n    white-space: nowrap;\n    overflow: hidden;\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .status-left {\n    display: flex;\n    align-items: center;\n    gap: 16px;\n    overflow: hidden;\n    min-width: 0;\n  }\n\n  .status-right {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    flex-shrink: 0;\n  }\n\n  .status-btn {\n    border: 1px solid var(--button-border);\n    border-radius: 5px;\n    background: var(--button-bg);\n    color: var(--button-text);\n    font-size: 11px;\n    height: 22px;\n    padding: 0 8px;\n    cursor: pointer;\n  }\n\n  .status-btn:hover {\n    filter: brightness(1.06);\n  }\n\n  .status-btn:disabled {\n    opacity: 0.55;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .status-state {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n  }\n\n  .state-dot {\n    width: 6px;\n    height: 6px;\n    border-radius: 50%;\n    flex-shrink: 0;\n  }\n\n  .state-dot.ready { background: #28C840; }\n  .state-dot.indexing { background: #FEBC2E; }\n  .state-dot.error { background: #FF5F57; }\n\n  .rebuild-btn {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 10px;\n    font-weight: 500;\n    background: var(--button-bg);\n    border: 1px solid var(--button-border);\n    border-radius: 4px;\n    color: var(--button-text);\n    height: 22px;\n    padding: 0 10px;\n    cursor: pointer;\n  }\n\n  .rebuild-btn:hover {\n    filter: brightness(1.1);\n  }\n\n  .rebuild-btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .rebuild-icon {\n    width: 11px;\n    height: 11px;\n    color: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .status-error {\n    color: var(--error-text);\n  }\n\n  .status-warning {\n    color: var(--warning-text);\n  }\n\n  .status-spotlight {\n    color: #f59e0b;\n    font-weight: 600;\n  }\n\n  .context-menu {\n    position: fixed;\n    z-index: 200;\n    width: 220px;\n    border: 1px solid var(--menu-border);\n    border-radius: 10px;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.16), inset 0 0 0 0.5px rgba(255, 255, 255, 0.18);\n    background: var(--menu-bg);\n    backdrop-filter: blur(28px) saturate(180%);\n    -webkit-backdrop-filter: blur(28px) saturate(180%);\n    overflow: hidden;\n  }\n\n  .context-menu button {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    padding: 8px 10px;\n    font-size: 12px;\n    color: var(--menu-text);\n  }\n\n  .context-menu button:hover {\n    background: var(--menu-hover);\n  }\n\n  .toast {\n    position: fixed;\n    right: 14px;\n    bottom: 18px;\n    background: var(--toast-bg);\n    color: var(--toast-text);\n    border-radius: 10px;\n    padding: 9px 12px;\n    font-size: 12px;\n    z-index: 250;\n    backdrop-filter: blur(20px) saturate(180%);\n    -webkit-backdrop-filter: blur(20px) saturate(180%);\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);\n  }\n</style>\n","structuredPatch":[{"oldStart":1470,"oldLines":7,"newStart":1470,"newLines":7,"lines":[" ","         <div class=\"col path\">","           <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('dir')}>","-            Path{#if sortBy === 'dir'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}","+            Path{#if sortBy === 'dir'}{@html sortIconHtml(sortDir)}{/if}","           </button>","           <button","             type=\"button\""]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"5c81ebff-1bd8-4271-ba47-7aff2ad2b2de"}
{"parentUuid":"ce88a12a-2ca0-4805-9f25-bdfaf85f040b","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01DctzV9JDeAoDWdU5LrjnB5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YbSYCid7paDwRdnCiMz3Rq","name":"Edit","input":{"replace_all":false,"file_path":"/Users/al02402336/everything/src/App.svelte","old_string":"            Size{#if sortBy === 'size'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}","new_string":"            Size{#if sortBy === 'size'}{@html sortIconHtml(sortDir)}{/if}"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":316,"cache_read_input_tokens":100521,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":316},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPQwv6fqHvxeUuizshh","type":"assistant","uuid":"b7d7c7c8-fd3d-4c82-bcc4-2400059f6ce5","timestamp":"2026-02-21T14:40:03.207Z"}
{"parentUuid":"b7d7c7c8-fd3d-4c82-bcc4-2400059f6ce5","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01YbSYCid7paDwRdnCiMz3Rq","toolUseID":"toolu_01YbSYCid7paDwRdnCiMz3Rq","timestamp":"2026-02-21T14:40:03.214Z","uuid":"4b3f482d-dd8c-40db-890e-ec7743962038"}
{"parentUuid":"b7d7c7c8-fd3d-4c82-bcc4-2400059f6ce5","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YbSYCid7paDwRdnCiMz3Rq","type":"tool_result","content":"The file /Users/al02402336/everything/src/App.svelte has been updated successfully."}]},"uuid":"c6a00b27-07ce-46c8-b66a-a3d3b0295ad3","timestamp":"2026-02-21T14:40:03.213Z","toolUseResult":{"filePath":"/Users/al02402336/everything/src/App.svelte","oldString":"            Size{#if sortBy === 'size'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}","newString":"            Size{#if sortBy === 'size'}{@html sortIconHtml(sortDir)}{/if}","originalFile":"<script>\n  import { onDestroy, onMount, tick } from 'svelte';\n  import { invoke } from '@tauri-apps/api/core';\n  import { listen } from '@tauri-apps/api/event';\n  import { getCurrentWindow } from '@tauri-apps/api/window';\n  import { startDrag } from '@crabnebula/tauri-plugin-drag';\n\n  const rowHeight = 30;\n  const PAGE_SIZE = 500;\n  let homePrefix = '';\n  const COL_WIDTHS_KEY = 'REDACTED';\n  const THEME_KEY = 'everything-theme';\n  const columnKeys = ['name', 'path', 'size', 'modified'];\n  const minColumnWidth = {\n    name: 180,\n    path: 240,\n    size: 75,\n    modified: 150\n  };\n  const defaultColumnRatios = {\n    name: 0.3,\n    path: 0.45,\n    size: 0.1\n  };\n\n  const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';\n  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || systemTheme; } catch { return systemTheme; } })();\n  function cycleTheme() {\n    theme = theme === 'dark' ? 'light' : 'dark';\n    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n    invoke('set_native_theme', { theme });\n  }\n\n  function sortIconHtml(dir) {\n    const d = dir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5';\n    return `<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"${d}\"/></svg>`;\n  }\n\n  let query = '';\n  let results = [];\n  let totalResults = 0;\n  let totalResultsKnown = false;\n\n  let dbLatencyMs = null;\n  let dbLastQuery = '';\n  let searchModeLabel = '';\n  let selectedIndices = new Set();\n  let selectionAnchor = -1;\n  let lastSelectedIndex = -1;\n  let editing = {\n    active: false,\n    path: '',\n    index: -1,\n    draftName: ''\n  };\n\n  let renameOverlay = { top: 0, left: 0, width: 0 };\n\n  let indexStatus = {\n    state: 'Indexing',\n    entriesCount: 0,\n    lastUpdated: null,\n    permissionErrors: 0,\n    message: null,\n    isCatchup: false\n  };\n\n  let indexingStartTime = null;\n  let indexingElapsed = '';\n  let indexingFinishedAt = '';\n\n  let sortBy = 'name';\n  let sortDir = 'asc';\n\n  let hasMore = true;\n  let loadingMore = false;\n  let searchGeneration = 0;\n\n  let scanned = 0;\n\n  let searchInputEl;\n  let renameInputEl;\n  let tableAreaEl;\n  let tableContainer;\n  let tableResizeObserver = null;\n  let viewportResizeRaf = null;\n  let scrollTop = 0;\n  let headerScrollLeft = 0;\n  let viewportHeight = 520;\n  let lastTableWidth = 0;\n  let resizingColumn = '';\n  let resizeCleanup = null;\n  let colWidths = {\n    name: 250,\n    path: 350,\n    size: 75,\n    modified: 150\n  };\n\n  let contextMenu = {\n    visible: false,\n    x: 0,\n    y: 0\n  };\n\n  let platform = '';\n  let toast = '';\n  let searchTimer;\n  let lastSearchFiredAt = 0;\n  let toastTimer;\n  let statusRefreshTimer;\n  let elapsedTimer;\n  let statusRefreshInFlight = false;\n  let lastReadyCount = 0;\n\n  const iconCache = new Map();\n  const iconLoading = new Set();\n\n  let highlightCache = new Map();\n  let highlightCacheQuery = '';\n\n  const folderFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='1' y='4' width='14' height='10' rx='2' fill='#d9b34f'/><rect x='1' y='2' width='6' height='4' rx='1' fill='#e6ca7a'/></svg>`\n    );\n  const fileFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='3' y='1' width='10' height='14' rx='1.5' fill='#b4bec9'/><rect x='5' y='5' width='6' height='1.2' fill='#8d98a5'/><rect x='5' y='8' width='6' height='1.2' fill='#8d98a5'/></svg>`\n    );\n\n  $: totalHeight = results.length * rowHeight;\n  $: startIndex = Math.max(0, Math.floor(scrollTop / rowHeight) - 10);\n  $: visibleCount = Math.ceil(viewportHeight / rowHeight) + 20;\n  $: endIndex = Math.min(results.length, startIndex + visibleCount);\n  $: visibleRows = results.slice(startIndex, endIndex);\n  $: translateY = startIndex * rowHeight;\n  $: tableMinWidth = colWidths.name + colWidths.path + colWidths.size + colWidths.modified;\n  $: tableGridStyle = `--col-name:${colWidths.name}px;--col-path:${colWidths.path}px;--col-size:${colWidths.size}px;--col-modified:${colWidths.modified}px;--table-min-width:${tableMinWidth}px;--header-offset:${-headerScrollLeft}px;`;\n\n  $: {\n    for (const entry of visibleRows) {\n      void ensureIcon(entry);\n    }\n  }\n\n  function showToast(message) {\n    toast = message;\n    clearTimeout(toastTimer);\n    toastTimer = setTimeout(() => {\n      toast = '';\n    }, 3000);\n  }\n\n  function bytesToBase64(bytes) {\n    let binary = '';\n    const chunk = 0x8000;\n    for (let i = 0; i < bytes.length; i += chunk) {\n      const part = bytes.subarray(i, i + chunk);\n      binary += String.fromCharCode(...part);\n    }\n    return btoa(binary);\n  }\n\n  function highlightSegments(name, q) {\n    q = (q || '').trim();\n    if (!q) return [{ text: name, hl: false }];\n\n    // Reset cache when query changes\n    if (q !== highlightCacheQuery) {\n      highlightCache = new Map();\n      highlightCacheQuery = q;\n    }\n\n    // Check cache\n    const cached = highlightCache.get(name);\n    if (cached) return cached;\n\n    if (q.includes('/')) q = q.slice(q.lastIndexOf('/') + 1);\n    q = q.replace(/[*?]/g, '');\n    const terms = q.split(/\\s+/).filter(Boolean);\n    if (terms.length === 0) return [{ text: name, hl: false }];\n\n    const lower = name.toLowerCase();\n    const marks = new Uint8Array(name.length);\n    for (const t of terms) {\n      const tl = t.toLowerCase();\n      let idx = lower.indexOf(tl);\n      while (idx !== -1) {\n        for (let i = idx; i < idx + tl.length; i++) marks[i] = 1;\n        idx = lower.indexOf(tl, idx + 1);\n      }\n    }\n\n    const segs = [];\n    let i = 0;\n    while (i < name.length) {\n      const m = marks[i];\n      let j = i + 1;\n      while (j < name.length && marks[j] === m) j++;\n      segs.push({ text: name.slice(i, j), hl: m === 1 });\n      i = j;\n    }\n\n    highlightCache.set(name, segs);\n    return segs;\n  }\n\n  const perFileIconExts = new Set(['exe', 'lnk', 'ico', 'url', 'scr', 'appx']);\n\n  function iconKey(entry) {\n    if (entry.isDir) return '__folder__';\n    const ext = (entry.ext || '').toLowerCase();\n    if (perFileIconExts.has(ext)) return entry.path;\n    return ext || '__file__';\n  }\n\n  function iconFor(entry) {\n    return iconCache.get(iconKey(entry)) || (entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n  }\n\n  async function ensureIcon(entry) {\n    const key = iconKey(entry);\n    if (iconCache.has(key) || iconLoading.has(key)) {\n      return;\n    }\n\n    iconLoading.add(key);\n    try {\n      const bytes = await invoke('get_file_icon', {\n        path: entry.path,\n        ext: entry.isDir ? 'folder' : entry.ext || '',\n      });\n      if (Array.isArray(bytes) && bytes.length > 0) {\n        const image = `data:image/png;base64,${bytesToBase64(Uint8Array.from(bytes))}`;\n        iconCache.set(key, image);\n      } else {\n        iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n      }\n    } catch {\n      iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n    } finally {\n      iconLoading.delete(key);\n    }\n  }\n\n  function syncColumnWidthsToContainer() {\n    const width = tableContainer?.clientWidth || tableAreaEl?.clientWidth;\n    if (!width || lastTableWidth !== 0) {\n      return;\n    }\n\n    const saved = loadColWidths();\n    if (saved) {\n      const total = columnKeys.reduce((s, k) => s + saved[k], 0);\n      if (Math.abs(total - width) > 2) {\n        const scale = (width - saved.modified) / (total - saved.modified);\n        let scaledName = Math.max(minColumnWidth.name, Math.round(saved.name * scale));\n        let scaledSize = Math.max(minColumnWidth.size, Math.round(saved.size * scale));\n        let rawPath = width - saved.modified - scaledName - scaledSize;\n        if (rawPath < minColumnWidth.path) {\n          const shortfall = minColumnWidth.path - rawPath;\n          const nameReduction = Math.min(shortfall, scaledName - minColumnWidth.name);\n          scaledName -= nameReduction;\n          const remaining = shortfall - nameReduction;\n          if (remaining > 0) {\n            scaledSize -= Math.min(remaining, scaledSize - minColumnWidth.size);\n          }\n          rawPath = width - saved.modified - scaledName - scaledSize;\n        }\n        const scaledPath = Math.max(minColumnWidth.path, rawPath);\n        colWidths = { name: scaledName, path: scaledPath, size: scaledSize, modified: saved.modified };\n      } else {\n        colWidths = saved;\n      }\n    } else {\n      const fixedModified = minColumnWidth.modified;\n      const rest = width - fixedModified;\n      const ratioSum = defaultColumnRatios.name + defaultColumnRatios.path + defaultColumnRatios.size;\n      colWidths = {\n        name: Math.max(minColumnWidth.name, Math.round(rest * defaultColumnRatios.name / ratioSum)),\n        path: Math.max(minColumnWidth.path, Math.round(rest * defaultColumnRatios.path / ratioSum)),\n        size: Math.max(minColumnWidth.size, Math.round(rest * defaultColumnRatios.size / ratioSum)),\n        modified: fixedModified\n      };\n    }\n    lastTableWidth = width;\n  }\n\n  function loadColWidths() {\n    try {\n      const raw = localStorage.getItem(COL_WIDTHS_KEY);\n      if (!raw) return null;\n      const parsed = JSON.parse(raw);\n      for (const key of columnKeys) {\n        if (typeof parsed[key] !== 'number' || parsed[key] < (minColumnWidth[key] || 0)) return null;\n      }\n      return parsed;\n    } catch {\n      return null;\n    }\n  }\n\n  function saveColWidths() {\n    localStorage.setItem(COL_WIDTHS_KEY, JSON.stringify(colWidths));\n  }\n\n  function updateViewportHeight() {\n    viewportHeight = tableContainer?.clientHeight || 520;\n    syncColumnWidthsToContainer();\n  }\n\n  function scheduleViewportHeightUpdate() {\n    if (viewportResizeRaf !== null) {\n      return;\n    }\n    viewportResizeRaf = requestAnimationFrame(() => {\n      viewportResizeRaf = null;\n      updateViewportHeight();\n    });\n  }\n\n  function startColumnResize(event, leftKey) {\n    event.preventDefault();\n    event.stopPropagation();\n\n    const index = columnKeys.indexOf(leftKey);\n    if (index < 0 || index >= columnKeys.length - 1) {\n      return;\n    }\n\n    const startX = event.clientX;\n    const startLeft = colWidths[leftKey];\n    const rightKey = columnKeys[index + 1];\n    const startRight = colWidths[rightKey];\n\n    resizeCleanup?.();\n    resizingColumn = leftKey;\n\n    const onMove = (moveEvent) => {\n      const delta = Math.round(moveEvent.clientX - startX);\n      if (leftKey === 'name') {\n        // Two-column trade: name and path swap space, each respects its minimum\n        const nextLeft = Math.max(\n          minColumnWidth[leftKey],\n          Math.min(startLeft + delta, startLeft + startRight - minColumnWidth[rightKey])\n        );\n        const nextRight = startLeft + startRight - nextLeft;\n        colWidths = { ...colWidths, [leftKey]: nextLeft, [rightKey]: nextRight };\n      } else {\n        // path splitter: path grows unconstrained (allows horizontal scroll on right drag)\n        const nextLeft = Math.max(minColumnWidth[leftKey], startLeft + delta);\n        colWidths = { ...colWidths, [leftKey]: nextLeft };\n      }\n    };\n\n    const onUp = () => {\n      cleanup();\n    };\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      document.body.style.cursor = '';\n      document.body.style.userSelect = '';\n      resizingColumn = '';\n      saveColWidths();\n      if (resizeCleanup === cleanup) {\n        resizeCleanup = null;\n      }\n    };\n\n    resizeCleanup = cleanup;\n    document.body.style.cursor = 'col-resize';\n    document.body.style.userSelect = 'none';\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  function selectedPaths() {\n    const sorted = [...selectedIndices].sort((a, b) => a - b);\n    return sorted.map((idx) => results[idx]).filter(Boolean).map((entry) => entry.path);\n  }\n\n  function clearSelection() {\n    selectedIndices = new Set();\n    selectionAnchor = -1;\n    lastSelectedIndex = -1;\n  }\n\n  function selectSingle(index) {\n    selectedIndices = new Set([index]);\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectToggle(index) {\n    const next = new Set(selectedIndices);\n    if (next.has(index)) {\n      next.delete(index);\n    } else {\n      next.add(index);\n    }\n    selectedIndices = next;\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectRange(index) {\n    const anchor = selectionAnchor >= 0 ? selectionAnchor : index;\n    const [from, to] = [Math.min(anchor, index), Math.max(anchor, index)];\n    const next = new Set();\n    for (let i = from; i <= to; i += 1) {\n      next.add(i);\n    }\n    selectedIndices = next;\n    lastSelectedIndex = index;\n  }\n\n  function primaryEntry() {\n    const idx = lastSelectedIndex >= 0 ? lastSelectedIndex : -1;\n    return idx >= 0 ? results[idx] : null;\n  }\n\n  async function refreshStatus() {\n    if (statusRefreshInFlight) {\n      return;\n    }\n    statusRefreshInFlight = true;\n    try {\n      const status = await invoke('get_index_status');\n      const prevState = indexStatus.state;\n      indexStatus = {\n        state: status.state,\n        entriesCount: status.entriesCount,\n        lastUpdated: status.lastUpdated,\n        permissionErrors: status.permissionErrors ?? 0,\n        message: status.message\n      };\n      if (status.state === 'Indexing' && prevState !== 'Indexing') {\n        startElapsedTimer();\n      } else if (status.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n      if (typeof status.scanned === 'number') {\n        scanned = status.scanned;\n      }\n      if (status.state === 'Ready' && prevState !== 'Ready') {\n        scheduleSearch();\n      }\n    } catch (err) {\n      showToast(`Failed to get status: ${String(err)}`);\n    } finally {\n      statusRefreshInFlight = false;\n    }\n  }\n\n  function scheduleSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const scheduledGen = searchGeneration;\n    clearTimeout(searchTimer);\n\n    const now = performance.now();\n    if (now - lastSearchFiredAt >= 200) {\n      // Leading edge: fire immediately if enough time has passed\n      lastSearchFiredAt = now;\n      void runSearch(preserveScroll);\n    } else {\n      // Trailing edge: debounce\n      searchTimer = setTimeout(() => {\n        if (scheduledGen !== searchGeneration) {\n          return;\n        }\n        lastSearchFiredAt = performance.now();\n        void runSearch(preserveScroll);\n      }, 200);\n    }\n  }\n\n  async function runSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const gen = searchGeneration;\n    const searchQuery = query;\n    const searchSortBy = sortBy;\n    const searchSortDir = sortDir;\n    const startedAt = performance.now();\n    try {\n      const keepPaths = new Set(selectedPaths());\n      const next = await invoke('search', {\n        query: searchQuery,\n        limit: PAGE_SIZE,\n        offset: 0,\n        sortBy: searchSortBy,\n        sortDir: searchSortDir\n      });\n\n      if (gen !== searchGeneration) return;\n\n      dbLatencyMs = Math.round(performance.now() - startedAt);\n      dbLastQuery = searchQuery;\n      const entries = Array.isArray(next.entries) ? next.entries : [];\n      searchModeLabel = next.modeLabel || '';\n      results = entries;\n      if (next.totalCount > 0) {\n        totalResults = next.totalCount;\n        totalResultsKnown = true;\n      } else {\n        totalResults = entries.length;\n        totalResultsKnown = false;\n      }\n      hasMore = totalResultsKnown ? results.length < totalResults : entries.length >= PAGE_SIZE;\n      if (!preserveScroll && tableContainer) tableContainer.scrollTop = 0;\n\n      const restored = new Set();\n      for (let i = 0; i < results.length; i += 1) {\n        if (keepPaths.has(results[i].path)) {\n          restored.add(i);\n        }\n      }\n      selectedIndices = restored;\n\n      updateViewportHeight();\n    } catch (err) {\n      if (gen !== searchGeneration) return;\n      showToast(`Search failed: ${String(err)}`);\n    }\n  }\n\n  async function loadMore() {\n    if (!hasMore || loadingMore) return;\n    const gen = searchGeneration;\n    loadingMore = true;\n    try {\n      const batch = await invoke('search', {\n        query,\n        limit: PAGE_SIZE,\n        offset: results.length,\n        sortBy: sortBy,\n        sortDir: sortDir\n      });\n      if (gen !== searchGeneration) return;\n      const arr = Array.isArray(batch.entries) ? batch.entries : [];\n      if (arr.length > 0) results = [...results, ...arr];\n      hasMore = totalResultsKnown ? results.length < totalResults : arr.length >= PAGE_SIZE;\n    } catch (err) {\n      showToast(`Failed to load more: ${String(err)}`);\n    } finally {\n      loadingMore = false;\n    }\n  }\n\n  function moveSelection(delta, withRange = false) {\n    if (results.length === 0) {\n      return;\n    }\n\n    const current = lastSelectedIndex >= 0 ? lastSelectedIndex : 0;\n    const next = Math.max(0, Math.min(results.length - 1, current + delta));\n\n    if (withRange) {\n      selectRange(next);\n    } else {\n      selectSingle(next);\n    }\n\n    const top = next * rowHeight;\n    const bottom = top + rowHeight;\n    if (top < scrollTop) {\n      tableContainer.scrollTop = top;\n    } else if (bottom > scrollTop + viewportHeight) {\n      tableContainer.scrollTop = bottom - viewportHeight;\n    }\n  }\n\n  function handleHeaderSort(column) {\n    if (sortBy === column) {\n      sortDir = sortDir === 'asc' ? 'desc' : 'asc';\n    } else {\n      sortBy = column;\n      sortDir = 'asc';\n    }\n    if (tableContainer) tableContainer.scrollTop = 0;\n    void runSearch();\n  }\n\n  function handleRowClick(event, index) {\n    contextMenu.visible = false;\n\n    if (event.shiftKey) {\n      selectRange(index);\n      return;\n    }\n\n    if (event.metaKey || event.ctrlKey) {\n      selectToggle(index);\n      return;\n    }\n\n    selectSingle(index);\n  }\n\n  function handleRowContextMenu(event, index) {\n    event.preventDefault();\n\n    if (!selectedIndices.has(index)) {\n      selectSingle(index);\n    }\n\n    if (platform === 'windows' || platform === 'macos') {\n      contextMenu.visible = false;\n      const paths = selectedPaths();\n      if (paths.length > 0) {\n        invoke('show_context_menu', {\n          paths,\n          x: event.clientX,\n          y: event.clientY,\n          singleSelection: selectedIndices.size === 1\n        });\n      }\n      return;\n    }\n\n    contextMenu = {\n      visible: true,\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n\n  function handleRowA11yKeydown(event, index) {\n    if (event.key === ' ' || event.key === 'Enter') {\n      event.preventDefault();\n      handleRowClick(event, index);\n    }\n  }\n\n  const DRAG_THRESHOLD = 5;\n  let dragCleanup = null;\n  const dragImgCache = new Map();\n\n  function dragPathsForIndex(index) {\n    const entry = results[index];\n    if (!entry) {\n      return [];\n    }\n\n    if (selectedIndices.has(index) && selectedIndices.size > 0) {\n      return selectedPaths();\n    }\n\n    return [entry.path];\n  }\n\n  function getDragIconEl(entry) {\n    const src = iconFor(entry);\n    let img = dragImgCache.get(src);\n    if (!img) {\n      img = new Image();\n      img.src = src;\n      dragImgCache.set(src, img);\n    }\n    return img.complete && img.naturalWidth > 0 ? img : null;\n  }\n\n  function fillRoundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function buildDragPreview(index) {\n    const entry = results[index];\n    if (!entry) return null;\n\n    const count = selectedIndices.has(index) ? selectedIndices.size : 1;\n    const isDark = theme === 'dark';\n\n    const w = 260;\n    const h = 28;\n    const stackGap = count > 1 ? 4 : 0;\n\n    const canvas = document.createElement('canvas');\n    canvas.width = w;\n    canvas.height = h + stackGap;\n    const ctx = canvas.getContext('2d');\n\n    if (count > 1) {\n      ctx.globalAlpha = 0.35;\n      ctx.fillStyle = isDark ? '#5a6070' : '#b0c4de';\n      fillRoundRect(ctx, 3, 0, w - 3, h, 5);\n      ctx.globalAlpha = 1.0;\n    }\n\n    const ry = stackGap;\n    ctx.fillStyle = isDark ? 'rgba(58, 64, 74, 0.94)' : 'rgba(214, 231, 255, 0.94)';\n    fillRoundRect(ctx, 0, ry, w, h, 5);\n\n    ctx.strokeStyle = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';\n    ctx.lineWidth = 0.5;\n    ctx.beginPath();\n    ctx.moveTo(5, ry);\n    ctx.arcTo(w, ry, w, ry + h, 5);\n    ctx.arcTo(w, ry + h, 0, ry + h, 5);\n    ctx.arcTo(0, ry + h, 0, ry, 5);\n    ctx.arcTo(0, ry, w, ry, 5);\n    ctx.closePath();\n    ctx.stroke();\n\n    const iconEl = getDragIconEl(entry);\n    if (iconEl) {\n      ctx.drawImage(iconEl, 6, ry + 6, 16, 16);\n    } else {\n      ctx.fillStyle = entry.isDir ? '#d9b34f' : '#8d98a5';\n      fillRoundRect(ctx, 6, ry + 6, 16, 16, 2);\n    }\n\n    ctx.fillStyle = isDark ? '#e6e6e8' : '#1a1a1a';\n    ctx.font = '12px -apple-system, \"SF Pro Text\", system-ui, sans-serif';\n    ctx.textBaseline = 'middle';\n\n    let nameMaxW = w - 34;\n    if (count > 1) nameMaxW -= 34;\n\n    let name = entry.name;\n    if (ctx.measureText(name).width > nameMaxW) {\n      while (name.length > 4 && ctx.measureText(name + '\\u2026').width > nameMaxW) {\n        name = name.slice(0, -1);\n      }\n      name += '\\u2026';\n    }\n    ctx.fillText(name, 28, ry + h / 2 + 1);\n\n    if (count > 1) {\n      const badge = String(count);\n      ctx.font = 'bold 10px -apple-system, system-ui, sans-serif';\n      const tw = ctx.measureText(badge).width;\n      const bw = Math.max(20, tw + 10);\n      const bx = w - bw - 6;\n      const by = ry + (h - 18) / 2;\n\n      ctx.fillStyle = isDark ? '#5b8bd9' : '#007aff';\n      fillRoundRect(ctx, bx, by, bw, 18, 9);\n\n      ctx.fillStyle = '#ffffff';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(badge, bx + bw / 2, by + 9);\n    }\n\n    return canvas.toDataURL('image/png');\n  }\n\n  function handleRowMouseDown(event, index) {\n    if (event.button !== 0) return;\n    if (event.metaKey || event.ctrlKey || event.shiftKey) return;\n    if (editing.active) return;\n\n    const startX = event.clientX;\n    const startY = event.clientY;\n    let dragging = false;\n\n    dragCleanup?.();\n\n    const onMove = (e) => {\n      if (dragging) return;\n      const dx = e.clientX - startX;\n      const dy = e.clientY - startY;\n      if (dx * dx + dy * dy < DRAG_THRESHOLD * DRAG_THRESHOLD) return;\n\n      dragging = true;\n      cleanup();\n\n      if (!selectedIndices.has(index)) {\n        selectSingle(index);\n      }\n\n      const paths = dragPathsForIndex(index);\n      if (paths.length > 0) {\n        const icon = buildDragPreview(index);\n        startDrag({ item: paths, icon }).catch(() => {});\n      }\n    };\n\n    const onUp = () => cleanup();\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      if (dragCleanup === cleanup) dragCleanup = null;\n    };\n\n    dragCleanup = cleanup;\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  async function handleRowDoubleClick(index) {\n    if (!selectedIndices.has(index) || selectedIndices.size > 1) {\n      selectSingle(index);\n      await tick();\n    }\n    await invoke('open', { paths: [results[index].path] }).catch((err) => {\n      showToast(`Failed to open: ${String(err)}`);\n    });\n  }\n\n  function closeContextMenu() {\n    contextMenu = {\n      ...contextMenu,\n      visible: false\n    };\n  }\n\n  async function openSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('open', { paths });\n    } catch (err) {\n      showToast(`Failed to open: ${String(err)}`);\n    }\n  }\n\n  async function openWithFallback() {\n    const target = primaryEntry();\n    if (!target) {\n      return;\n    }\n\n    try {\n      await invoke('open_with', { path: target.path });\n    } catch (err) {\n      showToast(`Open With failed: ${String(err)}`);\n    }\n  }\n\n  async function revealSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('reveal_in_finder', { paths });\n    } catch (err) {\n      showToast(`Failed to reveal in Finder: ${String(err)}`);\n    }\n  }\n\n  async function copySelectedPaths() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_paths', { paths });\n      showToast(`Copied ${paths.length} path(s)`);\n    } catch (err) {\n      showToast(`Failed to copy path: ${String(err)}`);\n    }\n  }\n\n  async function copyFiles() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_files', { paths });\n      showToast(`Copied ${paths.length} item(s)`);\n    } catch (err) {\n      showToast(`Failed to copy: ${String(err)}`);\n    }\n  }\n\n  async function trashSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    const message =\n      paths.length === 1\n        ? 'Move selected item to Trash?'\n        : `Move ${paths.length} items to Trash?`;\n\n    if (!window.confirm(message)) {\n      return;\n    }\n\n    try {\n      await invoke('move_to_trash', { paths });\n      showToast('Moved to Trash.');\n      clearSelection();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to move to Trash: ${String(err)}`);\n    }\n  }\n\n  async function resetIndex() {\n    if (indexStatus.state === 'Indexing') {\n      showToast('Indexing in progress. Please try again after it completes.');\n      return;\n    }\n\n    results = [];\n    totalResults = 0;\n    totalResultsKnown = false;\n    clearSelection();\n    scanned = 0;\n    dbLatencyMs = null;\n    dbLastQuery = '';\n    indexStatus = { ...indexStatus, state: 'Indexing', entriesCount: 0, message: null };\n    indexingStartTime = Date.now();\n    indexingElapsed = '';\n    indexingFinishedAt = '';\n\n    try {\n      await invoke('reset_index');\n    } catch (err) {\n      showToast(`Failed to reset index: ${String(err)}`);\n      await refreshStatus();\n    }\n  }\n\n  function isMultiSelected() {\n    return selectedIndices.size > 1;\n  }\n\n  function autoResizeRenameInput() {\n    if (!renameInputEl) return;\n    renameInputEl.style.height = '0';\n    renameInputEl.style.height = renameInputEl.scrollHeight + 'px';\n  }\n\n  async function startRename() {\n    if (isMultiSelected()) {\n      return;\n    }\n\n    const idx = lastSelectedIndex;\n    if (idx < 0 || !results[idx]) {\n      return;\n    }\n\n    const entry = results[idx];\n\n    // Calculate overlay position mathematically.\n    // Name cell text starts at: padding-left(16) + icon(16) + gap(6) = 38px from cell left.\n    // Textarea has padding-left: 0 and border: 1.5px, so text starts ~2px from overlay left.\n    if (tableContainer) {\n      const rect = tableContainer.getBoundingClientRect();\n      const cellLeft = rect.left - tableContainer.scrollLeft;\n      const textLeft = cellLeft + 38;\n      const cellRight = cellLeft + colWidths.name;\n      const rowTop = rect.top + idx * rowHeight - tableContainer.scrollTop;\n      renameOverlay = {\n        top: rowTop,\n        left: textLeft - 2,\n        width: cellRight - textLeft + 2 - 4\n      };\n    }\n\n    editing = {\n      active: true,\n      path: entry.path,\n      index: idx,\n      draftName: entry.name\n    };\n\n    await tick();\n\n    if (renameInputEl) {\n      autoResizeRenameInput();\n      renameInputEl.focus();\n      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n      renameInputEl.setSelectionRange(0, selectionEnd);\n    }\n  }\n\n  function cancelRename() {\n    editing = {\n      active: false,\n      path: '',\n      index: -1,\n      draftName: ''\n    };\n  }\n\n  async function commitRename() {\n    if (!editing.active || editing.index < 0 || !results[editing.index]) {\n      return;\n    }\n\n    const current = results[editing.index];\n    const nextName = editing.draftName;\n\n    try {\n      await invoke('rename', {\n        path: current.path,\n        newName: nextName\n      });\n      cancelRename();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to rename: ${String(err)}`);\n      await tick();\n      renameInputEl?.focus();\n    }\n  }\n\n  function onGlobalClick() {\n    closeContextMenu();\n  }\n\n  function onTitleBarMouseDown(event) {\n    if (event.button !== 0) {\n      return;\n    }\n\n    const activeElement = document.activeElement;\n    if (activeElement instanceof HTMLElement && isTextInputTarget(activeElement)) {\n      activeElement.blur();\n    }\n  }\n\n  async function focusSearch() {\n    await getCurrentWindow().show();\n    await getCurrentWindow().setFocus();\n    searchInputEl?.focus();\n    searchInputEl?.select();\n  }\n\n  function isTextInputTarget(target) {\n    return (\n      target instanceof HTMLInputElement ||\n      target instanceof HTMLTextAreaElement ||\n      target?.isContentEditable\n    );\n  }\n\n  async function handleKeydown(event) {\n    const isMetaSelectAll = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'a';\n    const isMetaCopy = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c';\n    const target = event.target;\n    const isTextInput = isTextInputTarget(target);\n\n    if (isMetaCopy && isTextInput) {\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      if (isTextInput) {\n        event.preventDefault();\n        if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n          target.select();\n        }\n        return;\n      }\n    }\n\n    if (editing.active) {\n      if (event.key === 'Enter') {\n        event.preventDefault();\n        await commitRename();\n        return;\n      }\n\n      if (event.key === 'Escape') {\n        event.preventDefault();\n        const idx = editing.index;\n        cancelRename();\n        selectSingle(idx);\n        await tick();\n        tableContainer?.querySelector('.row.selected')?.focus();\n        return;\n      }\n      return;\n    }\n\n    if (event.key === 'Escape') {\n      event.preventDefault();\n      clearSelection();\n      return;\n    }\n\n    if (event.key === 'ArrowDown') {\n      event.preventDefault();\n      moveSelection(1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'ArrowUp') {\n      event.preventDefault();\n      moveSelection(-1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageDown') {\n      event.preventDefault();\n      moveSelection(Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageUp') {\n      event.preventDefault();\n      moveSelection(-Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'Enter') {\n      event.preventDefault();\n      if (platform === 'windows') {\n        await openSelected();\n      } else {\n        await startRename();\n      }\n      return;\n    }\n\n    if (event.key === 'F2') {\n      event.preventDefault();\n      await startRename();\n      return;\n    }\n\n    if (event.key === ' ' && !isTextInput) {\n      event.preventDefault();\n      const entry = primaryEntry();\n      if (entry) {\n        await invoke('quick_look', { path: entry.path });\n      }\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'f') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      searchInputEl?.select();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'o') {\n      event.preventDefault();\n      await openSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {\n      event.preventDefault();\n      await revealSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c') {\n      event.preventDefault();\n      await copySelectedPaths();\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      event.preventDefault();\n      selectedIndices = new Set(Array.from({ length: results.length }, (_, i) => i));\n      return;\n    }\n\n    if (event.key === 'Delete' || ((event.metaKey || event.ctrlKey) && event.key === 'Backspace')) {\n      if (!isTextInput) {\n        event.preventDefault();\n        await trashSelected();\n      }\n      return;\n    }\n  }\n\n  function formatSize(entry) {\n    if (entry.isDir || entry.size == null) return '';\n    const bytes = entry.size;\n    if (bytes < 1024) return `${bytes} B`;\n    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n    return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n  }\n\n  function formatModified(entry) {\n    if (!entry.mtime) {\n      return '';\n    }\n\n    const d = new Date(entry.mtime * 1000);\n    const pad = (n) => String(n).padStart(2, '0');\n    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;\n  }\n\n  function formatLastUpdated(timestamp) {\n    if (!timestamp) {\n      return '-';\n    }\n\n    return new Date(timestamp * 1000).toLocaleString();\n  }\n\n  function formatElapsed(ms) {\n    const totalSec = Math.floor(ms / 1000);\n    const min = Math.floor(totalSec / 60);\n    const sec = totalSec % 60;\n    return min > 0 ? `${min}m ${sec}s` : `${sec}s`;\n  }\n\n  function updateElapsed() {\n    if (indexingStartTime && indexStatus.state === 'Indexing') {\n      indexingElapsed = formatElapsed(Date.now() - indexingStartTime);\n    }\n  }\n\n  function startElapsedTimer() {\n    clearInterval(elapsedTimer);\n    indexingStartTime = Date.now();\n    indexingElapsed = '0s';\n    indexingFinishedAt = '';\n    elapsedTimer = setInterval(updateElapsed, 1000);\n  }\n\n  function stopElapsedTimer() {\n    clearInterval(elapsedTimer);\n    if (indexingStartTime) {\n      const elapsed = Date.now() - indexingStartTime;\n      indexingFinishedAt = `${formatElapsed(elapsed)}`;\n    }\n    indexingStartTime = null;\n    indexingElapsed = '';\n  }\n\n  function displayPath(path) {\n    if (!path) {\n      return path;\n    }\n\n    if (!homePrefix) {\n      return path;\n    }\n\n    if (path === homePrefix) {\n      return '~';\n    }\n\n    if (path.startsWith(`${homePrefix}/`)) {\n      return `~${path.slice(homePrefix.length)}`;\n    }\n\n    return path;\n  }\n\n  let unlistenFns = [];\n\n  onMount(async () => {\n    const t0 = performance.now();\n    const ms = () => Math.round(performance.now() - t0);\n    const DEBUG_STARTUP = false;\n    const flog = DEBUG_STARTUP ? (msg) => invoke('frontend_log', { msg }).catch(() => {}) : () => {};\n\n    flog(`[startup/fe] onMount entered`);\n\n    updateViewportHeight();\n    flog(`[startup/fe] +${ms()}ms updateViewportHeight done`);\n\n    invoke('set_native_theme', { theme });\n\n    platform = await invoke('get_platform');\n    flog(`[startup/fe] +${ms()}ms get_platform done`);\n\n    const unlistenProgress = await listen('index_progress', (event) => {\n      scanned = event.payload.scanned;\n      if (indexStatus.state !== 'Indexing') {\n        indexStatus = {\n          ...indexStatus,\n          state: 'Indexing'\n        };\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_progress) registered`);\n\n    const unlistenState = await listen('index_state', (event) => {\n      flog(`[startup/fe] index_state event received: ${event.payload.state} at +${ms()}ms`);\n      const prevState = indexStatus.state;\n      indexStatus = {\n        ...indexStatus,\n        state: event.payload.state,\n        message: event.payload.message ?? null,\n        isCatchup: event.payload.isCatchup ?? false\n      };\n\n      if (event.payload.state === 'Indexing' && prevState !== 'Indexing') {\n        if (prevState === 'Ready') {\n          lastReadyCount = indexStatus.entriesCount;\n        }\n        startElapsedTimer();\n      } else if (event.payload.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n\n      if (event.payload.state === 'Ready') {\n        scheduleSearch();\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_state) registered`);\n\n    const unlistenUpdated = await listen('index_updated', (event) => {\n      indexStatus = {\n        ...indexStatus,\n        entriesCount: event.payload.entriesCount,\n        lastUpdated: event.payload.lastUpdated,\n        permissionErrors: event.payload.permissionErrors ?? indexStatus.permissionErrors\n      };\n\n      scheduleSearch(true);\n    });\n\n    const unlistenFocus = await listen('focus_search', () => {\n      void focusSearch();\n    });\n\n    const unlistenCtxMenuAction = await listen('context_menu_action', (event) => {\n      switch (event.payload) {\n        case 'open': void openSelected(); break;\n        case 'quick_look': {\n          const e = primaryEntry();\n          if (e) void invoke('quick_look', { path: e.path });\n          break;\n        }\n        case 'open_with': void openWithFallback(); break;\n        case 'reveal': void revealSelected(); break;\n        case 'copy_files': void copyFiles(); break;\n        case 'copy_path': void copySelectedPaths(); break;\n        case 'trash': void trashSelected(); break;\n        case 'rename': void startRename(); break;\n      }\n    });\n\n    unlistenFns = [unlistenProgress, unlistenState, unlistenUpdated, unlistenFocus, unlistenCtxMenuAction];\n    flog(`[startup/fe] +${ms()}ms all listeners registered`);\n\n    // Fetch backend state IMMEDIATELY after listeners are registered.\n    // Events emitted before listener registration are lost, so this\n    // is the only reliable way to get the current state.\n    await refreshStatus();\n    flog(`[startup/fe] +${ms()}ms refreshStatus done (state=${indexStatus.state})`);\n\n    // Show Svelte UI: remove skeleton, focus search input.\n    await tick();\n    document.getElementById('skeleton')?.remove();\n    await focusSearch();\n    flog(`[startup/fe] +${ms()}ms WINDOW VISIBLE â€” skeleton removed`);\n\n    try {\n      homePrefix = await invoke('get_home_dir');\n    } catch {\n      homePrefix = '';\n    }\n    flog(`[startup/fe] +${ms()}ms get_home_dir done`);\n\n    if (!localStorage.getItem('everything-fda-notice-v1')) {\n      showToast('macOS Full Disk Access permission may be required for full disk search.');\n      localStorage.setItem('everything-fda-notice-v1', '1');\n    }\n    flog(`[startup/fe] +${ms()}ms calling runSearch...`);\n    await runSearch();\n    flog(`[startup/fe] +${ms()}ms runSearch done`);\n\n    if (typeof ResizeObserver !== 'undefined') {\n      tableResizeObserver = new ResizeObserver(() => {\n        scheduleViewportHeightUpdate();\n      });\n      if (tableContainer) {\n        tableResizeObserver.observe(tableContainer);\n      } else if (tableAreaEl) {\n        tableResizeObserver.observe(tableAreaEl);\n      }\n    }\n\n    window.addEventListener('resize', scheduleViewportHeightUpdate);\n    window.addEventListener('click', onGlobalClick);\n    statusRefreshTimer = setInterval(() => {\n      if (indexStatus.state === 'Indexing') {\n        void refreshStatus();\n      }\n    }, 1000);\n    console.log(`[startup/fe] +${ms()}ms onMount complete`);\n  });\n\n  onDestroy(async () => {\n    clearTimeout(searchTimer);\n    clearTimeout(toastTimer);\n    clearInterval(statusRefreshTimer);\n    clearInterval(elapsedTimer);\n    resizeCleanup?.();\n\n    for (const unlisten of unlistenFns) {\n      unlisten();\n    }\n\n    tableResizeObserver?.disconnect();\n    tableResizeObserver = null;\n    if (viewportResizeRaf !== null) {\n      cancelAnimationFrame(viewportResizeRaf);\n      viewportResizeRaf = null;\n    }\n    window.removeEventListener('resize', scheduleViewportHeightUpdate);\n    window.removeEventListener('click', onGlobalClick);\n  });\n</script>\n\n<svelte:window on:keydown={handleKeydown} />\n\n<div class=\"app-shell\" data-theme={theme}>\n  <div class=\"title-bar\" role=\"presentation\" data-tauri-drag-region on:mousedown={onTitleBarMouseDown}>\n    <div class=\"title-left\"></div>\n    <div class=\"title-center\">\n      <svg class=\"title-icon\" viewBox=\"0 0 215 205\" fill-rule=\"evenodd\" aria-hidden=\"true\">\n        <path d=\"M85 0c46.9 0 85 38.1 85 85 0 20.1-7.2 38.5-19.2 52.7l40.7 40.8c5.8 5.8 5.8 15.2 0 21-5.8 5.8-15.2 5.8-21 0l-40.7-40.7c-13.6 9.7-30.4 15.2-44.8 15.2-46.9 0-85-42.1-85-89 0-46.9 38.1-85 85-85z m0 32c-29.3 0-53 23.7-53 53 0 29.3 23.7 53 53 53 29.3 0 53-23.7 53-53 0-29.3-23.7-53-53-53z\"/>\n      </svg>\n      <span class=\"title-text\">Everything</span>\n    </div>\n    <div class=\"title-right\"></div>\n  </div>\n\n  <header class=\"search-bar\">\n    <input\n      bind:this={searchInputEl}\n      class=\"search-input\"\n      type=\"text\"\n      bind:value={query}\n      on:input={scheduleSearch}\n      on:focus={clearSelection}\n      placeholder=\"Search file/folder names\"\n      autocomplete=\"off\"\n      spellcheck=\"false\"\n    />\n  </header>\n\n  <section class=\"table-area\" bind:this={tableAreaEl} style={tableGridStyle}>\n    <div class=\"table-header\">\n      <div class=\"table-header-track\">\n        <div class=\"col name\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('name')}>\n            Name{#if sortBy === 'name'}{@html sortIconHtml(sortDir)}{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'name'}\n            on:mousedown={(event) => startColumnResize(event, 'name')}\n            aria-label=\"Resize Name column\"\n          />\n        </div>\n\n        <div class=\"col path\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('dir')}>\n            Path{#if sortBy === 'dir'}{@html sortIconHtml(sortDir)}{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'path'}\n            on:mousedown={(event) => startColumnResize(event, 'path')}\n            aria-label=\"Resize Path column\"\n          />\n        </div>\n\n        <div class=\"col size\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('size')}>\n            Size{#if sortBy === 'size'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n\n        <div class=\"col modified\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('mtime')}>\n            Modified{#if sortBy === 'mtime'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n      </div>\n    </div>\n\n    <div\n      class=\"table-body\"\n      bind:this={tableContainer}\n      on:scroll={() => {\n        scrollTop = tableContainer.scrollTop;\n        headerScrollLeft = tableContainer.scrollLeft;\n        if (editing.active) void commitRename();\n        const scrollBottom = scrollTop + tableContainer.clientHeight;\n        if (scrollBottom >= totalHeight - rowHeight * 10) {\n          void loadMore();\n        }\n      }}\n    >\n      <div class=\"spacer\" style={`height:${totalHeight}px`}>\n        <div class=\"rows\" style={`transform: translateY(${translateY}px);`}>\n          {#each visibleRows as entry, localIndex}\n            {@const index = startIndex + localIndex}\n            <div\n              class=\"row {selectedIndices.has(index) ? 'selected' : ''}\"\n              on:mousedown={(event) => handleRowMouseDown(event, index)}\n              on:click={(event) => handleRowClick(event, index)}\n              on:keydown={(event) => handleRowA11yKeydown(event, index)}\n              on:dblclick={() => handleRowDoubleClick(index)}\n              on:contextmenu={(event) => handleRowContextMenu(event, index)}\n              role=\"row\"\n              tabindex=\"0\"\n            >\n              <div class=\"cell name\">\n                <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n                <span class=\"ellipsis\" class:name-editing={editing.active && editing.index === index}>{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n              </div>\n              <div class=\"cell path\"><span class=\"ellipsis\">{displayPath(entry.dir)}</span></div>\n              <div class=\"cell size\">{formatSize(entry)}</div>\n              <div class=\"cell modified\">{formatModified(entry)}</div>\n            </div>\n          {/each}\n        </div>\n      </div>\n    </div>\n  </section>\n\n  <footer class=\"status-bar\">\n    <div class=\"status-left\">\n      <span class=\"status-state\">\n        <span class=\"state-dot {indexStatus.state === 'Indexing' ? 'indexing' : indexStatus.state === 'Error' ? 'error' : 'ready'}\"></span>\n        {#if indexStatus.state === 'Indexing'}\n          Indexing{#if lastReadyCount > 0} ({Math.min(99, Math.round((scanned / lastReadyCount) * 100))}%){/if}{#if indexingElapsed} Â· {indexingElapsed}{/if}\n          {#if !indexStatus.isCatchup}\n            Â· {scanned.toLocaleString()} scanned\n          {/if}\n        {:else}\n          Index: {indexStatus.state}\n        {/if}\n      </span>\n      <span>{indexStatus.entriesCount.toLocaleString()} entries</span>\n      {#if indexingFinishedAt && indexStatus.state !== 'Indexing'}\n        <span>in {indexingFinishedAt}</span>\n      {/if}\n      {#if dbLatencyMs !== null && dbLastQuery}\n        <span>\"{dbLastQuery}\" {dbLatencyMs}ms Â· {totalResults} results</span>\n      {/if}\n      {#if searchModeLabel === 'spotlight' || searchModeLabel === 'spotlight_timeout'}\n        <span class=\"status-spotlight\">Spotlight fallback{#if searchModeLabel === 'spotlight_timeout'} (partial){/if}</span>\n      {/if}\n      {#if indexStatus.permissionErrors > 0}\n        <span class=\"status-warning\">{indexStatus.permissionErrors.toLocaleString()} permission errors</span>\n      {/if}\n      {#if indexStatus.message}\n        <span class={indexStatus.isCatchup ? 'index-progress' : 'status-error'}>{indexStatus.message}</span>\n      {/if}\n    </div>\n    <div class=\"status-right\">\n      <button class=\"status-btn\" on:click={cycleTheme} title=\"Switch theme\">\n        {theme === 'dark' ? 'â˜€ Light' : 'â—‘ Dark'}\n      </button>\n      <button\n        class=\"status-btn rebuild-btn\"\n        on:click={resetIndex}\n        disabled={indexStatus.state === 'Indexing'}\n        title={indexStatus.state === 'Indexing' ? 'Cannot reset while indexing is in progress.' : 'Reset and rebuild the index.'}\n      >\n        <svg class=\"rebuild-icon\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n          <path d=\"M23 4v6h-6\"/><path d=\"M20.49 15a9 9 0 1 1-2.12-9.36L23 10\"/>\n        </svg>\n        Rebuild Index\n      </button>\n    </div>\n  </footer>\n\n  {#if editing.active}\n    <div\n      class=\"rename-overlay\"\n      style=\"top:{renameOverlay.top}px; left:{renameOverlay.left}px; width:{renameOverlay.width}px;\"\n      role=\"presentation\"\n      on:mousedown|stopPropagation\n    >\n      <textarea\n        bind:this={renameInputEl}\n        class=\"rename-textarea\"\n        bind:value={editing.draftName}\n        on:input={autoResizeRenameInput}\n        on:click|stopPropagation\n        on:blur={commitRename}\n      />\n    </div>\n  {/if}\n\n  {#if contextMenu.visible}\n    <div class=\"context-menu\" style={`left:${contextMenu.x}px;top:${contextMenu.y}px;`}>\n      <button on:click={() => (closeContextMenu(), openSelected())}>Open</button>\n      <button on:click={async () => { closeContextMenu(); const e = primaryEntry(); if (e) await invoke('quick_look', { path: e.path }); }}>Quick Look</button>\n      <button on:click={() => (closeContextMenu(), openWithFallback())}>Open With... (Reveal in Finder)</button>\n      <button on:click={() => (closeContextMenu(), revealSelected())}>Reveal in Finder</button>\n      <button on:click={() => (closeContextMenu(), copySelectedPaths())}>Copy Path</button>\n      <button on:click={() => (closeContextMenu(), trashSelected())}>Move to Trash</button>\n      {#if selectedIndices.size === 1}\n        <button on:click={() => (closeContextMenu(), startRename())}>Rename</button>\n      {/if}\n    </div>\n  {/if}\n\n  {#if toast}\n    <div class=\"toast\">{toast}</div>\n  {/if}\n</div>\n\n<style>\n  :global(:root) {\n    color-scheme: light dark;\n    --bg-app: transparent;\n    --text-primary: #0d1826;\n    --text-muted: #48596c;\n    --bar-grad-top: rgba(255, 255, 255, 0.48);\n    --bar-grad-bottom: rgba(248, 250, 253, 0.42);\n    --surface-header: rgba(252, 252, 255, 0.40);\n    --surface: rgba(255, 255, 255, 0.22);\n    --border-soft: rgba(0, 0, 0, 0.07);\n    --border-input: rgba(0, 0, 0, 0.13);\n    --focus-ring: #6f96e6;\n    --row-border: rgba(0, 0, 0, 0.032);\n    --row-hover: rgba(0, 0, 0, 0.06);\n    --row-selected: rgba(0, 0, 0, 0.12);\n    --button-bg: rgba(255, 255, 255, 0.62);\n    --button-border: rgba(0, 0, 0, 0.10);\n    --button-text: #2c3e50;\n    --menu-bg: rgba(240, 241, 248, 0.90);\n    --menu-border: rgba(0, 0, 0, 0.06);\n    --menu-hover: rgba(255, 255, 255, 0.62);\n    --menu-text: #1a2a38;\n    --error-text: #b64545;\n    --warning-text: #8f6500;\n    --toast-bg: rgba(18, 22, 32, 0.90);\n    --toast-text: #ffffff;\n  }\n\n  @media (prefers-color-scheme: dark) {\n    :global(:root) {\n      --bg-app: transparent;\n      --text-primary: #e6e6ea;\n      --text-muted: #9494a4;\n      --bar-grad-top: rgba(38, 38, 46, 0.52);\n      --bar-grad-bottom: rgba(30, 30, 38, 0.46);\n      --surface-header: rgba(32, 32, 40, 0.46);\n      --surface: rgba(18, 18, 26, 0.32);\n      --border-soft: rgba(255, 255, 255, 0.065);\n      --border-input: rgba(255, 255, 255, 0.14);\n      --focus-ring: #5b8bd9;\n      --row-border: rgba(255, 255, 255, 0.026);\n      --row-hover: rgba(255, 255, 255, 0.08);\n      --row-selected: rgba(255, 255, 255, 0.14);\n      --button-bg: rgba(255, 255, 255, 0.072);\n      --button-border: rgba(255, 255, 255, 0.11);\n      --button-text: #d6d6e0;\n      --menu-bg: rgba(36, 36, 46, 0.90);\n      --menu-border: rgba(255, 255, 255, 0.066);\n      --menu-hover: rgba(255, 255, 255, 0.062);\n      --menu-text: #e0e0e8;\n      --error-text: #ff9d9d;\n      --warning-text: #e0c670;\n      --toast-bg: rgba(10, 10, 16, 0.93);\n      --toast-text: #f2f2f6;\n    }\n  }\n\n  /* â”€â”€ Theme: Dark â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme=\"dark\"]) {\n    color-scheme: dark;\n    --bg-app: #1E1E21;\n    --text-primary: #E2E8F0;\n    --text-muted: #94A3B8;\n    --bar-grad-top: #1E1E21;\n    --bar-grad-bottom: #1E1E21;\n    --surface-header: #1E1E21;\n    --surface: #1E1E21;\n    --bg-input: #161618;\n    --border-soft: #2A2A2D;\n    --border-input: rgba(255, 255, 255, 0.06);\n    --focus-ring: #4DA8FF;\n    --accent: #4DA8FF;\n    --row-border: rgba(255, 255, 255, 0.02);\n    --row-hover: #282828;\n    --row-selected: rgba(77, 168, 255, 0.10);\n    --button-bg: rgba(255, 255, 255, 0.05);\n    --button-border: #2A2A2D;\n    --button-text: #94A3B8;\n    --menu-bg: #252528;\n    --menu-border: #2A2A2D;\n    --menu-hover: rgba(255, 255, 255, 0.04);\n    --menu-text: #E2E8F0;\n    --error-text: #ff9d9d;\n    --warning-text: #e0c670;\n    --toast-bg: rgba(10, 10, 16, 0.93);\n    --toast-text: #f2f2f6;\n  }\n\n  /* â”€â”€ Theme: Light â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme=\"light\"]) {\n    color-scheme: light;\n    --bg-app: #F5F5F7;\n    --text-primary: #1C1C1E;\n    --text-muted: #6E6E7A;\n    --bar-grad-top: #F5F5F7;\n    --bar-grad-bottom: #F5F5F7;\n    --surface-header: #F5F5F7;\n    --surface: #F5F5F7;\n    --bg-input: #FFFFFF;\n    --border-soft: #D1D1D6;\n    --border-input: rgba(0, 0, 0, 0.10);\n    --focus-ring: #3A8BF5;\n    --accent: #3A8BF5;\n    --row-border: rgba(0, 0, 0, 0.04);\n    --row-hover: rgba(0, 0, 0, 0.04);\n    --row-selected: rgba(58, 139, 245, 0.10);\n    --button-bg: #FFFFFF;\n    --button-border: #D1D1D6;\n    --button-text: #3C3C43;\n    --menu-bg: #FFFFFF;\n    --menu-border: #D1D1D6;\n    --menu-hover: rgba(0, 0, 0, 0.05);\n    --menu-text: #1C1C1E;\n    --error-text: #D93025;\n    --warning-text: #B45309;\n    --toast-bg: rgba(255, 255, 255, 0.95);\n    --toast-text: #1C1C1E;\n  }\n\n  /* â”€â”€ Themed element overrides â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme]) {\n    background: var(--bg-app);\n  }\n\n  /* Search bar: flat, no gradient, no separator */\n  :global([data-theme]) .search-bar {\n    height: 44px;\n    padding: 0 16px;\n    background: var(--bg-app);\n    border-bottom: none;\n  }\n\n  :global([data-theme]) .search-input {\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n    font-family: 'JetBrains Mono', 'SF Mono', monospace;\n    font-size: 12px;\n    height: 34px;\n    border-radius: 8px;\n  }\n\n  /* Table header: flat bg, 16px edge padding */\n  :global([data-theme]) .table-header {\n    background: var(--bg-app);\n  }\n\n  :global([data-theme]) .col-button {\n    padding: 0 8px;\n  }\n\n  :global([data-theme]) .col.name .col-button {\n    padding-left: 16px;\n  }\n\n  /* Row cells: JetBrains Mono, 16px outer edges */\n  :global([data-theme]) .cell {\n    font-family: 'JetBrains Mono', monospace;\n  }\n\n  :global([data-theme]) .cell.name {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    padding-left: 16px;\n    font-size: 12px;\n    color: var(--text-primary);\n  }\n\n  :global([data-theme]) .cell.path {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.size {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.modified {\n    padding-right: 16px;\n    font-size: 11px;\n    white-space: nowrap;\n  }\n\n  :global([data-theme]) .row.selected {\n    box-shadow: inset 3px 0 0 var(--accent);\n  }\n\n  /* Dim path/size/date cells in themed mode */\n  :global([data-theme]) .cell.path,\n  :global([data-theme]) .cell.size,\n  :global([data-theme]) .cell.modified {\n    color: var(--text-muted);\n  }\n\n  :global(:root) {\n    background: transparent;\n  }\n\n  :global(html, body) {\n    margin: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    background: transparent;\n    color: var(--text-primary);\n    font-family: Inter, 'SF Pro Text', 'Segoe UI', Helvetica, Arial, sans-serif;\n  }\n\n  :global(#app) {\n    width: 100%;\n    height: 100%;\n  }\n\n  .app-shell {\n    display: grid;\n    grid-template-rows: auto auto 1fr auto;\n    height: 100%;\n    min-width: 0;\n  }\n\n  .title-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 44px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    cursor: default;\n    flex-shrink: 0;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-left {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-center {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-right {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-icon {\n    width: 14px;\n    height: 14px;\n    fill: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .title-text {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 13px;\n    font-weight: 500;\n    color: var(--text-primary);\n    letter-spacing: -0.01em;\n  }\n\n  .search-bar {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding: 8px;\n    background: linear-gradient(180deg, var(--bar-grad-top) 0%, var(--bar-grad-bottom) 100%);\n    border-bottom: 1px solid var(--border-soft);\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .search-input {\n    display: block;\n    box-sizing: border-box;\n    width: 100%;\n    min-width: 0;\n    flex: 1 1 auto;\n    height: 36px;\n    border: 1px solid var(--border-input);\n    border-radius: 14px;\n    padding: 0 10px;\n    font-size: 14px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    backdrop-filter: blur(12px) saturate(160%);\n    -webkit-backdrop-filter: blur(12px) saturate(160%);\n  }\n\n  .search-input::placeholder {\n    color: var(--text-muted);\n    opacity: 0.85;\n    font-size: 12px;\n  }\n\n  .search-input:focus {\n    outline: none;\n    border-color: var(--focus-ring);\n    box-shadow: 0 0 0 2px rgba(125, 169, 255, 0.25);\n  }\n\n  .table-area {\n    display: grid;\n    grid-template-rows: auto 1fr;\n    min-height: 0;\n    min-width: 0;\n  }\n\n  .table-header-track,\n  .row {\n    display: grid;\n    grid-template-columns: var(--col-name) var(--col-path) var(--col-size) var(--col-modified);\n    align-items: center;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .table-header {\n    height: 32px;\n    border-bottom: 1px solid var(--border-soft);\n    background: var(--surface-header);\n    user-select: none;\n    overflow: hidden;\n    flex-shrink: 0;\n  }\n\n  .table-header-track {\n    height: 100%;\n    transform: translateX(var(--header-offset, 0px));\n    will-change: transform;\n  }\n\n  .table-header .col {\n    position: relative;\n    min-width: 0;\n    height: 100%;\n  }\n\n  .col-button {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n    gap: 4px;\n    box-sizing: border-box;\n    padding: 0 8px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 11px;\n    font-weight: 600;\n    line-height: 1;\n    color: var(--text-muted);\n    text-align: left;\n    margin: 0;\n    border: none;\n    background: transparent;\n    cursor: pointer;\n  }\n\n  .sort-icon {\n    width: 10px;\n    height: 10px;\n    flex-shrink: 0;\n    color: var(--accent);\n  }\n\n  .col-resizer {\n    position: absolute;\n    top: 0;\n    right: -4px;\n    width: 8px;\n    height: 100%;\n    border: none;\n    padding: 0;\n    background: transparent;\n    cursor: col-resize;\n    z-index: 30;\n  }\n\n  .col-resizer::after {\n    content: '';\n    position: absolute;\n    top: 7px;\n    bottom: 7px;\n    left: 50%;\n    width: 1px;\n    transform: translateX(-50%);\n    background: var(--border-soft);\n    opacity: 0;\n    transition: opacity 0.15s ease;\n  }\n\n  .table-header .col:hover .col-resizer::after,\n  .col-resizer.active::after {\n    opacity: 1;\n  }\n\n  .table-body {\n    overflow: auto;\n    min-height: 0;\n    min-width: 0;\n    background: var(--surface);\n  }\n\n  .spacer {\n    position: relative;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .rows {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .row {\n    height: 30px;\n    border-bottom: 1px solid var(--row-border);\n    cursor: default;\n    -webkit-user-select: none;\n    user-select: none;\n    outline: none;\n  }\n\n  .row:hover {\n    background: var(--row-hover);\n  }\n\n  .row.selected {\n    background: var(--row-selected);\n  }\n\n  .cell {\n    padding: 0 8px;\n    font-size: 12px;\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    min-width: 0;\n  }\n\n  .cell.size {\n    text-align: right;\n    font-variant-numeric: tabular-nums;\n  }\n\n  .ellipsis {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n\n  .hl {\n    background: none;\n    color: inherit;\n    font-weight: 700;\n  }\n\n  .file-icon {\n    width: 16px;\n    height: 16px;\n    flex: 0 0 auto;\n  }\n\n  .name-editing {\n    opacity: 0.25;\n  }\n\n  .rename-overlay {\n    position: fixed;\n    z-index: 100;\n    min-width: 120px;\n  }\n\n  .rename-textarea {\n    display: block;\n    width: 100%;\n    box-sizing: border-box;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 12px;\n    line-height: 18px;\n    padding: 5px 4px 5px 0;\n    border: 1.5px solid var(--focus-ring);\n    border-radius: 4px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    outline: none;\n    resize: none;\n    overflow: hidden;\n    box-shadow: 0 2px 14px rgba(0, 0, 0, 0.22), 0 0 0 3px rgba(77, 168, 255, 0.13);\n  }\n\n  .status-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 32px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    border-top: 1px solid var(--border-soft);\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 11px;\n    color: var(--text-muted);\n    white-space: nowrap;\n    overflow: hidden;\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .status-left {\n    display: flex;\n    align-items: center;\n    gap: 16px;\n    overflow: hidden;\n    min-width: 0;\n  }\n\n  .status-right {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    flex-shrink: 0;\n  }\n\n  .status-btn {\n    border: 1px solid var(--button-border);\n    border-radius: 5px;\n    background: var(--button-bg);\n    color: var(--button-text);\n    font-size: 11px;\n    height: 22px;\n    padding: 0 8px;\n    cursor: pointer;\n  }\n\n  .status-btn:hover {\n    filter: brightness(1.06);\n  }\n\n  .status-btn:disabled {\n    opacity: 0.55;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .status-state {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n  }\n\n  .state-dot {\n    width: 6px;\n    height: 6px;\n    border-radius: 50%;\n    flex-shrink: 0;\n  }\n\n  .state-dot.ready { background: #28C840; }\n  .state-dot.indexing { background: #FEBC2E; }\n  .state-dot.error { background: #FF5F57; }\n\n  .rebuild-btn {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 10px;\n    font-weight: 500;\n    background: var(--button-bg);\n    border: 1px solid var(--button-border);\n    border-radius: 4px;\n    color: var(--button-text);\n    height: 22px;\n    padding: 0 10px;\n    cursor: pointer;\n  }\n\n  .rebuild-btn:hover {\n    filter: brightness(1.1);\n  }\n\n  .rebuild-btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .rebuild-icon {\n    width: 11px;\n    height: 11px;\n    color: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .status-error {\n    color: var(--error-text);\n  }\n\n  .status-warning {\n    color: var(--warning-text);\n  }\n\n  .status-spotlight {\n    color: #f59e0b;\n    font-weight: 600;\n  }\n\n  .context-menu {\n    position: fixed;\n    z-index: 200;\n    width: 220px;\n    border: 1px solid var(--menu-border);\n    border-radius: 10px;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.16), inset 0 0 0 0.5px rgba(255, 255, 255, 0.18);\n    background: var(--menu-bg);\n    backdrop-filter: blur(28px) saturate(180%);\n    -webkit-backdrop-filter: blur(28px) saturate(180%);\n    overflow: hidden;\n  }\n\n  .context-menu button {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    padding: 8px 10px;\n    font-size: 12px;\n    color: var(--menu-text);\n  }\n\n  .context-menu button:hover {\n    background: var(--menu-hover);\n  }\n\n  .toast {\n    position: fixed;\n    right: 14px;\n    bottom: 18px;\n    background: var(--toast-bg);\n    color: var(--toast-text);\n    border-radius: 10px;\n    padding: 9px 12px;\n    font-size: 12px;\n    z-index: 250;\n    backdrop-filter: blur(20px) saturate(180%);\n    -webkit-backdrop-filter: blur(20px) saturate(180%);\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);\n  }\n</style>\n","structuredPatch":[{"oldStart":1483,"oldLines":7,"newStart":1483,"newLines":7,"lines":[" ","         <div class=\"col size\">","           <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('size')}>","-            Size{#if sortBy === 'size'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}","+            Size{#if sortBy === 'size'}{@html sortIconHtml(sortDir)}{/if}","           </button>","         </div>"," "]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"b7d7c7c8-fd3d-4c82-bcc4-2400059f6ce5"}
{"parentUuid":"c6a00b27-07ce-46c8-b66a-a3d3b0295ad3","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01RstBxzfU7jyK5CqkumZdLM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KN2cyeUgNd5QiRiXebftJM","name":"Edit","input":{"replace_all":false,"file_path":"/Users/al02402336/everything/src/App.svelte","old_string":"            Modified{#if sortBy === 'mtime'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}","new_string":"            Modified{#if sortBy === 'mtime'}{@html sortIconHtml(sortDir)}{/if}"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":316,"cache_read_input_tokens":100837,"output_tokens":284,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":316,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYMPRDJoiu2eJ74XRDeLv","type":"assistant","uuid":"c528aef1-eb51-495e-a665-e20a26ac3baf","timestamp":"2026-02-21T14:40:06.745Z"}
{"parentUuid":"c528aef1-eb51-495e-a665-e20a26ac3baf","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01KN2cyeUgNd5QiRiXebftJM","toolUseID":"toolu_01KN2cyeUgNd5QiRiXebftJM","timestamp":"2026-02-21T14:40:06.754Z","uuid":"3abfbe87-6f3e-4964-8a8f-d890712fec32"}
{"parentUuid":"c528aef1-eb51-495e-a665-e20a26ac3baf","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KN2cyeUgNd5QiRiXebftJM","type":"tool_result","content":"The file /Users/al02402336/everything/src/App.svelte has been updated successfully."}]},"uuid":"9683dbd2-d5db-46e6-b74b-d95a7dc1b02f","timestamp":"2026-02-21T14:40:06.753Z","toolUseResult":{"filePath":"/Users/al02402336/everything/src/App.svelte","oldString":"            Modified{#if sortBy === 'mtime'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}","newString":"            Modified{#if sortBy === 'mtime'}{@html sortIconHtml(sortDir)}{/if}","originalFile":"<script>\n  import { onDestroy, onMount, tick } from 'svelte';\n  import { invoke } from '@tauri-apps/api/core';\n  import { listen } from '@tauri-apps/api/event';\n  import { getCurrentWindow } from '@tauri-apps/api/window';\n  import { startDrag } from '@crabnebula/tauri-plugin-drag';\n\n  const rowHeight = 30;\n  const PAGE_SIZE = 500;\n  let homePrefix = '';\n  const COL_WIDTHS_KEY = 'REDACTED';\n  const THEME_KEY = 'everything-theme';\n  const columnKeys = ['name', 'path', 'size', 'modified'];\n  const minColumnWidth = {\n    name: 180,\n    path: 240,\n    size: 75,\n    modified: 150\n  };\n  const defaultColumnRatios = {\n    name: 0.3,\n    path: 0.45,\n    size: 0.1\n  };\n\n  const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';\n  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || systemTheme; } catch { return systemTheme; } })();\n  function cycleTheme() {\n    theme = theme === 'dark' ? 'light' : 'dark';\n    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n    invoke('set_native_theme', { theme });\n  }\n\n  function sortIconHtml(dir) {\n    const d = dir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5';\n    return `<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"${d}\"/></svg>`;\n  }\n\n  let query = '';\n  let results = [];\n  let totalResults = 0;\n  let totalResultsKnown = false;\n\n  let dbLatencyMs = null;\n  let dbLastQuery = '';\n  let searchModeLabel = '';\n  let selectedIndices = new Set();\n  let selectionAnchor = -1;\n  let lastSelectedIndex = -1;\n  let editing = {\n    active: false,\n    path: '',\n    index: -1,\n    draftName: ''\n  };\n\n  let renameOverlay = { top: 0, left: 0, width: 0 };\n\n  let indexStatus = {\n    state: 'Indexing',\n    entriesCount: 0,\n    lastUpdated: null,\n    permissionErrors: 0,\n    message: null,\n    isCatchup: false\n  };\n\n  let indexingStartTime = null;\n  let indexingElapsed = '';\n  let indexingFinishedAt = '';\n\n  let sortBy = 'name';\n  let sortDir = 'asc';\n\n  let hasMore = true;\n  let loadingMore = false;\n  let searchGeneration = 0;\n\n  let scanned = 0;\n\n  let searchInputEl;\n  let renameInputEl;\n  let tableAreaEl;\n  let tableContainer;\n  let tableResizeObserver = null;\n  let viewportResizeRaf = null;\n  let scrollTop = 0;\n  let headerScrollLeft = 0;\n  let viewportHeight = 520;\n  let lastTableWidth = 0;\n  let resizingColumn = '';\n  let resizeCleanup = null;\n  let colWidths = {\n    name: 250,\n    path: 350,\n    size: 75,\n    modified: 150\n  };\n\n  let contextMenu = {\n    visible: false,\n    x: 0,\n    y: 0\n  };\n\n  let platform = '';\n  let toast = '';\n  let searchTimer;\n  let lastSearchFiredAt = 0;\n  let toastTimer;\n  let statusRefreshTimer;\n  let elapsedTimer;\n  let statusRefreshInFlight = false;\n  let lastReadyCount = 0;\n\n  const iconCache = new Map();\n  const iconLoading = new Set();\n\n  let highlightCache = new Map();\n  let highlightCacheQuery = '';\n\n  const folderFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='1' y='4' width='14' height='10' rx='2' fill='#d9b34f'/><rect x='1' y='2' width='6' height='4' rx='1' fill='#e6ca7a'/></svg>`\n    );\n  const fileFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='3' y='1' width='10' height='14' rx='1.5' fill='#b4bec9'/><rect x='5' y='5' width='6' height='1.2' fill='#8d98a5'/><rect x='5' y='8' width='6' height='1.2' fill='#8d98a5'/></svg>`\n    );\n\n  $: totalHeight = results.length * rowHeight;\n  $: startIndex = Math.max(0, Math.floor(scrollTop / rowHeight) - 10);\n  $: visibleCount = Math.ceil(viewportHeight / rowHeight) + 20;\n  $: endIndex = Math.min(results.length, startIndex + visibleCount);\n  $: visibleRows = results.slice(startIndex, endIndex);\n  $: translateY = startIndex * rowHeight;\n  $: tableMinWidth = colWidths.name + colWidths.path + colWidths.size + colWidths.modified;\n  $: tableGridStyle = `--col-name:${colWidths.name}px;--col-path:${colWidths.path}px;--col-size:${colWidths.size}px;--col-modified:${colWidths.modified}px;--table-min-width:${tableMinWidth}px;--header-offset:${-headerScrollLeft}px;`;\n\n  $: {\n    for (const entry of visibleRows) {\n      void ensureIcon(entry);\n    }\n  }\n\n  function showToast(message) {\n    toast = message;\n    clearTimeout(toastTimer);\n    toastTimer = setTimeout(() => {\n      toast = '';\n    }, 3000);\n  }\n\n  function bytesToBase64(bytes) {\n    let binary = '';\n    const chunk = 0x8000;\n    for (let i = 0; i < bytes.length; i += chunk) {\n      const part = bytes.subarray(i, i + chunk);\n      binary += String.fromCharCode(...part);\n    }\n    return btoa(binary);\n  }\n\n  function highlightSegments(name, q) {\n    q = (q || '').trim();\n    if (!q) return [{ text: name, hl: false }];\n\n    // Reset cache when query changes\n    if (q !== highlightCacheQuery) {\n      highlightCache = new Map();\n      highlightCacheQuery = q;\n    }\n\n    // Check cache\n    const cached = highlightCache.get(name);\n    if (cached) return cached;\n\n    if (q.includes('/')) q = q.slice(q.lastIndexOf('/') + 1);\n    q = q.replace(/[*?]/g, '');\n    const terms = q.split(/\\s+/).filter(Boolean);\n    if (terms.length === 0) return [{ text: name, hl: false }];\n\n    const lower = name.toLowerCase();\n    const marks = new Uint8Array(name.length);\n    for (const t of terms) {\n      const tl = t.toLowerCase();\n      let idx = lower.indexOf(tl);\n      while (idx !== -1) {\n        for (let i = idx; i < idx + tl.length; i++) marks[i] = 1;\n        idx = lower.indexOf(tl, idx + 1);\n      }\n    }\n\n    const segs = [];\n    let i = 0;\n    while (i < name.length) {\n      const m = marks[i];\n      let j = i + 1;\n      while (j < name.length && marks[j] === m) j++;\n      segs.push({ text: name.slice(i, j), hl: m === 1 });\n      i = j;\n    }\n\n    highlightCache.set(name, segs);\n    return segs;\n  }\n\n  const perFileIconExts = new Set(['exe', 'lnk', 'ico', 'url', 'scr', 'appx']);\n\n  function iconKey(entry) {\n    if (entry.isDir) return '__folder__';\n    const ext = (entry.ext || '').toLowerCase();\n    if (perFileIconExts.has(ext)) return entry.path;\n    return ext || '__file__';\n  }\n\n  function iconFor(entry) {\n    return iconCache.get(iconKey(entry)) || (entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n  }\n\n  async function ensureIcon(entry) {\n    const key = iconKey(entry);\n    if (iconCache.has(key) || iconLoading.has(key)) {\n      return;\n    }\n\n    iconLoading.add(key);\n    try {\n      const bytes = await invoke('get_file_icon', {\n        path: entry.path,\n        ext: entry.isDir ? 'folder' : entry.ext || '',\n      });\n      if (Array.isArray(bytes) && bytes.length > 0) {\n        const image = `data:image/png;base64,${bytesToBase64(Uint8Array.from(bytes))}`;\n        iconCache.set(key, image);\n      } else {\n        iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n      }\n    } catch {\n      iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n    } finally {\n      iconLoading.delete(key);\n    }\n  }\n\n  function syncColumnWidthsToContainer() {\n    const width = tableContainer?.clientWidth || tableAreaEl?.clientWidth;\n    if (!width || lastTableWidth !== 0) {\n      return;\n    }\n\n    const saved = loadColWidths();\n    if (saved) {\n      const total = columnKeys.reduce((s, k) => s + saved[k], 0);\n      if (Math.abs(total - width) > 2) {\n        const scale = (width - saved.modified) / (total - saved.modified);\n        let scaledName = Math.max(minColumnWidth.name, Math.round(saved.name * scale));\n        let scaledSize = Math.max(minColumnWidth.size, Math.round(saved.size * scale));\n        let rawPath = width - saved.modified - scaledName - scaledSize;\n        if (rawPath < minColumnWidth.path) {\n          const shortfall = minColumnWidth.path - rawPath;\n          const nameReduction = Math.min(shortfall, scaledName - minColumnWidth.name);\n          scaledName -= nameReduction;\n          const remaining = shortfall - nameReduction;\n          if (remaining > 0) {\n            scaledSize -= Math.min(remaining, scaledSize - minColumnWidth.size);\n          }\n          rawPath = width - saved.modified - scaledName - scaledSize;\n        }\n        const scaledPath = Math.max(minColumnWidth.path, rawPath);\n        colWidths = { name: scaledName, path: scaledPath, size: scaledSize, modified: saved.modified };\n      } else {\n        colWidths = saved;\n      }\n    } else {\n      const fixedModified = minColumnWidth.modified;\n      const rest = width - fixedModified;\n      const ratioSum = defaultColumnRatios.name + defaultColumnRatios.path + defaultColumnRatios.size;\n      colWidths = {\n        name: Math.max(minColumnWidth.name, Math.round(rest * defaultColumnRatios.name / ratioSum)),\n        path: Math.max(minColumnWidth.path, Math.round(rest * defaultColumnRatios.path / ratioSum)),\n        size: Math.max(minColumnWidth.size, Math.round(rest * defaultColumnRatios.size / ratioSum)),\n        modified: fixedModified\n      };\n    }\n    lastTableWidth = width;\n  }\n\n  function loadColWidths() {\n    try {\n      const raw = localStorage.getItem(COL_WIDTHS_KEY);\n      if (!raw) return null;\n      const parsed = JSON.parse(raw);\n      for (const key of columnKeys) {\n        if (typeof parsed[key] !== 'number' || parsed[key] < (minColumnWidth[key] || 0)) return null;\n      }\n      return parsed;\n    } catch {\n      return null;\n    }\n  }\n\n  function saveColWidths() {\n    localStorage.setItem(COL_WIDTHS_KEY, JSON.stringify(colWidths));\n  }\n\n  function updateViewportHeight() {\n    viewportHeight = tableContainer?.clientHeight || 520;\n    syncColumnWidthsToContainer();\n  }\n\n  function scheduleViewportHeightUpdate() {\n    if (viewportResizeRaf !== null) {\n      return;\n    }\n    viewportResizeRaf = requestAnimationFrame(() => {\n      viewportResizeRaf = null;\n      updateViewportHeight();\n    });\n  }\n\n  function startColumnResize(event, leftKey) {\n    event.preventDefault();\n    event.stopPropagation();\n\n    const index = columnKeys.indexOf(leftKey);\n    if (index < 0 || index >= columnKeys.length - 1) {\n      return;\n    }\n\n    const startX = event.clientX;\n    const startLeft = colWidths[leftKey];\n    const rightKey = columnKeys[index + 1];\n    const startRight = colWidths[rightKey];\n\n    resizeCleanup?.();\n    resizingColumn = leftKey;\n\n    const onMove = (moveEvent) => {\n      const delta = Math.round(moveEvent.clientX - startX);\n      if (leftKey === 'name') {\n        // Two-column trade: name and path swap space, each respects its minimum\n        const nextLeft = Math.max(\n          minColumnWidth[leftKey],\n          Math.min(startLeft + delta, startLeft + startRight - minColumnWidth[rightKey])\n        );\n        const nextRight = startLeft + startRight - nextLeft;\n        colWidths = { ...colWidths, [leftKey]: nextLeft, [rightKey]: nextRight };\n      } else {\n        // path splitter: path grows unconstrained (allows horizontal scroll on right drag)\n        const nextLeft = Math.max(minColumnWidth[leftKey], startLeft + delta);\n        colWidths = { ...colWidths, [leftKey]: nextLeft };\n      }\n    };\n\n    const onUp = () => {\n      cleanup();\n    };\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      document.body.style.cursor = '';\n      document.body.style.userSelect = '';\n      resizingColumn = '';\n      saveColWidths();\n      if (resizeCleanup === cleanup) {\n        resizeCleanup = null;\n      }\n    };\n\n    resizeCleanup = cleanup;\n    document.body.style.cursor = 'col-resize';\n    document.body.style.userSelect = 'none';\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  function selectedPaths() {\n    const sorted = [...selectedIndices].sort((a, b) => a - b);\n    return sorted.map((idx) => results[idx]).filter(Boolean).map((entry) => entry.path);\n  }\n\n  function clearSelection() {\n    selectedIndices = new Set();\n    selectionAnchor = -1;\n    lastSelectedIndex = -1;\n  }\n\n  function selectSingle(index) {\n    selectedIndices = new Set([index]);\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectToggle(index) {\n    const next = new Set(selectedIndices);\n    if (next.has(index)) {\n      next.delete(index);\n    } else {\n      next.add(index);\n    }\n    selectedIndices = next;\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectRange(index) {\n    const anchor = selectionAnchor >= 0 ? selectionAnchor : index;\n    const [from, to] = [Math.min(anchor, index), Math.max(anchor, index)];\n    const next = new Set();\n    for (let i = from; i <= to; i += 1) {\n      next.add(i);\n    }\n    selectedIndices = next;\n    lastSelectedIndex = index;\n  }\n\n  function primaryEntry() {\n    const idx = lastSelectedIndex >= 0 ? lastSelectedIndex : -1;\n    return idx >= 0 ? results[idx] : null;\n  }\n\n  async function refreshStatus() {\n    if (statusRefreshInFlight) {\n      return;\n    }\n    statusRefreshInFlight = true;\n    try {\n      const status = await invoke('get_index_status');\n      const prevState = indexStatus.state;\n      indexStatus = {\n        state: status.state,\n        entriesCount: status.entriesCount,\n        lastUpdated: status.lastUpdated,\n        permissionErrors: status.permissionErrors ?? 0,\n        message: status.message\n      };\n      if (status.state === 'Indexing' && prevState !== 'Indexing') {\n        startElapsedTimer();\n      } else if (status.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n      if (typeof status.scanned === 'number') {\n        scanned = status.scanned;\n      }\n      if (status.state === 'Ready' && prevState !== 'Ready') {\n        scheduleSearch();\n      }\n    } catch (err) {\n      showToast(`Failed to get status: ${String(err)}`);\n    } finally {\n      statusRefreshInFlight = false;\n    }\n  }\n\n  function scheduleSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const scheduledGen = searchGeneration;\n    clearTimeout(searchTimer);\n\n    const now = performance.now();\n    if (now - lastSearchFiredAt >= 200) {\n      // Leading edge: fire immediately if enough time has passed\n      lastSearchFiredAt = now;\n      void runSearch(preserveScroll);\n    } else {\n      // Trailing edge: debounce\n      searchTimer = setTimeout(() => {\n        if (scheduledGen !== searchGeneration) {\n          return;\n        }\n        lastSearchFiredAt = performance.now();\n        void runSearch(preserveScroll);\n      }, 200);\n    }\n  }\n\n  async function runSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const gen = searchGeneration;\n    const searchQuery = query;\n    const searchSortBy = sortBy;\n    const searchSortDir = sortDir;\n    const startedAt = performance.now();\n    try {\n      const keepPaths = new Set(selectedPaths());\n      const next = await invoke('search', {\n        query: searchQuery,\n        limit: PAGE_SIZE,\n        offset: 0,\n        sortBy: searchSortBy,\n        sortDir: searchSortDir\n      });\n\n      if (gen !== searchGeneration) return;\n\n      dbLatencyMs = Math.round(performance.now() - startedAt);\n      dbLastQuery = searchQuery;\n      const entries = Array.isArray(next.entries) ? next.entries : [];\n      searchModeLabel = next.modeLabel || '';\n      results = entries;\n      if (next.totalCount > 0) {\n        totalResults = next.totalCount;\n        totalResultsKnown = true;\n      } else {\n        totalResults = entries.length;\n        totalResultsKnown = false;\n      }\n      hasMore = totalResultsKnown ? results.length < totalResults : entries.length >= PAGE_SIZE;\n      if (!preserveScroll && tableContainer) tableContainer.scrollTop = 0;\n\n      const restored = new Set();\n      for (let i = 0; i < results.length; i += 1) {\n        if (keepPaths.has(results[i].path)) {\n          restored.add(i);\n        }\n      }\n      selectedIndices = restored;\n\n      updateViewportHeight();\n    } catch (err) {\n      if (gen !== searchGeneration) return;\n      showToast(`Search failed: ${String(err)}`);\n    }\n  }\n\n  async function loadMore() {\n    if (!hasMore || loadingMore) return;\n    const gen = searchGeneration;\n    loadingMore = true;\n    try {\n      const batch = await invoke('search', {\n        query,\n        limit: PAGE_SIZE,\n        offset: results.length,\n        sortBy: sortBy,\n        sortDir: sortDir\n      });\n      if (gen !== searchGeneration) return;\n      const arr = Array.isArray(batch.entries) ? batch.entries : [];\n      if (arr.length > 0) results = [...results, ...arr];\n      hasMore = totalResultsKnown ? results.length < totalResults : arr.length >= PAGE_SIZE;\n    } catch (err) {\n      showToast(`Failed to load more: ${String(err)}`);\n    } finally {\n      loadingMore = false;\n    }\n  }\n\n  function moveSelection(delta, withRange = false) {\n    if (results.length === 0) {\n      return;\n    }\n\n    const current = lastSelectedIndex >= 0 ? lastSelectedIndex : 0;\n    const next = Math.max(0, Math.min(results.length - 1, current + delta));\n\n    if (withRange) {\n      selectRange(next);\n    } else {\n      selectSingle(next);\n    }\n\n    const top = next * rowHeight;\n    const bottom = top + rowHeight;\n    if (top < scrollTop) {\n      tableContainer.scrollTop = top;\n    } else if (bottom > scrollTop + viewportHeight) {\n      tableContainer.scrollTop = bottom - viewportHeight;\n    }\n  }\n\n  function handleHeaderSort(column) {\n    if (sortBy === column) {\n      sortDir = sortDir === 'asc' ? 'desc' : 'asc';\n    } else {\n      sortBy = column;\n      sortDir = 'asc';\n    }\n    if (tableContainer) tableContainer.scrollTop = 0;\n    void runSearch();\n  }\n\n  function handleRowClick(event, index) {\n    contextMenu.visible = false;\n\n    if (event.shiftKey) {\n      selectRange(index);\n      return;\n    }\n\n    if (event.metaKey || event.ctrlKey) {\n      selectToggle(index);\n      return;\n    }\n\n    selectSingle(index);\n  }\n\n  function handleRowContextMenu(event, index) {\n    event.preventDefault();\n\n    if (!selectedIndices.has(index)) {\n      selectSingle(index);\n    }\n\n    if (platform === 'windows' || platform === 'macos') {\n      contextMenu.visible = false;\n      const paths = selectedPaths();\n      if (paths.length > 0) {\n        invoke('show_context_menu', {\n          paths,\n          x: event.clientX,\n          y: event.clientY,\n          singleSelection: selectedIndices.size === 1\n        });\n      }\n      return;\n    }\n\n    contextMenu = {\n      visible: true,\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n\n  function handleRowA11yKeydown(event, index) {\n    if (event.key === ' ' || event.key === 'Enter') {\n      event.preventDefault();\n      handleRowClick(event, index);\n    }\n  }\n\n  const DRAG_THRESHOLD = 5;\n  let dragCleanup = null;\n  const dragImgCache = new Map();\n\n  function dragPathsForIndex(index) {\n    const entry = results[index];\n    if (!entry) {\n      return [];\n    }\n\n    if (selectedIndices.has(index) && selectedIndices.size > 0) {\n      return selectedPaths();\n    }\n\n    return [entry.path];\n  }\n\n  function getDragIconEl(entry) {\n    const src = iconFor(entry);\n    let img = dragImgCache.get(src);\n    if (!img) {\n      img = new Image();\n      img.src = src;\n      dragImgCache.set(src, img);\n    }\n    return img.complete && img.naturalWidth > 0 ? img : null;\n  }\n\n  function fillRoundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function buildDragPreview(index) {\n    const entry = results[index];\n    if (!entry) return null;\n\n    const count = selectedIndices.has(index) ? selectedIndices.size : 1;\n    const isDark = theme === 'dark';\n\n    const w = 260;\n    const h = 28;\n    const stackGap = count > 1 ? 4 : 0;\n\n    const canvas = document.createElement('canvas');\n    canvas.width = w;\n    canvas.height = h + stackGap;\n    const ctx = canvas.getContext('2d');\n\n    if (count > 1) {\n      ctx.globalAlpha = 0.35;\n      ctx.fillStyle = isDark ? '#5a6070' : '#b0c4de';\n      fillRoundRect(ctx, 3, 0, w - 3, h, 5);\n      ctx.globalAlpha = 1.0;\n    }\n\n    const ry = stackGap;\n    ctx.fillStyle = isDark ? 'rgba(58, 64, 74, 0.94)' : 'rgba(214, 231, 255, 0.94)';\n    fillRoundRect(ctx, 0, ry, w, h, 5);\n\n    ctx.strokeStyle = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';\n    ctx.lineWidth = 0.5;\n    ctx.beginPath();\n    ctx.moveTo(5, ry);\n    ctx.arcTo(w, ry, w, ry + h, 5);\n    ctx.arcTo(w, ry + h, 0, ry + h, 5);\n    ctx.arcTo(0, ry + h, 0, ry, 5);\n    ctx.arcTo(0, ry, w, ry, 5);\n    ctx.closePath();\n    ctx.stroke();\n\n    const iconEl = getDragIconEl(entry);\n    if (iconEl) {\n      ctx.drawImage(iconEl, 6, ry + 6, 16, 16);\n    } else {\n      ctx.fillStyle = entry.isDir ? '#d9b34f' : '#8d98a5';\n      fillRoundRect(ctx, 6, ry + 6, 16, 16, 2);\n    }\n\n    ctx.fillStyle = isDark ? '#e6e6e8' : '#1a1a1a';\n    ctx.font = '12px -apple-system, \"SF Pro Text\", system-ui, sans-serif';\n    ctx.textBaseline = 'middle';\n\n    let nameMaxW = w - 34;\n    if (count > 1) nameMaxW -= 34;\n\n    let name = entry.name;\n    if (ctx.measureText(name).width > nameMaxW) {\n      while (name.length > 4 && ctx.measureText(name + '\\u2026').width > nameMaxW) {\n        name = name.slice(0, -1);\n      }\n      name += '\\u2026';\n    }\n    ctx.fillText(name, 28, ry + h / 2 + 1);\n\n    if (count > 1) {\n      const badge = String(count);\n      ctx.font = 'bold 10px -apple-system, system-ui, sans-serif';\n      const tw = ctx.measureText(badge).width;\n      const bw = Math.max(20, tw + 10);\n      const bx = w - bw - 6;\n      const by = ry + (h - 18) / 2;\n\n      ctx.fillStyle = isDark ? '#5b8bd9' : '#007aff';\n      fillRoundRect(ctx, bx, by, bw, 18, 9);\n\n      ctx.fillStyle = '#ffffff';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(badge, bx + bw / 2, by + 9);\n    }\n\n    return canvas.toDataURL('image/png');\n  }\n\n  function handleRowMouseDown(event, index) {\n    if (event.button !== 0) return;\n    if (event.metaKey || event.ctrlKey || event.shiftKey) return;\n    if (editing.active) return;\n\n    const startX = event.clientX;\n    const startY = event.clientY;\n    let dragging = false;\n\n    dragCleanup?.();\n\n    const onMove = (e) => {\n      if (dragging) return;\n      const dx = e.clientX - startX;\n      const dy = e.clientY - startY;\n      if (dx * dx + dy * dy < DRAG_THRESHOLD * DRAG_THRESHOLD) return;\n\n      dragging = true;\n      cleanup();\n\n      if (!selectedIndices.has(index)) {\n        selectSingle(index);\n      }\n\n      const paths = dragPathsForIndex(index);\n      if (paths.length > 0) {\n        const icon = buildDragPreview(index);\n        startDrag({ item: paths, icon }).catch(() => {});\n      }\n    };\n\n    const onUp = () => cleanup();\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      if (dragCleanup === cleanup) dragCleanup = null;\n    };\n\n    dragCleanup = cleanup;\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  async function handleRowDoubleClick(index) {\n    if (!selectedIndices.has(index) || selectedIndices.size > 1) {\n      selectSingle(index);\n      await tick();\n    }\n    await invoke('open', { paths: [results[index].path] }).catch((err) => {\n      showToast(`Failed to open: ${String(err)}`);\n    });\n  }\n\n  function closeContextMenu() {\n    contextMenu = {\n      ...contextMenu,\n      visible: false\n    };\n  }\n\n  async function openSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('open', { paths });\n    } catch (err) {\n      showToast(`Failed to open: ${String(err)}`);\n    }\n  }\n\n  async function openWithFallback() {\n    const target = primaryEntry();\n    if (!target) {\n      return;\n    }\n\n    try {\n      await invoke('open_with', { path: target.path });\n    } catch (err) {\n      showToast(`Open With failed: ${String(err)}`);\n    }\n  }\n\n  async function revealSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('reveal_in_finder', { paths });\n    } catch (err) {\n      showToast(`Failed to reveal in Finder: ${String(err)}`);\n    }\n  }\n\n  async function copySelectedPaths() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_paths', { paths });\n      showToast(`Copied ${paths.length} path(s)`);\n    } catch (err) {\n      showToast(`Failed to copy path: ${String(err)}`);\n    }\n  }\n\n  async function copyFiles() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_files', { paths });\n      showToast(`Copied ${paths.length} item(s)`);\n    } catch (err) {\n      showToast(`Failed to copy: ${String(err)}`);\n    }\n  }\n\n  async function trashSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    const message =\n      paths.length === 1\n        ? 'Move selected item to Trash?'\n        : `Move ${paths.length} items to Trash?`;\n\n    if (!window.confirm(message)) {\n      return;\n    }\n\n    try {\n      await invoke('move_to_trash', { paths });\n      showToast('Moved to Trash.');\n      clearSelection();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to move to Trash: ${String(err)}`);\n    }\n  }\n\n  async function resetIndex() {\n    if (indexStatus.state === 'Indexing') {\n      showToast('Indexing in progress. Please try again after it completes.');\n      return;\n    }\n\n    results = [];\n    totalResults = 0;\n    totalResultsKnown = false;\n    clearSelection();\n    scanned = 0;\n    dbLatencyMs = null;\n    dbLastQuery = '';\n    indexStatus = { ...indexStatus, state: 'Indexing', entriesCount: 0, message: null };\n    indexingStartTime = Date.now();\n    indexingElapsed = '';\n    indexingFinishedAt = '';\n\n    try {\n      await invoke('reset_index');\n    } catch (err) {\n      showToast(`Failed to reset index: ${String(err)}`);\n      await refreshStatus();\n    }\n  }\n\n  function isMultiSelected() {\n    return selectedIndices.size > 1;\n  }\n\n  function autoResizeRenameInput() {\n    if (!renameInputEl) return;\n    renameInputEl.style.height = '0';\n    renameInputEl.style.height = renameInputEl.scrollHeight + 'px';\n  }\n\n  async function startRename() {\n    if (isMultiSelected()) {\n      return;\n    }\n\n    const idx = lastSelectedIndex;\n    if (idx < 0 || !results[idx]) {\n      return;\n    }\n\n    const entry = results[idx];\n\n    // Calculate overlay position mathematically.\n    // Name cell text starts at: padding-left(16) + icon(16) + gap(6) = 38px from cell left.\n    // Textarea has padding-left: 0 and border: 1.5px, so text starts ~2px from overlay left.\n    if (tableContainer) {\n      const rect = tableContainer.getBoundingClientRect();\n      const cellLeft = rect.left - tableContainer.scrollLeft;\n      const textLeft = cellLeft + 38;\n      const cellRight = cellLeft + colWidths.name;\n      const rowTop = rect.top + idx * rowHeight - tableContainer.scrollTop;\n      renameOverlay = {\n        top: rowTop,\n        left: textLeft - 2,\n        width: cellRight - textLeft + 2 - 4\n      };\n    }\n\n    editing = {\n      active: true,\n      path: entry.path,\n      index: idx,\n      draftName: entry.name\n    };\n\n    await tick();\n\n    if (renameInputEl) {\n      autoResizeRenameInput();\n      renameInputEl.focus();\n      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n      renameInputEl.setSelectionRange(0, selectionEnd);\n    }\n  }\n\n  function cancelRename() {\n    editing = {\n      active: false,\n      path: '',\n      index: -1,\n      draftName: ''\n    };\n  }\n\n  async function commitRename() {\n    if (!editing.active || editing.index < 0 || !results[editing.index]) {\n      return;\n    }\n\n    const current = results[editing.index];\n    const nextName = editing.draftName;\n\n    try {\n      await invoke('rename', {\n        path: current.path,\n        newName: nextName\n      });\n      cancelRename();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to rename: ${String(err)}`);\n      await tick();\n      renameInputEl?.focus();\n    }\n  }\n\n  function onGlobalClick() {\n    closeContextMenu();\n  }\n\n  function onTitleBarMouseDown(event) {\n    if (event.button !== 0) {\n      return;\n    }\n\n    const activeElement = document.activeElement;\n    if (activeElement instanceof HTMLElement && isTextInputTarget(activeElement)) {\n      activeElement.blur();\n    }\n  }\n\n  async function focusSearch() {\n    await getCurrentWindow().show();\n    await getCurrentWindow().setFocus();\n    searchInputEl?.focus();\n    searchInputEl?.select();\n  }\n\n  function isTextInputTarget(target) {\n    return (\n      target instanceof HTMLInputElement ||\n      target instanceof HTMLTextAreaElement ||\n      target?.isContentEditable\n    );\n  }\n\n  async function handleKeydown(event) {\n    const isMetaSelectAll = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'a';\n    const isMetaCopy = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c';\n    const target = event.target;\n    const isTextInput = isTextInputTarget(target);\n\n    if (isMetaCopy && isTextInput) {\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      if (isTextInput) {\n        event.preventDefault();\n        if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n          target.select();\n        }\n        return;\n      }\n    }\n\n    if (editing.active) {\n      if (event.key === 'Enter') {\n        event.preventDefault();\n        await commitRename();\n        return;\n      }\n\n      if (event.key === 'Escape') {\n        event.preventDefault();\n        const idx = editing.index;\n        cancelRename();\n        selectSingle(idx);\n        await tick();\n        tableContainer?.querySelector('.row.selected')?.focus();\n        return;\n      }\n      return;\n    }\n\n    if (event.key === 'Escape') {\n      event.preventDefault();\n      clearSelection();\n      return;\n    }\n\n    if (event.key === 'ArrowDown') {\n      event.preventDefault();\n      moveSelection(1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'ArrowUp') {\n      event.preventDefault();\n      moveSelection(-1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageDown') {\n      event.preventDefault();\n      moveSelection(Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageUp') {\n      event.preventDefault();\n      moveSelection(-Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'Enter') {\n      event.preventDefault();\n      if (platform === 'windows') {\n        await openSelected();\n      } else {\n        await startRename();\n      }\n      return;\n    }\n\n    if (event.key === 'F2') {\n      event.preventDefault();\n      await startRename();\n      return;\n    }\n\n    if (event.key === ' ' && !isTextInput) {\n      event.preventDefault();\n      const entry = primaryEntry();\n      if (entry) {\n        await invoke('quick_look', { path: entry.path });\n      }\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'f') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      searchInputEl?.select();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'o') {\n      event.preventDefault();\n      await openSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {\n      event.preventDefault();\n      await revealSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c') {\n      event.preventDefault();\n      await copySelectedPaths();\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      event.preventDefault();\n      selectedIndices = new Set(Array.from({ length: results.length }, (_, i) => i));\n      return;\n    }\n\n    if (event.key === 'Delete' || ((event.metaKey || event.ctrlKey) && event.key === 'Backspace')) {\n      if (!isTextInput) {\n        event.preventDefault();\n        await trashSelected();\n      }\n      return;\n    }\n  }\n\n  function formatSize(entry) {\n    if (entry.isDir || entry.size == null) return '';\n    const bytes = entry.size;\n    if (bytes < 1024) return `${bytes} B`;\n    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n    return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n  }\n\n  function formatModified(entry) {\n    if (!entry.mtime) {\n      return '';\n    }\n\n    const d = new Date(entry.mtime * 1000);\n    const pad = (n) => String(n).padStart(2, '0');\n    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;\n  }\n\n  function formatLastUpdated(timestamp) {\n    if (!timestamp) {\n      return '-';\n    }\n\n    return new Date(timestamp * 1000).toLocaleString();\n  }\n\n  function formatElapsed(ms) {\n    const totalSec = Math.floor(ms / 1000);\n    const min = Math.floor(totalSec / 60);\n    const sec = totalSec % 60;\n    return min > 0 ? `${min}m ${sec}s` : `${sec}s`;\n  }\n\n  function updateElapsed() {\n    if (indexingStartTime && indexStatus.state === 'Indexing') {\n      indexingElapsed = formatElapsed(Date.now() - indexingStartTime);\n    }\n  }\n\n  function startElapsedTimer() {\n    clearInterval(elapsedTimer);\n    indexingStartTime = Date.now();\n    indexingElapsed = '0s';\n    indexingFinishedAt = '';\n    elapsedTimer = setInterval(updateElapsed, 1000);\n  }\n\n  function stopElapsedTimer() {\n    clearInterval(elapsedTimer);\n    if (indexingStartTime) {\n      const elapsed = Date.now() - indexingStartTime;\n      indexingFinishedAt = `${formatElapsed(elapsed)}`;\n    }\n    indexingStartTime = null;\n    indexingElapsed = '';\n  }\n\n  function displayPath(path) {\n    if (!path) {\n      return path;\n    }\n\n    if (!homePrefix) {\n      return path;\n    }\n\n    if (path === homePrefix) {\n      return '~';\n    }\n\n    if (path.startsWith(`${homePrefix}/`)) {\n      return `~${path.slice(homePrefix.length)}`;\n    }\n\n    return path;\n  }\n\n  let unlistenFns = [];\n\n  onMount(async () => {\n    const t0 = performance.now();\n    const ms = () => Math.round(performance.now() - t0);\n    const DEBUG_STARTUP = false;\n    const flog = DEBUG_STARTUP ? (msg) => invoke('frontend_log', { msg }).catch(() => {}) : () => {};\n\n    flog(`[startup/fe] onMount entered`);\n\n    updateViewportHeight();\n    flog(`[startup/fe] +${ms()}ms updateViewportHeight done`);\n\n    invoke('set_native_theme', { theme });\n\n    platform = await invoke('get_platform');\n    flog(`[startup/fe] +${ms()}ms get_platform done`);\n\n    const unlistenProgress = await listen('index_progress', (event) => {\n      scanned = event.payload.scanned;\n      if (indexStatus.state !== 'Indexing') {\n        indexStatus = {\n          ...indexStatus,\n          state: 'Indexing'\n        };\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_progress) registered`);\n\n    const unlistenState = await listen('index_state', (event) => {\n      flog(`[startup/fe] index_state event received: ${event.payload.state} at +${ms()}ms`);\n      const prevState = indexStatus.state;\n      indexStatus = {\n        ...indexStatus,\n        state: event.payload.state,\n        message: event.payload.message ?? null,\n        isCatchup: event.payload.isCatchup ?? false\n      };\n\n      if (event.payload.state === 'Indexing' && prevState !== 'Indexing') {\n        if (prevState === 'Ready') {\n          lastReadyCount = indexStatus.entriesCount;\n        }\n        startElapsedTimer();\n      } else if (event.payload.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n\n      if (event.payload.state === 'Ready') {\n        scheduleSearch();\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_state) registered`);\n\n    const unlistenUpdated = await listen('index_updated', (event) => {\n      indexStatus = {\n        ...indexStatus,\n        entriesCount: event.payload.entriesCount,\n        lastUpdated: event.payload.lastUpdated,\n        permissionErrors: event.payload.permissionErrors ?? indexStatus.permissionErrors\n      };\n\n      scheduleSearch(true);\n    });\n\n    const unlistenFocus = await listen('focus_search', () => {\n      void focusSearch();\n    });\n\n    const unlistenCtxMenuAction = await listen('context_menu_action', (event) => {\n      switch (event.payload) {\n        case 'open': void openSelected(); break;\n        case 'quick_look': {\n          const e = primaryEntry();\n          if (e) void invoke('quick_look', { path: e.path });\n          break;\n        }\n        case 'open_with': void openWithFallback(); break;\n        case 'reveal': void revealSelected(); break;\n        case 'copy_files': void copyFiles(); break;\n        case 'copy_path': void copySelectedPaths(); break;\n        case 'trash': void trashSelected(); break;\n        case 'rename': void startRename(); break;\n      }\n    });\n\n    unlistenFns = [unlistenProgress, unlistenState, unlistenUpdated, unlistenFocus, unlistenCtxMenuAction];\n    flog(`[startup/fe] +${ms()}ms all listeners registered`);\n\n    // Fetch backend state IMMEDIATELY after listeners are registered.\n    // Events emitted before listener registration are lost, so this\n    // is the only reliable way to get the current state.\n    await refreshStatus();\n    flog(`[startup/fe] +${ms()}ms refreshStatus done (state=${indexStatus.state})`);\n\n    // Show Svelte UI: remove skeleton, focus search input.\n    await tick();\n    document.getElementById('skeleton')?.remove();\n    await focusSearch();\n    flog(`[startup/fe] +${ms()}ms WINDOW VISIBLE â€” skeleton removed`);\n\n    try {\n      homePrefix = await invoke('get_home_dir');\n    } catch {\n      homePrefix = '';\n    }\n    flog(`[startup/fe] +${ms()}ms get_home_dir done`);\n\n    if (!localStorage.getItem('everything-fda-notice-v1')) {\n      showToast('macOS Full Disk Access permission may be required for full disk search.');\n      localStorage.setItem('everything-fda-notice-v1', '1');\n    }\n    flog(`[startup/fe] +${ms()}ms calling runSearch...`);\n    await runSearch();\n    flog(`[startup/fe] +${ms()}ms runSearch done`);\n\n    if (typeof ResizeObserver !== 'undefined') {\n      tableResizeObserver = new ResizeObserver(() => {\n        scheduleViewportHeightUpdate();\n      });\n      if (tableContainer) {\n        tableResizeObserver.observe(tableContainer);\n      } else if (tableAreaEl) {\n        tableResizeObserver.observe(tableAreaEl);\n      }\n    }\n\n    window.addEventListener('resize', scheduleViewportHeightUpdate);\n    window.addEventListener('click', onGlobalClick);\n    statusRefreshTimer = setInterval(() => {\n      if (indexStatus.state === 'Indexing') {\n        void refreshStatus();\n      }\n    }, 1000);\n    console.log(`[startup/fe] +${ms()}ms onMount complete`);\n  });\n\n  onDestroy(async () => {\n    clearTimeout(searchTimer);\n    clearTimeout(toastTimer);\n    clearInterval(statusRefreshTimer);\n    clearInterval(elapsedTimer);\n    resizeCleanup?.();\n\n    for (const unlisten of unlistenFns) {\n      unlisten();\n    }\n\n    tableResizeObserver?.disconnect();\n    tableResizeObserver = null;\n    if (viewportResizeRaf !== null) {\n      cancelAnimationFrame(viewportResizeRaf);\n      viewportResizeRaf = null;\n    }\n    window.removeEventListener('resize', scheduleViewportHeightUpdate);\n    window.removeEventListener('click', onGlobalClick);\n  });\n</script>\n\n<svelte:window on:keydown={handleKeydown} />\n\n<div class=\"app-shell\" data-theme={theme}>\n  <div class=\"title-bar\" role=\"presentation\" data-tauri-drag-region on:mousedown={onTitleBarMouseDown}>\n    <div class=\"title-left\"></div>\n    <div class=\"title-center\">\n      <svg class=\"title-icon\" viewBox=\"0 0 215 205\" fill-rule=\"evenodd\" aria-hidden=\"true\">\n        <path d=\"M85 0c46.9 0 85 38.1 85 85 0 20.1-7.2 38.5-19.2 52.7l40.7 40.8c5.8 5.8 5.8 15.2 0 21-5.8 5.8-15.2 5.8-21 0l-40.7-40.7c-13.6 9.7-30.4 15.2-44.8 15.2-46.9 0-85-42.1-85-89 0-46.9 38.1-85 85-85z m0 32c-29.3 0-53 23.7-53 53 0 29.3 23.7 53 53 53 29.3 0 53-23.7 53-53 0-29.3-23.7-53-53-53z\"/>\n      </svg>\n      <span class=\"title-text\">Everything</span>\n    </div>\n    <div class=\"title-right\"></div>\n  </div>\n\n  <header class=\"search-bar\">\n    <input\n      bind:this={searchInputEl}\n      class=\"search-input\"\n      type=\"text\"\n      bind:value={query}\n      on:input={scheduleSearch}\n      on:focus={clearSelection}\n      placeholder=\"Search file/folder names\"\n      autocomplete=\"off\"\n      spellcheck=\"false\"\n    />\n  </header>\n\n  <section class=\"table-area\" bind:this={tableAreaEl} style={tableGridStyle}>\n    <div class=\"table-header\">\n      <div class=\"table-header-track\">\n        <div class=\"col name\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('name')}>\n            Name{#if sortBy === 'name'}{@html sortIconHtml(sortDir)}{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'name'}\n            on:mousedown={(event) => startColumnResize(event, 'name')}\n            aria-label=\"Resize Name column\"\n          />\n        </div>\n\n        <div class=\"col path\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('dir')}>\n            Path{#if sortBy === 'dir'}{@html sortIconHtml(sortDir)}{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'path'}\n            on:mousedown={(event) => startColumnResize(event, 'path')}\n            aria-label=\"Resize Path column\"\n          />\n        </div>\n\n        <div class=\"col size\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('size')}>\n            Size{#if sortBy === 'size'}{@html sortIconHtml(sortDir)}{/if}\n          </button>\n        </div>\n\n        <div class=\"col modified\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('mtime')}>\n            Modified{#if sortBy === 'mtime'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n      </div>\n    </div>\n\n    <div\n      class=\"table-body\"\n      bind:this={tableContainer}\n      on:scroll={() => {\n        scrollTop = tableContainer.scrollTop;\n        headerScrollLeft = tableContainer.scrollLeft;\n        if (editing.active) void commitRename();\n        const scrollBottom = scrollTop + tableContainer.clientHeight;\n        if (scrollBottom >= totalHeight - rowHeight * 10) {\n          void loadMore();\n        }\n      }}\n    >\n      <div class=\"spacer\" style={`height:${totalHeight}px`}>\n        <div class=\"rows\" style={`transform: translateY(${translateY}px);`}>\n          {#each visibleRows as entry, localIndex}\n            {@const index = startIndex + localIndex}\n            <div\n              class=\"row {selectedIndices.has(index) ? 'selected' : ''}\"\n              on:mousedown={(event) => handleRowMouseDown(event, index)}\n              on:click={(event) => handleRowClick(event, index)}\n              on:keydown={(event) => handleRowA11yKeydown(event, index)}\n              on:dblclick={() => handleRowDoubleClick(index)}\n              on:contextmenu={(event) => handleRowContextMenu(event, index)}\n              role=\"row\"\n              tabindex=\"0\"\n            >\n              <div class=\"cell name\">\n                <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n                <span class=\"ellipsis\" class:name-editing={editing.active && editing.index === index}>{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n              </div>\n              <div class=\"cell path\"><span class=\"ellipsis\">{displayPath(entry.dir)}</span></div>\n              <div class=\"cell size\">{formatSize(entry)}</div>\n              <div class=\"cell modified\">{formatModified(entry)}</div>\n            </div>\n          {/each}\n        </div>\n      </div>\n    </div>\n  </section>\n\n  <footer class=\"status-bar\">\n    <div class=\"status-left\">\n      <span class=\"status-state\">\n        <span class=\"state-dot {indexStatus.state === 'Indexing' ? 'indexing' : indexStatus.state === 'Error' ? 'error' : 'ready'}\"></span>\n        {#if indexStatus.state === 'Indexing'}\n          Indexing{#if lastReadyCount > 0} ({Math.min(99, Math.round((scanned / lastReadyCount) * 100))}%){/if}{#if indexingElapsed} Â· {indexingElapsed}{/if}\n          {#if !indexStatus.isCatchup}\n            Â· {scanned.toLocaleString()} scanned\n          {/if}\n        {:else}\n          Index: {indexStatus.state}\n        {/if}\n      </span>\n      <span>{indexStatus.entriesCount.toLocaleString()} entries</span>\n      {#if indexingFinishedAt && indexStatus.state !== 'Indexing'}\n        <span>in {indexingFinishedAt}</span>\n      {/if}\n      {#if dbLatencyMs !== null && dbLastQuery}\n        <span>\"{dbLastQuery}\" {dbLatencyMs}ms Â· {totalResults} results</span>\n      {/if}\n      {#if searchModeLabel === 'spotlight' || searchModeLabel === 'spotlight_timeout'}\n        <span class=\"status-spotlight\">Spotlight fallback{#if searchModeLabel === 'spotlight_timeout'} (partial){/if}</span>\n      {/if}\n      {#if indexStatus.permissionErrors > 0}\n        <span class=\"status-warning\">{indexStatus.permissionErrors.toLocaleString()} permission errors</span>\n      {/if}\n      {#if indexStatus.message}\n        <span class={indexStatus.isCatchup ? 'index-progress' : 'status-error'}>{indexStatus.message}</span>\n      {/if}\n    </div>\n    <div class=\"status-right\">\n      <button class=\"status-btn\" on:click={cycleTheme} title=\"Switch theme\">\n        {theme === 'dark' ? 'â˜€ Light' : 'â—‘ Dark'}\n      </button>\n      <button\n        class=\"status-btn rebuild-btn\"\n        on:click={resetIndex}\n        disabled={indexStatus.state === 'Indexing'}\n        title={indexStatus.state === 'Indexing' ? 'Cannot reset while indexing is in progress.' : 'Reset and rebuild the index.'}\n      >\n        <svg class=\"rebuild-icon\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n          <path d=\"M23 4v6h-6\"/><path d=\"M20.49 15a9 9 0 1 1-2.12-9.36L23 10\"/>\n        </svg>\n        Rebuild Index\n      </button>\n    </div>\n  </footer>\n\n  {#if editing.active}\n    <div\n      class=\"rename-overlay\"\n      style=\"top:{renameOverlay.top}px; left:{renameOverlay.left}px; width:{renameOverlay.width}px;\"\n      role=\"presentation\"\n      on:mousedown|stopPropagation\n    >\n      <textarea\n        bind:this={renameInputEl}\n        class=\"rename-textarea\"\n        bind:value={editing.draftName}\n        on:input={autoResizeRenameInput}\n        on:click|stopPropagation\n        on:blur={commitRename}\n      />\n    </div>\n  {/if}\n\n  {#if contextMenu.visible}\n    <div class=\"context-menu\" style={`left:${contextMenu.x}px;top:${contextMenu.y}px;`}>\n      <button on:click={() => (closeContextMenu(), openSelected())}>Open</button>\n      <button on:click={async () => { closeContextMenu(); const e = primaryEntry(); if (e) await invoke('quick_look', { path: e.path }); }}>Quick Look</button>\n      <button on:click={() => (closeContextMenu(), openWithFallback())}>Open With... (Reveal in Finder)</button>\n      <button on:click={() => (closeContextMenu(), revealSelected())}>Reveal in Finder</button>\n      <button on:click={() => (closeContextMenu(), copySelectedPaths())}>Copy Path</button>\n      <button on:click={() => (closeContextMenu(), trashSelected())}>Move to Trash</button>\n      {#if selectedIndices.size === 1}\n        <button on:click={() => (closeContextMenu(), startRename())}>Rename</button>\n      {/if}\n    </div>\n  {/if}\n\n  {#if toast}\n    <div class=\"toast\">{toast}</div>\n  {/if}\n</div>\n\n<style>\n  :global(:root) {\n    color-scheme: light dark;\n    --bg-app: transparent;\n    --text-primary: #0d1826;\n    --text-muted: #48596c;\n    --bar-grad-top: rgba(255, 255, 255, 0.48);\n    --bar-grad-bottom: rgba(248, 250, 253, 0.42);\n    --surface-header: rgba(252, 252, 255, 0.40);\n    --surface: rgba(255, 255, 255, 0.22);\n    --border-soft: rgba(0, 0, 0, 0.07);\n    --border-input: rgba(0, 0, 0, 0.13);\n    --focus-ring: #6f96e6;\n    --row-border: rgba(0, 0, 0, 0.032);\n    --row-hover: rgba(0, 0, 0, 0.06);\n    --row-selected: rgba(0, 0, 0, 0.12);\n    --button-bg: rgba(255, 255, 255, 0.62);\n    --button-border: rgba(0, 0, 0, 0.10);\n    --button-text: #2c3e50;\n    --menu-bg: rgba(240, 241, 248, 0.90);\n    --menu-border: rgba(0, 0, 0, 0.06);\n    --menu-hover: rgba(255, 255, 255, 0.62);\n    --menu-text: #1a2a38;\n    --error-text: #b64545;\n    --warning-text: #8f6500;\n    --toast-bg: rgba(18, 22, 32, 0.90);\n    --toast-text: #ffffff;\n  }\n\n  @media (prefers-color-scheme: dark) {\n    :global(:root) {\n      --bg-app: transparent;\n      --text-primary: #e6e6ea;\n      --text-muted: #9494a4;\n      --bar-grad-top: rgba(38, 38, 46, 0.52);\n      --bar-grad-bottom: rgba(30, 30, 38, 0.46);\n      --surface-header: rgba(32, 32, 40, 0.46);\n      --surface: rgba(18, 18, 26, 0.32);\n      --border-soft: rgba(255, 255, 255, 0.065);\n      --border-input: rgba(255, 255, 255, 0.14);\n      --focus-ring: #5b8bd9;\n      --row-border: rgba(255, 255, 255, 0.026);\n      --row-hover: rgba(255, 255, 255, 0.08);\n      --row-selected: rgba(255, 255, 255, 0.14);\n      --button-bg: rgba(255, 255, 255, 0.072);\n      --button-border: rgba(255, 255, 255, 0.11);\n      --button-text: #d6d6e0;\n      --menu-bg: rgba(36, 36, 46, 0.90);\n      --menu-border: rgba(255, 255, 255, 0.066);\n      --menu-hover: rgba(255, 255, 255, 0.062);\n      --menu-text: #e0e0e8;\n      --error-text: #ff9d9d;\n      --warning-text: #e0c670;\n      --toast-bg: rgba(10, 10, 16, 0.93);\n      --toast-text: #f2f2f6;\n    }\n  }\n\n  /* â”€â”€ Theme: Dark â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme=\"dark\"]) {\n    color-scheme: dark;\n    --bg-app: #1E1E21;\n    --text-primary: #E2E8F0;\n    --text-muted: #94A3B8;\n    --bar-grad-top: #1E1E21;\n    --bar-grad-bottom: #1E1E21;\n    --surface-header: #1E1E21;\n    --surface: #1E1E21;\n    --bg-input: #161618;\n    --border-soft: #2A2A2D;\n    --border-input: rgba(255, 255, 255, 0.06);\n    --focus-ring: #4DA8FF;\n    --accent: #4DA8FF;\n    --row-border: rgba(255, 255, 255, 0.02);\n    --row-hover: #282828;\n    --row-selected: rgba(77, 168, 255, 0.10);\n    --button-bg: rgba(255, 255, 255, 0.05);\n    --button-border: #2A2A2D;\n    --button-text: #94A3B8;\n    --menu-bg: #252528;\n    --menu-border: #2A2A2D;\n    --menu-hover: rgba(255, 255, 255, 0.04);\n    --menu-text: #E2E8F0;\n    --error-text: #ff9d9d;\n    --warning-text: #e0c670;\n    --toast-bg: rgba(10, 10, 16, 0.93);\n    --toast-text: #f2f2f6;\n  }\n\n  /* â”€â”€ Theme: Light â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme=\"light\"]) {\n    color-scheme: light;\n    --bg-app: #F5F5F7;\n    --text-primary: #1C1C1E;\n    --text-muted: #6E6E7A;\n    --bar-grad-top: #F5F5F7;\n    --bar-grad-bottom: #F5F5F7;\n    --surface-header: #F5F5F7;\n    --surface: #F5F5F7;\n    --bg-input: #FFFFFF;\n    --border-soft: #D1D1D6;\n    --border-input: rgba(0, 0, 0, 0.10);\n    --focus-ring: #3A8BF5;\n    --accent: #3A8BF5;\n    --row-border: rgba(0, 0, 0, 0.04);\n    --row-hover: rgba(0, 0, 0, 0.04);\n    --row-selected: rgba(58, 139, 245, 0.10);\n    --button-bg: #FFFFFF;\n    --button-border: #D1D1D6;\n    --button-text: #3C3C43;\n    --menu-bg: #FFFFFF;\n    --menu-border: #D1D1D6;\n    --menu-hover: rgba(0, 0, 0, 0.05);\n    --menu-text: #1C1C1E;\n    --error-text: #D93025;\n    --warning-text: #B45309;\n    --toast-bg: rgba(255, 255, 255, 0.95);\n    --toast-text: #1C1C1E;\n  }\n\n  /* â”€â”€ Themed element overrides â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme]) {\n    background: var(--bg-app);\n  }\n\n  /* Search bar: flat, no gradient, no separator */\n  :global([data-theme]) .search-bar {\n    height: 44px;\n    padding: 0 16px;\n    background: var(--bg-app);\n    border-bottom: none;\n  }\n\n  :global([data-theme]) .search-input {\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n    font-family: 'JetBrains Mono', 'SF Mono', monospace;\n    font-size: 12px;\n    height: 34px;\n    border-radius: 8px;\n  }\n\n  /* Table header: flat bg, 16px edge padding */\n  :global([data-theme]) .table-header {\n    background: var(--bg-app);\n  }\n\n  :global([data-theme]) .col-button {\n    padding: 0 8px;\n  }\n\n  :global([data-theme]) .col.name .col-button {\n    padding-left: 16px;\n  }\n\n  /* Row cells: JetBrains Mono, 16px outer edges */\n  :global([data-theme]) .cell {\n    font-family: 'JetBrains Mono', monospace;\n  }\n\n  :global([data-theme]) .cell.name {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    padding-left: 16px;\n    font-size: 12px;\n    color: var(--text-primary);\n  }\n\n  :global([data-theme]) .cell.path {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.size {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.modified {\n    padding-right: 16px;\n    font-size: 11px;\n    white-space: nowrap;\n  }\n\n  :global([data-theme]) .row.selected {\n    box-shadow: inset 3px 0 0 var(--accent);\n  }\n\n  /* Dim path/size/date cells in themed mode */\n  :global([data-theme]) .cell.path,\n  :global([data-theme]) .cell.size,\n  :global([data-theme]) .cell.modified {\n    color: var(--text-muted);\n  }\n\n  :global(:root) {\n    background: transparent;\n  }\n\n  :global(html, body) {\n    margin: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    background: transparent;\n    color: var(--text-primary);\n    font-family: Inter, 'SF Pro Text', 'Segoe UI', Helvetica, Arial, sans-serif;\n  }\n\n  :global(#app) {\n    width: 100%;\n    height: 100%;\n  }\n\n  .app-shell {\n    display: grid;\n    grid-template-rows: auto auto 1fr auto;\n    height: 100%;\n    min-width: 0;\n  }\n\n  .title-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 44px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    cursor: default;\n    flex-shrink: 0;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-left {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-center {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-right {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-icon {\n    width: 14px;\n    height: 14px;\n    fill: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .title-text {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 13px;\n    font-weight: 500;\n    color: var(--text-primary);\n    letter-spacing: -0.01em;\n  }\n\n  .search-bar {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding: 8px;\n    background: linear-gradient(180deg, var(--bar-grad-top) 0%, var(--bar-grad-bottom) 100%);\n    border-bottom: 1px solid var(--border-soft);\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .search-input {\n    display: block;\n    box-sizing: border-box;\n    width: 100%;\n    min-width: 0;\n    flex: 1 1 auto;\n    height: 36px;\n    border: 1px solid var(--border-input);\n    border-radius: 14px;\n    padding: 0 10px;\n    font-size: 14px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    backdrop-filter: blur(12px) saturate(160%);\n    -webkit-backdrop-filter: blur(12px) saturate(160%);\n  }\n\n  .search-input::placeholder {\n    color: var(--text-muted);\n    opacity: 0.85;\n    font-size: 12px;\n  }\n\n  .search-input:focus {\n    outline: none;\n    border-color: var(--focus-ring);\n    box-shadow: 0 0 0 2px rgba(125, 169, 255, 0.25);\n  }\n\n  .table-area {\n    display: grid;\n    grid-template-rows: auto 1fr;\n    min-height: 0;\n    min-width: 0;\n  }\n\n  .table-header-track,\n  .row {\n    display: grid;\n    grid-template-columns: var(--col-name) var(--col-path) var(--col-size) var(--col-modified);\n    align-items: center;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .table-header {\n    height: 32px;\n    border-bottom: 1px solid var(--border-soft);\n    background: var(--surface-header);\n    user-select: none;\n    overflow: hidden;\n    flex-shrink: 0;\n  }\n\n  .table-header-track {\n    height: 100%;\n    transform: translateX(var(--header-offset, 0px));\n    will-change: transform;\n  }\n\n  .table-header .col {\n    position: relative;\n    min-width: 0;\n    height: 100%;\n  }\n\n  .col-button {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n    gap: 4px;\n    box-sizing: border-box;\n    padding: 0 8px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 11px;\n    font-weight: 600;\n    line-height: 1;\n    color: var(--text-muted);\n    text-align: left;\n    margin: 0;\n    border: none;\n    background: transparent;\n    cursor: pointer;\n  }\n\n  .sort-icon {\n    width: 10px;\n    height: 10px;\n    flex-shrink: 0;\n    color: var(--accent);\n  }\n\n  .col-resizer {\n    position: absolute;\n    top: 0;\n    right: -4px;\n    width: 8px;\n    height: 100%;\n    border: none;\n    padding: 0;\n    background: transparent;\n    cursor: col-resize;\n    z-index: 30;\n  }\n\n  .col-resizer::after {\n    content: '';\n    position: absolute;\n    top: 7px;\n    bottom: 7px;\n    left: 50%;\n    width: 1px;\n    transform: translateX(-50%);\n    background: var(--border-soft);\n    opacity: 0;\n    transition: opacity 0.15s ease;\n  }\n\n  .table-header .col:hover .col-resizer::after,\n  .col-resizer.active::after {\n    opacity: 1;\n  }\n\n  .table-body {\n    overflow: auto;\n    min-height: 0;\n    min-width: 0;\n    background: var(--surface);\n  }\n\n  .spacer {\n    position: relative;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .rows {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .row {\n    height: 30px;\n    border-bottom: 1px solid var(--row-border);\n    cursor: default;\n    -webkit-user-select: none;\n    user-select: none;\n    outline: none;\n  }\n\n  .row:hover {\n    background: var(--row-hover);\n  }\n\n  .row.selected {\n    background: var(--row-selected);\n  }\n\n  .cell {\n    padding: 0 8px;\n    font-size: 12px;\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    min-width: 0;\n  }\n\n  .cell.size {\n    text-align: right;\n    font-variant-numeric: tabular-nums;\n  }\n\n  .ellipsis {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n\n  .hl {\n    background: none;\n    color: inherit;\n    font-weight: 700;\n  }\n\n  .file-icon {\n    width: 16px;\n    height: 16px;\n    flex: 0 0 auto;\n  }\n\n  .name-editing {\n    opacity: 0.25;\n  }\n\n  .rename-overlay {\n    position: fixed;\n    z-index: 100;\n    min-width: 120px;\n  }\n\n  .rename-textarea {\n    display: block;\n    width: 100%;\n    box-sizing: border-box;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 12px;\n    line-height: 18px;\n    padding: 5px 4px 5px 0;\n    border: 1.5px solid var(--focus-ring);\n    border-radius: 4px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    outline: none;\n    resize: none;\n    overflow: hidden;\n    box-shadow: 0 2px 14px rgba(0, 0, 0, 0.22), 0 0 0 3px rgba(77, 168, 255, 0.13);\n  }\n\n  .status-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 32px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    border-top: 1px solid var(--border-soft);\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 11px;\n    color: var(--text-muted);\n    white-space: nowrap;\n    overflow: hidden;\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .status-left {\n    display: flex;\n    align-items: center;\n    gap: 16px;\n    overflow: hidden;\n    min-width: 0;\n  }\n\n  .status-right {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    flex-shrink: 0;\n  }\n\n  .status-btn {\n    border: 1px solid var(--button-border);\n    border-radius: 5px;\n    background: var(--button-bg);\n    color: var(--button-text);\n    font-size: 11px;\n    height: 22px;\n    padding: 0 8px;\n    cursor: pointer;\n  }\n\n  .status-btn:hover {\n    filter: brightness(1.06);\n  }\n\n  .status-btn:disabled {\n    opacity: 0.55;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .status-state {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n  }\n\n  .state-dot {\n    width: 6px;\n    height: 6px;\n    border-radius: 50%;\n    flex-shrink: 0;\n  }\n\n  .state-dot.ready { background: #28C840; }\n  .state-dot.indexing { background: #FEBC2E; }\n  .state-dot.error { background: #FF5F57; }\n\n  .rebuild-btn {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 10px;\n    font-weight: 500;\n    background: var(--button-bg);\n    border: 1px solid var(--button-border);\n    border-radius: 4px;\n    color: var(--button-text);\n    height: 22px;\n    padding: 0 10px;\n    cursor: pointer;\n  }\n\n  .rebuild-btn:hover {\n    filter: brightness(1.1);\n  }\n\n  .rebuild-btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .rebuild-icon {\n    width: 11px;\n    height: 11px;\n    color: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .status-error {\n    color: var(--error-text);\n  }\n\n  .status-warning {\n    color: var(--warning-text);\n  }\n\n  .status-spotlight {\n    color: #f59e0b;\n    font-weight: 600;\n  }\n\n  .context-menu {\n    position: fixed;\n    z-index: 200;\n    width: 220px;\n    border: 1px solid var(--menu-border);\n    border-radius: 10px;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.16), inset 0 0 0 0.5px rgba(255, 255, 255, 0.18);\n    background: var(--menu-bg);\n    backdrop-filter: blur(28px) saturate(180%);\n    -webkit-backdrop-filter: blur(28px) saturate(180%);\n    overflow: hidden;\n  }\n\n  .context-menu button {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    padding: 8px 10px;\n    font-size: 12px;\n    color: var(--menu-text);\n  }\n\n  .context-menu button:hover {\n    background: var(--menu-hover);\n  }\n\n  .toast {\n    position: fixed;\n    right: 14px;\n    bottom: 18px;\n    background: var(--toast-bg);\n    color: var(--toast-text);\n    border-radius: 10px;\n    padding: 9px 12px;\n    font-size: 12px;\n    z-index: 250;\n    backdrop-filter: blur(20px) saturate(180%);\n    -webkit-backdrop-filter: blur(20px) saturate(180%);\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);\n  }\n</style>\n","structuredPatch":[{"oldStart":1489,"oldLines":7,"newStart":1489,"newLines":7,"lines":[" ","         <div class=\"col modified\">","           <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('mtime')}>","-            Modified{#if sortBy === 'mtime'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}","+            Modified{#if sortBy === 'mtime'}{@html sortIconHtml(sortDir)}{/if}","           </button>","         </div>","       </div>"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"c528aef1-eb51-495e-a665-e20a26ac3baf"}
{"parentUuid":"9683dbd2-d5db-46e6-b74b-d95a7dc1b02f","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01FdhNZR99WDNRQbMLEKSXSe","type":"message","role":"assistant","content":[{"type":"text","text":"ì´ì œ `.sort-icon`ì„ `:global`ë¡œ ë³€ê²½í•˜ê³  `.rebuild-btn` CSSë¥¼ ì •ë¦¬í•©ë‹ˆë‹¤."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":318,"cache_read_input_tokens":101153,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":318},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPRUNvUsDrdxp3auY3N","type":"assistant","uuid":"0a0d38f0-ce33-4b74-a058-31510d0ea032","timestamp":"2026-02-21T14:40:09.587Z"}
{"parentUuid":"0a0d38f0-ce33-4b74-a058-31510d0ea032","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01FdhNZR99WDNRQbMLEKSXSe","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Kx7Bc1wQjEkhGPuhxFeJa2","name":"Read","input":{"file_path":"/Users/al02402336/everything/src/App.svelte","offset":1985,"limit":12},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":318,"cache_read_input_tokens":101153,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":318},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPRUNvUsDrdxp3auY3N","type":"assistant","uuid":"91e0b273-169b-4f96-a39e-0c20a8d3a5b6","timestamp":"2026-02-21T14:40:10.239Z"}
{"parentUuid":"91e0b273-169b-4f96-a39e-0c20a8d3a5b6","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01Kx7Bc1wQjEkhGPuhxFeJa2","toolUseID":"toolu_01Kx7Bc1wQjEkhGPuhxFeJa2","timestamp":"2026-02-21T14:40:10.269Z","uuid":"ee5fae9f-815f-4fc0-ac71-126bbc91c788"}
{"parentUuid":"91e0b273-169b-4f96-a39e-0c20a8d3a5b6","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Kx7Bc1wQjEkhGPuhxFeJa2","type":"tool_result","content":"  1985â†’    border: none;\n  1986â†’    background: transparent;\n  1987â†’    cursor: pointer;\n  1988â†’  }\n  1989â†’\n  1990â†’  .sort-icon {\n  1991â†’    width: 10px;\n  1992â†’    height: 10px;\n  1993â†’    flex-shrink: 0;\n  1994â†’    color: var(--accent);\n  1995â†’  }\n  1996â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"72327f52-0c30-4caa-8276-0bfd59e59edb","timestamp":"2026-02-21T14:40:10.268Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src/App.svelte","content":"    border: none;\n    background: transparent;\n    cursor: pointer;\n  }\n\n  .sort-icon {\n    width: 10px;\n    height: 10px;\n    flex-shrink: 0;\n    color: var(--accent);\n  }\n","numLines":12,"startLine":1985,"totalLines":2282}},"sourceToolAssistantUUID":"91e0b273-169b-4f96-a39e-0c20a8d3a5b6"}
{"parentUuid":"72327f52-0c30-4caa-8276-0bfd59e59edb","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01CmJpkEwcAGvD5jA9CyLTP4","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Vw1NijmnXy2HDzfDsQySAS","name":"Edit","input":{"replace_all":false,"file_path":"/Users/al02402336/everything/src/App.svelte","old_string":"  .sort-icon {\n    width: 10px;\n    height: 10px;\n    flex-shrink: 0;\n    color: var(--accent);\n  }","new_string":"  :global(.sort-icon) {\n    width: 10px;\n    height: 10px;\n    flex-shrink: 0;\n    color: var(--accent);\n  }"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":346,"cache_read_input_tokens":101471,"output_tokens":214,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":346,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYMPRkQ5a5Eyf6rtxikbC","type":"assistant","uuid":"a081b0ed-8e79-422a-8813-f8c8a5df31df","timestamp":"2026-02-21T14:40:13.650Z"}
{"parentUuid":"a081b0ed-8e79-422a-8813-f8c8a5df31df","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01Vw1NijmnXy2HDzfDsQySAS","toolUseID":"toolu_01Vw1NijmnXy2HDzfDsQySAS","timestamp":"2026-02-21T14:40:13.659Z","uuid":"fc58658d-c4ac-4140-83d0-36bc577125ce"}
{"parentUuid":"a081b0ed-8e79-422a-8813-f8c8a5df31df","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Vw1NijmnXy2HDzfDsQySAS","type":"tool_result","content":"The file /Users/al02402336/everything/src/App.svelte has been updated successfully."}]},"uuid":"9d67d6bc-9b24-4bbe-8d2f-05b2c5e5ae82","timestamp":"2026-02-21T14:40:13.658Z","toolUseResult":{"filePath":"/Users/al02402336/everything/src/App.svelte","oldString":"  .sort-icon {\n    width: 10px;\n    height: 10px;\n    flex-shrink: 0;\n    color: var(--accent);\n  }","newString":"  :global(.sort-icon) {\n    width: 10px;\n    height: 10px;\n    flex-shrink: 0;\n    color: var(--accent);\n  }","originalFile":"<script>\n  import { onDestroy, onMount, tick } from 'svelte';\n  import { invoke } from '@tauri-apps/api/core';\n  import { listen } from '@tauri-apps/api/event';\n  import { getCurrentWindow } from '@tauri-apps/api/window';\n  import { startDrag } from '@crabnebula/tauri-plugin-drag';\n\n  const rowHeight = 30;\n  const PAGE_SIZE = 500;\n  let homePrefix = '';\n  const COL_WIDTHS_KEY = 'REDACTED';\n  const THEME_KEY = 'everything-theme';\n  const columnKeys = ['name', 'path', 'size', 'modified'];\n  const minColumnWidth = {\n    name: 180,\n    path: 240,\n    size: 75,\n    modified: 150\n  };\n  const defaultColumnRatios = {\n    name: 0.3,\n    path: 0.45,\n    size: 0.1\n  };\n\n  const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';\n  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || systemTheme; } catch { return systemTheme; } })();\n  function cycleTheme() {\n    theme = theme === 'dark' ? 'light' : 'dark';\n    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n    invoke('set_native_theme', { theme });\n  }\n\n  function sortIconHtml(dir) {\n    const d = dir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5';\n    return `<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"${d}\"/></svg>`;\n  }\n\n  let query = '';\n  let results = [];\n  let totalResults = 0;\n  let totalResultsKnown = false;\n\n  let dbLatencyMs = null;\n  let dbLastQuery = '';\n  let searchModeLabel = '';\n  let selectedIndices = new Set();\n  let selectionAnchor = -1;\n  let lastSelectedIndex = -1;\n  let editing = {\n    active: false,\n    path: '',\n    index: -1,\n    draftName: ''\n  };\n\n  let renameOverlay = { top: 0, left: 0, width: 0 };\n\n  let indexStatus = {\n    state: 'Indexing',\n    entriesCount: 0,\n    lastUpdated: null,\n    permissionErrors: 0,\n    message: null,\n    isCatchup: false\n  };\n\n  let indexingStartTime = null;\n  let indexingElapsed = '';\n  let indexingFinishedAt = '';\n\n  let sortBy = 'name';\n  let sortDir = 'asc';\n\n  let hasMore = true;\n  let loadingMore = false;\n  let searchGeneration = 0;\n\n  let scanned = 0;\n\n  let searchInputEl;\n  let renameInputEl;\n  let tableAreaEl;\n  let tableContainer;\n  let tableResizeObserver = null;\n  let viewportResizeRaf = null;\n  let scrollTop = 0;\n  let headerScrollLeft = 0;\n  let viewportHeight = 520;\n  let lastTableWidth = 0;\n  let resizingColumn = '';\n  let resizeCleanup = null;\n  let colWidths = {\n    name: 250,\n    path: 350,\n    size: 75,\n    modified: 150\n  };\n\n  let contextMenu = {\n    visible: false,\n    x: 0,\n    y: 0\n  };\n\n  let platform = '';\n  let toast = '';\n  let searchTimer;\n  let lastSearchFiredAt = 0;\n  let toastTimer;\n  let statusRefreshTimer;\n  let elapsedTimer;\n  let statusRefreshInFlight = false;\n  let lastReadyCount = 0;\n\n  const iconCache = new Map();\n  const iconLoading = new Set();\n\n  let highlightCache = new Map();\n  let highlightCacheQuery = '';\n\n  const folderFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='1' y='4' width='14' height='10' rx='2' fill='#d9b34f'/><rect x='1' y='2' width='6' height='4' rx='1' fill='#e6ca7a'/></svg>`\n    );\n  const fileFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='3' y='1' width='10' height='14' rx='1.5' fill='#b4bec9'/><rect x='5' y='5' width='6' height='1.2' fill='#8d98a5'/><rect x='5' y='8' width='6' height='1.2' fill='#8d98a5'/></svg>`\n    );\n\n  $: totalHeight = results.length * rowHeight;\n  $: startIndex = Math.max(0, Math.floor(scrollTop / rowHeight) - 10);\n  $: visibleCount = Math.ceil(viewportHeight / rowHeight) + 20;\n  $: endIndex = Math.min(results.length, startIndex + visibleCount);\n  $: visibleRows = results.slice(startIndex, endIndex);\n  $: translateY = startIndex * rowHeight;\n  $: tableMinWidth = colWidths.name + colWidths.path + colWidths.size + colWidths.modified;\n  $: tableGridStyle = `--col-name:${colWidths.name}px;--col-path:${colWidths.path}px;--col-size:${colWidths.size}px;--col-modified:${colWidths.modified}px;--table-min-width:${tableMinWidth}px;--header-offset:${-headerScrollLeft}px;`;\n\n  $: {\n    for (const entry of visibleRows) {\n      void ensureIcon(entry);\n    }\n  }\n\n  function showToast(message) {\n    toast = message;\n    clearTimeout(toastTimer);\n    toastTimer = setTimeout(() => {\n      toast = '';\n    }, 3000);\n  }\n\n  function bytesToBase64(bytes) {\n    let binary = '';\n    const chunk = 0x8000;\n    for (let i = 0; i < bytes.length; i += chunk) {\n      const part = bytes.subarray(i, i + chunk);\n      binary += String.fromCharCode(...part);\n    }\n    return btoa(binary);\n  }\n\n  function highlightSegments(name, q) {\n    q = (q || '').trim();\n    if (!q) return [{ text: name, hl: false }];\n\n    // Reset cache when query changes\n    if (q !== highlightCacheQuery) {\n      highlightCache = new Map();\n      highlightCacheQuery = q;\n    }\n\n    // Check cache\n    const cached = highlightCache.get(name);\n    if (cached) return cached;\n\n    if (q.includes('/')) q = q.slice(q.lastIndexOf('/') + 1);\n    q = q.replace(/[*?]/g, '');\n    const terms = q.split(/\\s+/).filter(Boolean);\n    if (terms.length === 0) return [{ text: name, hl: false }];\n\n    const lower = name.toLowerCase();\n    const marks = new Uint8Array(name.length);\n    for (const t of terms) {\n      const tl = t.toLowerCase();\n      let idx = lower.indexOf(tl);\n      while (idx !== -1) {\n        for (let i = idx; i < idx + tl.length; i++) marks[i] = 1;\n        idx = lower.indexOf(tl, idx + 1);\n      }\n    }\n\n    const segs = [];\n    let i = 0;\n    while (i < name.length) {\n      const m = marks[i];\n      let j = i + 1;\n      while (j < name.length && marks[j] === m) j++;\n      segs.push({ text: name.slice(i, j), hl: m === 1 });\n      i = j;\n    }\n\n    highlightCache.set(name, segs);\n    return segs;\n  }\n\n  const perFileIconExts = new Set(['exe', 'lnk', 'ico', 'url', 'scr', 'appx']);\n\n  function iconKey(entry) {\n    if (entry.isDir) return '__folder__';\n    const ext = (entry.ext || '').toLowerCase();\n    if (perFileIconExts.has(ext)) return entry.path;\n    return ext || '__file__';\n  }\n\n  function iconFor(entry) {\n    return iconCache.get(iconKey(entry)) || (entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n  }\n\n  async function ensureIcon(entry) {\n    const key = iconKey(entry);\n    if (iconCache.has(key) || iconLoading.has(key)) {\n      return;\n    }\n\n    iconLoading.add(key);\n    try {\n      const bytes = await invoke('get_file_icon', {\n        path: entry.path,\n        ext: entry.isDir ? 'folder' : entry.ext || '',\n      });\n      if (Array.isArray(bytes) && bytes.length > 0) {\n        const image = `data:image/png;base64,${bytesToBase64(Uint8Array.from(bytes))}`;\n        iconCache.set(key, image);\n      } else {\n        iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n      }\n    } catch {\n      iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n    } finally {\n      iconLoading.delete(key);\n    }\n  }\n\n  function syncColumnWidthsToContainer() {\n    const width = tableContainer?.clientWidth || tableAreaEl?.clientWidth;\n    if (!width || lastTableWidth !== 0) {\n      return;\n    }\n\n    const saved = loadColWidths();\n    if (saved) {\n      const total = columnKeys.reduce((s, k) => s + saved[k], 0);\n      if (Math.abs(total - width) > 2) {\n        const scale = (width - saved.modified) / (total - saved.modified);\n        let scaledName = Math.max(minColumnWidth.name, Math.round(saved.name * scale));\n        let scaledSize = Math.max(minColumnWidth.size, Math.round(saved.size * scale));\n        let rawPath = width - saved.modified - scaledName - scaledSize;\n        if (rawPath < minColumnWidth.path) {\n          const shortfall = minColumnWidth.path - rawPath;\n          const nameReduction = Math.min(shortfall, scaledName - minColumnWidth.name);\n          scaledName -= nameReduction;\n          const remaining = shortfall - nameReduction;\n          if (remaining > 0) {\n            scaledSize -= Math.min(remaining, scaledSize - minColumnWidth.size);\n          }\n          rawPath = width - saved.modified - scaledName - scaledSize;\n        }\n        const scaledPath = Math.max(minColumnWidth.path, rawPath);\n        colWidths = { name: scaledName, path: scaledPath, size: scaledSize, modified: saved.modified };\n      } else {\n        colWidths = saved;\n      }\n    } else {\n      const fixedModified = minColumnWidth.modified;\n      const rest = width - fixedModified;\n      const ratioSum = defaultColumnRatios.name + defaultColumnRatios.path + defaultColumnRatios.size;\n      colWidths = {\n        name: Math.max(minColumnWidth.name, Math.round(rest * defaultColumnRatios.name / ratioSum)),\n        path: Math.max(minColumnWidth.path, Math.round(rest * defaultColumnRatios.path / ratioSum)),\n        size: Math.max(minColumnWidth.size, Math.round(rest * defaultColumnRatios.size / ratioSum)),\n        modified: fixedModified\n      };\n    }\n    lastTableWidth = width;\n  }\n\n  function loadColWidths() {\n    try {\n      const raw = localStorage.getItem(COL_WIDTHS_KEY);\n      if (!raw) return null;\n      const parsed = JSON.parse(raw);\n      for (const key of columnKeys) {\n        if (typeof parsed[key] !== 'number' || parsed[key] < (minColumnWidth[key] || 0)) return null;\n      }\n      return parsed;\n    } catch {\n      return null;\n    }\n  }\n\n  function saveColWidths() {\n    localStorage.setItem(COL_WIDTHS_KEY, JSON.stringify(colWidths));\n  }\n\n  function updateViewportHeight() {\n    viewportHeight = tableContainer?.clientHeight || 520;\n    syncColumnWidthsToContainer();\n  }\n\n  function scheduleViewportHeightUpdate() {\n    if (viewportResizeRaf !== null) {\n      return;\n    }\n    viewportResizeRaf = requestAnimationFrame(() => {\n      viewportResizeRaf = null;\n      updateViewportHeight();\n    });\n  }\n\n  function startColumnResize(event, leftKey) {\n    event.preventDefault();\n    event.stopPropagation();\n\n    const index = columnKeys.indexOf(leftKey);\n    if (index < 0 || index >= columnKeys.length - 1) {\n      return;\n    }\n\n    const startX = event.clientX;\n    const startLeft = colWidths[leftKey];\n    const rightKey = columnKeys[index + 1];\n    const startRight = colWidths[rightKey];\n\n    resizeCleanup?.();\n    resizingColumn = leftKey;\n\n    const onMove = (moveEvent) => {\n      const delta = Math.round(moveEvent.clientX - startX);\n      if (leftKey === 'name') {\n        // Two-column trade: name and path swap space, each respects its minimum\n        const nextLeft = Math.max(\n          minColumnWidth[leftKey],\n          Math.min(startLeft + delta, startLeft + startRight - minColumnWidth[rightKey])\n        );\n        const nextRight = startLeft + startRight - nextLeft;\n        colWidths = { ...colWidths, [leftKey]: nextLeft, [rightKey]: nextRight };\n      } else {\n        // path splitter: path grows unconstrained (allows horizontal scroll on right drag)\n        const nextLeft = Math.max(minColumnWidth[leftKey], startLeft + delta);\n        colWidths = { ...colWidths, [leftKey]: nextLeft };\n      }\n    };\n\n    const onUp = () => {\n      cleanup();\n    };\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      document.body.style.cursor = '';\n      document.body.style.userSelect = '';\n      resizingColumn = '';\n      saveColWidths();\n      if (resizeCleanup === cleanup) {\n        resizeCleanup = null;\n      }\n    };\n\n    resizeCleanup = cleanup;\n    document.body.style.cursor = 'col-resize';\n    document.body.style.userSelect = 'none';\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  function selectedPaths() {\n    const sorted = [...selectedIndices].sort((a, b) => a - b);\n    return sorted.map((idx) => results[idx]).filter(Boolean).map((entry) => entry.path);\n  }\n\n  function clearSelection() {\n    selectedIndices = new Set();\n    selectionAnchor = -1;\n    lastSelectedIndex = -1;\n  }\n\n  function selectSingle(index) {\n    selectedIndices = new Set([index]);\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectToggle(index) {\n    const next = new Set(selectedIndices);\n    if (next.has(index)) {\n      next.delete(index);\n    } else {\n      next.add(index);\n    }\n    selectedIndices = next;\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectRange(index) {\n    const anchor = selectionAnchor >= 0 ? selectionAnchor : index;\n    const [from, to] = [Math.min(anchor, index), Math.max(anchor, index)];\n    const next = new Set();\n    for (let i = from; i <= to; i += 1) {\n      next.add(i);\n    }\n    selectedIndices = next;\n    lastSelectedIndex = index;\n  }\n\n  function primaryEntry() {\n    const idx = lastSelectedIndex >= 0 ? lastSelectedIndex : -1;\n    return idx >= 0 ? results[idx] : null;\n  }\n\n  async function refreshStatus() {\n    if (statusRefreshInFlight) {\n      return;\n    }\n    statusRefreshInFlight = true;\n    try {\n      const status = await invoke('get_index_status');\n      const prevState = indexStatus.state;\n      indexStatus = {\n        state: status.state,\n        entriesCount: status.entriesCount,\n        lastUpdated: status.lastUpdated,\n        permissionErrors: status.permissionErrors ?? 0,\n        message: status.message\n      };\n      if (status.state === 'Indexing' && prevState !== 'Indexing') {\n        startElapsedTimer();\n      } else if (status.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n      if (typeof status.scanned === 'number') {\n        scanned = status.scanned;\n      }\n      if (status.state === 'Ready' && prevState !== 'Ready') {\n        scheduleSearch();\n      }\n    } catch (err) {\n      showToast(`Failed to get status: ${String(err)}`);\n    } finally {\n      statusRefreshInFlight = false;\n    }\n  }\n\n  function scheduleSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const scheduledGen = searchGeneration;\n    clearTimeout(searchTimer);\n\n    const now = performance.now();\n    if (now - lastSearchFiredAt >= 200) {\n      // Leading edge: fire immediately if enough time has passed\n      lastSearchFiredAt = now;\n      void runSearch(preserveScroll);\n    } else {\n      // Trailing edge: debounce\n      searchTimer = setTimeout(() => {\n        if (scheduledGen !== searchGeneration) {\n          return;\n        }\n        lastSearchFiredAt = performance.now();\n        void runSearch(preserveScroll);\n      }, 200);\n    }\n  }\n\n  async function runSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const gen = searchGeneration;\n    const searchQuery = query;\n    const searchSortBy = sortBy;\n    const searchSortDir = sortDir;\n    const startedAt = performance.now();\n    try {\n      const keepPaths = new Set(selectedPaths());\n      const next = await invoke('search', {\n        query: searchQuery,\n        limit: PAGE_SIZE,\n        offset: 0,\n        sortBy: searchSortBy,\n        sortDir: searchSortDir\n      });\n\n      if (gen !== searchGeneration) return;\n\n      dbLatencyMs = Math.round(performance.now() - startedAt);\n      dbLastQuery = searchQuery;\n      const entries = Array.isArray(next.entries) ? next.entries : [];\n      searchModeLabel = next.modeLabel || '';\n      results = entries;\n      if (next.totalCount > 0) {\n        totalResults = next.totalCount;\n        totalResultsKnown = true;\n      } else {\n        totalResults = entries.length;\n        totalResultsKnown = false;\n      }\n      hasMore = totalResultsKnown ? results.length < totalResults : entries.length >= PAGE_SIZE;\n      if (!preserveScroll && tableContainer) tableContainer.scrollTop = 0;\n\n      const restored = new Set();\n      for (let i = 0; i < results.length; i += 1) {\n        if (keepPaths.has(results[i].path)) {\n          restored.add(i);\n        }\n      }\n      selectedIndices = restored;\n\n      updateViewportHeight();\n    } catch (err) {\n      if (gen !== searchGeneration) return;\n      showToast(`Search failed: ${String(err)}`);\n    }\n  }\n\n  async function loadMore() {\n    if (!hasMore || loadingMore) return;\n    const gen = searchGeneration;\n    loadingMore = true;\n    try {\n      const batch = await invoke('search', {\n        query,\n        limit: PAGE_SIZE,\n        offset: results.length,\n        sortBy: sortBy,\n        sortDir: sortDir\n      });\n      if (gen !== searchGeneration) return;\n      const arr = Array.isArray(batch.entries) ? batch.entries : [];\n      if (arr.length > 0) results = [...results, ...arr];\n      hasMore = totalResultsKnown ? results.length < totalResults : arr.length >= PAGE_SIZE;\n    } catch (err) {\n      showToast(`Failed to load more: ${String(err)}`);\n    } finally {\n      loadingMore = false;\n    }\n  }\n\n  function moveSelection(delta, withRange = false) {\n    if (results.length === 0) {\n      return;\n    }\n\n    const current = lastSelectedIndex >= 0 ? lastSelectedIndex : 0;\n    const next = Math.max(0, Math.min(results.length - 1, current + delta));\n\n    if (withRange) {\n      selectRange(next);\n    } else {\n      selectSingle(next);\n    }\n\n    const top = next * rowHeight;\n    const bottom = top + rowHeight;\n    if (top < scrollTop) {\n      tableContainer.scrollTop = top;\n    } else if (bottom > scrollTop + viewportHeight) {\n      tableContainer.scrollTop = bottom - viewportHeight;\n    }\n  }\n\n  function handleHeaderSort(column) {\n    if (sortBy === column) {\n      sortDir = sortDir === 'asc' ? 'desc' : 'asc';\n    } else {\n      sortBy = column;\n      sortDir = 'asc';\n    }\n    if (tableContainer) tableContainer.scrollTop = 0;\n    void runSearch();\n  }\n\n  function handleRowClick(event, index) {\n    contextMenu.visible = false;\n\n    if (event.shiftKey) {\n      selectRange(index);\n      return;\n    }\n\n    if (event.metaKey || event.ctrlKey) {\n      selectToggle(index);\n      return;\n    }\n\n    selectSingle(index);\n  }\n\n  function handleRowContextMenu(event, index) {\n    event.preventDefault();\n\n    if (!selectedIndices.has(index)) {\n      selectSingle(index);\n    }\n\n    if (platform === 'windows' || platform === 'macos') {\n      contextMenu.visible = false;\n      const paths = selectedPaths();\n      if (paths.length > 0) {\n        invoke('show_context_menu', {\n          paths,\n          x: event.clientX,\n          y: event.clientY,\n          singleSelection: selectedIndices.size === 1\n        });\n      }\n      return;\n    }\n\n    contextMenu = {\n      visible: true,\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n\n  function handleRowA11yKeydown(event, index) {\n    if (event.key === ' ' || event.key === 'Enter') {\n      event.preventDefault();\n      handleRowClick(event, index);\n    }\n  }\n\n  const DRAG_THRESHOLD = 5;\n  let dragCleanup = null;\n  const dragImgCache = new Map();\n\n  function dragPathsForIndex(index) {\n    const entry = results[index];\n    if (!entry) {\n      return [];\n    }\n\n    if (selectedIndices.has(index) && selectedIndices.size > 0) {\n      return selectedPaths();\n    }\n\n    return [entry.path];\n  }\n\n  function getDragIconEl(entry) {\n    const src = iconFor(entry);\n    let img = dragImgCache.get(src);\n    if (!img) {\n      img = new Image();\n      img.src = src;\n      dragImgCache.set(src, img);\n    }\n    return img.complete && img.naturalWidth > 0 ? img : null;\n  }\n\n  function fillRoundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function buildDragPreview(index) {\n    const entry = results[index];\n    if (!entry) return null;\n\n    const count = selectedIndices.has(index) ? selectedIndices.size : 1;\n    const isDark = theme === 'dark';\n\n    const w = 260;\n    const h = 28;\n    const stackGap = count > 1 ? 4 : 0;\n\n    const canvas = document.createElement('canvas');\n    canvas.width = w;\n    canvas.height = h + stackGap;\n    const ctx = canvas.getContext('2d');\n\n    if (count > 1) {\n      ctx.globalAlpha = 0.35;\n      ctx.fillStyle = isDark ? '#5a6070' : '#b0c4de';\n      fillRoundRect(ctx, 3, 0, w - 3, h, 5);\n      ctx.globalAlpha = 1.0;\n    }\n\n    const ry = stackGap;\n    ctx.fillStyle = isDark ? 'rgba(58, 64, 74, 0.94)' : 'rgba(214, 231, 255, 0.94)';\n    fillRoundRect(ctx, 0, ry, w, h, 5);\n\n    ctx.strokeStyle = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';\n    ctx.lineWidth = 0.5;\n    ctx.beginPath();\n    ctx.moveTo(5, ry);\n    ctx.arcTo(w, ry, w, ry + h, 5);\n    ctx.arcTo(w, ry + h, 0, ry + h, 5);\n    ctx.arcTo(0, ry + h, 0, ry, 5);\n    ctx.arcTo(0, ry, w, ry, 5);\n    ctx.closePath();\n    ctx.stroke();\n\n    const iconEl = getDragIconEl(entry);\n    if (iconEl) {\n      ctx.drawImage(iconEl, 6, ry + 6, 16, 16);\n    } else {\n      ctx.fillStyle = entry.isDir ? '#d9b34f' : '#8d98a5';\n      fillRoundRect(ctx, 6, ry + 6, 16, 16, 2);\n    }\n\n    ctx.fillStyle = isDark ? '#e6e6e8' : '#1a1a1a';\n    ctx.font = '12px -apple-system, \"SF Pro Text\", system-ui, sans-serif';\n    ctx.textBaseline = 'middle';\n\n    let nameMaxW = w - 34;\n    if (count > 1) nameMaxW -= 34;\n\n    let name = entry.name;\n    if (ctx.measureText(name).width > nameMaxW) {\n      while (name.length > 4 && ctx.measureText(name + '\\u2026').width > nameMaxW) {\n        name = name.slice(0, -1);\n      }\n      name += '\\u2026';\n    }\n    ctx.fillText(name, 28, ry + h / 2 + 1);\n\n    if (count > 1) {\n      const badge = String(count);\n      ctx.font = 'bold 10px -apple-system, system-ui, sans-serif';\n      const tw = ctx.measureText(badge).width;\n      const bw = Math.max(20, tw + 10);\n      const bx = w - bw - 6;\n      const by = ry + (h - 18) / 2;\n\n      ctx.fillStyle = isDark ? '#5b8bd9' : '#007aff';\n      fillRoundRect(ctx, bx, by, bw, 18, 9);\n\n      ctx.fillStyle = '#ffffff';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(badge, bx + bw / 2, by + 9);\n    }\n\n    return canvas.toDataURL('image/png');\n  }\n\n  function handleRowMouseDown(event, index) {\n    if (event.button !== 0) return;\n    if (event.metaKey || event.ctrlKey || event.shiftKey) return;\n    if (editing.active) return;\n\n    const startX = event.clientX;\n    const startY = event.clientY;\n    let dragging = false;\n\n    dragCleanup?.();\n\n    const onMove = (e) => {\n      if (dragging) return;\n      const dx = e.clientX - startX;\n      const dy = e.clientY - startY;\n      if (dx * dx + dy * dy < DRAG_THRESHOLD * DRAG_THRESHOLD) return;\n\n      dragging = true;\n      cleanup();\n\n      if (!selectedIndices.has(index)) {\n        selectSingle(index);\n      }\n\n      const paths = dragPathsForIndex(index);\n      if (paths.length > 0) {\n        const icon = buildDragPreview(index);\n        startDrag({ item: paths, icon }).catch(() => {});\n      }\n    };\n\n    const onUp = () => cleanup();\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      if (dragCleanup === cleanup) dragCleanup = null;\n    };\n\n    dragCleanup = cleanup;\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  async function handleRowDoubleClick(index) {\n    if (!selectedIndices.has(index) || selectedIndices.size > 1) {\n      selectSingle(index);\n      await tick();\n    }\n    await invoke('open', { paths: [results[index].path] }).catch((err) => {\n      showToast(`Failed to open: ${String(err)}`);\n    });\n  }\n\n  function closeContextMenu() {\n    contextMenu = {\n      ...contextMenu,\n      visible: false\n    };\n  }\n\n  async function openSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('open', { paths });\n    } catch (err) {\n      showToast(`Failed to open: ${String(err)}`);\n    }\n  }\n\n  async function openWithFallback() {\n    const target = primaryEntry();\n    if (!target) {\n      return;\n    }\n\n    try {\n      await invoke('open_with', { path: target.path });\n    } catch (err) {\n      showToast(`Open With failed: ${String(err)}`);\n    }\n  }\n\n  async function revealSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('reveal_in_finder', { paths });\n    } catch (err) {\n      showToast(`Failed to reveal in Finder: ${String(err)}`);\n    }\n  }\n\n  async function copySelectedPaths() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_paths', { paths });\n      showToast(`Copied ${paths.length} path(s)`);\n    } catch (err) {\n      showToast(`Failed to copy path: ${String(err)}`);\n    }\n  }\n\n  async function copyFiles() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_files', { paths });\n      showToast(`Copied ${paths.length} item(s)`);\n    } catch (err) {\n      showToast(`Failed to copy: ${String(err)}`);\n    }\n  }\n\n  async function trashSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    const message =\n      paths.length === 1\n        ? 'Move selected item to Trash?'\n        : `Move ${paths.length} items to Trash?`;\n\n    if (!window.confirm(message)) {\n      return;\n    }\n\n    try {\n      await invoke('move_to_trash', { paths });\n      showToast('Moved to Trash.');\n      clearSelection();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to move to Trash: ${String(err)}`);\n    }\n  }\n\n  async function resetIndex() {\n    if (indexStatus.state === 'Indexing') {\n      showToast('Indexing in progress. Please try again after it completes.');\n      return;\n    }\n\n    results = [];\n    totalResults = 0;\n    totalResultsKnown = false;\n    clearSelection();\n    scanned = 0;\n    dbLatencyMs = null;\n    dbLastQuery = '';\n    indexStatus = { ...indexStatus, state: 'Indexing', entriesCount: 0, message: null };\n    indexingStartTime = Date.now();\n    indexingElapsed = '';\n    indexingFinishedAt = '';\n\n    try {\n      await invoke('reset_index');\n    } catch (err) {\n      showToast(`Failed to reset index: ${String(err)}`);\n      await refreshStatus();\n    }\n  }\n\n  function isMultiSelected() {\n    return selectedIndices.size > 1;\n  }\n\n  function autoResizeRenameInput() {\n    if (!renameInputEl) return;\n    renameInputEl.style.height = '0';\n    renameInputEl.style.height = renameInputEl.scrollHeight + 'px';\n  }\n\n  async function startRename() {\n    if (isMultiSelected()) {\n      return;\n    }\n\n    const idx = lastSelectedIndex;\n    if (idx < 0 || !results[idx]) {\n      return;\n    }\n\n    const entry = results[idx];\n\n    // Calculate overlay position mathematically.\n    // Name cell text starts at: padding-left(16) + icon(16) + gap(6) = 38px from cell left.\n    // Textarea has padding-left: 0 and border: 1.5px, so text starts ~2px from overlay left.\n    if (tableContainer) {\n      const rect = tableContainer.getBoundingClientRect();\n      const cellLeft = rect.left - tableContainer.scrollLeft;\n      const textLeft = cellLeft + 38;\n      const cellRight = cellLeft + colWidths.name;\n      const rowTop = rect.top + idx * rowHeight - tableContainer.scrollTop;\n      renameOverlay = {\n        top: rowTop,\n        left: textLeft - 2,\n        width: cellRight - textLeft + 2 - 4\n      };\n    }\n\n    editing = {\n      active: true,\n      path: entry.path,\n      index: idx,\n      draftName: entry.name\n    };\n\n    await tick();\n\n    if (renameInputEl) {\n      autoResizeRenameInput();\n      renameInputEl.focus();\n      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n      renameInputEl.setSelectionRange(0, selectionEnd);\n    }\n  }\n\n  function cancelRename() {\n    editing = {\n      active: false,\n      path: '',\n      index: -1,\n      draftName: ''\n    };\n  }\n\n  async function commitRename() {\n    if (!editing.active || editing.index < 0 || !results[editing.index]) {\n      return;\n    }\n\n    const current = results[editing.index];\n    const nextName = editing.draftName;\n\n    try {\n      await invoke('rename', {\n        path: current.path,\n        newName: nextName\n      });\n      cancelRename();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to rename: ${String(err)}`);\n      await tick();\n      renameInputEl?.focus();\n    }\n  }\n\n  function onGlobalClick() {\n    closeContextMenu();\n  }\n\n  function onTitleBarMouseDown(event) {\n    if (event.button !== 0) {\n      return;\n    }\n\n    const activeElement = document.activeElement;\n    if (activeElement instanceof HTMLElement && isTextInputTarget(activeElement)) {\n      activeElement.blur();\n    }\n  }\n\n  async function focusSearch() {\n    await getCurrentWindow().show();\n    await getCurrentWindow().setFocus();\n    searchInputEl?.focus();\n    searchInputEl?.select();\n  }\n\n  function isTextInputTarget(target) {\n    return (\n      target instanceof HTMLInputElement ||\n      target instanceof HTMLTextAreaElement ||\n      target?.isContentEditable\n    );\n  }\n\n  async function handleKeydown(event) {\n    const isMetaSelectAll = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'a';\n    const isMetaCopy = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c';\n    const target = event.target;\n    const isTextInput = isTextInputTarget(target);\n\n    if (isMetaCopy && isTextInput) {\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      if (isTextInput) {\n        event.preventDefault();\n        if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n          target.select();\n        }\n        return;\n      }\n    }\n\n    if (editing.active) {\n      if (event.key === 'Enter') {\n        event.preventDefault();\n        await commitRename();\n        return;\n      }\n\n      if (event.key === 'Escape') {\n        event.preventDefault();\n        const idx = editing.index;\n        cancelRename();\n        selectSingle(idx);\n        await tick();\n        tableContainer?.querySelector('.row.selected')?.focus();\n        return;\n      }\n      return;\n    }\n\n    if (event.key === 'Escape') {\n      event.preventDefault();\n      clearSelection();\n      return;\n    }\n\n    if (event.key === 'ArrowDown') {\n      event.preventDefault();\n      moveSelection(1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'ArrowUp') {\n      event.preventDefault();\n      moveSelection(-1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageDown') {\n      event.preventDefault();\n      moveSelection(Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageUp') {\n      event.preventDefault();\n      moveSelection(-Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'Enter') {\n      event.preventDefault();\n      if (platform === 'windows') {\n        await openSelected();\n      } else {\n        await startRename();\n      }\n      return;\n    }\n\n    if (event.key === 'F2') {\n      event.preventDefault();\n      await startRename();\n      return;\n    }\n\n    if (event.key === ' ' && !isTextInput) {\n      event.preventDefault();\n      const entry = primaryEntry();\n      if (entry) {\n        await invoke('quick_look', { path: entry.path });\n      }\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'f') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      searchInputEl?.select();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'o') {\n      event.preventDefault();\n      await openSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {\n      event.preventDefault();\n      await revealSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c') {\n      event.preventDefault();\n      await copySelectedPaths();\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      event.preventDefault();\n      selectedIndices = new Set(Array.from({ length: results.length }, (_, i) => i));\n      return;\n    }\n\n    if (event.key === 'Delete' || ((event.metaKey || event.ctrlKey) && event.key === 'Backspace')) {\n      if (!isTextInput) {\n        event.preventDefault();\n        await trashSelected();\n      }\n      return;\n    }\n  }\n\n  function formatSize(entry) {\n    if (entry.isDir || entry.size == null) return '';\n    const bytes = entry.size;\n    if (bytes < 1024) return `${bytes} B`;\n    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n    return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n  }\n\n  function formatModified(entry) {\n    if (!entry.mtime) {\n      return '';\n    }\n\n    const d = new Date(entry.mtime * 1000);\n    const pad = (n) => String(n).padStart(2, '0');\n    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;\n  }\n\n  function formatLastUpdated(timestamp) {\n    if (!timestamp) {\n      return '-';\n    }\n\n    return new Date(timestamp * 1000).toLocaleString();\n  }\n\n  function formatElapsed(ms) {\n    const totalSec = Math.floor(ms / 1000);\n    const min = Math.floor(totalSec / 60);\n    const sec = totalSec % 60;\n    return min > 0 ? `${min}m ${sec}s` : `${sec}s`;\n  }\n\n  function updateElapsed() {\n    if (indexingStartTime && indexStatus.state === 'Indexing') {\n      indexingElapsed = formatElapsed(Date.now() - indexingStartTime);\n    }\n  }\n\n  function startElapsedTimer() {\n    clearInterval(elapsedTimer);\n    indexingStartTime = Date.now();\n    indexingElapsed = '0s';\n    indexingFinishedAt = '';\n    elapsedTimer = setInterval(updateElapsed, 1000);\n  }\n\n  function stopElapsedTimer() {\n    clearInterval(elapsedTimer);\n    if (indexingStartTime) {\n      const elapsed = Date.now() - indexingStartTime;\n      indexingFinishedAt = `${formatElapsed(elapsed)}`;\n    }\n    indexingStartTime = null;\n    indexingElapsed = '';\n  }\n\n  function displayPath(path) {\n    if (!path) {\n      return path;\n    }\n\n    if (!homePrefix) {\n      return path;\n    }\n\n    if (path === homePrefix) {\n      return '~';\n    }\n\n    if (path.startsWith(`${homePrefix}/`)) {\n      return `~${path.slice(homePrefix.length)}`;\n    }\n\n    return path;\n  }\n\n  let unlistenFns = [];\n\n  onMount(async () => {\n    const t0 = performance.now();\n    const ms = () => Math.round(performance.now() - t0);\n    const DEBUG_STARTUP = false;\n    const flog = DEBUG_STARTUP ? (msg) => invoke('frontend_log', { msg }).catch(() => {}) : () => {};\n\n    flog(`[startup/fe] onMount entered`);\n\n    updateViewportHeight();\n    flog(`[startup/fe] +${ms()}ms updateViewportHeight done`);\n\n    invoke('set_native_theme', { theme });\n\n    platform = await invoke('get_platform');\n    flog(`[startup/fe] +${ms()}ms get_platform done`);\n\n    const unlistenProgress = await listen('index_progress', (event) => {\n      scanned = event.payload.scanned;\n      if (indexStatus.state !== 'Indexing') {\n        indexStatus = {\n          ...indexStatus,\n          state: 'Indexing'\n        };\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_progress) registered`);\n\n    const unlistenState = await listen('index_state', (event) => {\n      flog(`[startup/fe] index_state event received: ${event.payload.state} at +${ms()}ms`);\n      const prevState = indexStatus.state;\n      indexStatus = {\n        ...indexStatus,\n        state: event.payload.state,\n        message: event.payload.message ?? null,\n        isCatchup: event.payload.isCatchup ?? false\n      };\n\n      if (event.payload.state === 'Indexing' && prevState !== 'Indexing') {\n        if (prevState === 'Ready') {\n          lastReadyCount = indexStatus.entriesCount;\n        }\n        startElapsedTimer();\n      } else if (event.payload.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n\n      if (event.payload.state === 'Ready') {\n        scheduleSearch();\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_state) registered`);\n\n    const unlistenUpdated = await listen('index_updated', (event) => {\n      indexStatus = {\n        ...indexStatus,\n        entriesCount: event.payload.entriesCount,\n        lastUpdated: event.payload.lastUpdated,\n        permissionErrors: event.payload.permissionErrors ?? indexStatus.permissionErrors\n      };\n\n      scheduleSearch(true);\n    });\n\n    const unlistenFocus = await listen('focus_search', () => {\n      void focusSearch();\n    });\n\n    const unlistenCtxMenuAction = await listen('context_menu_action', (event) => {\n      switch (event.payload) {\n        case 'open': void openSelected(); break;\n        case 'quick_look': {\n          const e = primaryEntry();\n          if (e) void invoke('quick_look', { path: e.path });\n          break;\n        }\n        case 'open_with': void openWithFallback(); break;\n        case 'reveal': void revealSelected(); break;\n        case 'copy_files': void copyFiles(); break;\n        case 'copy_path': void copySelectedPaths(); break;\n        case 'trash': void trashSelected(); break;\n        case 'rename': void startRename(); break;\n      }\n    });\n\n    unlistenFns = [unlistenProgress, unlistenState, unlistenUpdated, unlistenFocus, unlistenCtxMenuAction];\n    flog(`[startup/fe] +${ms()}ms all listeners registered`);\n\n    // Fetch backend state IMMEDIATELY after listeners are registered.\n    // Events emitted before listener registration are lost, so this\n    // is the only reliable way to get the current state.\n    await refreshStatus();\n    flog(`[startup/fe] +${ms()}ms refreshStatus done (state=${indexStatus.state})`);\n\n    // Show Svelte UI: remove skeleton, focus search input.\n    await tick();\n    document.getElementById('skeleton')?.remove();\n    await focusSearch();\n    flog(`[startup/fe] +${ms()}ms WINDOW VISIBLE â€” skeleton removed`);\n\n    try {\n      homePrefix = await invoke('get_home_dir');\n    } catch {\n      homePrefix = '';\n    }\n    flog(`[startup/fe] +${ms()}ms get_home_dir done`);\n\n    if (!localStorage.getItem('everything-fda-notice-v1')) {\n      showToast('macOS Full Disk Access permission may be required for full disk search.');\n      localStorage.setItem('everything-fda-notice-v1', '1');\n    }\n    flog(`[startup/fe] +${ms()}ms calling runSearch...`);\n    await runSearch();\n    flog(`[startup/fe] +${ms()}ms runSearch done`);\n\n    if (typeof ResizeObserver !== 'undefined') {\n      tableResizeObserver = new ResizeObserver(() => {\n        scheduleViewportHeightUpdate();\n      });\n      if (tableContainer) {\n        tableResizeObserver.observe(tableContainer);\n      } else if (tableAreaEl) {\n        tableResizeObserver.observe(tableAreaEl);\n      }\n    }\n\n    window.addEventListener('resize', scheduleViewportHeightUpdate);\n    window.addEventListener('click', onGlobalClick);\n    statusRefreshTimer = setInterval(() => {\n      if (indexStatus.state === 'Indexing') {\n        void refreshStatus();\n      }\n    }, 1000);\n    console.log(`[startup/fe] +${ms()}ms onMount complete`);\n  });\n\n  onDestroy(async () => {\n    clearTimeout(searchTimer);\n    clearTimeout(toastTimer);\n    clearInterval(statusRefreshTimer);\n    clearInterval(elapsedTimer);\n    resizeCleanup?.();\n\n    for (const unlisten of unlistenFns) {\n      unlisten();\n    }\n\n    tableResizeObserver?.disconnect();\n    tableResizeObserver = null;\n    if (viewportResizeRaf !== null) {\n      cancelAnimationFrame(viewportResizeRaf);\n      viewportResizeRaf = null;\n    }\n    window.removeEventListener('resize', scheduleViewportHeightUpdate);\n    window.removeEventListener('click', onGlobalClick);\n  });\n</script>\n\n<svelte:window on:keydown={handleKeydown} />\n\n<div class=\"app-shell\" data-theme={theme}>\n  <div class=\"title-bar\" role=\"presentation\" data-tauri-drag-region on:mousedown={onTitleBarMouseDown}>\n    <div class=\"title-left\"></div>\n    <div class=\"title-center\">\n      <svg class=\"title-icon\" viewBox=\"0 0 215 205\" fill-rule=\"evenodd\" aria-hidden=\"true\">\n        <path d=\"M85 0c46.9 0 85 38.1 85 85 0 20.1-7.2 38.5-19.2 52.7l40.7 40.8c5.8 5.8 5.8 15.2 0 21-5.8 5.8-15.2 5.8-21 0l-40.7-40.7c-13.6 9.7-30.4 15.2-44.8 15.2-46.9 0-85-42.1-85-89 0-46.9 38.1-85 85-85z m0 32c-29.3 0-53 23.7-53 53 0 29.3 23.7 53 53 53 29.3 0 53-23.7 53-53 0-29.3-23.7-53-53-53z\"/>\n      </svg>\n      <span class=\"title-text\">Everything</span>\n    </div>\n    <div class=\"title-right\"></div>\n  </div>\n\n  <header class=\"search-bar\">\n    <input\n      bind:this={searchInputEl}\n      class=\"search-input\"\n      type=\"text\"\n      bind:value={query}\n      on:input={scheduleSearch}\n      on:focus={clearSelection}\n      placeholder=\"Search file/folder names\"\n      autocomplete=\"off\"\n      spellcheck=\"false\"\n    />\n  </header>\n\n  <section class=\"table-area\" bind:this={tableAreaEl} style={tableGridStyle}>\n    <div class=\"table-header\">\n      <div class=\"table-header-track\">\n        <div class=\"col name\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('name')}>\n            Name{#if sortBy === 'name'}{@html sortIconHtml(sortDir)}{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'name'}\n            on:mousedown={(event) => startColumnResize(event, 'name')}\n            aria-label=\"Resize Name column\"\n          />\n        </div>\n\n        <div class=\"col path\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('dir')}>\n            Path{#if sortBy === 'dir'}{@html sortIconHtml(sortDir)}{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'path'}\n            on:mousedown={(event) => startColumnResize(event, 'path')}\n            aria-label=\"Resize Path column\"\n          />\n        </div>\n\n        <div class=\"col size\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('size')}>\n            Size{#if sortBy === 'size'}{@html sortIconHtml(sortDir)}{/if}\n          </button>\n        </div>\n\n        <div class=\"col modified\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('mtime')}>\n            Modified{#if sortBy === 'mtime'}{@html sortIconHtml(sortDir)}{/if}\n          </button>\n        </div>\n      </div>\n    </div>\n\n    <div\n      class=\"table-body\"\n      bind:this={tableContainer}\n      on:scroll={() => {\n        scrollTop = tableContainer.scrollTop;\n        headerScrollLeft = tableContainer.scrollLeft;\n        if (editing.active) void commitRename();\n        const scrollBottom = scrollTop + tableContainer.clientHeight;\n        if (scrollBottom >= totalHeight - rowHeight * 10) {\n          void loadMore();\n        }\n      }}\n    >\n      <div class=\"spacer\" style={`height:${totalHeight}px`}>\n        <div class=\"rows\" style={`transform: translateY(${translateY}px);`}>\n          {#each visibleRows as entry, localIndex}\n            {@const index = startIndex + localIndex}\n            <div\n              class=\"row {selectedIndices.has(index) ? 'selected' : ''}\"\n              on:mousedown={(event) => handleRowMouseDown(event, index)}\n              on:click={(event) => handleRowClick(event, index)}\n              on:keydown={(event) => handleRowA11yKeydown(event, index)}\n              on:dblclick={() => handleRowDoubleClick(index)}\n              on:contextmenu={(event) => handleRowContextMenu(event, index)}\n              role=\"row\"\n              tabindex=\"0\"\n            >\n              <div class=\"cell name\">\n                <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n                <span class=\"ellipsis\" class:name-editing={editing.active && editing.index === index}>{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n              </div>\n              <div class=\"cell path\"><span class=\"ellipsis\">{displayPath(entry.dir)}</span></div>\n              <div class=\"cell size\">{formatSize(entry)}</div>\n              <div class=\"cell modified\">{formatModified(entry)}</div>\n            </div>\n          {/each}\n        </div>\n      </div>\n    </div>\n  </section>\n\n  <footer class=\"status-bar\">\n    <div class=\"status-left\">\n      <span class=\"status-state\">\n        <span class=\"state-dot {indexStatus.state === 'Indexing' ? 'indexing' : indexStatus.state === 'Error' ? 'error' : 'ready'}\"></span>\n        {#if indexStatus.state === 'Indexing'}\n          Indexing{#if lastReadyCount > 0} ({Math.min(99, Math.round((scanned / lastReadyCount) * 100))}%){/if}{#if indexingElapsed} Â· {indexingElapsed}{/if}\n          {#if !indexStatus.isCatchup}\n            Â· {scanned.toLocaleString()} scanned\n          {/if}\n        {:else}\n          Index: {indexStatus.state}\n        {/if}\n      </span>\n      <span>{indexStatus.entriesCount.toLocaleString()} entries</span>\n      {#if indexingFinishedAt && indexStatus.state !== 'Indexing'}\n        <span>in {indexingFinishedAt}</span>\n      {/if}\n      {#if dbLatencyMs !== null && dbLastQuery}\n        <span>\"{dbLastQuery}\" {dbLatencyMs}ms Â· {totalResults} results</span>\n      {/if}\n      {#if searchModeLabel === 'spotlight' || searchModeLabel === 'spotlight_timeout'}\n        <span class=\"status-spotlight\">Spotlight fallback{#if searchModeLabel === 'spotlight_timeout'} (partial){/if}</span>\n      {/if}\n      {#if indexStatus.permissionErrors > 0}\n        <span class=\"status-warning\">{indexStatus.permissionErrors.toLocaleString()} permission errors</span>\n      {/if}\n      {#if indexStatus.message}\n        <span class={indexStatus.isCatchup ? 'index-progress' : 'status-error'}>{indexStatus.message}</span>\n      {/if}\n    </div>\n    <div class=\"status-right\">\n      <button class=\"status-btn\" on:click={cycleTheme} title=\"Switch theme\">\n        {theme === 'dark' ? 'â˜€ Light' : 'â—‘ Dark'}\n      </button>\n      <button\n        class=\"status-btn rebuild-btn\"\n        on:click={resetIndex}\n        disabled={indexStatus.state === 'Indexing'}\n        title={indexStatus.state === 'Indexing' ? 'Cannot reset while indexing is in progress.' : 'Reset and rebuild the index.'}\n      >\n        <svg class=\"rebuild-icon\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n          <path d=\"M23 4v6h-6\"/><path d=\"M20.49 15a9 9 0 1 1-2.12-9.36L23 10\"/>\n        </svg>\n        Rebuild Index\n      </button>\n    </div>\n  </footer>\n\n  {#if editing.active}\n    <div\n      class=\"rename-overlay\"\n      style=\"top:{renameOverlay.top}px; left:{renameOverlay.left}px; width:{renameOverlay.width}px;\"\n      role=\"presentation\"\n      on:mousedown|stopPropagation\n    >\n      <textarea\n        bind:this={renameInputEl}\n        class=\"rename-textarea\"\n        bind:value={editing.draftName}\n        on:input={autoResizeRenameInput}\n        on:click|stopPropagation\n        on:blur={commitRename}\n      />\n    </div>\n  {/if}\n\n  {#if contextMenu.visible}\n    <div class=\"context-menu\" style={`left:${contextMenu.x}px;top:${contextMenu.y}px;`}>\n      <button on:click={() => (closeContextMenu(), openSelected())}>Open</button>\n      <button on:click={async () => { closeContextMenu(); const e = primaryEntry(); if (e) await invoke('quick_look', { path: e.path }); }}>Quick Look</button>\n      <button on:click={() => (closeContextMenu(), openWithFallback())}>Open With... (Reveal in Finder)</button>\n      <button on:click={() => (closeContextMenu(), revealSelected())}>Reveal in Finder</button>\n      <button on:click={() => (closeContextMenu(), copySelectedPaths())}>Copy Path</button>\n      <button on:click={() => (closeContextMenu(), trashSelected())}>Move to Trash</button>\n      {#if selectedIndices.size === 1}\n        <button on:click={() => (closeContextMenu(), startRename())}>Rename</button>\n      {/if}\n    </div>\n  {/if}\n\n  {#if toast}\n    <div class=\"toast\">{toast}</div>\n  {/if}\n</div>\n\n<style>\n  :global(:root) {\n    color-scheme: light dark;\n    --bg-app: transparent;\n    --text-primary: #0d1826;\n    --text-muted: #48596c;\n    --bar-grad-top: rgba(255, 255, 255, 0.48);\n    --bar-grad-bottom: rgba(248, 250, 253, 0.42);\n    --surface-header: rgba(252, 252, 255, 0.40);\n    --surface: rgba(255, 255, 255, 0.22);\n    --border-soft: rgba(0, 0, 0, 0.07);\n    --border-input: rgba(0, 0, 0, 0.13);\n    --focus-ring: #6f96e6;\n    --row-border: rgba(0, 0, 0, 0.032);\n    --row-hover: rgba(0, 0, 0, 0.06);\n    --row-selected: rgba(0, 0, 0, 0.12);\n    --button-bg: rgba(255, 255, 255, 0.62);\n    --button-border: rgba(0, 0, 0, 0.10);\n    --button-text: #2c3e50;\n    --menu-bg: rgba(240, 241, 248, 0.90);\n    --menu-border: rgba(0, 0, 0, 0.06);\n    --menu-hover: rgba(255, 255, 255, 0.62);\n    --menu-text: #1a2a38;\n    --error-text: #b64545;\n    --warning-text: #8f6500;\n    --toast-bg: rgba(18, 22, 32, 0.90);\n    --toast-text: #ffffff;\n  }\n\n  @media (prefers-color-scheme: dark) {\n    :global(:root) {\n      --bg-app: transparent;\n      --text-primary: #e6e6ea;\n      --text-muted: #9494a4;\n      --bar-grad-top: rgba(38, 38, 46, 0.52);\n      --bar-grad-bottom: rgba(30, 30, 38, 0.46);\n      --surface-header: rgba(32, 32, 40, 0.46);\n      --surface: rgba(18, 18, 26, 0.32);\n      --border-soft: rgba(255, 255, 255, 0.065);\n      --border-input: rgba(255, 255, 255, 0.14);\n      --focus-ring: #5b8bd9;\n      --row-border: rgba(255, 255, 255, 0.026);\n      --row-hover: rgba(255, 255, 255, 0.08);\n      --row-selected: rgba(255, 255, 255, 0.14);\n      --button-bg: rgba(255, 255, 255, 0.072);\n      --button-border: rgba(255, 255, 255, 0.11);\n      --button-text: #d6d6e0;\n      --menu-bg: rgba(36, 36, 46, 0.90);\n      --menu-border: rgba(255, 255, 255, 0.066);\n      --menu-hover: rgba(255, 255, 255, 0.062);\n      --menu-text: #e0e0e8;\n      --error-text: #ff9d9d;\n      --warning-text: #e0c670;\n      --toast-bg: rgba(10, 10, 16, 0.93);\n      --toast-text: #f2f2f6;\n    }\n  }\n\n  /* â”€â”€ Theme: Dark â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme=\"dark\"]) {\n    color-scheme: dark;\n    --bg-app: #1E1E21;\n    --text-primary: #E2E8F0;\n    --text-muted: #94A3B8;\n    --bar-grad-top: #1E1E21;\n    --bar-grad-bottom: #1E1E21;\n    --surface-header: #1E1E21;\n    --surface: #1E1E21;\n    --bg-input: #161618;\n    --border-soft: #2A2A2D;\n    --border-input: rgba(255, 255, 255, 0.06);\n    --focus-ring: #4DA8FF;\n    --accent: #4DA8FF;\n    --row-border: rgba(255, 255, 255, 0.02);\n    --row-hover: #282828;\n    --row-selected: rgba(77, 168, 255, 0.10);\n    --button-bg: rgba(255, 255, 255, 0.05);\n    --button-border: #2A2A2D;\n    --button-text: #94A3B8;\n    --menu-bg: #252528;\n    --menu-border: #2A2A2D;\n    --menu-hover: rgba(255, 255, 255, 0.04);\n    --menu-text: #E2E8F0;\n    --error-text: #ff9d9d;\n    --warning-text: #e0c670;\n    --toast-bg: rgba(10, 10, 16, 0.93);\n    --toast-text: #f2f2f6;\n  }\n\n  /* â”€â”€ Theme: Light â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme=\"light\"]) {\n    color-scheme: light;\n    --bg-app: #F5F5F7;\n    --text-primary: #1C1C1E;\n    --text-muted: #6E6E7A;\n    --bar-grad-top: #F5F5F7;\n    --bar-grad-bottom: #F5F5F7;\n    --surface-header: #F5F5F7;\n    --surface: #F5F5F7;\n    --bg-input: #FFFFFF;\n    --border-soft: #D1D1D6;\n    --border-input: rgba(0, 0, 0, 0.10);\n    --focus-ring: #3A8BF5;\n    --accent: #3A8BF5;\n    --row-border: rgba(0, 0, 0, 0.04);\n    --row-hover: rgba(0, 0, 0, 0.04);\n    --row-selected: rgba(58, 139, 245, 0.10);\n    --button-bg: #FFFFFF;\n    --button-border: #D1D1D6;\n    --button-text: #3C3C43;\n    --menu-bg: #FFFFFF;\n    --menu-border: #D1D1D6;\n    --menu-hover: rgba(0, 0, 0, 0.05);\n    --menu-text: #1C1C1E;\n    --error-text: #D93025;\n    --warning-text: #B45309;\n    --toast-bg: rgba(255, 255, 255, 0.95);\n    --toast-text: #1C1C1E;\n  }\n\n  /* â”€â”€ Themed element overrides â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme]) {\n    background: var(--bg-app);\n  }\n\n  /* Search bar: flat, no gradient, no separator */\n  :global([data-theme]) .search-bar {\n    height: 44px;\n    padding: 0 16px;\n    background: var(--bg-app);\n    border-bottom: none;\n  }\n\n  :global([data-theme]) .search-input {\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n    font-family: 'JetBrains Mono', 'SF Mono', monospace;\n    font-size: 12px;\n    height: 34px;\n    border-radius: 8px;\n  }\n\n  /* Table header: flat bg, 16px edge padding */\n  :global([data-theme]) .table-header {\n    background: var(--bg-app);\n  }\n\n  :global([data-theme]) .col-button {\n    padding: 0 8px;\n  }\n\n  :global([data-theme]) .col.name .col-button {\n    padding-left: 16px;\n  }\n\n  /* Row cells: JetBrains Mono, 16px outer edges */\n  :global([data-theme]) .cell {\n    font-family: 'JetBrains Mono', monospace;\n  }\n\n  :global([data-theme]) .cell.name {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    padding-left: 16px;\n    font-size: 12px;\n    color: var(--text-primary);\n  }\n\n  :global([data-theme]) .cell.path {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.size {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.modified {\n    padding-right: 16px;\n    font-size: 11px;\n    white-space: nowrap;\n  }\n\n  :global([data-theme]) .row.selected {\n    box-shadow: inset 3px 0 0 var(--accent);\n  }\n\n  /* Dim path/size/date cells in themed mode */\n  :global([data-theme]) .cell.path,\n  :global([data-theme]) .cell.size,\n  :global([data-theme]) .cell.modified {\n    color: var(--text-muted);\n  }\n\n  :global(:root) {\n    background: transparent;\n  }\n\n  :global(html, body) {\n    margin: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    background: transparent;\n    color: var(--text-primary);\n    font-family: Inter, 'SF Pro Text', 'Segoe UI', Helvetica, Arial, sans-serif;\n  }\n\n  :global(#app) {\n    width: 100%;\n    height: 100%;\n  }\n\n  .app-shell {\n    display: grid;\n    grid-template-rows: auto auto 1fr auto;\n    height: 100%;\n    min-width: 0;\n  }\n\n  .title-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 44px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    cursor: default;\n    flex-shrink: 0;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-left {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-center {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-right {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-icon {\n    width: 14px;\n    height: 14px;\n    fill: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .title-text {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 13px;\n    font-weight: 500;\n    color: var(--text-primary);\n    letter-spacing: -0.01em;\n  }\n\n  .search-bar {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding: 8px;\n    background: linear-gradient(180deg, var(--bar-grad-top) 0%, var(--bar-grad-bottom) 100%);\n    border-bottom: 1px solid var(--border-soft);\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .search-input {\n    display: block;\n    box-sizing: border-box;\n    width: 100%;\n    min-width: 0;\n    flex: 1 1 auto;\n    height: 36px;\n    border: 1px solid var(--border-input);\n    border-radius: 14px;\n    padding: 0 10px;\n    font-size: 14px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    backdrop-filter: blur(12px) saturate(160%);\n    -webkit-backdrop-filter: blur(12px) saturate(160%);\n  }\n\n  .search-input::placeholder {\n    color: var(--text-muted);\n    opacity: 0.85;\n    font-size: 12px;\n  }\n\n  .search-input:focus {\n    outline: none;\n    border-color: var(--focus-ring);\n    box-shadow: 0 0 0 2px rgba(125, 169, 255, 0.25);\n  }\n\n  .table-area {\n    display: grid;\n    grid-template-rows: auto 1fr;\n    min-height: 0;\n    min-width: 0;\n  }\n\n  .table-header-track,\n  .row {\n    display: grid;\n    grid-template-columns: var(--col-name) var(--col-path) var(--col-size) var(--col-modified);\n    align-items: center;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .table-header {\n    height: 32px;\n    border-bottom: 1px solid var(--border-soft);\n    background: var(--surface-header);\n    user-select: none;\n    overflow: hidden;\n    flex-shrink: 0;\n  }\n\n  .table-header-track {\n    height: 100%;\n    transform: translateX(var(--header-offset, 0px));\n    will-change: transform;\n  }\n\n  .table-header .col {\n    position: relative;\n    min-width: 0;\n    height: 100%;\n  }\n\n  .col-button {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n    gap: 4px;\n    box-sizing: border-box;\n    padding: 0 8px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 11px;\n    font-weight: 600;\n    line-height: 1;\n    color: var(--text-muted);\n    text-align: left;\n    margin: 0;\n    border: none;\n    background: transparent;\n    cursor: pointer;\n  }\n\n  .sort-icon {\n    width: 10px;\n    height: 10px;\n    flex-shrink: 0;\n    color: var(--accent);\n  }\n\n  .col-resizer {\n    position: absolute;\n    top: 0;\n    right: -4px;\n    width: 8px;\n    height: 100%;\n    border: none;\n    padding: 0;\n    background: transparent;\n    cursor: col-resize;\n    z-index: 30;\n  }\n\n  .col-resizer::after {\n    content: '';\n    position: absolute;\n    top: 7px;\n    bottom: 7px;\n    left: 50%;\n    width: 1px;\n    transform: translateX(-50%);\n    background: var(--border-soft);\n    opacity: 0;\n    transition: opacity 0.15s ease;\n  }\n\n  .table-header .col:hover .col-resizer::after,\n  .col-resizer.active::after {\n    opacity: 1;\n  }\n\n  .table-body {\n    overflow: auto;\n    min-height: 0;\n    min-width: 0;\n    background: var(--surface);\n  }\n\n  .spacer {\n    position: relative;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .rows {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .row {\n    height: 30px;\n    border-bottom: 1px solid var(--row-border);\n    cursor: default;\n    -webkit-user-select: none;\n    user-select: none;\n    outline: none;\n  }\n\n  .row:hover {\n    background: var(--row-hover);\n  }\n\n  .row.selected {\n    background: var(--row-selected);\n  }\n\n  .cell {\n    padding: 0 8px;\n    font-size: 12px;\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    min-width: 0;\n  }\n\n  .cell.size {\n    text-align: right;\n    font-variant-numeric: tabular-nums;\n  }\n\n  .ellipsis {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n\n  .hl {\n    background: none;\n    color: inherit;\n    font-weight: 700;\n  }\n\n  .file-icon {\n    width: 16px;\n    height: 16px;\n    flex: 0 0 auto;\n  }\n\n  .name-editing {\n    opacity: 0.25;\n  }\n\n  .rename-overlay {\n    position: fixed;\n    z-index: 100;\n    min-width: 120px;\n  }\n\n  .rename-textarea {\n    display: block;\n    width: 100%;\n    box-sizing: border-box;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 12px;\n    line-height: 18px;\n    padding: 5px 4px 5px 0;\n    border: 1.5px solid var(--focus-ring);\n    border-radius: 4px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    outline: none;\n    resize: none;\n    overflow: hidden;\n    box-shadow: 0 2px 14px rgba(0, 0, 0, 0.22), 0 0 0 3px rgba(77, 168, 255, 0.13);\n  }\n\n  .status-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 32px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    border-top: 1px solid var(--border-soft);\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 11px;\n    color: var(--text-muted);\n    white-space: nowrap;\n    overflow: hidden;\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .status-left {\n    display: flex;\n    align-items: center;\n    gap: 16px;\n    overflow: hidden;\n    min-width: 0;\n  }\n\n  .status-right {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    flex-shrink: 0;\n  }\n\n  .status-btn {\n    border: 1px solid var(--button-border);\n    border-radius: 5px;\n    background: var(--button-bg);\n    color: var(--button-text);\n    font-size: 11px;\n    height: 22px;\n    padding: 0 8px;\n    cursor: pointer;\n  }\n\n  .status-btn:hover {\n    filter: brightness(1.06);\n  }\n\n  .status-btn:disabled {\n    opacity: 0.55;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .status-state {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n  }\n\n  .state-dot {\n    width: 6px;\n    height: 6px;\n    border-radius: 50%;\n    flex-shrink: 0;\n  }\n\n  .state-dot.ready { background: #28C840; }\n  .state-dot.indexing { background: #FEBC2E; }\n  .state-dot.error { background: #FF5F57; }\n\n  .rebuild-btn {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 10px;\n    font-weight: 500;\n    background: var(--button-bg);\n    border: 1px solid var(--button-border);\n    border-radius: 4px;\n    color: var(--button-text);\n    height: 22px;\n    padding: 0 10px;\n    cursor: pointer;\n  }\n\n  .rebuild-btn:hover {\n    filter: brightness(1.1);\n  }\n\n  .rebuild-btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .rebuild-icon {\n    width: 11px;\n    height: 11px;\n    color: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .status-error {\n    color: var(--error-text);\n  }\n\n  .status-warning {\n    color: var(--warning-text);\n  }\n\n  .status-spotlight {\n    color: #f59e0b;\n    font-weight: 600;\n  }\n\n  .context-menu {\n    position: fixed;\n    z-index: 200;\n    width: 220px;\n    border: 1px solid var(--menu-border);\n    border-radius: 10px;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.16), inset 0 0 0 0.5px rgba(255, 255, 255, 0.18);\n    background: var(--menu-bg);\n    backdrop-filter: blur(28px) saturate(180%);\n    -webkit-backdrop-filter: blur(28px) saturate(180%);\n    overflow: hidden;\n  }\n\n  .context-menu button {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    padding: 8px 10px;\n    font-size: 12px;\n    color: var(--menu-text);\n  }\n\n  .context-menu button:hover {\n    background: var(--menu-hover);\n  }\n\n  .toast {\n    position: fixed;\n    right: 14px;\n    bottom: 18px;\n    background: var(--toast-bg);\n    color: var(--toast-text);\n    border-radius: 10px;\n    padding: 9px 12px;\n    font-size: 12px;\n    z-index: 250;\n    backdrop-filter: blur(20px) saturate(180%);\n    -webkit-backdrop-filter: blur(20px) saturate(180%);\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);\n  }\n</style>\n","structuredPatch":[{"oldStart":1987,"oldLines":7,"newStart":1987,"newLines":7,"lines":["     cursor: pointer;","   }"," ","-  .sort-icon {","+  :global(.sort-icon) {","     width: 10px;","     height: 10px;","     flex-shrink: 0;"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"a081b0ed-8e79-422a-8813-f8c8a5df31df"}
{"parentUuid":"9d67d6bc-9b24-4bbe-8d2f-05b2c5e5ae82","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01JTaAiB95d88cZaegqeSQsA","type":"message","role":"assistant","content":[{"type":"text","text":"ì´ì œ `.rebuild-btn` CSSì—ì„œ `.status-btn`ê³¼ ì¤‘ë³µëœ í”„ë¡œí¼í‹°ë¥¼ ì œê±°í•©ë‹ˆë‹¤."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":248,"cache_read_input_tokens":101817,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":248},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPRyxuWkkRXWTLbBbf3","type":"assistant","uuid":"3041603b-8b7b-4b9e-8b2b-981914f230d7","timestamp":"2026-02-21T14:40:16.916Z"}
{"parentUuid":"3041603b-8b7b-4b9e-8b2b-981914f230d7","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01JTaAiB95d88cZaegqeSQsA","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017TsgHyKvZiD8fPi575JT1Y","name":"Read","input":{"file_path":"/Users/al02402336/everything/src/App.svelte","offset":2190,"limit":40},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":248,"cache_read_input_tokens":101817,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":248},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPRyxuWkkRXWTLbBbf3","type":"assistant","uuid":"07b4213d-2fb7-44e0-8a48-657fcb7adc43","timestamp":"2026-02-21T14:40:17.577Z"}
{"parentUuid":"07b4213d-2fb7-44e0-8a48-657fcb7adc43","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_017TsgHyKvZiD8fPi575JT1Y","toolUseID":"toolu_017TsgHyKvZiD8fPi575JT1Y","timestamp":"2026-02-21T14:40:17.592Z","uuid":"e30c601e-0ff8-43fe-9e0f-daddf4c6da9b"}
{"parentUuid":"07b4213d-2fb7-44e0-8a48-657fcb7adc43","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017TsgHyKvZiD8fPi575JT1Y","type":"tool_result","content":"  2190â†’  .state-dot.ready { background: #28C840; }\n  2191â†’  .state-dot.indexing { background: #FEBC2E; }\n  2192â†’  .state-dot.error { background: #FF5F57; }\n  2193â†’\n  2194â†’  .rebuild-btn {\n  2195â†’    display: flex;\n  2196â†’    align-items: center;\n  2197â†’    gap: 6px;\n  2198â†’    font-family: Inter, 'SF Pro Text', sans-serif;\n  2199â†’    font-size: 10px;\n  2200â†’    font-weight: 500;\n  2201â†’    background: var(--button-bg);\n  2202â†’    border: 1px solid var(--button-border);\n  2203â†’    border-radius: 4px;\n  2204â†’    color: var(--button-text);\n  2205â†’    height: 22px;\n  2206â†’    padding: 0 10px;\n  2207â†’    cursor: pointer;\n  2208â†’  }\n  2209â†’\n  2210â†’  .rebuild-btn:hover {\n  2211â†’    filter: brightness(1.1);\n  2212â†’  }\n  2213â†’\n  2214â†’  .rebuild-btn:disabled {\n  2215â†’    opacity: 0.5;\n  2216â†’    cursor: not-allowed;\n  2217â†’    filter: none;\n  2218â†’  }\n  2219â†’\n  2220â†’  .rebuild-icon {\n  2221â†’    width: 11px;\n  2222â†’    height: 11px;\n  2223â†’    color: var(--accent);\n  2224â†’    flex-shrink: 0;\n  2225â†’  }\n  2226â†’\n  2227â†’  .status-error {\n  2228â†’    color: var(--error-text);\n  2229â†’  }\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"61f07699-9b50-4f90-a049-e0fffecd9217","timestamp":"2026-02-21T14:40:17.591Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src/App.svelte","content":"  .state-dot.ready { background: #28C840; }\n  .state-dot.indexing { background: #FEBC2E; }\n  .state-dot.error { background: #FF5F57; }\n\n  .rebuild-btn {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 10px;\n    font-weight: 500;\n    background: var(--button-bg);\n    border: 1px solid var(--button-border);\n    border-radius: 4px;\n    color: var(--button-text);\n    height: 22px;\n    padding: 0 10px;\n    cursor: pointer;\n  }\n\n  .rebuild-btn:hover {\n    filter: brightness(1.1);\n  }\n\n  .rebuild-btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .rebuild-icon {\n    width: 11px;\n    height: 11px;\n    color: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .status-error {\n    color: var(--error-text);\n  }","numLines":40,"startLine":2190,"totalLines":2282}},"sourceToolAssistantUUID":"07b4213d-2fb7-44e0-8a48-657fcb7adc43"}
{"parentUuid":"61f07699-9b50-4f90-a049-e0fffecd9217","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01CLWkNqAXieTMBVz1JfQeUE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015fnKypZJH8ZedtApcRNW2q","name":"Edit","input":{"replace_all":false,"file_path":"/Users/al02402336/everything/src/App.svelte","old_string":"  .rebuild-btn {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 10px;\n    font-weight: 500;\n    background: var(--button-bg);\n    border: 1px solid var(--button-border);\n    border-radius: 4px;\n    color: var(--button-text);\n    height: 22px;\n    padding: 0 10px;\n    cursor: pointer;\n  }\n\n  .rebuild-btn:hover {\n    filter: brightness(1.1);\n  }\n\n  .rebuild-btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    filter: none;\n  }","new_string":"  .rebuild-btn {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 10px;\n    font-weight: 500;\n    border-radius: 4px;\n    padding: 0 10px;\n  }\n\n  .rebuild-btn:hover {\n    filter: brightness(1.1);\n  }\n\n  .rebuild-btn:disabled {\n    opacity: 0.5;\n  }"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":715,"cache_read_input_tokens":102065,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":715},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPSGnSPKAvMPmt4fpGY","type":"assistant","uuid":"457a04d0-0254-4ec0-a41b-0257d8febff6","timestamp":"2026-02-21T14:40:22.683Z"}
{"parentUuid":"457a04d0-0254-4ec0-a41b-0257d8febff6","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_015fnKypZJH8ZedtApcRNW2q","toolUseID":"toolu_015fnKypZJH8ZedtApcRNW2q","timestamp":"2026-02-21T14:40:22.691Z","uuid":"eb0372c4-82f8-4e6d-80b3-f2a1fbd4dc9d"}
{"parentUuid":"457a04d0-0254-4ec0-a41b-0257d8febff6","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015fnKypZJH8ZedtApcRNW2q","type":"tool_result","content":"The file /Users/al02402336/everything/src/App.svelte has been updated successfully."}]},"uuid":"ffbdeafc-b9b5-4f1a-8a0e-171cc169195e","timestamp":"2026-02-21T14:40:22.690Z","toolUseResult":{"filePath":"/Users/al02402336/everything/src/App.svelte","oldString":"  .rebuild-btn {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 10px;\n    font-weight: 500;\n    background: var(--button-bg);\n    border: 1px solid var(--button-border);\n    border-radius: 4px;\n    color: var(--button-text);\n    height: 22px;\n    padding: 0 10px;\n    cursor: pointer;\n  }\n\n  .rebuild-btn:hover {\n    filter: brightness(1.1);\n  }\n\n  .rebuild-btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    filter: none;\n  }","newString":"  .rebuild-btn {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 10px;\n    font-weight: 500;\n    border-radius: 4px;\n    padding: 0 10px;\n  }\n\n  .rebuild-btn:hover {\n    filter: brightness(1.1);\n  }\n\n  .rebuild-btn:disabled {\n    opacity: 0.5;\n  }","originalFile":"<script>\n  import { onDestroy, onMount, tick } from 'svelte';\n  import { invoke } from '@tauri-apps/api/core';\n  import { listen } from '@tauri-apps/api/event';\n  import { getCurrentWindow } from '@tauri-apps/api/window';\n  import { startDrag } from '@crabnebula/tauri-plugin-drag';\n\n  const rowHeight = 30;\n  const PAGE_SIZE = 500;\n  let homePrefix = '';\n  const COL_WIDTHS_KEY = 'REDACTED';\n  const THEME_KEY = 'everything-theme';\n  const columnKeys = ['name', 'path', 'size', 'modified'];\n  const minColumnWidth = {\n    name: 180,\n    path: 240,\n    size: 75,\n    modified: 150\n  };\n  const defaultColumnRatios = {\n    name: 0.3,\n    path: 0.45,\n    size: 0.1\n  };\n\n  const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';\n  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || systemTheme; } catch { return systemTheme; } })();\n  function cycleTheme() {\n    theme = theme === 'dark' ? 'light' : 'dark';\n    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n    invoke('set_native_theme', { theme });\n  }\n\n  function sortIconHtml(dir) {\n    const d = dir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5';\n    return `<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"${d}\"/></svg>`;\n  }\n\n  let query = '';\n  let results = [];\n  let totalResults = 0;\n  let totalResultsKnown = false;\n\n  let dbLatencyMs = null;\n  let dbLastQuery = '';\n  let searchModeLabel = '';\n  let selectedIndices = new Set();\n  let selectionAnchor = -1;\n  let lastSelectedIndex = -1;\n  let editing = {\n    active: false,\n    path: '',\n    index: -1,\n    draftName: ''\n  };\n\n  let renameOverlay = { top: 0, left: 0, width: 0 };\n\n  let indexStatus = {\n    state: 'Indexing',\n    entriesCount: 0,\n    lastUpdated: null,\n    permissionErrors: 0,\n    message: null,\n    isCatchup: false\n  };\n\n  let indexingStartTime = null;\n  let indexingElapsed = '';\n  let indexingFinishedAt = '';\n\n  let sortBy = 'name';\n  let sortDir = 'asc';\n\n  let hasMore = true;\n  let loadingMore = false;\n  let searchGeneration = 0;\n\n  let scanned = 0;\n\n  let searchInputEl;\n  let renameInputEl;\n  let tableAreaEl;\n  let tableContainer;\n  let tableResizeObserver = null;\n  let viewportResizeRaf = null;\n  let scrollTop = 0;\n  let headerScrollLeft = 0;\n  let viewportHeight = 520;\n  let lastTableWidth = 0;\n  let resizingColumn = '';\n  let resizeCleanup = null;\n  let colWidths = {\n    name: 250,\n    path: 350,\n    size: 75,\n    modified: 150\n  };\n\n  let contextMenu = {\n    visible: false,\n    x: 0,\n    y: 0\n  };\n\n  let platform = '';\n  let toast = '';\n  let searchTimer;\n  let lastSearchFiredAt = 0;\n  let toastTimer;\n  let statusRefreshTimer;\n  let elapsedTimer;\n  let statusRefreshInFlight = false;\n  let lastReadyCount = 0;\n\n  const iconCache = new Map();\n  const iconLoading = new Set();\n\n  let highlightCache = new Map();\n  let highlightCacheQuery = '';\n\n  const folderFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='1' y='4' width='14' height='10' rx='2' fill='#d9b34f'/><rect x='1' y='2' width='6' height='4' rx='1' fill='#e6ca7a'/></svg>`\n    );\n  const fileFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='3' y='1' width='10' height='14' rx='1.5' fill='#b4bec9'/><rect x='5' y='5' width='6' height='1.2' fill='#8d98a5'/><rect x='5' y='8' width='6' height='1.2' fill='#8d98a5'/></svg>`\n    );\n\n  $: totalHeight = results.length * rowHeight;\n  $: startIndex = Math.max(0, Math.floor(scrollTop / rowHeight) - 10);\n  $: visibleCount = Math.ceil(viewportHeight / rowHeight) + 20;\n  $: endIndex = Math.min(results.length, startIndex + visibleCount);\n  $: visibleRows = results.slice(startIndex, endIndex);\n  $: translateY = startIndex * rowHeight;\n  $: tableMinWidth = colWidths.name + colWidths.path + colWidths.size + colWidths.modified;\n  $: tableGridStyle = `--col-name:${colWidths.name}px;--col-path:${colWidths.path}px;--col-size:${colWidths.size}px;--col-modified:${colWidths.modified}px;--table-min-width:${tableMinWidth}px;--header-offset:${-headerScrollLeft}px;`;\n\n  $: {\n    for (const entry of visibleRows) {\n      void ensureIcon(entry);\n    }\n  }\n\n  function showToast(message) {\n    toast = message;\n    clearTimeout(toastTimer);\n    toastTimer = setTimeout(() => {\n      toast = '';\n    }, 3000);\n  }\n\n  function bytesToBase64(bytes) {\n    let binary = '';\n    const chunk = 0x8000;\n    for (let i = 0; i < bytes.length; i += chunk) {\n      const part = bytes.subarray(i, i + chunk);\n      binary += String.fromCharCode(...part);\n    }\n    return btoa(binary);\n  }\n\n  function highlightSegments(name, q) {\n    q = (q || '').trim();\n    if (!q) return [{ text: name, hl: false }];\n\n    // Reset cache when query changes\n    if (q !== highlightCacheQuery) {\n      highlightCache = new Map();\n      highlightCacheQuery = q;\n    }\n\n    // Check cache\n    const cached = highlightCache.get(name);\n    if (cached) return cached;\n\n    if (q.includes('/')) q = q.slice(q.lastIndexOf('/') + 1);\n    q = q.replace(/[*?]/g, '');\n    const terms = q.split(/\\s+/).filter(Boolean);\n    if (terms.length === 0) return [{ text: name, hl: false }];\n\n    const lower = name.toLowerCase();\n    const marks = new Uint8Array(name.length);\n    for (const t of terms) {\n      const tl = t.toLowerCase();\n      let idx = lower.indexOf(tl);\n      while (idx !== -1) {\n        for (let i = idx; i < idx + tl.length; i++) marks[i] = 1;\n        idx = lower.indexOf(tl, idx + 1);\n      }\n    }\n\n    const segs = [];\n    let i = 0;\n    while (i < name.length) {\n      const m = marks[i];\n      let j = i + 1;\n      while (j < name.length && marks[j] === m) j++;\n      segs.push({ text: name.slice(i, j), hl: m === 1 });\n      i = j;\n    }\n\n    highlightCache.set(name, segs);\n    return segs;\n  }\n\n  const perFileIconExts = new Set(['exe', 'lnk', 'ico', 'url', 'scr', 'appx']);\n\n  function iconKey(entry) {\n    if (entry.isDir) return '__folder__';\n    const ext = (entry.ext || '').toLowerCase();\n    if (perFileIconExts.has(ext)) return entry.path;\n    return ext || '__file__';\n  }\n\n  function iconFor(entry) {\n    return iconCache.get(iconKey(entry)) || (entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n  }\n\n  async function ensureIcon(entry) {\n    const key = iconKey(entry);\n    if (iconCache.has(key) || iconLoading.has(key)) {\n      return;\n    }\n\n    iconLoading.add(key);\n    try {\n      const bytes = await invoke('get_file_icon', {\n        path: entry.path,\n        ext: entry.isDir ? 'folder' : entry.ext || '',\n      });\n      if (Array.isArray(bytes) && bytes.length > 0) {\n        const image = `data:image/png;base64,${bytesToBase64(Uint8Array.from(bytes))}`;\n        iconCache.set(key, image);\n      } else {\n        iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n      }\n    } catch {\n      iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n    } finally {\n      iconLoading.delete(key);\n    }\n  }\n\n  function syncColumnWidthsToContainer() {\n    const width = tableContainer?.clientWidth || tableAreaEl?.clientWidth;\n    if (!width || lastTableWidth !== 0) {\n      return;\n    }\n\n    const saved = loadColWidths();\n    if (saved) {\n      const total = columnKeys.reduce((s, k) => s + saved[k], 0);\n      if (Math.abs(total - width) > 2) {\n        const scale = (width - saved.modified) / (total - saved.modified);\n        let scaledName = Math.max(minColumnWidth.name, Math.round(saved.name * scale));\n        let scaledSize = Math.max(minColumnWidth.size, Math.round(saved.size * scale));\n        let rawPath = width - saved.modified - scaledName - scaledSize;\n        if (rawPath < minColumnWidth.path) {\n          const shortfall = minColumnWidth.path - rawPath;\n          const nameReduction = Math.min(shortfall, scaledName - minColumnWidth.name);\n          scaledName -= nameReduction;\n          const remaining = shortfall - nameReduction;\n          if (remaining > 0) {\n            scaledSize -= Math.min(remaining, scaledSize - minColumnWidth.size);\n          }\n          rawPath = width - saved.modified - scaledName - scaledSize;\n        }\n        const scaledPath = Math.max(minColumnWidth.path, rawPath);\n        colWidths = { name: scaledName, path: scaledPath, size: scaledSize, modified: saved.modified };\n      } else {\n        colWidths = saved;\n      }\n    } else {\n      const fixedModified = minColumnWidth.modified;\n      const rest = width - fixedModified;\n      const ratioSum = defaultColumnRatios.name + defaultColumnRatios.path + defaultColumnRatios.size;\n      colWidths = {\n        name: Math.max(minColumnWidth.name, Math.round(rest * defaultColumnRatios.name / ratioSum)),\n        path: Math.max(minColumnWidth.path, Math.round(rest * defaultColumnRatios.path / ratioSum)),\n        size: Math.max(minColumnWidth.size, Math.round(rest * defaultColumnRatios.size / ratioSum)),\n        modified: fixedModified\n      };\n    }\n    lastTableWidth = width;\n  }\n\n  function loadColWidths() {\n    try {\n      const raw = localStorage.getItem(COL_WIDTHS_KEY);\n      if (!raw) return null;\n      const parsed = JSON.parse(raw);\n      for (const key of columnKeys) {\n        if (typeof parsed[key] !== 'number' || parsed[key] < (minColumnWidth[key] || 0)) return null;\n      }\n      return parsed;\n    } catch {\n      return null;\n    }\n  }\n\n  function saveColWidths() {\n    localStorage.setItem(COL_WIDTHS_KEY, JSON.stringify(colWidths));\n  }\n\n  function updateViewportHeight() {\n    viewportHeight = tableContainer?.clientHeight || 520;\n    syncColumnWidthsToContainer();\n  }\n\n  function scheduleViewportHeightUpdate() {\n    if (viewportResizeRaf !== null) {\n      return;\n    }\n    viewportResizeRaf = requestAnimationFrame(() => {\n      viewportResizeRaf = null;\n      updateViewportHeight();\n    });\n  }\n\n  function startColumnResize(event, leftKey) {\n    event.preventDefault();\n    event.stopPropagation();\n\n    const index = columnKeys.indexOf(leftKey);\n    if (index < 0 || index >= columnKeys.length - 1) {\n      return;\n    }\n\n    const startX = event.clientX;\n    const startLeft = colWidths[leftKey];\n    const rightKey = columnKeys[index + 1];\n    const startRight = colWidths[rightKey];\n\n    resizeCleanup?.();\n    resizingColumn = leftKey;\n\n    const onMove = (moveEvent) => {\n      const delta = Math.round(moveEvent.clientX - startX);\n      if (leftKey === 'name') {\n        // Two-column trade: name and path swap space, each respects its minimum\n        const nextLeft = Math.max(\n          minColumnWidth[leftKey],\n          Math.min(startLeft + delta, startLeft + startRight - minColumnWidth[rightKey])\n        );\n        const nextRight = startLeft + startRight - nextLeft;\n        colWidths = { ...colWidths, [leftKey]: nextLeft, [rightKey]: nextRight };\n      } else {\n        // path splitter: path grows unconstrained (allows horizontal scroll on right drag)\n        const nextLeft = Math.max(minColumnWidth[leftKey], startLeft + delta);\n        colWidths = { ...colWidths, [leftKey]: nextLeft };\n      }\n    };\n\n    const onUp = () => {\n      cleanup();\n    };\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      document.body.style.cursor = '';\n      document.body.style.userSelect = '';\n      resizingColumn = '';\n      saveColWidths();\n      if (resizeCleanup === cleanup) {\n        resizeCleanup = null;\n      }\n    };\n\n    resizeCleanup = cleanup;\n    document.body.style.cursor = 'col-resize';\n    document.body.style.userSelect = 'none';\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  function selectedPaths() {\n    const sorted = [...selectedIndices].sort((a, b) => a - b);\n    return sorted.map((idx) => results[idx]).filter(Boolean).map((entry) => entry.path);\n  }\n\n  function clearSelection() {\n    selectedIndices = new Set();\n    selectionAnchor = -1;\n    lastSelectedIndex = -1;\n  }\n\n  function selectSingle(index) {\n    selectedIndices = new Set([index]);\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectToggle(index) {\n    const next = new Set(selectedIndices);\n    if (next.has(index)) {\n      next.delete(index);\n    } else {\n      next.add(index);\n    }\n    selectedIndices = next;\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectRange(index) {\n    const anchor = selectionAnchor >= 0 ? selectionAnchor : index;\n    const [from, to] = [Math.min(anchor, index), Math.max(anchor, index)];\n    const next = new Set();\n    for (let i = from; i <= to; i += 1) {\n      next.add(i);\n    }\n    selectedIndices = next;\n    lastSelectedIndex = index;\n  }\n\n  function primaryEntry() {\n    const idx = lastSelectedIndex >= 0 ? lastSelectedIndex : -1;\n    return idx >= 0 ? results[idx] : null;\n  }\n\n  async function refreshStatus() {\n    if (statusRefreshInFlight) {\n      return;\n    }\n    statusRefreshInFlight = true;\n    try {\n      const status = await invoke('get_index_status');\n      const prevState = indexStatus.state;\n      indexStatus = {\n        state: status.state,\n        entriesCount: status.entriesCount,\n        lastUpdated: status.lastUpdated,\n        permissionErrors: status.permissionErrors ?? 0,\n        message: status.message\n      };\n      if (status.state === 'Indexing' && prevState !== 'Indexing') {\n        startElapsedTimer();\n      } else if (status.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n      if (typeof status.scanned === 'number') {\n        scanned = status.scanned;\n      }\n      if (status.state === 'Ready' && prevState !== 'Ready') {\n        scheduleSearch();\n      }\n    } catch (err) {\n      showToast(`Failed to get status: ${String(err)}`);\n    } finally {\n      statusRefreshInFlight = false;\n    }\n  }\n\n  function scheduleSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const scheduledGen = searchGeneration;\n    clearTimeout(searchTimer);\n\n    const now = performance.now();\n    if (now - lastSearchFiredAt >= 200) {\n      // Leading edge: fire immediately if enough time has passed\n      lastSearchFiredAt = now;\n      void runSearch(preserveScroll);\n    } else {\n      // Trailing edge: debounce\n      searchTimer = setTimeout(() => {\n        if (scheduledGen !== searchGeneration) {\n          return;\n        }\n        lastSearchFiredAt = performance.now();\n        void runSearch(preserveScroll);\n      }, 200);\n    }\n  }\n\n  async function runSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const gen = searchGeneration;\n    const searchQuery = query;\n    const searchSortBy = sortBy;\n    const searchSortDir = sortDir;\n    const startedAt = performance.now();\n    try {\n      const keepPaths = new Set(selectedPaths());\n      const next = await invoke('search', {\n        query: searchQuery,\n        limit: PAGE_SIZE,\n        offset: 0,\n        sortBy: searchSortBy,\n        sortDir: searchSortDir\n      });\n\n      if (gen !== searchGeneration) return;\n\n      dbLatencyMs = Math.round(performance.now() - startedAt);\n      dbLastQuery = searchQuery;\n      const entries = Array.isArray(next.entries) ? next.entries : [];\n      searchModeLabel = next.modeLabel || '';\n      results = entries;\n      if (next.totalCount > 0) {\n        totalResults = next.totalCount;\n        totalResultsKnown = true;\n      } else {\n        totalResults = entries.length;\n        totalResultsKnown = false;\n      }\n      hasMore = totalResultsKnown ? results.length < totalResults : entries.length >= PAGE_SIZE;\n      if (!preserveScroll && tableContainer) tableContainer.scrollTop = 0;\n\n      const restored = new Set();\n      for (let i = 0; i < results.length; i += 1) {\n        if (keepPaths.has(results[i].path)) {\n          restored.add(i);\n        }\n      }\n      selectedIndices = restored;\n\n      updateViewportHeight();\n    } catch (err) {\n      if (gen !== searchGeneration) return;\n      showToast(`Search failed: ${String(err)}`);\n    }\n  }\n\n  async function loadMore() {\n    if (!hasMore || loadingMore) return;\n    const gen = searchGeneration;\n    loadingMore = true;\n    try {\n      const batch = await invoke('search', {\n        query,\n        limit: PAGE_SIZE,\n        offset: results.length,\n        sortBy: sortBy,\n        sortDir: sortDir\n      });\n      if (gen !== searchGeneration) return;\n      const arr = Array.isArray(batch.entries) ? batch.entries : [];\n      if (arr.length > 0) results = [...results, ...arr];\n      hasMore = totalResultsKnown ? results.length < totalResults : arr.length >= PAGE_SIZE;\n    } catch (err) {\n      showToast(`Failed to load more: ${String(err)}`);\n    } finally {\n      loadingMore = false;\n    }\n  }\n\n  function moveSelection(delta, withRange = false) {\n    if (results.length === 0) {\n      return;\n    }\n\n    const current = lastSelectedIndex >= 0 ? lastSelectedIndex : 0;\n    const next = Math.max(0, Math.min(results.length - 1, current + delta));\n\n    if (withRange) {\n      selectRange(next);\n    } else {\n      selectSingle(next);\n    }\n\n    const top = next * rowHeight;\n    const bottom = top + rowHeight;\n    if (top < scrollTop) {\n      tableContainer.scrollTop = top;\n    } else if (bottom > scrollTop + viewportHeight) {\n      tableContainer.scrollTop = bottom - viewportHeight;\n    }\n  }\n\n  function handleHeaderSort(column) {\n    if (sortBy === column) {\n      sortDir = sortDir === 'asc' ? 'desc' : 'asc';\n    } else {\n      sortBy = column;\n      sortDir = 'asc';\n    }\n    if (tableContainer) tableContainer.scrollTop = 0;\n    void runSearch();\n  }\n\n  function handleRowClick(event, index) {\n    contextMenu.visible = false;\n\n    if (event.shiftKey) {\n      selectRange(index);\n      return;\n    }\n\n    if (event.metaKey || event.ctrlKey) {\n      selectToggle(index);\n      return;\n    }\n\n    selectSingle(index);\n  }\n\n  function handleRowContextMenu(event, index) {\n    event.preventDefault();\n\n    if (!selectedIndices.has(index)) {\n      selectSingle(index);\n    }\n\n    if (platform === 'windows' || platform === 'macos') {\n      contextMenu.visible = false;\n      const paths = selectedPaths();\n      if (paths.length > 0) {\n        invoke('show_context_menu', {\n          paths,\n          x: event.clientX,\n          y: event.clientY,\n          singleSelection: selectedIndices.size === 1\n        });\n      }\n      return;\n    }\n\n    contextMenu = {\n      visible: true,\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n\n  function handleRowA11yKeydown(event, index) {\n    if (event.key === ' ' || event.key === 'Enter') {\n      event.preventDefault();\n      handleRowClick(event, index);\n    }\n  }\n\n  const DRAG_THRESHOLD = 5;\n  let dragCleanup = null;\n  const dragImgCache = new Map();\n\n  function dragPathsForIndex(index) {\n    const entry = results[index];\n    if (!entry) {\n      return [];\n    }\n\n    if (selectedIndices.has(index) && selectedIndices.size > 0) {\n      return selectedPaths();\n    }\n\n    return [entry.path];\n  }\n\n  function getDragIconEl(entry) {\n    const src = iconFor(entry);\n    let img = dragImgCache.get(src);\n    if (!img) {\n      img = new Image();\n      img.src = src;\n      dragImgCache.set(src, img);\n    }\n    return img.complete && img.naturalWidth > 0 ? img : null;\n  }\n\n  function fillRoundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function buildDragPreview(index) {\n    const entry = results[index];\n    if (!entry) return null;\n\n    const count = selectedIndices.has(index) ? selectedIndices.size : 1;\n    const isDark = theme === 'dark';\n\n    const w = 260;\n    const h = 28;\n    const stackGap = count > 1 ? 4 : 0;\n\n    const canvas = document.createElement('canvas');\n    canvas.width = w;\n    canvas.height = h + stackGap;\n    const ctx = canvas.getContext('2d');\n\n    if (count > 1) {\n      ctx.globalAlpha = 0.35;\n      ctx.fillStyle = isDark ? '#5a6070' : '#b0c4de';\n      fillRoundRect(ctx, 3, 0, w - 3, h, 5);\n      ctx.globalAlpha = 1.0;\n    }\n\n    const ry = stackGap;\n    ctx.fillStyle = isDark ? 'rgba(58, 64, 74, 0.94)' : 'rgba(214, 231, 255, 0.94)';\n    fillRoundRect(ctx, 0, ry, w, h, 5);\n\n    ctx.strokeStyle = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';\n    ctx.lineWidth = 0.5;\n    ctx.beginPath();\n    ctx.moveTo(5, ry);\n    ctx.arcTo(w, ry, w, ry + h, 5);\n    ctx.arcTo(w, ry + h, 0, ry + h, 5);\n    ctx.arcTo(0, ry + h, 0, ry, 5);\n    ctx.arcTo(0, ry, w, ry, 5);\n    ctx.closePath();\n    ctx.stroke();\n\n    const iconEl = getDragIconEl(entry);\n    if (iconEl) {\n      ctx.drawImage(iconEl, 6, ry + 6, 16, 16);\n    } else {\n      ctx.fillStyle = entry.isDir ? '#d9b34f' : '#8d98a5';\n      fillRoundRect(ctx, 6, ry + 6, 16, 16, 2);\n    }\n\n    ctx.fillStyle = isDark ? '#e6e6e8' : '#1a1a1a';\n    ctx.font = '12px -apple-system, \"SF Pro Text\", system-ui, sans-serif';\n    ctx.textBaseline = 'middle';\n\n    let nameMaxW = w - 34;\n    if (count > 1) nameMaxW -= 34;\n\n    let name = entry.name;\n    if (ctx.measureText(name).width > nameMaxW) {\n      while (name.length > 4 && ctx.measureText(name + '\\u2026').width > nameMaxW) {\n        name = name.slice(0, -1);\n      }\n      name += '\\u2026';\n    }\n    ctx.fillText(name, 28, ry + h / 2 + 1);\n\n    if (count > 1) {\n      const badge = String(count);\n      ctx.font = 'bold 10px -apple-system, system-ui, sans-serif';\n      const tw = ctx.measureText(badge).width;\n      const bw = Math.max(20, tw + 10);\n      const bx = w - bw - 6;\n      const by = ry + (h - 18) / 2;\n\n      ctx.fillStyle = isDark ? '#5b8bd9' : '#007aff';\n      fillRoundRect(ctx, bx, by, bw, 18, 9);\n\n      ctx.fillStyle = '#ffffff';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(badge, bx + bw / 2, by + 9);\n    }\n\n    return canvas.toDataURL('image/png');\n  }\n\n  function handleRowMouseDown(event, index) {\n    if (event.button !== 0) return;\n    if (event.metaKey || event.ctrlKey || event.shiftKey) return;\n    if (editing.active) return;\n\n    const startX = event.clientX;\n    const startY = event.clientY;\n    let dragging = false;\n\n    dragCleanup?.();\n\n    const onMove = (e) => {\n      if (dragging) return;\n      const dx = e.clientX - startX;\n      const dy = e.clientY - startY;\n      if (dx * dx + dy * dy < DRAG_THRESHOLD * DRAG_THRESHOLD) return;\n\n      dragging = true;\n      cleanup();\n\n      if (!selectedIndices.has(index)) {\n        selectSingle(index);\n      }\n\n      const paths = dragPathsForIndex(index);\n      if (paths.length > 0) {\n        const icon = buildDragPreview(index);\n        startDrag({ item: paths, icon }).catch(() => {});\n      }\n    };\n\n    const onUp = () => cleanup();\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      if (dragCleanup === cleanup) dragCleanup = null;\n    };\n\n    dragCleanup = cleanup;\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  async function handleRowDoubleClick(index) {\n    if (!selectedIndices.has(index) || selectedIndices.size > 1) {\n      selectSingle(index);\n      await tick();\n    }\n    await invoke('open', { paths: [results[index].path] }).catch((err) => {\n      showToast(`Failed to open: ${String(err)}`);\n    });\n  }\n\n  function closeContextMenu() {\n    contextMenu = {\n      ...contextMenu,\n      visible: false\n    };\n  }\n\n  async function openSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('open', { paths });\n    } catch (err) {\n      showToast(`Failed to open: ${String(err)}`);\n    }\n  }\n\n  async function openWithFallback() {\n    const target = primaryEntry();\n    if (!target) {\n      return;\n    }\n\n    try {\n      await invoke('open_with', { path: target.path });\n    } catch (err) {\n      showToast(`Open With failed: ${String(err)}`);\n    }\n  }\n\n  async function revealSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('reveal_in_finder', { paths });\n    } catch (err) {\n      showToast(`Failed to reveal in Finder: ${String(err)}`);\n    }\n  }\n\n  async function copySelectedPaths() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_paths', { paths });\n      showToast(`Copied ${paths.length} path(s)`);\n    } catch (err) {\n      showToast(`Failed to copy path: ${String(err)}`);\n    }\n  }\n\n  async function copyFiles() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_files', { paths });\n      showToast(`Copied ${paths.length} item(s)`);\n    } catch (err) {\n      showToast(`Failed to copy: ${String(err)}`);\n    }\n  }\n\n  async function trashSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    const message =\n      paths.length === 1\n        ? 'Move selected item to Trash?'\n        : `Move ${paths.length} items to Trash?`;\n\n    if (!window.confirm(message)) {\n      return;\n    }\n\n    try {\n      await invoke('move_to_trash', { paths });\n      showToast('Moved to Trash.');\n      clearSelection();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to move to Trash: ${String(err)}`);\n    }\n  }\n\n  async function resetIndex() {\n    if (indexStatus.state === 'Indexing') {\n      showToast('Indexing in progress. Please try again after it completes.');\n      return;\n    }\n\n    results = [];\n    totalResults = 0;\n    totalResultsKnown = false;\n    clearSelection();\n    scanned = 0;\n    dbLatencyMs = null;\n    dbLastQuery = '';\n    indexStatus = { ...indexStatus, state: 'Indexing', entriesCount: 0, message: null };\n    indexingStartTime = Date.now();\n    indexingElapsed = '';\n    indexingFinishedAt = '';\n\n    try {\n      await invoke('reset_index');\n    } catch (err) {\n      showToast(`Failed to reset index: ${String(err)}`);\n      await refreshStatus();\n    }\n  }\n\n  function isMultiSelected() {\n    return selectedIndices.size > 1;\n  }\n\n  function autoResizeRenameInput() {\n    if (!renameInputEl) return;\n    renameInputEl.style.height = '0';\n    renameInputEl.style.height = renameInputEl.scrollHeight + 'px';\n  }\n\n  async function startRename() {\n    if (isMultiSelected()) {\n      return;\n    }\n\n    const idx = lastSelectedIndex;\n    if (idx < 0 || !results[idx]) {\n      return;\n    }\n\n    const entry = results[idx];\n\n    // Calculate overlay position mathematically.\n    // Name cell text starts at: padding-left(16) + icon(16) + gap(6) = 38px from cell left.\n    // Textarea has padding-left: 0 and border: 1.5px, so text starts ~2px from overlay left.\n    if (tableContainer) {\n      const rect = tableContainer.getBoundingClientRect();\n      const cellLeft = rect.left - tableContainer.scrollLeft;\n      const textLeft = cellLeft + 38;\n      const cellRight = cellLeft + colWidths.name;\n      const rowTop = rect.top + idx * rowHeight - tableContainer.scrollTop;\n      renameOverlay = {\n        top: rowTop,\n        left: textLeft - 2,\n        width: cellRight - textLeft + 2 - 4\n      };\n    }\n\n    editing = {\n      active: true,\n      path: entry.path,\n      index: idx,\n      draftName: entry.name\n    };\n\n    await tick();\n\n    if (renameInputEl) {\n      autoResizeRenameInput();\n      renameInputEl.focus();\n      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n      renameInputEl.setSelectionRange(0, selectionEnd);\n    }\n  }\n\n  function cancelRename() {\n    editing = {\n      active: false,\n      path: '',\n      index: -1,\n      draftName: ''\n    };\n  }\n\n  async function commitRename() {\n    if (!editing.active || editing.index < 0 || !results[editing.index]) {\n      return;\n    }\n\n    const current = results[editing.index];\n    const nextName = editing.draftName;\n\n    try {\n      await invoke('rename', {\n        path: current.path,\n        newName: nextName\n      });\n      cancelRename();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to rename: ${String(err)}`);\n      await tick();\n      renameInputEl?.focus();\n    }\n  }\n\n  function onGlobalClick() {\n    closeContextMenu();\n  }\n\n  function onTitleBarMouseDown(event) {\n    if (event.button !== 0) {\n      return;\n    }\n\n    const activeElement = document.activeElement;\n    if (activeElement instanceof HTMLElement && isTextInputTarget(activeElement)) {\n      activeElement.blur();\n    }\n  }\n\n  async function focusSearch() {\n    await getCurrentWindow().show();\n    await getCurrentWindow().setFocus();\n    searchInputEl?.focus();\n    searchInputEl?.select();\n  }\n\n  function isTextInputTarget(target) {\n    return (\n      target instanceof HTMLInputElement ||\n      target instanceof HTMLTextAreaElement ||\n      target?.isContentEditable\n    );\n  }\n\n  async function handleKeydown(event) {\n    const isMetaSelectAll = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'a';\n    const isMetaCopy = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c';\n    const target = event.target;\n    const isTextInput = isTextInputTarget(target);\n\n    if (isMetaCopy && isTextInput) {\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      if (isTextInput) {\n        event.preventDefault();\n        if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n          target.select();\n        }\n        return;\n      }\n    }\n\n    if (editing.active) {\n      if (event.key === 'Enter') {\n        event.preventDefault();\n        await commitRename();\n        return;\n      }\n\n      if (event.key === 'Escape') {\n        event.preventDefault();\n        const idx = editing.index;\n        cancelRename();\n        selectSingle(idx);\n        await tick();\n        tableContainer?.querySelector('.row.selected')?.focus();\n        return;\n      }\n      return;\n    }\n\n    if (event.key === 'Escape') {\n      event.preventDefault();\n      clearSelection();\n      return;\n    }\n\n    if (event.key === 'ArrowDown') {\n      event.preventDefault();\n      moveSelection(1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'ArrowUp') {\n      event.preventDefault();\n      moveSelection(-1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageDown') {\n      event.preventDefault();\n      moveSelection(Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageUp') {\n      event.preventDefault();\n      moveSelection(-Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'Enter') {\n      event.preventDefault();\n      if (platform === 'windows') {\n        await openSelected();\n      } else {\n        await startRename();\n      }\n      return;\n    }\n\n    if (event.key === 'F2') {\n      event.preventDefault();\n      await startRename();\n      return;\n    }\n\n    if (event.key === ' ' && !isTextInput) {\n      event.preventDefault();\n      const entry = primaryEntry();\n      if (entry) {\n        await invoke('quick_look', { path: entry.path });\n      }\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'f') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      searchInputEl?.select();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'o') {\n      event.preventDefault();\n      await openSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {\n      event.preventDefault();\n      await revealSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c') {\n      event.preventDefault();\n      await copySelectedPaths();\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      event.preventDefault();\n      selectedIndices = new Set(Array.from({ length: results.length }, (_, i) => i));\n      return;\n    }\n\n    if (event.key === 'Delete' || ((event.metaKey || event.ctrlKey) && event.key === 'Backspace')) {\n      if (!isTextInput) {\n        event.preventDefault();\n        await trashSelected();\n      }\n      return;\n    }\n  }\n\n  function formatSize(entry) {\n    if (entry.isDir || entry.size == null) return '';\n    const bytes = entry.size;\n    if (bytes < 1024) return `${bytes} B`;\n    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n    return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n  }\n\n  function formatModified(entry) {\n    if (!entry.mtime) {\n      return '';\n    }\n\n    const d = new Date(entry.mtime * 1000);\n    const pad = (n) => String(n).padStart(2, '0');\n    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;\n  }\n\n  function formatLastUpdated(timestamp) {\n    if (!timestamp) {\n      return '-';\n    }\n\n    return new Date(timestamp * 1000).toLocaleString();\n  }\n\n  function formatElapsed(ms) {\n    const totalSec = Math.floor(ms / 1000);\n    const min = Math.floor(totalSec / 60);\n    const sec = totalSec % 60;\n    return min > 0 ? `${min}m ${sec}s` : `${sec}s`;\n  }\n\n  function updateElapsed() {\n    if (indexingStartTime && indexStatus.state === 'Indexing') {\n      indexingElapsed = formatElapsed(Date.now() - indexingStartTime);\n    }\n  }\n\n  function startElapsedTimer() {\n    clearInterval(elapsedTimer);\n    indexingStartTime = Date.now();\n    indexingElapsed = '0s';\n    indexingFinishedAt = '';\n    elapsedTimer = setInterval(updateElapsed, 1000);\n  }\n\n  function stopElapsedTimer() {\n    clearInterval(elapsedTimer);\n    if (indexingStartTime) {\n      const elapsed = Date.now() - indexingStartTime;\n      indexingFinishedAt = `${formatElapsed(elapsed)}`;\n    }\n    indexingStartTime = null;\n    indexingElapsed = '';\n  }\n\n  function displayPath(path) {\n    if (!path) {\n      return path;\n    }\n\n    if (!homePrefix) {\n      return path;\n    }\n\n    if (path === homePrefix) {\n      return '~';\n    }\n\n    if (path.startsWith(`${homePrefix}/`)) {\n      return `~${path.slice(homePrefix.length)}`;\n    }\n\n    return path;\n  }\n\n  let unlistenFns = [];\n\n  onMount(async () => {\n    const t0 = performance.now();\n    const ms = () => Math.round(performance.now() - t0);\n    const DEBUG_STARTUP = false;\n    const flog = DEBUG_STARTUP ? (msg) => invoke('frontend_log', { msg }).catch(() => {}) : () => {};\n\n    flog(`[startup/fe] onMount entered`);\n\n    updateViewportHeight();\n    flog(`[startup/fe] +${ms()}ms updateViewportHeight done`);\n\n    invoke('set_native_theme', { theme });\n\n    platform = await invoke('get_platform');\n    flog(`[startup/fe] +${ms()}ms get_platform done`);\n\n    const unlistenProgress = await listen('index_progress', (event) => {\n      scanned = event.payload.scanned;\n      if (indexStatus.state !== 'Indexing') {\n        indexStatus = {\n          ...indexStatus,\n          state: 'Indexing'\n        };\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_progress) registered`);\n\n    const unlistenState = await listen('index_state', (event) => {\n      flog(`[startup/fe] index_state event received: ${event.payload.state} at +${ms()}ms`);\n      const prevState = indexStatus.state;\n      indexStatus = {\n        ...indexStatus,\n        state: event.payload.state,\n        message: event.payload.message ?? null,\n        isCatchup: event.payload.isCatchup ?? false\n      };\n\n      if (event.payload.state === 'Indexing' && prevState !== 'Indexing') {\n        if (prevState === 'Ready') {\n          lastReadyCount = indexStatus.entriesCount;\n        }\n        startElapsedTimer();\n      } else if (event.payload.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n\n      if (event.payload.state === 'Ready') {\n        scheduleSearch();\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_state) registered`);\n\n    const unlistenUpdated = await listen('index_updated', (event) => {\n      indexStatus = {\n        ...indexStatus,\n        entriesCount: event.payload.entriesCount,\n        lastUpdated: event.payload.lastUpdated,\n        permissionErrors: event.payload.permissionErrors ?? indexStatus.permissionErrors\n      };\n\n      scheduleSearch(true);\n    });\n\n    const unlistenFocus = await listen('focus_search', () => {\n      void focusSearch();\n    });\n\n    const unlistenCtxMenuAction = await listen('context_menu_action', (event) => {\n      switch (event.payload) {\n        case 'open': void openSelected(); break;\n        case 'quick_look': {\n          const e = primaryEntry();\n          if (e) void invoke('quick_look', { path: e.path });\n          break;\n        }\n        case 'open_with': void openWithFallback(); break;\n        case 'reveal': void revealSelected(); break;\n        case 'copy_files': void copyFiles(); break;\n        case 'copy_path': void copySelectedPaths(); break;\n        case 'trash': void trashSelected(); break;\n        case 'rename': void startRename(); break;\n      }\n    });\n\n    unlistenFns = [unlistenProgress, unlistenState, unlistenUpdated, unlistenFocus, unlistenCtxMenuAction];\n    flog(`[startup/fe] +${ms()}ms all listeners registered`);\n\n    // Fetch backend state IMMEDIATELY after listeners are registered.\n    // Events emitted before listener registration are lost, so this\n    // is the only reliable way to get the current state.\n    await refreshStatus();\n    flog(`[startup/fe] +${ms()}ms refreshStatus done (state=${indexStatus.state})`);\n\n    // Show Svelte UI: remove skeleton, focus search input.\n    await tick();\n    document.getElementById('skeleton')?.remove();\n    await focusSearch();\n    flog(`[startup/fe] +${ms()}ms WINDOW VISIBLE â€” skeleton removed`);\n\n    try {\n      homePrefix = await invoke('get_home_dir');\n    } catch {\n      homePrefix = '';\n    }\n    flog(`[startup/fe] +${ms()}ms get_home_dir done`);\n\n    if (!localStorage.getItem('everything-fda-notice-v1')) {\n      showToast('macOS Full Disk Access permission may be required for full disk search.');\n      localStorage.setItem('everything-fda-notice-v1', '1');\n    }\n    flog(`[startup/fe] +${ms()}ms calling runSearch...`);\n    await runSearch();\n    flog(`[startup/fe] +${ms()}ms runSearch done`);\n\n    if (typeof ResizeObserver !== 'undefined') {\n      tableResizeObserver = new ResizeObserver(() => {\n        scheduleViewportHeightUpdate();\n      });\n      if (tableContainer) {\n        tableResizeObserver.observe(tableContainer);\n      } else if (tableAreaEl) {\n        tableResizeObserver.observe(tableAreaEl);\n      }\n    }\n\n    window.addEventListener('resize', scheduleViewportHeightUpdate);\n    window.addEventListener('click', onGlobalClick);\n    statusRefreshTimer = setInterval(() => {\n      if (indexStatus.state === 'Indexing') {\n        void refreshStatus();\n      }\n    }, 1000);\n    console.log(`[startup/fe] +${ms()}ms onMount complete`);\n  });\n\n  onDestroy(async () => {\n    clearTimeout(searchTimer);\n    clearTimeout(toastTimer);\n    clearInterval(statusRefreshTimer);\n    clearInterval(elapsedTimer);\n    resizeCleanup?.();\n\n    for (const unlisten of unlistenFns) {\n      unlisten();\n    }\n\n    tableResizeObserver?.disconnect();\n    tableResizeObserver = null;\n    if (viewportResizeRaf !== null) {\n      cancelAnimationFrame(viewportResizeRaf);\n      viewportResizeRaf = null;\n    }\n    window.removeEventListener('resize', scheduleViewportHeightUpdate);\n    window.removeEventListener('click', onGlobalClick);\n  });\n</script>\n\n<svelte:window on:keydown={handleKeydown} />\n\n<div class=\"app-shell\" data-theme={theme}>\n  <div class=\"title-bar\" role=\"presentation\" data-tauri-drag-region on:mousedown={onTitleBarMouseDown}>\n    <div class=\"title-left\"></div>\n    <div class=\"title-center\">\n      <svg class=\"title-icon\" viewBox=\"0 0 215 205\" fill-rule=\"evenodd\" aria-hidden=\"true\">\n        <path d=\"M85 0c46.9 0 85 38.1 85 85 0 20.1-7.2 38.5-19.2 52.7l40.7 40.8c5.8 5.8 5.8 15.2 0 21-5.8 5.8-15.2 5.8-21 0l-40.7-40.7c-13.6 9.7-30.4 15.2-44.8 15.2-46.9 0-85-42.1-85-89 0-46.9 38.1-85 85-85z m0 32c-29.3 0-53 23.7-53 53 0 29.3 23.7 53 53 53 29.3 0 53-23.7 53-53 0-29.3-23.7-53-53-53z\"/>\n      </svg>\n      <span class=\"title-text\">Everything</span>\n    </div>\n    <div class=\"title-right\"></div>\n  </div>\n\n  <header class=\"search-bar\">\n    <input\n      bind:this={searchInputEl}\n      class=\"search-input\"\n      type=\"text\"\n      bind:value={query}\n      on:input={scheduleSearch}\n      on:focus={clearSelection}\n      placeholder=\"Search file/folder names\"\n      autocomplete=\"off\"\n      spellcheck=\"false\"\n    />\n  </header>\n\n  <section class=\"table-area\" bind:this={tableAreaEl} style={tableGridStyle}>\n    <div class=\"table-header\">\n      <div class=\"table-header-track\">\n        <div class=\"col name\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('name')}>\n            Name{#if sortBy === 'name'}{@html sortIconHtml(sortDir)}{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'name'}\n            on:mousedown={(event) => startColumnResize(event, 'name')}\n            aria-label=\"Resize Name column\"\n          />\n        </div>\n\n        <div class=\"col path\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('dir')}>\n            Path{#if sortBy === 'dir'}{@html sortIconHtml(sortDir)}{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'path'}\n            on:mousedown={(event) => startColumnResize(event, 'path')}\n            aria-label=\"Resize Path column\"\n          />\n        </div>\n\n        <div class=\"col size\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('size')}>\n            Size{#if sortBy === 'size'}{@html sortIconHtml(sortDir)}{/if}\n          </button>\n        </div>\n\n        <div class=\"col modified\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('mtime')}>\n            Modified{#if sortBy === 'mtime'}{@html sortIconHtml(sortDir)}{/if}\n          </button>\n        </div>\n      </div>\n    </div>\n\n    <div\n      class=\"table-body\"\n      bind:this={tableContainer}\n      on:scroll={() => {\n        scrollTop = tableContainer.scrollTop;\n        headerScrollLeft = tableContainer.scrollLeft;\n        if (editing.active) void commitRename();\n        const scrollBottom = scrollTop + tableContainer.clientHeight;\n        if (scrollBottom >= totalHeight - rowHeight * 10) {\n          void loadMore();\n        }\n      }}\n    >\n      <div class=\"spacer\" style={`height:${totalHeight}px`}>\n        <div class=\"rows\" style={`transform: translateY(${translateY}px);`}>\n          {#each visibleRows as entry, localIndex}\n            {@const index = startIndex + localIndex}\n            <div\n              class=\"row {selectedIndices.has(index) ? 'selected' : ''}\"\n              on:mousedown={(event) => handleRowMouseDown(event, index)}\n              on:click={(event) => handleRowClick(event, index)}\n              on:keydown={(event) => handleRowA11yKeydown(event, index)}\n              on:dblclick={() => handleRowDoubleClick(index)}\n              on:contextmenu={(event) => handleRowContextMenu(event, index)}\n              role=\"row\"\n              tabindex=\"0\"\n            >\n              <div class=\"cell name\">\n                <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n                <span class=\"ellipsis\" class:name-editing={editing.active && editing.index === index}>{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n              </div>\n              <div class=\"cell path\"><span class=\"ellipsis\">{displayPath(entry.dir)}</span></div>\n              <div class=\"cell size\">{formatSize(entry)}</div>\n              <div class=\"cell modified\">{formatModified(entry)}</div>\n            </div>\n          {/each}\n        </div>\n      </div>\n    </div>\n  </section>\n\n  <footer class=\"status-bar\">\n    <div class=\"status-left\">\n      <span class=\"status-state\">\n        <span class=\"state-dot {indexStatus.state === 'Indexing' ? 'indexing' : indexStatus.state === 'Error' ? 'error' : 'ready'}\"></span>\n        {#if indexStatus.state === 'Indexing'}\n          Indexing{#if lastReadyCount > 0} ({Math.min(99, Math.round((scanned / lastReadyCount) * 100))}%){/if}{#if indexingElapsed} Â· {indexingElapsed}{/if}\n          {#if !indexStatus.isCatchup}\n            Â· {scanned.toLocaleString()} scanned\n          {/if}\n        {:else}\n          Index: {indexStatus.state}\n        {/if}\n      </span>\n      <span>{indexStatus.entriesCount.toLocaleString()} entries</span>\n      {#if indexingFinishedAt && indexStatus.state !== 'Indexing'}\n        <span>in {indexingFinishedAt}</span>\n      {/if}\n      {#if dbLatencyMs !== null && dbLastQuery}\n        <span>\"{dbLastQuery}\" {dbLatencyMs}ms Â· {totalResults} results</span>\n      {/if}\n      {#if searchModeLabel === 'spotlight' || searchModeLabel === 'spotlight_timeout'}\n        <span class=\"status-spotlight\">Spotlight fallback{#if searchModeLabel === 'spotlight_timeout'} (partial){/if}</span>\n      {/if}\n      {#if indexStatus.permissionErrors > 0}\n        <span class=\"status-warning\">{indexStatus.permissionErrors.toLocaleString()} permission errors</span>\n      {/if}\n      {#if indexStatus.message}\n        <span class={indexStatus.isCatchup ? 'index-progress' : 'status-error'}>{indexStatus.message}</span>\n      {/if}\n    </div>\n    <div class=\"status-right\">\n      <button class=\"status-btn\" on:click={cycleTheme} title=\"Switch theme\">\n        {theme === 'dark' ? 'â˜€ Light' : 'â—‘ Dark'}\n      </button>\n      <button\n        class=\"status-btn rebuild-btn\"\n        on:click={resetIndex}\n        disabled={indexStatus.state === 'Indexing'}\n        title={indexStatus.state === 'Indexing' ? 'Cannot reset while indexing is in progress.' : 'Reset and rebuild the index.'}\n      >\n        <svg class=\"rebuild-icon\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n          <path d=\"M23 4v6h-6\"/><path d=\"M20.49 15a9 9 0 1 1-2.12-9.36L23 10\"/>\n        </svg>\n        Rebuild Index\n      </button>\n    </div>\n  </footer>\n\n  {#if editing.active}\n    <div\n      class=\"rename-overlay\"\n      style=\"top:{renameOverlay.top}px; left:{renameOverlay.left}px; width:{renameOverlay.width}px;\"\n      role=\"presentation\"\n      on:mousedown|stopPropagation\n    >\n      <textarea\n        bind:this={renameInputEl}\n        class=\"rename-textarea\"\n        bind:value={editing.draftName}\n        on:input={autoResizeRenameInput}\n        on:click|stopPropagation\n        on:blur={commitRename}\n      />\n    </div>\n  {/if}\n\n  {#if contextMenu.visible}\n    <div class=\"context-menu\" style={`left:${contextMenu.x}px;top:${contextMenu.y}px;`}>\n      <button on:click={() => (closeContextMenu(), openSelected())}>Open</button>\n      <button on:click={async () => { closeContextMenu(); const e = primaryEntry(); if (e) await invoke('quick_look', { path: e.path }); }}>Quick Look</button>\n      <button on:click={() => (closeContextMenu(), openWithFallback())}>Open With... (Reveal in Finder)</button>\n      <button on:click={() => (closeContextMenu(), revealSelected())}>Reveal in Finder</button>\n      <button on:click={() => (closeContextMenu(), copySelectedPaths())}>Copy Path</button>\n      <button on:click={() => (closeContextMenu(), trashSelected())}>Move to Trash</button>\n      {#if selectedIndices.size === 1}\n        <button on:click={() => (closeContextMenu(), startRename())}>Rename</button>\n      {/if}\n    </div>\n  {/if}\n\n  {#if toast}\n    <div class=\"toast\">{toast}</div>\n  {/if}\n</div>\n\n<style>\n  :global(:root) {\n    color-scheme: light dark;\n    --bg-app: transparent;\n    --text-primary: #0d1826;\n    --text-muted: #48596c;\n    --bar-grad-top: rgba(255, 255, 255, 0.48);\n    --bar-grad-bottom: rgba(248, 250, 253, 0.42);\n    --surface-header: rgba(252, 252, 255, 0.40);\n    --surface: rgba(255, 255, 255, 0.22);\n    --border-soft: rgba(0, 0, 0, 0.07);\n    --border-input: rgba(0, 0, 0, 0.13);\n    --focus-ring: #6f96e6;\n    --row-border: rgba(0, 0, 0, 0.032);\n    --row-hover: rgba(0, 0, 0, 0.06);\n    --row-selected: rgba(0, 0, 0, 0.12);\n    --button-bg: rgba(255, 255, 255, 0.62);\n    --button-border: rgba(0, 0, 0, 0.10);\n    --button-text: #2c3e50;\n    --menu-bg: rgba(240, 241, 248, 0.90);\n    --menu-border: rgba(0, 0, 0, 0.06);\n    --menu-hover: rgba(255, 255, 255, 0.62);\n    --menu-text: #1a2a38;\n    --error-text: #b64545;\n    --warning-text: #8f6500;\n    --toast-bg: rgba(18, 22, 32, 0.90);\n    --toast-text: #ffffff;\n  }\n\n  @media (prefers-color-scheme: dark) {\n    :global(:root) {\n      --bg-app: transparent;\n      --text-primary: #e6e6ea;\n      --text-muted: #9494a4;\n      --bar-grad-top: rgba(38, 38, 46, 0.52);\n      --bar-grad-bottom: rgba(30, 30, 38, 0.46);\n      --surface-header: rgba(32, 32, 40, 0.46);\n      --surface: rgba(18, 18, 26, 0.32);\n      --border-soft: rgba(255, 255, 255, 0.065);\n      --border-input: rgba(255, 255, 255, 0.14);\n      --focus-ring: #5b8bd9;\n      --row-border: rgba(255, 255, 255, 0.026);\n      --row-hover: rgba(255, 255, 255, 0.08);\n      --row-selected: rgba(255, 255, 255, 0.14);\n      --button-bg: rgba(255, 255, 255, 0.072);\n      --button-border: rgba(255, 255, 255, 0.11);\n      --button-text: #d6d6e0;\n      --menu-bg: rgba(36, 36, 46, 0.90);\n      --menu-border: rgba(255, 255, 255, 0.066);\n      --menu-hover: rgba(255, 255, 255, 0.062);\n      --menu-text: #e0e0e8;\n      --error-text: #ff9d9d;\n      --warning-text: #e0c670;\n      --toast-bg: rgba(10, 10, 16, 0.93);\n      --toast-text: #f2f2f6;\n    }\n  }\n\n  /* â”€â”€ Theme: Dark â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme=\"dark\"]) {\n    color-scheme: dark;\n    --bg-app: #1E1E21;\n    --text-primary: #E2E8F0;\n    --text-muted: #94A3B8;\n    --bar-grad-top: #1E1E21;\n    --bar-grad-bottom: #1E1E21;\n    --surface-header: #1E1E21;\n    --surface: #1E1E21;\n    --bg-input: #161618;\n    --border-soft: #2A2A2D;\n    --border-input: rgba(255, 255, 255, 0.06);\n    --focus-ring: #4DA8FF;\n    --accent: #4DA8FF;\n    --row-border: rgba(255, 255, 255, 0.02);\n    --row-hover: #282828;\n    --row-selected: rgba(77, 168, 255, 0.10);\n    --button-bg: rgba(255, 255, 255, 0.05);\n    --button-border: #2A2A2D;\n    --button-text: #94A3B8;\n    --menu-bg: #252528;\n    --menu-border: #2A2A2D;\n    --menu-hover: rgba(255, 255, 255, 0.04);\n    --menu-text: #E2E8F0;\n    --error-text: #ff9d9d;\n    --warning-text: #e0c670;\n    --toast-bg: rgba(10, 10, 16, 0.93);\n    --toast-text: #f2f2f6;\n  }\n\n  /* â”€â”€ Theme: Light â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme=\"light\"]) {\n    color-scheme: light;\n    --bg-app: #F5F5F7;\n    --text-primary: #1C1C1E;\n    --text-muted: #6E6E7A;\n    --bar-grad-top: #F5F5F7;\n    --bar-grad-bottom: #F5F5F7;\n    --surface-header: #F5F5F7;\n    --surface: #F5F5F7;\n    --bg-input: #FFFFFF;\n    --border-soft: #D1D1D6;\n    --border-input: rgba(0, 0, 0, 0.10);\n    --focus-ring: #3A8BF5;\n    --accent: #3A8BF5;\n    --row-border: rgba(0, 0, 0, 0.04);\n    --row-hover: rgba(0, 0, 0, 0.04);\n    --row-selected: rgba(58, 139, 245, 0.10);\n    --button-bg: #FFFFFF;\n    --button-border: #D1D1D6;\n    --button-text: #3C3C43;\n    --menu-bg: #FFFFFF;\n    --menu-border: #D1D1D6;\n    --menu-hover: rgba(0, 0, 0, 0.05);\n    --menu-text: #1C1C1E;\n    --error-text: #D93025;\n    --warning-text: #B45309;\n    --toast-bg: rgba(255, 255, 255, 0.95);\n    --toast-text: #1C1C1E;\n  }\n\n  /* â”€â”€ Themed element overrides â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme]) {\n    background: var(--bg-app);\n  }\n\n  /* Search bar: flat, no gradient, no separator */\n  :global([data-theme]) .search-bar {\n    height: 44px;\n    padding: 0 16px;\n    background: var(--bg-app);\n    border-bottom: none;\n  }\n\n  :global([data-theme]) .search-input {\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n    font-family: 'JetBrains Mono', 'SF Mono', monospace;\n    font-size: 12px;\n    height: 34px;\n    border-radius: 8px;\n  }\n\n  /* Table header: flat bg, 16px edge padding */\n  :global([data-theme]) .table-header {\n    background: var(--bg-app);\n  }\n\n  :global([data-theme]) .col-button {\n    padding: 0 8px;\n  }\n\n  :global([data-theme]) .col.name .col-button {\n    padding-left: 16px;\n  }\n\n  /* Row cells: JetBrains Mono, 16px outer edges */\n  :global([data-theme]) .cell {\n    font-family: 'JetBrains Mono', monospace;\n  }\n\n  :global([data-theme]) .cell.name {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    padding-left: 16px;\n    font-size: 12px;\n    color: var(--text-primary);\n  }\n\n  :global([data-theme]) .cell.path {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.size {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.modified {\n    padding-right: 16px;\n    font-size: 11px;\n    white-space: nowrap;\n  }\n\n  :global([data-theme]) .row.selected {\n    box-shadow: inset 3px 0 0 var(--accent);\n  }\n\n  /* Dim path/size/date cells in themed mode */\n  :global([data-theme]) .cell.path,\n  :global([data-theme]) .cell.size,\n  :global([data-theme]) .cell.modified {\n    color: var(--text-muted);\n  }\n\n  :global(:root) {\n    background: transparent;\n  }\n\n  :global(html, body) {\n    margin: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    background: transparent;\n    color: var(--text-primary);\n    font-family: Inter, 'SF Pro Text', 'Segoe UI', Helvetica, Arial, sans-serif;\n  }\n\n  :global(#app) {\n    width: 100%;\n    height: 100%;\n  }\n\n  .app-shell {\n    display: grid;\n    grid-template-rows: auto auto 1fr auto;\n    height: 100%;\n    min-width: 0;\n  }\n\n  .title-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 44px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    cursor: default;\n    flex-shrink: 0;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-left {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-center {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-right {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-icon {\n    width: 14px;\n    height: 14px;\n    fill: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .title-text {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 13px;\n    font-weight: 500;\n    color: var(--text-primary);\n    letter-spacing: -0.01em;\n  }\n\n  .search-bar {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding: 8px;\n    background: linear-gradient(180deg, var(--bar-grad-top) 0%, var(--bar-grad-bottom) 100%);\n    border-bottom: 1px solid var(--border-soft);\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .search-input {\n    display: block;\n    box-sizing: border-box;\n    width: 100%;\n    min-width: 0;\n    flex: 1 1 auto;\n    height: 36px;\n    border: 1px solid var(--border-input);\n    border-radius: 14px;\n    padding: 0 10px;\n    font-size: 14px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    backdrop-filter: blur(12px) saturate(160%);\n    -webkit-backdrop-filter: blur(12px) saturate(160%);\n  }\n\n  .search-input::placeholder {\n    color: var(--text-muted);\n    opacity: 0.85;\n    font-size: 12px;\n  }\n\n  .search-input:focus {\n    outline: none;\n    border-color: var(--focus-ring);\n    box-shadow: 0 0 0 2px rgba(125, 169, 255, 0.25);\n  }\n\n  .table-area {\n    display: grid;\n    grid-template-rows: auto 1fr;\n    min-height: 0;\n    min-width: 0;\n  }\n\n  .table-header-track,\n  .row {\n    display: grid;\n    grid-template-columns: var(--col-name) var(--col-path) var(--col-size) var(--col-modified);\n    align-items: center;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .table-header {\n    height: 32px;\n    border-bottom: 1px solid var(--border-soft);\n    background: var(--surface-header);\n    user-select: none;\n    overflow: hidden;\n    flex-shrink: 0;\n  }\n\n  .table-header-track {\n    height: 100%;\n    transform: translateX(var(--header-offset, 0px));\n    will-change: transform;\n  }\n\n  .table-header .col {\n    position: relative;\n    min-width: 0;\n    height: 100%;\n  }\n\n  .col-button {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n    gap: 4px;\n    box-sizing: border-box;\n    padding: 0 8px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 11px;\n    font-weight: 600;\n    line-height: 1;\n    color: var(--text-muted);\n    text-align: left;\n    margin: 0;\n    border: none;\n    background: transparent;\n    cursor: pointer;\n  }\n\n  :global(.sort-icon) {\n    width: 10px;\n    height: 10px;\n    flex-shrink: 0;\n    color: var(--accent);\n  }\n\n  .col-resizer {\n    position: absolute;\n    top: 0;\n    right: -4px;\n    width: 8px;\n    height: 100%;\n    border: none;\n    padding: 0;\n    background: transparent;\n    cursor: col-resize;\n    z-index: 30;\n  }\n\n  .col-resizer::after {\n    content: '';\n    position: absolute;\n    top: 7px;\n    bottom: 7px;\n    left: 50%;\n    width: 1px;\n    transform: translateX(-50%);\n    background: var(--border-soft);\n    opacity: 0;\n    transition: opacity 0.15s ease;\n  }\n\n  .table-header .col:hover .col-resizer::after,\n  .col-resizer.active::after {\n    opacity: 1;\n  }\n\n  .table-body {\n    overflow: auto;\n    min-height: 0;\n    min-width: 0;\n    background: var(--surface);\n  }\n\n  .spacer {\n    position: relative;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .rows {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .row {\n    height: 30px;\n    border-bottom: 1px solid var(--row-border);\n    cursor: default;\n    -webkit-user-select: none;\n    user-select: none;\n    outline: none;\n  }\n\n  .row:hover {\n    background: var(--row-hover);\n  }\n\n  .row.selected {\n    background: var(--row-selected);\n  }\n\n  .cell {\n    padding: 0 8px;\n    font-size: 12px;\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    min-width: 0;\n  }\n\n  .cell.size {\n    text-align: right;\n    font-variant-numeric: tabular-nums;\n  }\n\n  .ellipsis {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n\n  .hl {\n    background: none;\n    color: inherit;\n    font-weight: 700;\n  }\n\n  .file-icon {\n    width: 16px;\n    height: 16px;\n    flex: 0 0 auto;\n  }\n\n  .name-editing {\n    opacity: 0.25;\n  }\n\n  .rename-overlay {\n    position: fixed;\n    z-index: 100;\n    min-width: 120px;\n  }\n\n  .rename-textarea {\n    display: block;\n    width: 100%;\n    box-sizing: border-box;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 12px;\n    line-height: 18px;\n    padding: 5px 4px 5px 0;\n    border: 1.5px solid var(--focus-ring);\n    border-radius: 4px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    outline: none;\n    resize: none;\n    overflow: hidden;\n    box-shadow: 0 2px 14px rgba(0, 0, 0, 0.22), 0 0 0 3px rgba(77, 168, 255, 0.13);\n  }\n\n  .status-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 32px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    border-top: 1px solid var(--border-soft);\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 11px;\n    color: var(--text-muted);\n    white-space: nowrap;\n    overflow: hidden;\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .status-left {\n    display: flex;\n    align-items: center;\n    gap: 16px;\n    overflow: hidden;\n    min-width: 0;\n  }\n\n  .status-right {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    flex-shrink: 0;\n  }\n\n  .status-btn {\n    border: 1px solid var(--button-border);\n    border-radius: 5px;\n    background: var(--button-bg);\n    color: var(--button-text);\n    font-size: 11px;\n    height: 22px;\n    padding: 0 8px;\n    cursor: pointer;\n  }\n\n  .status-btn:hover {\n    filter: brightness(1.06);\n  }\n\n  .status-btn:disabled {\n    opacity: 0.55;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .status-state {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n  }\n\n  .state-dot {\n    width: 6px;\n    height: 6px;\n    border-radius: 50%;\n    flex-shrink: 0;\n  }\n\n  .state-dot.ready { background: #28C840; }\n  .state-dot.indexing { background: #FEBC2E; }\n  .state-dot.error { background: #FF5F57; }\n\n  .rebuild-btn {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 10px;\n    font-weight: 500;\n    background: var(--button-bg);\n    border: 1px solid var(--button-border);\n    border-radius: 4px;\n    color: var(--button-text);\n    height: 22px;\n    padding: 0 10px;\n    cursor: pointer;\n  }\n\n  .rebuild-btn:hover {\n    filter: brightness(1.1);\n  }\n\n  .rebuild-btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .rebuild-icon {\n    width: 11px;\n    height: 11px;\n    color: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .status-error {\n    color: var(--error-text);\n  }\n\n  .status-warning {\n    color: var(--warning-text);\n  }\n\n  .status-spotlight {\n    color: #f59e0b;\n    font-weight: 600;\n  }\n\n  .context-menu {\n    position: fixed;\n    z-index: 200;\n    width: 220px;\n    border: 1px solid var(--menu-border);\n    border-radius: 10px;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.16), inset 0 0 0 0.5px rgba(255, 255, 255, 0.18);\n    background: var(--menu-bg);\n    backdrop-filter: blur(28px) saturate(180%);\n    -webkit-backdrop-filter: blur(28px) saturate(180%);\n    overflow: hidden;\n  }\n\n  .context-menu button {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    padding: 8px 10px;\n    font-size: 12px;\n    color: var(--menu-text);\n  }\n\n  .context-menu button:hover {\n    background: var(--menu-hover);\n  }\n\n  .toast {\n    position: fixed;\n    right: 14px;\n    bottom: 18px;\n    background: var(--toast-bg);\n    color: var(--toast-text);\n    border-radius: 10px;\n    padding: 9px 12px;\n    font-size: 12px;\n    z-index: 250;\n    backdrop-filter: blur(20px) saturate(180%);\n    -webkit-backdrop-filter: blur(20px) saturate(180%);\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);\n  }\n</style>\n","structuredPatch":[{"oldStart":2198,"oldLines":13,"newStart":2198,"newLines":8,"lines":["     font-family: Inter, 'SF Pro Text', sans-serif;","     font-size: 10px;","     font-weight: 500;","-    background: var(--button-bg);","-    border: 1px solid var(--button-border);","     border-radius: 4px;","-    color: var(--button-text);","-    height: 22px;","     padding: 0 10px;","-    cursor: pointer;","   }"," ","   .rebuild-btn:hover {"]},{"oldStart":2213,"oldLines":8,"newStart":2208,"newLines":6,"lines":[" ","   .rebuild-btn:disabled {","     opacity: 0.5;","-    cursor: not-allowed;","-    filter: none;","   }"," ","   .rebuild-icon {"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"457a04d0-0254-4ec0-a41b-0257d8febff6"}
{"parentUuid":"ffbdeafc-b9b5-4f1a-8a0e-171cc169195e","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01QMS3aJZur8ubZndAJgtUtX","type":"message","role":"assistant","content":[{"type":"text","text":"ëª¨ë“  ìˆ˜ì •ì´ ì™„ë£Œë˜ì—ˆëŠ”ì§€ ìµœì¢… í™•ì¸í•©ë‹ˆë‹¤."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":621,"cache_read_input_tokens":102780,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":621},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPSeUfK73L47ASramsn","type":"assistant","uuid":"739c56b3-cac7-46c5-bc33-c19e7fbbed99","timestamp":"2026-02-21T14:40:24.885Z"}
{"parentUuid":"739c56b3-cac7-46c5-bc33-c19e7fbbed99","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01QMS3aJZur8ubZndAJgtUtX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013agj6Ukj9P56wLz4K39coW","name":"Bash","input":{"command":"npm run lint 2>&1 | tail -20","description":"Run lint to verify no errors","timeout":60000},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":621,"cache_read_input_tokens":102780,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":621},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPSeUfK73L47ASramsn","type":"assistant","uuid":"687acc2d-812d-4ab3-918f-fd06186eeeaa","timestamp":"2026-02-21T14:40:25.849Z"}
{"type":"queue-operation","operation":"enqueue","timestamp":"2026-02-21T14:40:28.898Z","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","content":"{\"task_id\":\"bcfb5b2\",\"tool_use_id\":\"toolu_013agj6Ukj9P56wLz4K39coW\",\"description\":\"Run lint to verify no errors\",\"task_type\":\"local_bash\"}"}
{"parentUuid":"687acc2d-812d-4ab3-918f-fd06186eeeaa","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":3,"totalLines":0,"totalBytes":0,"taskId":"bcfb5b2","timeoutMs":60000},"toolUseID":"bash-progress-0","parentToolUseID":"toolu_013agj6Ukj9P56wLz4K39coW","uuid":"d291854e-0f03-4874-bd59-f207550e8a98","timestamp":"2026-02-21T14:40:28.898Z"}
{"parentUuid":"d291854e-0f03-4874-bd59-f207550e8a98","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":4,"totalLines":0,"totalBytes":0,"taskId":"bcfb5b2","timeoutMs":60000},"toolUseID":"bash-progress-1","parentToolUseID":"toolu_013agj6Ukj9P56wLz4K39coW","uuid":"e1dbe348-6829-4e8d-ab66-8544bc380910","timestamp":"2026-02-21T14:40:29.899Z"}
{"parentUuid":"687acc2d-812d-4ab3-918f-fd06186eeeaa","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013agj6Ukj9P56wLz4K39coW","type":"tool_result","content":"dist/assets/jetbrains-mono-latin-500-normal-BWZEU5yA.woff2      21.83 kB\ndist/assets/inter-latin-400-normal-C38fXH4l.woff2               23.66 kB\ndist/assets/inter-latin-500-normal-Cerq10X2.woff2               24.27 kB\ndist/assets/inter-latin-600-normal-LgqL8muc.woff2               24.45 kB\ndist/assets/jetbrains-mono-latin-400-normal-6-qcROiO.woff       27.50 kB\ndist/assets/jetbrains-mono-latin-500-normal-CJOVTJB7.woff       28.21 kB\ndist/assets/inter-latin-400-normal-CyCys3Eg.woff                30.70 kB\ndist/assets/inter-latin-600-normal-CiBQ2DWP.woff                31.26 kB\ndist/assets/inter-latin-500-normal-BL9OpVg8.woff                31.28 kB\ndist/assets/inter-latin-ext-400-normal-C1nco2VV.woff2           35.00 kB\ndist/assets/inter-latin-ext-500-normal-CV4jyFjo.woff2           36.02 kB\ndist/assets/inter-latin-ext-600-normal-D2bJ5OIk.woff2           36.26 kB\ndist/assets/inter-latin-ext-400-normal-77YHD8bZ.woff            47.56 kB\ndist/assets/inter-latin-ext-500-normal-BxGbmqWO.woff            48.49 kB\ndist/assets/inter-latin-ext-600-normal-CIVaiw4L.woff            48.67 kB\ndist/assets/index-CNSOtBqO.css                                  42.19 kB â”‚ gzip: 17.71 kB\ndist/assets/index-C-uKS9_4.js                                   57.90 kB â”‚ gzip: 19.29 kB\nâœ“ built in 445ms\n    Checking everything v0.2.0 (/Users/al02402336/everything/src-tauri)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 2.71s","is_error":false}]},"uuid":"b1770e05-493b-4c1d-a964-abc5da3435ec","timestamp":"2026-02-21T14:40:30.556Z","toolUseResult":{"stdout":"dist/assets/jetbrains-mono-latin-500-normal-BWZEU5yA.woff2      21.83 kB\ndist/assets/inter-latin-400-normal-C38fXH4l.woff2               23.66 kB\ndist/assets/inter-latin-500-normal-Cerq10X2.woff2               24.27 kB\ndist/assets/inter-latin-600-normal-LgqL8muc.woff2               24.45 kB\ndist/assets/jetbrains-mono-latin-400-normal-6-qcROiO.woff       27.50 kB\ndist/assets/jetbrains-mono-latin-500-normal-CJOVTJB7.woff       28.21 kB\ndist/assets/inter-latin-400-normal-CyCys3Eg.woff                30.70 kB\ndist/assets/inter-latin-600-normal-CiBQ2DWP.woff                31.26 kB\ndist/assets/inter-latin-500-normal-BL9OpVg8.woff                31.28 kB\ndist/assets/inter-latin-ext-400-normal-C1nco2VV.woff2           35.00 kB\ndist/assets/inter-latin-ext-500-normal-CV4jyFjo.woff2           36.02 kB\ndist/assets/inter-latin-ext-600-normal-D2bJ5OIk.woff2           36.26 kB\ndist/assets/inter-latin-ext-400-normal-77YHD8bZ.woff            47.56 kB\ndist/assets/inter-latin-ext-500-normal-BxGbmqWO.woff            48.49 kB\ndist/assets/inter-latin-ext-600-normal-CIVaiw4L.woff            48.67 kB\ndist/assets/index-CNSOtBqO.css                                  42.19 kB â”‚ gzip: 17.71 kB\ndist/assets/index-C-uKS9_4.js                                   57.90 kB â”‚ gzip: 19.29 kB\nâœ“ built in 445ms\n    Checking everything v0.2.0 (/Users/al02402336/everything/src-tauri)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 2.71s","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"687acc2d-812d-4ab3-918f-fd06186eeeaa"}
{"parentUuid":"b1770e05-493b-4c1d-a964-abc5da3435ec","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01UyrULFPPNZxSwn6fSznAAW","type":"message","role":"assistant","content":[{"type":"text","text":"ë¹Œë“œ clean. ê²½ê³  ì—†ìŒ."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":758,"cache_read_input_tokens":103401,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":758},"output_tokens":4,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPTDv5AfUv99DKdtjru","type":"assistant","uuid":"5d976dc5-844f-4d85-b673-3c09639d4945","timestamp":"2026-02-21T14:40:32.674Z"}
{"parentUuid":"5d976dc5-844f-4d85-b673-3c09639d4945","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01UyrULFPPNZxSwn6fSznAAW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017ZRRMKBZYyUv4LzVrXjViy","name":"TaskUpdate","input":{"taskId":"1","status":"completed"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":758,"cache_read_input_tokens":103401,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":758},"output_tokens":4,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPTDv5AfUv99DKdtjru","type":"assistant","uuid":"90d4343f-a1bc-4e11-b2d7-38716cea518a","timestamp":"2026-02-21T14:40:33.005Z"}
{"parentUuid":"90d4343f-a1bc-4e11-b2d7-38716cea518a","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017ZRRMKBZYyUv4LzVrXjViy","type":"tool_result","content":"Updated task #1 status"}]},"uuid":"7d14df39-6b14-48b1-bfb5-308381d132cc","timestamp":"2026-02-21T14:40:33.009Z","toolUseResult":{"success":true,"taskId":"1","updatedFields":["status"],"statusChange":{"from":"in_progress","to":"completed"}},"sourceToolAssistantUUID":"90d4343f-a1bc-4e11-b2d7-38716cea518a"}
{"parentUuid":"7d14df39-6b14-48b1-bfb5-308381d132cc","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01QJfrFp3oDUw8d8vLCdyuoL","type":"message","role":"assistant","content":[{"type":"text","text":"5ê°€ì§€ ì´ìŠˆ ëª¨ë‘ ìˆ˜ì • ì™„ë£Œí–ˆìŠµë‹ˆë‹¤:\n\n| ì´ìŠˆ | ìˆ˜ì • ë‚´ìš© |\n|---|---|\n| **ìŠ¤í¬ë¡¤ ì‹œ rename ë¬´ìŒ ì‚­ì œ** | `cancelRename()` â†’ `void commitRename()` â€” ìŠ¤í¬ë¡¤í•˜ë©´ ì»¤ë°‹ |\n| **drag preview í…Œë§ˆ ë¶ˆì¼ì¹˜** | `window.matchMedia(...)` â†’ `theme === 'dark'` â€” theme ìƒíƒœ ì§ì ‘ ì‚¬ìš© |\n| **ë¯¸ì •ì˜ `.theme-btn` í´ëž˜ìŠ¤** | ë²„íŠ¼ì—ì„œ `theme-btn` í´ëž˜ìŠ¤ ì œê±° |\n| **`.rebuild-btn` CSS ì¤‘ë³µ** | `.status-btn`ê³¼ ë™ì¼í•œ `background`, `border`, `color`, `height`, `cursor` 6ê°œ í”„ë¡œí¼í‹° ì œê±°, `:disabled` ì—ì„œ ì¤‘ë³µ ê·œì¹™ ì œê±° |\n| **sort icon SVG 4ì¤‘ ë³µì‚¬** | `sortIconHtml(dir)` í—¬í¼ í•¨ìˆ˜ ì¶”ê°€, `{@html}` í˜¸ì¶œë¡œ êµì²´, `.sort-icon` â†’ `:global(.sort-icon)` |"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":102,"cache_read_input_tokens":104159,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":102},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPTS2bEtLg5q2LGtFDy","type":"assistant","uuid":"9ee1bc06-b4d1-46f0-9a8e-aa7ff23f788a","timestamp":"2026-02-21T14:40:41.798Z"}
{"parentUuid":"9ee1bc06-b4d1-46f0-9a8e-aa7ff23f788a","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"entire hooks claude-code stop"},"parentToolUseID":"729a6728-1eac-437f-a8ad-acdf40e7e5b6","toolUseID":"729a6728-1eac-437f-a8ad-acdf40e7e5b6","timestamp":"2026-02-21T14:40:41.849Z","uuid":"3ec63049-e0f7-404e-a5de-1190546fa3cc"}
{"type":"queue-operation","operation":"remove","timestamp":"2026-02-21T14:40:43.635Z","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8"}
{"parentUuid":"3ec63049-e0f7-404e-a5de-1190546fa3cc","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"system","subtype":"stop_hook_summary","hookCount":1,"hookInfos":[{"command":"entire hooks claude-code stop","durationMs":1766}],"hookErrors":[],"preventedContinuation":false,"stopReason":"","hasOutput":true,"level":"suggestion","timestamp":"2026-02-21T14:40:43.616Z","uuid":"b3f90500-f187-4d8d-9ff3-98c76c9c0451","toolUseID":"729a6728-1eac-437f-a8ad-acdf40e7e5b6"}
{"parentUuid":"b3f90500-f187-4d8d-9ff3-98c76c9c0451","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"system","subtype":"turn_duration","durationMs":250485,"timestamp":"2026-02-21T14:40:43.617Z","uuid":"c4325764-3c3c-4eea-850b-3d474288ea96","isMeta":false}
{"type":"file-history-snapshot","messageId":"bd5ba824-e5d8-4205-abfb-4b9d5affe05c","snapshot":{"messageId":"bd5ba824-e5d8-4205-abfb-4b9d5affe05c","trackedFileBackups":{"src/App.svelte":{"backupFileName":"f2ffc3f5647f6015@v2","version":2,"backupTime":"2026-02-21T14:44:27.392Z"}},"timestamp":"2026-02-21T14:44:27.391Z"},"isSnapshotUpdate":false}
{"parentUuid":"c4325764-3c3c-4eea-850b-3d474288ea96","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":"renameì´ ìž…ë ¥ì°½ì´ ëœ¨ëŠ”ë° ê¸°ì¡´ nameê³¼ ìœ„ì¹˜ê°€ ì•ˆë§žì•„."},"uuid":"bd5ba824-e5d8-4205-abfb-4b9d5affe05c","timestamp":"2026-02-21T14:44:25.129Z","permissionMode":"bypassPermissions"}
{"parentUuid":"bd5ba824-e5d8-4205-abfb-4b9d5affe05c","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01PjxNPzpUvbdPWzruEXzt7T","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user is saying that the rename input overlay position doesn't align with the original name text. Let me look at the rename overlay position calculation code and the CSS to understand the issue.\n\nLet me read the relevant parts of the code.","signature":"EpsDCkYICxgCKkDSska1W3ZPJSLXgbVui2TVWX8pInzI2eOvaXst20k5056ZNGOOKF4ztJb5cdBvMcWWOIOJ7PiICJMiiJplC0DaEgxQYPaR9yMU9P0ONdcaDG+piwDc/1HkN0xfjiIwxgnXha4ybNEkT6THkKYyeFQ92AgMmqDf4EDr9d1K920ftIbbb9X0O+o63niKi4GEKoICL+n8l1PNi9nfpS8VtlwW/xyE/29SOmkYtYE/hAKzWPFc5oU4pV/mYl2OuSqmtg2d+2cLaKQGOhoXUw7NVnfDZXF+/pzwlmeZ893uwwiV7HEH2Aum7WZt4lCaZk2lGKv7C+1qMK9d1SD3WFgup/W1WRlD3RA/r6V+3wWoefvZczqNLHLb1mcwcqgDUCWP4aHt1oS8ch6pWVZ9ItveoCnvkCFmRH91up838xGFF2b1D5LOkVhsenguUrm2n0ZzS2/u4Qe6+CdKo8rmTWCMghK1r7LWlCc/RHWTFEW+wFrXEM6U2ucUqzCnJtPSA2hcG26y3qtkcAetR7ugufQNgNugkB6HGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":415,"cache_read_input_tokens":104574,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":415},"output_tokens":0,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPkgqoJQRvbDtr9j6Ep","type":"assistant","uuid":"9b38bce2-fc39-45cb-9882-80377ae247d2","timestamp":"2026-02-21T14:44:30.495Z"}
{"parentUuid":"9b38bce2-fc39-45cb-9882-80377ae247d2","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01PjxNPzpUvbdPWzruEXzt7T","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PqEYJzkK1MonBeL8o1sSVZ","name":"Read","input":{"file_path":"/Users/al02402336/everything/src/App.svelte","offset":953,"limit":40},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":415,"cache_read_input_tokens":104574,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":415},"output_tokens":0,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPkgqoJQRvbDtr9j6Ep","type":"assistant","uuid":"6e80a84c-89db-495d-904c-c156246e9c46","timestamp":"2026-02-21T14:44:31.188Z"}
{"parentUuid":"6e80a84c-89db-495d-904c-c156246e9c46","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01PqEYJzkK1MonBeL8o1sSVZ","toolUseID":"toolu_01PqEYJzkK1MonBeL8o1sSVZ","timestamp":"2026-02-21T14:44:31.200Z","uuid":"3dfe713a-1ecb-4e19-a356-267cf36ece82"}
{"parentUuid":"6e80a84c-89db-495d-904c-c156246e9c46","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PqEYJzkK1MonBeL8o1sSVZ","type":"tool_result","content":"   953â†’    const idx = lastSelectedIndex;\n   954â†’    if (idx < 0 || !results[idx]) {\n   955â†’      return;\n   956â†’    }\n   957â†’\n   958â†’    const entry = results[idx];\n   959â†’\n   960â†’    // Calculate overlay position mathematically.\n   961â†’    // Name cell text starts at: padding-left(16) + icon(16) + gap(6) = 38px from cell left.\n   962â†’    // Textarea has padding-left: 0 and border: 1.5px, so text starts ~2px from overlay left.\n   963â†’    if (tableContainer) {\n   964â†’      const rect = tableContainer.getBoundingClientRect();\n   965â†’      const cellLeft = rect.left - tableContainer.scrollLeft;\n   966â†’      const textLeft = cellLeft + 38;\n   967â†’      const cellRight = cellLeft + colWidths.name;\n   968â†’      const rowTop = rect.top + idx * rowHeight - tableContainer.scrollTop;\n   969â†’      renameOverlay = {\n   970â†’        top: rowTop,\n   971â†’        left: textLeft - 2,\n   972â†’        width: cellRight - textLeft + 2 - 4\n   973â†’      };\n   974â†’    }\n   975â†’\n   976â†’    editing = {\n   977â†’      active: true,\n   978â†’      path: entry.path,\n   979â†’      index: idx,\n   980â†’      draftName: entry.name\n   981â†’    };\n   982â†’\n   983â†’    await tick();\n   984â†’\n   985â†’    if (renameInputEl) {\n   986â†’      autoResizeRenameInput();\n   987â†’      renameInputEl.focus();\n   988â†’      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n   989â†’      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n   990â†’      renameInputEl.setSelectionRange(0, selectionEnd);\n   991â†’    }\n   992â†’  }\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"64a0de9b-0ad5-4439-ab98-5aa15795cd07","timestamp":"2026-02-21T14:44:31.199Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src/App.svelte","content":"    const idx = lastSelectedIndex;\n    if (idx < 0 || !results[idx]) {\n      return;\n    }\n\n    const entry = results[idx];\n\n    // Calculate overlay position mathematically.\n    // Name cell text starts at: padding-left(16) + icon(16) + gap(6) = 38px from cell left.\n    // Textarea has padding-left: 0 and border: 1.5px, so text starts ~2px from overlay left.\n    if (tableContainer) {\n      const rect = tableContainer.getBoundingClientRect();\n      const cellLeft = rect.left - tableContainer.scrollLeft;\n      const textLeft = cellLeft + 38;\n      const cellRight = cellLeft + colWidths.name;\n      const rowTop = rect.top + idx * rowHeight - tableContainer.scrollTop;\n      renameOverlay = {\n        top: rowTop,\n        left: textLeft - 2,\n        width: cellRight - textLeft + 2 - 4\n      };\n    }\n\n    editing = {\n      active: true,\n      path: entry.path,\n      index: idx,\n      draftName: entry.name\n    };\n\n    await tick();\n\n    if (renameInputEl) {\n      autoResizeRenameInput();\n      renameInputEl.focus();\n      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n      renameInputEl.setSelectionRange(0, selectionEnd);\n    }\n  }","numLines":40,"startLine":953,"totalLines":2275}},"sourceToolAssistantUUID":"6e80a84c-89db-495d-904c-c156246e9c46"}
{"parentUuid":"64a0de9b-0ad5-4439-ab98-5aa15795cd07","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_015RHMbLXNsd79FfAgHxp2dm","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Dk3xgiZxHh7w377Yw3NWz5","name":"Read","input":{"file_path":"/Users/al02402336/everything/src/App.svelte","offset":2095,"limit":30},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":774,"cache_read_input_tokens":104989,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":774},"output_tokens":18,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPkyBJvcEQTw5Dnus2N","type":"assistant","uuid":"7d98dfbe-4c65-4a44-88a1-5388e2dea0b9","timestamp":"2026-02-21T14:44:33.528Z"}
{"parentUuid":"7d98dfbe-4c65-4a44-88a1-5388e2dea0b9","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01Dk3xgiZxHh7w377Yw3NWz5","toolUseID":"toolu_01Dk3xgiZxHh7w377Yw3NWz5","timestamp":"2026-02-21T14:44:33.536Z","uuid":"e14a7232-5b24-4674-88b9-8259dddf10f7"}
{"parentUuid":"7d98dfbe-4c65-4a44-88a1-5388e2dea0b9","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Dk3xgiZxHh7w377Yw3NWz5","type":"tool_result","content":"  2095â†’\n  2096â†’  .name-editing {\n  2097â†’    opacity: 0.25;\n  2098â†’  }\n  2099â†’\n  2100â†’  .rename-overlay {\n  2101â†’    position: fixed;\n  2102â†’    z-index: 100;\n  2103â†’    min-width: 120px;\n  2104â†’  }\n  2105â†’\n  2106â†’  .rename-textarea {\n  2107â†’    display: block;\n  2108â†’    width: 100%;\n  2109â†’    box-sizing: border-box;\n  2110â†’    font-family: Inter, 'SF Pro Text', sans-serif;\n  2111â†’    font-size: 12px;\n  2112â†’    line-height: 18px;\n  2113â†’    padding: 5px 4px 5px 0;\n  2114â†’    border: 1.5px solid var(--focus-ring);\n  2115â†’    border-radius: 4px;\n  2116â†’    background: var(--bg-input, var(--surface));\n  2117â†’    color: var(--text-primary);\n  2118â†’    outline: none;\n  2119â†’    resize: none;\n  2120â†’    overflow: hidden;\n  2121â†’    box-shadow: 0 2px 14px rgba(0, 0, 0, 0.22), 0 0 0 3px rgba(77, 168, 255, 0.13);\n  2122â†’  }\n  2123â†’\n  2124â†’  .status-bar {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"d98f6b6b-4227-441a-a841-7287192d17e8","timestamp":"2026-02-21T14:44:33.535Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src/App.svelte","content":"\n  .name-editing {\n    opacity: 0.25;\n  }\n\n  .rename-overlay {\n    position: fixed;\n    z-index: 100;\n    min-width: 120px;\n  }\n\n  .rename-textarea {\n    display: block;\n    width: 100%;\n    box-sizing: border-box;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 12px;\n    line-height: 18px;\n    padding: 5px 4px 5px 0;\n    border: 1.5px solid var(--focus-ring);\n    border-radius: 4px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    outline: none;\n    resize: none;\n    overflow: hidden;\n    box-shadow: 0 2px 14px rgba(0, 0, 0, 0.22), 0 0 0 3px rgba(77, 168, 255, 0.13);\n  }\n\n  .status-bar {","numLines":30,"startLine":2095,"totalLines":2275}},"sourceToolAssistantUUID":"7d98dfbe-4c65-4a44-88a1-5388e2dea0b9"}
{"parentUuid":"d98f6b6b-4227-441a-a841-7287192d17e8","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01Bsoa2MNm2vY41SDSYNT9QS","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The issue is about the rename overlay position not aligning with the original name text.\n\nLet me analyze the position calculation:\n\n```js\nconst rect = tableContainer.getBoundingClientRect();\nconst cellLeft = rect.left - tableContainer.scrollLeft;\nconst textLeft = cellLeft + 38;\nconst cellRight = cellLeft + colWidths.name;\nconst rowTop = rect.top + idx * rowHeight - tableContainer.scrollTop;\nrenameOverlay = {\n  top: rowTop,\n  left: textLeft - 2,\n  width: cellRight - textLeft + 2 - 4\n};\n\n\n```\n\nThe calculation assumes the text starts 38px from the cell left (16px padding + 16px icon + 6px gap), but I need to verify this against the actual CSS. Looking at the cell styling, I see the padding-left is set to 16px, but I need to check what the full cell padding structure is to confirm the 38px offset is correct.\n\n```\nWriting component styles...\n```\n\nWait, I need to switch to prose since we're moving away from code. Let me reconsider the positioning: the table body container's left edge in the viewport minus the scroll offset gives me the cell's left position, and from there the text starts 38 pixels over due to padding, icon width, and gap. The textarea overlay needs to account for its own border and padding to align the text cursor properly, which is why there's a 2-pixel offset adjustment.\n\nBut the user is reporting visual misalignment, so I should look at other factorsâ€”particularly how the row's vertical position is calculated using the selected index, row height, and scroll offset.\n\nThe real issue might be that the overlay is positioned at the top of the row, but the text inside is vertically centered. The textarea has padding and line-height that need to account for this centering offset, otherwise it'll sit too high compared to the actual text baseline. px` from the overlay top, so the text center is at `overlayTop + 6.5 + 9 = overlayTop + 15.5px`. For these to align, I need `overlayTop + 15.5 = rowTop + 15`, which means `overlayTop = rowTop - 0.5px`. That's the adjustment needed to make the textarea text vertically centered with the original row text.\n\nWith `top: rowTop`, there's only a 0.5px vertical offset, so the misalignment the user is seeing is likely coming from the horizontal positioning instead. Let me work through the horizontal calculation now.\n\nThe tableContainer's `getBoundingClientRect().left` gives its viewport position, and subtracting `scrollLeft` should give me the correct cell position in viewport coordinates. When there's no horizontal scroll, the cell's viewport left equals `rect.left`, but as `scrollLeft` increases, the calculation becomes `rect.left - scrollLeft`. This logic seems sound, but I'm realizing the calculation might be incomplete or there's something I'm missing about how the scroll offset applies. Left = rect.left`, and the first column is correctly positioned at the container's left edge.\n\nNow I'm considering what else might be causing the misalignment. The new title bar adds 44px to the top, which changes the grid layout, but `getBoundingClientRect()` should already account for that since it returns viewport coordinates. The `.table-body` CSS might have padding or borders I'm not accounting for...\n\nChecking the styles...\n\nNo padding or borders on the table body, so `rect.left` is exactly where the content starts. The themed mode applies 16px padding-left to the name cell, which combines with the 16px icon width and 6px gap to reach 38px total. Since `data-theme` is always set on the app shell, that's not the issue either.\n\nLet me step back and measure this directly from the DOM instead of relying on calculations. I'll find the actual row element and get the precise position of the text within itâ€”that's more reliable than trying to match every CSS rule mathematically. Looking at the template structure, each row has a name cell containing an icon and a text span, so I can query the DOM to find the exact coordinates. I need to reconsider how positioning works with the virtual scroll setup. The `.rows` container is transformed by the start index offset, and it sits inside a spacer that's the full height. When I calculate the viewport position of a row, I need to account for the transform on `.rows` and where the spacer itself sits relative to the scrollable viewport.\n\nLet me verify the formula: if the table container's bounding rect gives me its viewport top, and I add the row's index times row height, then subtract the scroll offset, I should get the correct viewport Y position. That checks out mathematically. But now I'm wondering if `getBoundingClientRect()` is actually giving me what I expect in this scrolling context.\n\nThe table structure has a grid with the header taking up 32px and the body filling the rest, so the body's rect.top should correctly point to where the content starts. The real question is whether the user's misalignment is horizontal or verticalâ€”they mentioned the overlay doesn't match the name text, which could be either a column offset or a row offset issue.\n\nLooking at the horizontal positioning more carefully: the `.cell.name` element is the entire grid cell itself, so its left edge should align with x=0 within that column, and the padding-left of 8px (or 16px with theming) is applied inside that cell. The calculation `cellLeft = rect.left - tableContainer.scrollLeft` should give the correct viewport position, but I need to verify whether the overlay is actually accounting for the cell's padding when positioning the text. I need to verify my coordinate calculations are actually correct by measuring the span element's position directly rather than continuing to reason through the math. I need to verify the math hereâ€”`startIndex` is computed reactively based on scroll position, so `visibleIndex = idx - startIndex` correctly maps the item's position in the full results array to its position in the rendered rows. Since the `.rows` div renders a slice of results from `startIndex` to `endIndex`, the element at `rowEls[visibleIndex]` should correspond to the right item. This DOM-based approach is definitely more reliable than calculating positions mathematically, so let me go with this implementation.\n\nNow I'm checking the positioning calculation for the textarea overlay. The `rowTop` is computed as the row's bounding rect top plus the offset from scroll, which gives viewport coordinates. The text in the cell is centered vertically around `rowTop + 15` (half of the 30px row height), and the textarea's text center should land at roughly the same spot accounting for padding and line height. But there might be something I'm overlookingâ€”maybe the title bar or some other container offset is throwing things off. Let me trace through what `getBoundingClientRect().top` actually returns for the table container. 0 - 0 = rect.top). âœ“\n\nI think the math checks out, so let me switch to using DOM measurement instead since that's more reliable than trying to trace through all these calculations. When I work through the positioning more carefullyâ€”with the absolutely positioned rows and the transform appliedâ€”the viewport coordinates should work out correctly, but measuring directly from the DOM will be clearer.\n\nLooking at the CSS for the table container and body, there's no border or padding that would throw off the measurements. Let me dig into whether something else is causing the offset issue.\n\nActually, I'm wondering if the problem is that we're measuring the `tableContainer` before the overlay is even rendered. We calculate the position and set `renameOverlay`, but we don't call `await tick()` until after we've already set `editing.active = true`. Since the table layout shouldn't change when the editing state flips, this should be fineâ€”but let me trace through the exact sequence to be sure. During the flush, the rename overlay div gets created with the correct computed position values, and the input binding is established. But I'm realizing the actual issue might be in the CSSâ€”the `.cell.name` element has different padding values depending on the theme, and those padding differences could be throwing off the position calculation when the overlay tries to align with the cell.\n\nLet me trace through the layout structure more carefully. The `.app-shell` uses a grid layout with no padding, and `.table-area` is also a grid with no extra spacing. The `.table-header` has `overflow: hidden` which clips content, while the table body scrolls independently. I'm wondering if there's some hidden padding or margin in the parent containers that's affecting where the overlay actually renders relative to where I calculated it should be.\n\nActually, I'm realizing there might be a mismatch between the virtual scroll buffer and the actual rendered position. When I calculate `rowTop` using the scroll offset, I'm assuming the rendered row's position matches the calculation, but the virtual scroller might be rendering rows with a buffer that shifts where they actually appear on screen.\n\nLet me try a different approachâ€”instead of relying on math, I'll measure the actual DOM position of the span element directly after it's rendered.\n\nWriting the rename function... I'm realizing the timing issue hereâ€”if I set `editing.active = true` first, the overlay div renders immediately at position 0,0 before I can measure the span, which would cause a visible flicker as it jumps to the correct position. I need to measure the span and set `renameOverlay` before the overlay becomes visible, but the span won't exist in the DOM until after a tick.\n\nLet me step back and look at what the user is actually reporting. They say the position is wrong, and while my math seems sound, there's clearly a practical mismatch happening. I'm noticing the CSS comment mentions `padding-left: 16px`, but the base `.cell` styling only has `padding: 0 8px`. The 16px padding only applies when `data-theme` is set, which should always be true, but let me verify this is actually the source of the discrepancy.\n\nActually, I think I've been looking at this wrong. The real issue might be with the vertical positioningâ€”the `rowTop` calculation positions the overlay at the top of the row div, but the textarea itself has a 1.5px border and 5px padding on top, which means the actual text baseline is offset from where I'm placing the overlay.\n\nLet me reconsider the horizontal alignment instead. The textarea has `padding-left: 0`, so the text should start right at the border edge, but maybe there's something else shifting it left or right that I'm missing.\n\nActually, I think I need to step back from all these pixel calculationsâ€”they're getting too speculative. The better approach is to measure the actual DOM elements directly, which would eliminate all this uncertainty about borders and padding. The tricky part is that I need to position the overlay before making the span invisible, so I can't just measure the span's position after the fact.\n\nBut I can measure the row itself since it's already rendered in the DOM. I'll query for the specific row based on its visible index, find the name cell within it, and use its bounding rectangle to position the overlay accurately.\n\nMeasuring the cell's position... I'm realizing the span element is already in the DOM before editing starts, so I can measure it directly by querying the row and finding the ellipsis span, then use its bounding rectangle to position the overlay instead of calculating padding and offsets manually.\n\nRefining the positioning logic... Refining the overlay positioning logic... Still writing the rename function... Calculating text alignment offsets...\n\nThe span's text center sits around `spanRect.top + 7-8px`, while the textarea's text center is at `spanRect.top + 15.5px` â€” that's roughly a 7-8px vertical gap. I need to adjust the overlay position so these centers align by accounting for the textarea's border, padding, and line height. .top - 8. The overlay would be 8px above the span.\n\nWith the textarea's padding and line-height, it ends up being about 31px tall, positioned 8px above the span, which means it extends 8px past the span's bottom. So visually it covers the row and bleeds into the next one. But actually, the input doesn't need to match the span's dimensions exactlyâ€”what matters is that the text aligns properly.\n\nLet me think about this differently: I want the text inside the rename input to sit at the same vertical position as the filename text in the row. The simplest approach is to position the overlay at the row's top and let the textarea fill the row height, then adjust the padding so the text centers within the 30px row.\n\nWith the textarea having 1.5px borders top and bottom, 5px padding top and bottom, and an 18px line-height, the inner content is 28px tall and the total outer height is 31px. To center this 31px element in a 30px row, I'd need a -0.5px offset, but positioning at the row's top essentially achieves the same visual alignment.\n\nNow I'm wondering if the real issue is with how `startIndex` is being calculated...\n\nComputing `startIndex` reactively based on `scrollTop` and `rowHeight` should work correctly since Svelte updates reactive declarations synchronously when dependencies change. The scroll event handler updates `scrollTop`, which triggers `startIndex` to recalculate. But when `startRename` fires in response to keyboard or context menu input, I need to verify that `startIndex` reflects the current scroll position at that exact moment, not a stale value from an earlier state.\n\nI'm going to abandon the mathematical approach and just measure the DOM directly, which is unambiguous. I'll grab the visible row element using the calculated `visibleIndex`, then measure the span's bounding rect to get its exact position and dimensions.\n\nMeasuring DOM elements... Calculating textarea positioning...\n\nThe core issue is that the textarea's padding and border offset the text position by about 6.5px from the top edge, so I need to subtract that offset from `spanRect.top` to align the visible text with the original span. Alternatively, I could use `rowTop` as the reference point and account for the vertical centering within the row height.\n\nFor horizontal alignment, I'm working through the left edge positioningâ€”the textarea's border and padding shift the text position, so I need to factor in those offsets when positioning relative to `spanRect.left`.\n\nBut stepping back, I'm wondering if the actual problem is something simpler. The user's complaint is that the rename input doesn't align with the original name position. Let me trace through a concrete example with actual numbers to see where the misalignment might really be happening. Now I'm verifying the actual positioning by tracing through the DOM structureâ€”the cell has left padding, then the icon, then a gap, and finally the text span starts at x=38. The overlay's textarea is positioned at left=36 with a 1.5px border, so the text inside sits at 37.5px, which is just half a pixel off from where the actual text begins.\n\nFor the vertical alignment, the row spans from 210 to 240 with flexbox centering, and the span itself is about 16px tall, so it should be centered around y=217. But when I add the overlay's padding and border, the text ends up starting at 223.5 instead, creating a 6px gap between where the overlay thinks the text should be and where it actually is.\n\nThe mathematical approach of just using the row's top (210) gets me closerâ€”the overlay text would be at 216.5, only 0.5px off from the actual 217. The DOM measurement approach of using the span's bounding rect (217) overshoots significantly because it doesn't account for the overlay's own padding and border offset.\n\nSo the math checks out. The real issue must be something elseâ€”maybe the table container's actual position in the window, or how the grid layout is affecting the coordinates. Let me trace through the actual layout structure to see where the misalignment is really coming from. Looking at the recent commits, there's definitely an overlay title bar enabled in this Tauri v2 setup. The custom `.title-bar` div serves as the draggable region while the native decorations are hidden, so the WebView content actually starts at y=0 without any additional offset from Tauri's side.\n\nSince I can't pinpoint the issue through static code analysis, I'm going to measure the DOM directlyâ€”grabbing the row element to get its top position and the span within it to get the left position, then using those coordinates to position the popup accurately.\n\nGetting DOM measurements... I realize the issueâ€”`rowRect.right` extends too far since the row can be wider than the NAME column. I should target the name cell's right edge instead to properly constrain the overlay width.\n\nCalculating overlay dimensions... I'm checking for an edge case where the selected row might not be visibleâ€”if that happens, `visibleIndex` would be negative and the overlay would just stay at its default position, which isn't ideal but won't crash. It's probably not worth adding extra fallback logic for this unlikely scenario, so I'll move forward with the implementation.","signature":"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"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":591,"cache_read_input_tokens":105763,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":591},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPm9JWaDmFS8D2miyeX","type":"assistant","uuid":"9c1742e2-3878-44ee-91aa-b9e04517e0ad","timestamp":"2026-02-21T14:48:26.639Z"}
{"parentUuid":"9c1742e2-3878-44ee-91aa-b9e04517e0ad","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01Bsoa2MNm2vY41SDSYNT9QS","type":"message","role":"assistant","content":[{"type":"text","text":"ìˆ˜í•™ì  ê³„ì‚° ëŒ€ì‹  ì‹¤ì œ DOM ìš”ì†Œì˜ ìœ„ì¹˜ë¥¼ ì¸¡ì •í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ìˆ˜ì •í•©ë‹ˆë‹¤. í™”ë©´ì— ë Œë”ë§ëœ span/ì…€ì˜ `getBoundingClientRect()`ë¥¼ ì§ì ‘ ì½ìœ¼ë©´ padding, gap ë“±ì˜ ìˆ˜ì¹˜ë¥¼ ì§ì ‘ ë§žì¶œ í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":591,"cache_read_input_tokens":105763,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":591},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPm9JWaDmFS8D2miyeX","type":"assistant","uuid":"978f5274-d685-4519-83af-a0a74552b33b","timestamp":"2026-02-21T14:48:27.180Z"}
{"parentUuid":"978f5274-d685-4519-83af-a0a74552b33b","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01Bsoa2MNm2vY41SDSYNT9QS","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01194qhjfWc1DFP4FALeqQRu","name":"Read","input":{"file_path":"/Users/al02402336/everything/src/App.svelte","offset":956,"limit":20},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":591,"cache_read_input_tokens":105763,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":591},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMPm9JWaDmFS8D2miyeX","type":"assistant","uuid":"52c4c123-462a-4a94-9914-39ce5be25258","timestamp":"2026-02-21T14:48:28.596Z"}
{"parentUuid":"52c4c123-462a-4a94-9914-39ce5be25258","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01194qhjfWc1DFP4FALeqQRu","toolUseID":"toolu_01194qhjfWc1DFP4FALeqQRu","timestamp":"2026-02-21T14:48:28.624Z","uuid":"09e79220-d855-4922-b0bf-f8776bbb0b2e"}
{"parentUuid":"52c4c123-462a-4a94-9914-39ce5be25258","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01194qhjfWc1DFP4FALeqQRu","type":"tool_result","content":"   956â†’      await invoke('move_to_trash', { paths });\n   957â†’      showToast('Moved to Trash.');\n   958â†’      clearSelection();\n   959â†’      await runSearch();\n   960â†’    } catch (err) {\n   961â†’      showToast(`Failed to move to Trash: ${String(err)}`);\n   962â†’    }\n   963â†’  }\n   964â†’\n   965â†’  async function resetIndex() {\n   966â†’    if (indexStatus.state === 'Indexing') {\n   967â†’      showToast('Indexing in progress. Please try again after it completes.');\n   968â†’      return;\n   969â†’    }\n   970â†’\n   971â†’    results = [];\n   972â†’    totalResults = 0;\n   973â†’    totalResultsKnown = false;\n   974â†’    clearSelection();\n   975â†’    scanned = 0;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"8c5af22c-0aa0-4177-a6e6-b697bef000a4","timestamp":"2026-02-21T14:48:28.623Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src/App.svelte","content":"      await invoke('move_to_trash', { paths });\n      showToast('Moved to Trash.');\n      clearSelection();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to move to Trash: ${String(err)}`);\n    }\n  }\n\n  async function resetIndex() {\n    if (indexStatus.state === 'Indexing') {\n      showToast('Indexing in progress. Please try again after it completes.');\n      return;\n    }\n\n    results = [];\n    totalResults = 0;\n    totalResultsKnown = false;\n    clearSelection();\n    scanned = 0;","numLines":20,"startLine":956,"totalLines":2506}},"sourceToolAssistantUUID":"52c4c123-462a-4a94-9914-39ce5be25258"}
{"parentUuid":"8c5af22c-0aa0-4177-a6e6-b697bef000a4","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01UxgUNJ6mu31hkBK3dTy4gW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TvWKXLgU2zmafkbdBrUJiJ","name":"Grep","input":{"pattern":"async function startRename","path":"/Users/al02402336/everything/src/App.svelte","output_mode":"content","-n":true},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":14720,"cache_read_input_tokens":106354,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":14720},"output_tokens":26,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMQ4UgZKioZjQWhpiBDC","type":"assistant","uuid":"4225a0e0-b332-4b71-8fec-95afd6f84771","timestamp":"2026-02-21T14:48:32.614Z"}
{"parentUuid":"4225a0e0-b332-4b71-8fec-95afd6f84771","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Grep","command":"callback"},"parentToolUseID":"toolu_01TvWKXLgU2zmafkbdBrUJiJ","toolUseID":"toolu_01TvWKXLgU2zmafkbdBrUJiJ","timestamp":"2026-02-21T14:48:33.286Z","uuid":"dd8e48f0-a70f-4e4d-9ac9-a98f1c5d97fd"}
{"parentUuid":"4225a0e0-b332-4b71-8fec-95afd6f84771","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TvWKXLgU2zmafkbdBrUJiJ","type":"tool_result","content":"1004:  async function startRename() {"}]},"uuid":"4fb42ece-14b3-44d1-9f33-3e3c8fc2d8c5","timestamp":"2026-02-21T14:48:33.285Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"1004:  async function startRename() {","numLines":1},"sourceToolAssistantUUID":"4225a0e0-b332-4b71-8fec-95afd6f84771"}
{"parentUuid":"4fb42ece-14b3-44d1-9f33-3e3c8fc2d8c5","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01EDH6ZsT6D9yJMyYYwSofnG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MXrBMQTD3zeZS4Yrb1uqeP","name":"Read","input":{"file_path":"/Users/al02402336/everything/src/App.svelte","offset":1004,"limit":50},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":148,"cache_read_input_tokens":121074,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":148},"output_tokens":18,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMQ4pVfm6BJLM9GHir9V","type":"assistant","uuid":"3b0f6af2-801d-46c7-9865-d1bc015bac0e","timestamp":"2026-02-21T14:48:35.729Z"}
{"parentUuid":"3b0f6af2-801d-46c7-9865-d1bc015bac0e","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01MXrBMQTD3zeZS4Yrb1uqeP","toolUseID":"toolu_01MXrBMQTD3zeZS4Yrb1uqeP","timestamp":"2026-02-21T14:48:35.742Z","uuid":"e8905ea1-f3ab-4362-a0e9-b80407527e41"}
{"parentUuid":"3b0f6af2-801d-46c7-9865-d1bc015bac0e","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MXrBMQTD3zeZS4Yrb1uqeP","type":"tool_result","content":"  1004â†’  async function startRename() {\n  1005â†’    if (isMultiSelected()) {\n  1006â†’      return;\n  1007â†’    }\n  1008â†’\n  1009â†’    const idx = lastSelectedIndex;\n  1010â†’    if (idx < 0 || !results[idx]) {\n  1011â†’      return;\n  1012â†’    }\n  1013â†’\n  1014â†’    const entry = results[idx];\n  1015â†’\n  1016â†’    // Calculate overlay position mathematically.\n  1017â†’    // Name cell text starts at: padding-left(16) + icon(16) + gap(6) = 38px from cell left.\n  1018â†’    // Textarea has padding-left: 0 and border: 1.5px, so text starts ~2px from overlay left.\n  1019â†’    if (tableContainer) {\n  1020â†’      const rect = tableContainer.getBoundingClientRect();\n  1021â†’      const cellLeft = rect.left - tableContainer.scrollLeft;\n  1022â†’      const textLeft = cellLeft + 38;\n  1023â†’      const cellRight = cellLeft + colWidths.name;\n  1024â†’      const rowTop = rect.top + idx * rowHeight - tableContainer.scrollTop;\n  1025â†’      renameOverlay = {\n  1026â†’        top: rowTop,\n  1027â†’        left: textLeft - 2,\n  1028â†’        width: cellRight - textLeft + 2 - 4\n  1029â†’      };\n  1030â†’    }\n  1031â†’\n  1032â†’    editing = {\n  1033â†’      active: true,\n  1034â†’      path: entry.path,\n  1035â†’      index: idx,\n  1036â†’      draftName: entry.name\n  1037â†’    };\n  1038â†’\n  1039â†’    await tick();\n  1040â†’\n  1041â†’    if (renameInputEl) {\n  1042â†’      autoResizeRenameInput();\n  1043â†’      renameInputEl.focus();\n  1044â†’      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n  1045â†’      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n  1046â†’      renameInputEl.setSelectionRange(0, selectionEnd);\n  1047â†’    }\n  1048â†’  }\n  1049â†’\n  1050â†’  function cancelRename() {\n  1051â†’    editing = {\n  1052â†’      active: false,\n  1053â†’      path: '',\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"b44dc735-16bd-43bd-894b-560e4d86634f","timestamp":"2026-02-21T14:48:35.740Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src/App.svelte","content":"  async function startRename() {\n    if (isMultiSelected()) {\n      return;\n    }\n\n    const idx = lastSelectedIndex;\n    if (idx < 0 || !results[idx]) {\n      return;\n    }\n\n    const entry = results[idx];\n\n    // Calculate overlay position mathematically.\n    // Name cell text starts at: padding-left(16) + icon(16) + gap(6) = 38px from cell left.\n    // Textarea has padding-left: 0 and border: 1.5px, so text starts ~2px from overlay left.\n    if (tableContainer) {\n      const rect = tableContainer.getBoundingClientRect();\n      const cellLeft = rect.left - tableContainer.scrollLeft;\n      const textLeft = cellLeft + 38;\n      const cellRight = cellLeft + colWidths.name;\n      const rowTop = rect.top + idx * rowHeight - tableContainer.scrollTop;\n      renameOverlay = {\n        top: rowTop,\n        left: textLeft - 2,\n        width: cellRight - textLeft + 2 - 4\n      };\n    }\n\n    editing = {\n      active: true,\n      path: entry.path,\n      index: idx,\n      draftName: entry.name\n    };\n\n    await tick();\n\n    if (renameInputEl) {\n      autoResizeRenameInput();\n      renameInputEl.focus();\n      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n      renameInputEl.setSelectionRange(0, selectionEnd);\n    }\n  }\n\n  function cancelRename() {\n    editing = {\n      active: false,\n      path: '',","numLines":50,"startLine":1004,"totalLines":2506}},"sourceToolAssistantUUID":"3b0f6af2-801d-46c7-9865-d1bc015bac0e"}
{"parentUuid":"b44dc735-16bd-43bd-894b-560e4d86634f","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01MZri868cQPbqmwiGnvhgJx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014uzLxno3yKcDk7fPpLmFTB","name":"Edit","input":{"replace_all":false,"file_path":"/Users/al02402336/everything/src/App.svelte","old_string":"    const entry = results[idx];\n\n    // Calculate overlay position mathematically.\n    // Name cell text starts at: padding-left(16) + icon(16) + gap(6) = 38px from cell left.\n    // Textarea has padding-left: 0 and border: 1.5px, so text starts ~2px from overlay left.\n    if (tableContainer) {\n      const rect = tableContainer.getBoundingClientRect();\n      const cellLeft = rect.left - tableContainer.scrollLeft;\n      const textLeft = cellLeft + 38;\n      const cellRight = cellLeft + colWidths.name;\n      const rowTop = rect.top + idx * rowHeight - tableContainer.scrollTop;\n      renameOverlay = {\n        top: rowTop,\n        left: textLeft - 2,\n        width: cellRight - textLeft + 2 - 4\n      };\n    }","new_string":"    const entry = results[idx];\n\n    // Measure overlay position from the actual rendered DOM elements.\n    const visibleIndex = idx - startIndex;\n    const rowEl = tableContainer?.querySelectorAll('.row')?.[visibleIndex];\n    const nameCell = rowEl?.querySelector('.cell.name');\n    const span = nameCell?.querySelector('.ellipsis');\n    if (rowEl && nameCell && span) {\n      const rowRect = rowEl.getBoundingClientRect();\n      const spanRect = span.getBoundingClientRect();\n      const nameCellRect = nameCell.getBoundingClientRect();\n      renameOverlay = {\n        top: rowRect.top,\n        left: spanRect.left - 2,\n        width: nameCellRect.right - spanRect.left - 2 - 8\n      };\n    }"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":842,"cache_read_input_tokens":121222,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":842},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMQ4zp322f1R4w6UqoET","type":"assistant","uuid":"2618c459-223c-4b08-9bc1-7f176b986393","timestamp":"2026-02-21T14:48:41.853Z"}
{"parentUuid":"2618c459-223c-4b08-9bc1-7f176b986393","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_014uzLxno3yKcDk7fPpLmFTB","toolUseID":"toolu_014uzLxno3yKcDk7fPpLmFTB","timestamp":"2026-02-21T14:48:41.863Z","uuid":"de73de9a-63ef-4afe-ad51-ebd9630c00aa"}
{"parentUuid":"2618c459-223c-4b08-9bc1-7f176b986393","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014uzLxno3yKcDk7fPpLmFTB","type":"tool_result","content":"The file /Users/al02402336/everything/src/App.svelte has been updated successfully."}]},"uuid":"67d0690a-2685-44c4-bfd2-2903c02d5ffe","timestamp":"2026-02-21T14:48:41.862Z","toolUseResult":{"filePath":"/Users/al02402336/everything/src/App.svelte","oldString":"    const entry = results[idx];\n\n    // Calculate overlay position mathematically.\n    // Name cell text starts at: padding-left(16) + icon(16) + gap(6) = 38px from cell left.\n    // Textarea has padding-left: 0 and border: 1.5px, so text starts ~2px from overlay left.\n    if (tableContainer) {\n      const rect = tableContainer.getBoundingClientRect();\n      const cellLeft = rect.left - tableContainer.scrollLeft;\n      const textLeft = cellLeft + 38;\n      const cellRight = cellLeft + colWidths.name;\n      const rowTop = rect.top + idx * rowHeight - tableContainer.scrollTop;\n      renameOverlay = {\n        top: rowTop,\n        left: textLeft - 2,\n        width: cellRight - textLeft + 2 - 4\n      };\n    }","newString":"    const entry = results[idx];\n\n    // Measure overlay position from the actual rendered DOM elements.\n    const visibleIndex = idx - startIndex;\n    const rowEl = tableContainer?.querySelectorAll('.row')?.[visibleIndex];\n    const nameCell = rowEl?.querySelector('.cell.name');\n    const span = nameCell?.querySelector('.ellipsis');\n    if (rowEl && nameCell && span) {\n      const rowRect = rowEl.getBoundingClientRect();\n      const spanRect = span.getBoundingClientRect();\n      const nameCellRect = nameCell.getBoundingClientRect();\n      renameOverlay = {\n        top: rowRect.top,\n        left: spanRect.left - 2,\n        width: nameCellRect.right - spanRect.left - 2 - 8\n      };\n    }","originalFile":"<script>\n  import { onDestroy, onMount, tick } from 'svelte';\n  import { invoke } from '@tauri-apps/api/core';\n  import { listen } from '@tauri-apps/api/event';\n  import { startDrag } from '@crabnebula/tauri-plugin-drag';\n  import 'overlayscrollbars/overlayscrollbars.css';\n  import { OverlayScrollbars } from 'overlayscrollbars';\n\n  let osInstance = null;\n  let osViewport = null;\n  let scrollCleanup = null;\n  function getScrollEl() {\n    return osViewport || tableContainer;\n  }\n\n  const rowHeight = 30;\n  const PAGE_SIZE = 500;\n  let homePrefix = '';\n  const COL_WIDTHS_KEY = 'REDACTED';\n  const THEME_KEY = 'everything-theme';\n  const columnKeys = ['name', 'path', 'size', 'modified'];\n  const minColumnWidth = {\n    name: 180,\n    path: 240,\n    size: 75,\n    modified: 150\n  };\n  const defaultColumnRatios = {\n    name: 0.3,\n    path: 0.45,\n    size: 0.1\n  };\n  const DEBUG_STARTUP = false;\n\n  const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';\n  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || systemTheme; } catch { return systemTheme; } })();\n  function cycleTheme() {\n    theme = theme === 'dark' ? 'light' : 'dark';\n    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n    invoke('set_native_theme', { theme });\n  }\n\n  function sortIconHtml(dir) {\n    const d = dir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5';\n    return `<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"${d}\"/></svg>`;\n  }\n\n  let query = '';\n  let results = [];\n  let totalResults = 0;\n  let totalResultsKnown = false;\n\n  let dbLatencyMs = null;\n  let dbLastQuery = '';\n  let searchModeLabel = '';\n  let selectedIndices = new Set();\n  let selectionAnchor = -1;\n  let lastSelectedIndex = -1;\n  let editing = {\n    active: false,\n    path: '',\n    index: -1,\n    draftName: ''\n  };\n\n  let renameOverlay = { top: 0, left: 0, width: 0 };\n\n  let indexStatus = {\n    state: 'Indexing',\n    entriesCount: 0,\n    lastUpdated: null,\n    permissionErrors: 0,\n    message: null,\n    isCatchup: false\n  };\n\n  let indexingStartTime = null;\n  let indexingElapsed = '';\n  let indexingFinishedAt = '';\n\n  let sortBy = 'name';\n  let sortDir = 'asc';\n\n  let hasMore = true;\n  let loadingMore = false;\n  let searchGeneration = 0;\n  let scheduleGeneration = 0;\n  let searchPending = false;\n\n  let scanned = 0;\n\n  let searchInputEl;\n  let renameInputEl;\n  let tableAreaEl;\n  let tableContainer;\n  let tableResizeObserver = null;\n  let viewportResizeRaf = null;\n  let scrollTop = 0;\n  let headerScrollLeft = 0;\n  let viewportHeight = 520;\n  let lastTableWidth = 0;\n  let resizingColumn = '';\n  let resizeCleanup = null;\n  let colWidths = {\n    name: 250,\n    path: 350,\n    size: 75,\n    modified: 150\n  };\n\n  let contextMenu = {\n    visible: false,\n    x: 0,\n    y: 0\n  };\n\n  let platform = '';\n  let toast = '';\n  let searchTimer;\n  let lastSearchFiredAt = 0;\n  let toastTimer;\n  let statusRefreshTimer;\n  let elapsedTimer;\n  let statusRefreshInFlight = false;\n  let resetInFlight = false;\n  let lastReadyCount = 0;\n\n  const iconCache = new Map();\n  const iconLoading = new Set();\n\n  let highlightCache = new Map();\n  let highlightCacheQuery = '';\n\n  function startupLog(msg) {\n    if (!DEBUG_STARTUP) {\n      return;\n    }\n    void invoke('frontend_log', { msg }).catch(() => {});\n  }\n\n  const folderFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='1' y='4' width='14' height='10' rx='2' fill='#d9b34f'/><rect x='1' y='2' width='6' height='4' rx='1' fill='#e6ca7a'/></svg>`\n    );\n  const fileFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='3' y='1' width='10' height='14' rx='1.5' fill='#b4bec9'/><rect x='5' y='5' width='6' height='1.2' fill='#8d98a5'/><rect x='5' y='8' width='6' height='1.2' fill='#8d98a5'/></svg>`\n    );\n\n  $: totalHeight = results.length * rowHeight;\n  $: startIndex = Math.max(0, Math.floor(scrollTop / rowHeight) - 10);\n  $: visibleCount = Math.ceil(viewportHeight / rowHeight) + 20;\n  $: endIndex = Math.min(results.length, startIndex + visibleCount);\n  $: visibleRows = results.slice(startIndex, endIndex);\n  $: translateY = startIndex * rowHeight;\n\n  $: tableMinWidth = colWidths.name + colWidths.path + colWidths.size + colWidths.modified;\n  $: tableGridStyle = `--col-name:${colWidths.name}px;--col-path:${colWidths.path}px;--col-size:${colWidths.size}px;--col-modified:${colWidths.modified}px;--table-min-width:${tableMinWidth}px;--header-offset:${-headerScrollLeft}px;`;\n\n  $: {\n    for (const entry of visibleRows) {\n      void ensureIcon(entry);\n    }\n  }\n\n  function showToast(message) {\n    toast = message;\n    clearTimeout(toastTimer);\n    toastTimer = setTimeout(() => {\n      toast = '';\n    }, 3000);\n  }\n\n  function bytesToBase64(bytes) {\n    let binary = '';\n    const chunk = 0x8000;\n    for (let i = 0; i < bytes.length; i += chunk) {\n      const part = bytes.subarray(i, i + chunk);\n      binary += String.fromCharCode(...part);\n    }\n    return btoa(binary);\n  }\n\n  function highlightSegments(name, q) {\n    q = (q || '').trim();\n    if (!q) return [{ text: name, hl: false }];\n\n    // Reset cache when query changes\n    if (q !== highlightCacheQuery) {\n      highlightCache = new Map();\n      highlightCacheQuery = q;\n    }\n\n    // Check cache\n    const cached = highlightCache.get(name);\n    if (cached) return cached;\n\n    if (q.includes('/')) q = q.slice(q.lastIndexOf('/') + 1);\n    q = q.replace(/[*?]/g, '');\n    const terms = q.split(/\\s+/).filter(Boolean);\n    if (terms.length === 0) return [{ text: name, hl: false }];\n\n    const lower = name.toLowerCase();\n    const marks = new Uint8Array(name.length);\n    for (const t of terms) {\n      const tl = t.toLowerCase();\n      let idx = lower.indexOf(tl);\n      while (idx !== -1) {\n        for (let i = idx; i < idx + tl.length; i++) marks[i] = 1;\n        idx = lower.indexOf(tl, idx + 1);\n      }\n    }\n\n    const segs = [];\n    let i = 0;\n    while (i < name.length) {\n      const m = marks[i];\n      let j = i + 1;\n      while (j < name.length && marks[j] === m) j++;\n      segs.push({ text: name.slice(i, j), hl: m === 1 });\n      i = j;\n    }\n\n    highlightCache.set(name, segs);\n    return segs;\n  }\n\n  const perFileIconExts = new Set(['exe', 'lnk', 'ico', 'url', 'scr', 'appx']);\n\n  function iconKey(entry) {\n    if (entry.isDir) return '__folder__';\n    const ext = (entry.ext || '').toLowerCase();\n    if (perFileIconExts.has(ext)) return entry.path;\n    return ext || '__file__';\n  }\n\n  function iconFor(entry) {\n    return iconCache.get(iconKey(entry)) || (entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n  }\n\n  async function ensureIcon(entry) {\n    const key = iconKey(entry);\n    if (iconCache.has(key) || iconLoading.has(key)) {\n      return;\n    }\n\n    iconLoading.add(key);\n    try {\n      const bytes = await invoke('get_file_icon', {\n        path: entry.path,\n        ext: entry.isDir ? 'folder' : entry.ext || '',\n      });\n      if (Array.isArray(bytes) && bytes.length > 0) {\n        const image = `data:image/png;base64,${bytesToBase64(Uint8Array.from(bytes))}`;\n        iconCache.set(key, image);\n      } else {\n        iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n      }\n    } catch {\n      iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n    } finally {\n      iconLoading.delete(key);\n    }\n  }\n\n  function syncColumnWidthsToContainer() {\n    const width = tableContainer ? getScrollEl().clientWidth : tableAreaEl?.clientWidth;\n    if (!width || lastTableWidth !== 0) {\n      return;\n    }\n\n    const saved = loadColWidths();\n    if (saved) {\n      const total = columnKeys.reduce((s, k) => s + saved[k], 0);\n      if (Math.abs(total - width) > 2) {\n        const scale = (width - saved.modified) / (total - saved.modified);\n        let scaledName = Math.max(minColumnWidth.name, Math.round(saved.name * scale));\n        let scaledSize = Math.max(minColumnWidth.size, Math.round(saved.size * scale));\n        let rawPath = width - saved.modified - scaledName - scaledSize;\n        if (rawPath < minColumnWidth.path) {\n          const shortfall = minColumnWidth.path - rawPath;\n          const nameReduction = Math.min(shortfall, scaledName - minColumnWidth.name);\n          scaledName -= nameReduction;\n          const remaining = shortfall - nameReduction;\n          if (remaining > 0) {\n            scaledSize -= Math.min(remaining, scaledSize - minColumnWidth.size);\n          }\n          rawPath = width - saved.modified - scaledName - scaledSize;\n        }\n        const scaledPath = Math.max(minColumnWidth.path, rawPath);\n        colWidths = { name: scaledName, path: scaledPath, size: scaledSize, modified: saved.modified };\n      } else {\n        colWidths = saved;\n      }\n    } else {\n      const fixedModified = minColumnWidth.modified;\n      const rest = width - fixedModified;\n      const ratioSum = defaultColumnRatios.name + defaultColumnRatios.path + defaultColumnRatios.size;\n      colWidths = {\n        name: Math.max(minColumnWidth.name, Math.round(rest * defaultColumnRatios.name / ratioSum)),\n        path: Math.max(minColumnWidth.path, Math.round(rest * defaultColumnRatios.path / ratioSum)),\n        size: Math.max(minColumnWidth.size, Math.round(rest * defaultColumnRatios.size / ratioSum)),\n        modified: fixedModified\n      };\n    }\n    lastTableWidth = width;\n  }\n\n  function loadColWidths() {\n    try {\n      const raw = localStorage.getItem(COL_WIDTHS_KEY);\n      if (!raw) return null;\n      const parsed = JSON.parse(raw);\n      for (const key of columnKeys) {\n        if (typeof parsed[key] !== 'number' || parsed[key] < (minColumnWidth[key] || 0)) return null;\n      }\n      return parsed;\n    } catch {\n      return null;\n    }\n  }\n\n  function saveColWidths() {\n    localStorage.setItem(COL_WIDTHS_KEY, JSON.stringify(colWidths));\n  }\n\n  function updateViewportHeight() {\n    viewportHeight = tableContainer ? getScrollEl().clientHeight : 520;\n    syncColumnWidthsToContainer();\n  }\n\n  function scheduleViewportHeightUpdate() {\n    if (viewportResizeRaf !== null) {\n      return;\n    }\n    viewportResizeRaf = requestAnimationFrame(() => {\n      viewportResizeRaf = null;\n      updateViewportHeight();\n    });\n  }\n\n  function startColumnResize(event, leftKey) {\n    event.preventDefault();\n    event.stopPropagation();\n\n    const index = columnKeys.indexOf(leftKey);\n    if (index < 0 || index >= columnKeys.length - 1) {\n      return;\n    }\n\n    const startX = event.clientX;\n    const startLeft = colWidths[leftKey];\n    const rightKey = columnKeys[index + 1];\n    const startRight = colWidths[rightKey];\n\n    resizeCleanup?.();\n    resizingColumn = leftKey;\n\n    const onMove = (moveEvent) => {\n      const delta = Math.round(moveEvent.clientX - startX);\n      if (leftKey === 'name') {\n        // Two-column trade: name and path swap space, each respects its minimum\n        const nextLeft = Math.max(\n          minColumnWidth[leftKey],\n          Math.min(startLeft + delta, startLeft + startRight - minColumnWidth[rightKey])\n        );\n        const nextRight = startLeft + startRight - nextLeft;\n        colWidths = { ...colWidths, [leftKey]: nextLeft, [rightKey]: nextRight };\n      } else {\n        // path splitter: path grows unconstrained (allows horizontal scroll on right drag)\n        const nextLeft = Math.max(minColumnWidth[leftKey], startLeft + delta);\n        colWidths = { ...colWidths, [leftKey]: nextLeft };\n      }\n    };\n\n    const onUp = () => {\n      cleanup();\n    };\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      document.body.style.cursor = '';\n      document.body.style.userSelect = '';\n      resizingColumn = '';\n      saveColWidths();\n      if (resizeCleanup === cleanup) {\n        resizeCleanup = null;\n      }\n    };\n\n    resizeCleanup = cleanup;\n    document.body.style.cursor = 'col-resize';\n    document.body.style.userSelect = 'none';\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  function selectedPaths() {\n    const sorted = [...selectedIndices].sort((a, b) => a - b);\n    return sorted.map((idx) => results[idx]).filter(Boolean).map((entry) => entry.path);\n  }\n\n  function clearSelection() {\n    selectedIndices = new Set();\n    selectionAnchor = -1;\n    lastSelectedIndex = -1;\n  }\n\n  function selectSingle(index) {\n    selectedIndices = new Set([index]);\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectToggle(index) {\n    const next = new Set(selectedIndices);\n    if (next.has(index)) {\n      next.delete(index);\n    } else {\n      next.add(index);\n    }\n    selectedIndices = next;\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectRange(index) {\n    const anchor = selectionAnchor >= 0 ? selectionAnchor : index;\n    const [from, to] = [Math.min(anchor, index), Math.max(anchor, index)];\n    const next = new Set();\n    for (let i = from; i <= to; i += 1) {\n      next.add(i);\n    }\n    selectedIndices = next;\n    lastSelectedIndex = index;\n  }\n\n  function primaryEntry() {\n    const idx = lastSelectedIndex >= 0 ? lastSelectedIndex : -1;\n    return idx >= 0 ? results[idx] : null;\n  }\n\n  async function refreshStatus() {\n    if (statusRefreshInFlight || resetInFlight) {\n      startupLog('[startup/fe] refreshStatus skipped (in-flight)');\n      return;\n    }\n    statusRefreshInFlight = true;\n    const startedAt = performance.now();\n    startupLog('[startup/fe] refreshStatus start');\n    try {\n      const status = await invoke('get_index_status');\n      const prevState = indexStatus.state;\n      indexStatus = {\n        state: status.state,\n        entriesCount: status.entriesCount,\n        lastUpdated: status.lastUpdated,\n        permissionErrors: status.permissionErrors ?? 0,\n        message: status.message\n      };\n      if (status.state === 'Indexing' && prevState !== 'Indexing') {\n        startElapsedTimer();\n      } else if (status.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n      if (typeof status.scanned === 'number') {\n        scanned = status.scanned;\n      }\n      if (status.state === 'Ready' && prevState !== 'Ready') {\n        scheduleSearch(true);\n      }\n      startupLog(\n        `[startup/fe] refreshStatus done in ${Math.round(performance.now() - startedAt)}ms `\n        + `(state=${status.state}, entries=${status.entriesCount}, scanned=${status.scanned ?? 'n/a'}, `\n        + `indexed=${status.indexed ?? 'n/a'})`\n      );\n    } catch (err) {\n      startupLog(\n        `[startup/fe] refreshStatus failed in ${Math.round(performance.now() - startedAt)}ms: ${String(err)}`\n      );\n      showToast(`Failed to get status: ${String(err)}`);\n    } finally {\n      statusRefreshInFlight = false;\n    }\n  }\n\n  function scheduleSearch(preserveScroll = false) {\n    // Use a separate counter for debounce cancellation so that scheduling\n    // a search does not invalidate in-flight loadMore calls (which check\n    // searchGeneration). Only runSearch bumps searchGeneration.\n    scheduleGeneration += 1;\n    const scheduledGen = scheduleGeneration;\n    clearTimeout(searchTimer);\n\n    const now = performance.now();\n    if (now - lastSearchFiredAt >= 200) {\n      // Leading edge: fire immediately if enough time has passed\n      lastSearchFiredAt = now;\n      void runSearch(preserveScroll);\n    } else {\n      // Trailing edge: debounce\n      searchTimer = setTimeout(() => {\n        if (scheduledGen !== scheduleGeneration) {\n          return;\n        }\n        lastSearchFiredAt = performance.now();\n        void runSearch(preserveScroll);\n      }, 200);\n    }\n  }\n\n  async function runSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const gen = searchGeneration;\n    searchPending = true;\n    const searchQuery = query;\n    const searchSortBy = sortBy;\n    const searchSortDir = sortDir;\n    const startedAt = performance.now();\n    // When preserving scroll, reload at least as many results as currently\n    // loaded so totalHeight stays stable and scrollTop isn't clamped.\n    const fetchLimit = preserveScroll\n      ? Math.max(PAGE_SIZE, results.length)\n      : PAGE_SIZE;\n    try {\n      const keepPaths = new Set(selectedPaths());\n      const next = await invoke('search', {\n        query: searchQuery,\n        limit: fetchLimit,\n        offset: 0,\n        sortBy: searchSortBy,\n        sortDir: searchSortDir\n      });\n\n      if (gen !== searchGeneration) return;\n\n      dbLatencyMs = Math.round(performance.now() - startedAt);\n      dbLastQuery = searchQuery;\n      const entries = Array.isArray(next.entries) ? next.entries : [];\n      searchModeLabel = next.modeLabel || '';\n\n      // During the await, loadMore may have grown results beyond fetchLimit.\n      // Replacing a larger result set with a smaller one would shrink\n      // totalHeight and cause the browser to clamp scrollTop â†’ scroll jump.\n      // Skip this update; the existing results are still valid (same query/sort).\n      if (preserveScroll && entries.length < results.length) return;\n\n      if (preserveScroll && tableContainer) scrollTop = getScrollEl().scrollTop;\n      results = entries;\n      if (next.totalCount > 0) {\n        totalResults = next.totalCount;\n        totalResultsKnown = true;\n      } else {\n        totalResults = entries.length;\n        totalResultsKnown = false;\n      }\n      hasMore = totalResultsKnown ? results.length < totalResults : entries.length >= fetchLimit;\n      if (!preserveScroll && tableContainer) getScrollEl().scrollTop = 0;\n\n      const restored = new Set();\n      for (let i = 0; i < results.length; i += 1) {\n        if (keepPaths.has(results[i].path)) {\n          restored.add(i);\n        }\n      }\n      selectedIndices = restored;\n\n      updateViewportHeight();\n    } catch (err) {\n      if (gen !== searchGeneration) return;\n      showToast(`Search failed: ${String(err)}`);\n    } finally {\n      searchPending = false;\n    }\n  }\n\n  async function loadMore() {\n    if (!hasMore || loadingMore || searchPending) return;\n    const gen = searchGeneration;\n    loadingMore = true;\n    try {\n      const batch = await invoke('search', {\n        query,\n        limit: PAGE_SIZE,\n        offset: results.length,\n        sortBy: sortBy,\n        sortDir: sortDir\n      });\n      if (gen !== searchGeneration) return;\n      const arr = Array.isArray(batch.entries) ? batch.entries : [];\n      if (arr.length > 0) {\n        if (tableContainer) scrollTop = getScrollEl().scrollTop;\n        results = [...results, ...arr];\n      }\n      hasMore = totalResultsKnown ? results.length < totalResults : arr.length >= PAGE_SIZE;\n    } catch (err) {\n      showToast(`Failed to load more: ${String(err)}`);\n    } finally {\n      loadingMore = false;\n    }\n  }\n\n  function moveSelection(delta, withRange = false) {\n    if (results.length === 0) {\n      return;\n    }\n\n    const current = lastSelectedIndex >= 0 ? lastSelectedIndex : 0;\n    const next = Math.max(0, Math.min(results.length - 1, current + delta));\n\n    if (withRange) {\n      selectRange(next);\n    } else {\n      selectSingle(next);\n    }\n\n    const top = next * rowHeight;\n    const bottom = top + rowHeight;\n    if (top < scrollTop) {\n      if (tableContainer) getScrollEl().scrollTop = top;\n    } else if (bottom > scrollTop + viewportHeight) {\n      if (tableContainer) getScrollEl().scrollTop = bottom - viewportHeight;\n    }\n  }\n\n  function handleHeaderSort(column) {\n    if (sortBy === column) {\n      sortDir = sortDir === 'asc' ? 'desc' : 'asc';\n    } else {\n      sortBy = column;\n      sortDir = 'asc';\n    }\n    if (tableContainer) getScrollEl().scrollTop = 0;\n    void runSearch();\n  }\n\n  function handleRowClick(event, index) {\n    contextMenu.visible = false;\n\n    if (event.shiftKey) {\n      selectRange(index);\n      return;\n    }\n\n    if (event.metaKey || event.ctrlKey) {\n      selectToggle(index);\n      return;\n    }\n\n    selectSingle(index);\n  }\n\n  function handleRowContextMenu(event, index) {\n    event.preventDefault();\n\n    if (!selectedIndices.has(index)) {\n      selectSingle(index);\n    }\n\n    if (platform === 'windows' || platform === 'macos') {\n      contextMenu.visible = false;\n      const paths = selectedPaths();\n      if (paths.length > 0) {\n        invoke('show_context_menu', {\n          paths,\n          x: event.clientX,\n          y: event.clientY,\n          singleSelection: selectedIndices.size === 1\n        });\n      }\n      return;\n    }\n\n    contextMenu = {\n      visible: true,\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n\n  function handleRowA11yKeydown(event, index) {\n    if (event.key === ' ' || event.key === 'Enter') {\n      event.preventDefault();\n      handleRowClick(event, index);\n    }\n  }\n\n  const DRAG_THRESHOLD = 5;\n  let dragCleanup = null;\n  const dragImgCache = new Map();\n\n  function dragPathsForIndex(index) {\n    const entry = results[index];\n    if (!entry) {\n      return [];\n    }\n\n    if (selectedIndices.has(index) && selectedIndices.size > 0) {\n      return selectedPaths();\n    }\n\n    return [entry.path];\n  }\n\n  function getDragIconEl(entry) {\n    const src = iconFor(entry);\n    let img = dragImgCache.get(src);\n    if (!img) {\n      img = new Image();\n      img.src = src;\n      dragImgCache.set(src, img);\n    }\n    return img.complete && img.naturalWidth > 0 ? img : null;\n  }\n\n  function fillRoundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function buildDragPreview(index) {\n    const entry = results[index];\n    if (!entry) return null;\n\n    const count = selectedIndices.has(index) ? selectedIndices.size : 1;\n    const isDark = theme === 'dark';\n\n    const w = 260;\n    const h = 28;\n    const stackGap = count > 1 ? 4 : 0;\n\n    const canvas = document.createElement('canvas');\n    canvas.width = w;\n    canvas.height = h + stackGap;\n    const ctx = canvas.getContext('2d');\n\n    if (count > 1) {\n      ctx.globalAlpha = 0.35;\n      ctx.fillStyle = isDark ? '#5a6070' : '#b0c4de';\n      fillRoundRect(ctx, 3, 0, w - 3, h, 5);\n      ctx.globalAlpha = 1.0;\n    }\n\n    const ry = stackGap;\n    ctx.fillStyle = isDark ? 'rgba(58, 64, 74, 0.94)' : 'rgba(214, 231, 255, 0.94)';\n    fillRoundRect(ctx, 0, ry, w, h, 5);\n\n    ctx.strokeStyle = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';\n    ctx.lineWidth = 0.5;\n    ctx.beginPath();\n    ctx.moveTo(5, ry);\n    ctx.arcTo(w, ry, w, ry + h, 5);\n    ctx.arcTo(w, ry + h, 0, ry + h, 5);\n    ctx.arcTo(0, ry + h, 0, ry, 5);\n    ctx.arcTo(0, ry, w, ry, 5);\n    ctx.closePath();\n    ctx.stroke();\n\n    const iconEl = getDragIconEl(entry);\n    if (iconEl) {\n      ctx.drawImage(iconEl, 6, ry + 6, 16, 16);\n    } else {\n      ctx.fillStyle = entry.isDir ? '#d9b34f' : '#8d98a5';\n      fillRoundRect(ctx, 6, ry + 6, 16, 16, 2);\n    }\n\n    ctx.fillStyle = isDark ? '#e6e6e8' : '#1a1a1a';\n    ctx.font = '12px -apple-system, \"SF Pro Text\", system-ui, sans-serif';\n    ctx.textBaseline = 'middle';\n\n    let nameMaxW = w - 34;\n    if (count > 1) nameMaxW -= 34;\n\n    let name = entry.name;\n    if (ctx.measureText(name).width > nameMaxW) {\n      while (name.length > 4 && ctx.measureText(name + '\\u2026').width > nameMaxW) {\n        name = name.slice(0, -1);\n      }\n      name += '\\u2026';\n    }\n    ctx.fillText(name, 28, ry + h / 2 + 1);\n\n    if (count > 1) {\n      const badge = String(count);\n      ctx.font = 'bold 10px -apple-system, system-ui, sans-serif';\n      const tw = ctx.measureText(badge).width;\n      const bw = Math.max(20, tw + 10);\n      const bx = w - bw - 6;\n      const by = ry + (h - 18) / 2;\n\n      ctx.fillStyle = isDark ? '#5b8bd9' : '#007aff';\n      fillRoundRect(ctx, bx, by, bw, 18, 9);\n\n      ctx.fillStyle = '#ffffff';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(badge, bx + bw / 2, by + 9);\n    }\n\n    return canvas.toDataURL('image/png');\n  }\n\n  function handleRowMouseDown(event, index) {\n    if (event.button !== 0) return;\n    if (event.metaKey || event.ctrlKey || event.shiftKey) return;\n    if (editing.active) return;\n\n    const startX = event.clientX;\n    const startY = event.clientY;\n    let dragging = false;\n\n    dragCleanup?.();\n\n    const onMove = (e) => {\n      if (dragging) return;\n      const dx = e.clientX - startX;\n      const dy = e.clientY - startY;\n      if (dx * dx + dy * dy < DRAG_THRESHOLD * DRAG_THRESHOLD) return;\n\n      dragging = true;\n      cleanup();\n\n      if (!selectedIndices.has(index)) {\n        selectSingle(index);\n      }\n\n      const paths = dragPathsForIndex(index);\n      if (paths.length > 0) {\n        const icon = buildDragPreview(index);\n        startDrag({ item: paths, icon }).catch(() => {});\n      }\n    };\n\n    const onUp = () => cleanup();\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      if (dragCleanup === cleanup) dragCleanup = null;\n    };\n\n    dragCleanup = cleanup;\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  async function handleRowDoubleClick(index) {\n    if (!selectedIndices.has(index) || selectedIndices.size > 1) {\n      selectSingle(index);\n      await tick();\n    }\n    await invoke('open', { paths: [results[index].path] }).catch((err) => {\n      showToast(`Failed to open: ${String(err)}`);\n    });\n  }\n\n  function closeContextMenu() {\n    contextMenu = {\n      ...contextMenu,\n      visible: false\n    };\n  }\n\n  async function openSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('open', { paths });\n    } catch (err) {\n      showToast(`Failed to open: ${String(err)}`);\n    }\n  }\n\n  async function openWithFallback() {\n    const target = primaryEntry();\n    if (!target) {\n      return;\n    }\n\n    try {\n      await invoke('open_with', { path: target.path });\n    } catch (err) {\n      showToast(`Open With failed: ${String(err)}`);\n    }\n  }\n\n  async function revealSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('reveal_in_finder', { paths });\n    } catch (err) {\n      showToast(`Failed to reveal in Finder: ${String(err)}`);\n    }\n  }\n\n  async function copySelectedPaths() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_paths', { paths });\n      showToast(`Copied ${paths.length} path(s)`);\n    } catch (err) {\n      showToast(`Failed to copy path: ${String(err)}`);\n    }\n  }\n\n  async function copyFiles() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_files', { paths });\n      showToast(`Copied ${paths.length} item(s)`);\n    } catch (err) {\n      showToast(`Failed to copy: ${String(err)}`);\n    }\n  }\n\n  async function trashSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    const message =\n      paths.length === 1\n        ? 'Move selected item to Trash?'\n        : `Move ${paths.length} items to Trash?`;\n\n    if (!window.confirm(message)) {\n      return;\n    }\n\n    try {\n      await invoke('move_to_trash', { paths });\n      showToast('Moved to Trash.');\n      clearSelection();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to move to Trash: ${String(err)}`);\n    }\n  }\n\n  async function resetIndex() {\n    if (indexStatus.state === 'Indexing') {\n      showToast('Indexing in progress. Please try again after it completes.');\n      return;\n    }\n\n    results = [];\n    totalResults = 0;\n    totalResultsKnown = false;\n    clearSelection();\n    scanned = 0;\n    dbLatencyMs = null;\n    dbLastQuery = '';\n    indexStatus = { ...indexStatus, state: 'Indexing', entriesCount: 0, message: null };\n    indexingStartTime = Date.now();\n    indexingElapsed = '';\n    indexingFinishedAt = '';\n\n    resetInFlight = true;\n    try {\n      await invoke('reset_index');\n    } catch (err) {\n      showToast(`Failed to reset index: ${String(err)}`);\n      await refreshStatus();\n    } finally {\n      resetInFlight = false;\n    }\n  }\n\n  function isMultiSelected() {\n    return selectedIndices.size > 1;\n  }\n\n  function autoResizeRenameInput() {\n    if (!renameInputEl) return;\n    renameInputEl.style.height = '0';\n    renameInputEl.style.height = renameInputEl.scrollHeight + 'px';\n  }\n\n  async function startRename() {\n    if (isMultiSelected()) {\n      return;\n    }\n\n    const idx = lastSelectedIndex;\n    if (idx < 0 || !results[idx]) {\n      return;\n    }\n\n    const entry = results[idx];\n\n    // Calculate overlay position mathematically.\n    // Name cell text starts at: padding-left(16) + icon(16) + gap(6) = 38px from cell left.\n    // Textarea has padding-left: 0 and border: 1.5px, so text starts ~2px from overlay left.\n    if (tableContainer) {\n      const rect = tableContainer.getBoundingClientRect();\n      const cellLeft = rect.left - tableContainer.scrollLeft;\n      const textLeft = cellLeft + 38;\n      const cellRight = cellLeft + colWidths.name;\n      const rowTop = rect.top + idx * rowHeight - tableContainer.scrollTop;\n      renameOverlay = {\n        top: rowTop,\n        left: textLeft - 2,\n        width: cellRight - textLeft + 2 - 4\n      };\n    }\n\n    editing = {\n      active: true,\n      path: entry.path,\n      index: idx,\n      draftName: entry.name\n    };\n\n    await tick();\n\n    if (renameInputEl) {\n      autoResizeRenameInput();\n      renameInputEl.focus();\n      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n      renameInputEl.setSelectionRange(0, selectionEnd);\n    }\n  }\n\n  function cancelRename() {\n    editing = {\n      active: false,\n      path: '',\n      index: -1,\n      draftName: ''\n    };\n  }\n\n  async function commitRename() {\n    if (!editing.active || editing.index < 0 || !results[editing.index]) {\n      return;\n    }\n\n    const current = results[editing.index];\n    const nextName = editing.draftName;\n\n    try {\n      await invoke('rename', {\n        path: current.path,\n        newName: nextName\n      });\n      cancelRename();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to rename: ${String(err)}`);\n      await tick();\n      renameInputEl?.focus();\n    }\n  }\n\n  function onGlobalClick() {\n    closeContextMenu();\n  }\n\n  function onTitleBarMouseDown(event) {\n    if (event.button !== 0) {\n      return;\n    }\n\n    const activeElement = document.activeElement;\n    if (activeElement instanceof HTMLElement && isTextInputTarget(activeElement)) {\n      activeElement.blur();\n    }\n  }\n\n  async function focusSearch() {\n    searchInputEl?.focus();\n    searchInputEl?.select();\n  }\n\n  function isTextInputTarget(target) {\n    return (\n      target instanceof HTMLInputElement ||\n      target instanceof HTMLTextAreaElement ||\n      target?.isContentEditable\n    );\n  }\n\n  async function handleKeydown(event) {\n    const isMetaSelectAll = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'a';\n    const isMetaCopy = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c';\n    const target = event.target;\n    const isTextInput = isTextInputTarget(target);\n\n    if (isMetaCopy && isTextInput) {\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      if (isTextInput) {\n        event.preventDefault();\n        if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n          target.select();\n        }\n        return;\n      }\n    }\n\n    if (editing.active) {\n      if (event.key === 'Enter') {\n        event.preventDefault();\n        await commitRename();\n        return;\n      }\n\n      if (event.key === 'Escape') {\n        event.preventDefault();\n        const idx = editing.index;\n        cancelRename();\n        selectSingle(idx);\n        await tick();\n        tableContainer?.querySelector('.row.selected')?.focus();\n        return;\n      }\n      return;\n    }\n\n    if (event.key === 'Escape') {\n      event.preventDefault();\n      clearSelection();\n      return;\n    }\n\n    if (event.key === 'ArrowDown') {\n      event.preventDefault();\n      moveSelection(1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'ArrowUp') {\n      event.preventDefault();\n      moveSelection(-1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageDown') {\n      event.preventDefault();\n      moveSelection(Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageUp') {\n      event.preventDefault();\n      moveSelection(-Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'Enter') {\n      event.preventDefault();\n      if (platform === 'windows') {\n        await openSelected();\n      } else {\n        await startRename();\n      }\n      return;\n    }\n\n    if (event.key === 'F2') {\n      event.preventDefault();\n      await startRename();\n      return;\n    }\n\n    if (event.key === ' ' && !isTextInput) {\n      event.preventDefault();\n      const entry = primaryEntry();\n      if (entry) {\n        await invoke('quick_look', { path: entry.path });\n      }\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'f') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      searchInputEl?.select();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'o') {\n      event.preventDefault();\n      await openSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {\n      event.preventDefault();\n      await revealSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c') {\n      event.preventDefault();\n      await copySelectedPaths();\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      event.preventDefault();\n      selectedIndices = new Set(Array.from({ length: results.length }, (_, i) => i));\n      return;\n    }\n\n    if (event.key === 'Delete' || ((event.metaKey || event.ctrlKey) && event.key === 'Backspace')) {\n      if (!isTextInput) {\n        event.preventDefault();\n        await trashSelected();\n      }\n      return;\n    }\n  }\n\n  function formatSize(entry) {\n    if (entry.isDir || entry.size == null) return '';\n    const bytes = entry.size;\n    if (bytes < 1024) return `${bytes} B`;\n    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n    return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n  }\n\n  function formatModified(entry) {\n    if (!entry.mtime) {\n      return '';\n    }\n\n    const d = new Date(entry.mtime * 1000);\n    const pad = (n) => String(n).padStart(2, '0');\n    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;\n  }\n\n  function formatLastUpdated(timestamp) {\n    if (!timestamp) {\n      return '-';\n    }\n\n    return new Date(timestamp * 1000).toLocaleString();\n  }\n\n  function formatElapsed(ms) {\n    const totalSec = Math.floor(ms / 1000);\n    const min = Math.floor(totalSec / 60);\n    const sec = totalSec % 60;\n    return min > 0 ? `${min}m ${sec}s` : `${sec}s`;\n  }\n\n  function updateElapsed() {\n    if (indexingStartTime && indexStatus.state === 'Indexing') {\n      indexingElapsed = formatElapsed(Date.now() - indexingStartTime);\n    }\n  }\n\n  function startElapsedTimer() {\n    clearInterval(elapsedTimer);\n    indexingStartTime = Date.now();\n    indexingElapsed = '0s';\n    indexingFinishedAt = '';\n    elapsedTimer = setInterval(updateElapsed, 1000);\n  }\n\n  function stopElapsedTimer() {\n    clearInterval(elapsedTimer);\n    if (indexingStartTime) {\n      const elapsed = Date.now() - indexingStartTime;\n      indexingFinishedAt = `${formatElapsed(elapsed)}`;\n    }\n    indexingStartTime = null;\n    indexingElapsed = '';\n  }\n\n  function displayPath(path) {\n    if (!path) {\n      return path;\n    }\n\n    if (!homePrefix) {\n      return path;\n    }\n\n    if (path === homePrefix) {\n      return '~';\n    }\n\n    if (path.startsWith(`${homePrefix}/`)) {\n      return `~${path.slice(homePrefix.length)}`;\n    }\n\n    return path;\n  }\n\n  let unlistenFns = [];\n\n  onMount(async () => {\n    const t0 = performance.now();\n    const ms = () => Math.round(performance.now() - t0);\n    const step = async (name, fn) => {\n      const startedAt = performance.now();\n      startupLog(`[startup/fe] +${ms()}ms ${name} start`);\n      try {\n        const result = await fn();\n        startupLog(`[startup/fe] +${ms()}ms ${name} done (${Math.round(performance.now() - startedAt)}ms)`);\n        return result;\n      } catch (err) {\n        startupLog(\n          `[startup/fe] +${ms()}ms ${name} failed (${Math.round(performance.now() - startedAt)}ms): ${String(err)}`\n        );\n        throw err;\n      }\n    };\n\n    startupLog('[startup/fe] onMount entered');\n\n    updateViewportHeight();\n    startupLog(`[startup/fe] +${ms()}ms updateViewportHeight done`);\n\n    invoke('set_native_theme', { theme });\n\n    platform = await step('invoke(get_platform)', () => invoke('get_platform'));\n\n    const unlistenProgress = await step(\n      'listen(index_progress)',\n      () => listen('index_progress', (event) => {\n        scanned = event.payload.scanned;\n        indexed = event.payload.indexed;\n        currentPath = event.payload.currentPath;\n        if (indexStatus.state !== 'Indexing') {\n          indexStatus = {\n            ...indexStatus,\n            state: 'Indexing'\n          };\n        }\n      })\n    );\n\n    const unlistenState = await step(\n      'listen(index_state)',\n      () => listen('index_state', (event) => {\n        startupLog(`[startup/fe] index_state event received: ${event.payload.state} at +${ms()}ms`);\n        const prevState = indexStatus.state;\n        indexStatus = {\n          ...indexStatus,\n          state: event.payload.state,\n          message: event.payload.message ?? null,\n          isCatchup: event.payload.isCatchup ?? false\n        };\n\n        if (event.payload.state === 'Indexing' && prevState !== 'Indexing') {\n          if (prevState === 'Ready') {\n            lastReadyCount = indexStatus.entriesCount;\n          }\n          startElapsedTimer();\n        } else if (event.payload.state !== 'Indexing' && prevState === 'Indexing') {\n          stopElapsedTimer();\n        }\n\n        if (event.payload.state === 'Ready') {\n          scheduleSearch(true);\n        }\n      })\n    );\n\n    const unlistenUpdated = await step(\n      'listen(index_updated)',\n      () => listen('index_updated', (event) => {\n        indexStatus = {\n          ...indexStatus,\n          entriesCount: event.payload.entriesCount,\n          lastUpdated: event.payload.lastUpdated,\n          permissionErrors: event.payload.permissionErrors ?? indexStatus.permissionErrors\n        };\n\n        scheduleSearch(true);\n      })\n    );\n\n    const unlistenFocus = await step('listen(focus_search)', () => listen('focus_search', () => {\n      void focusSearch();\n    }));\n\n    const unlistenCtxMenuAction = await step(\n      'listen(context_menu_action)',\n      () => listen('context_menu_action', (event) => {\n        switch (event.payload) {\n          case 'open': void openSelected(); break;\n          case 'quick_look': {\n            const e = primaryEntry();\n            if (e) void invoke('quick_look', { path: e.path });\n            break;\n          }\n          case 'open_with': void openWithFallback(); break;\n          case 'reveal': void revealSelected(); break;\n          case 'copy_files': void copyFiles(); break;\n          case 'copy_path': void copySelectedPaths(); break;\n          case 'trash': void trashSelected(); break;\n          case 'rename': void startRename(); break;\n        }\n      })\n    );\n\n    unlistenFns = [unlistenProgress, unlistenState, unlistenUpdated, unlistenFocus, unlistenCtxMenuAction];\n    startupLog(`[startup/fe] +${ms()}ms all listeners registered`);\n\n    // Fetch backend state IMMEDIATELY after listeners are registered.\n    // Events emitted before listener registration are lost, so this\n    // is the only reliable way to get the current state.\n    await step('refreshStatus()', () => refreshStatus());\n\n    // Show Svelte UI: remove skeleton, focus search input.\n    await step('tick()', () => tick());\n    document.getElementById('skeleton')?.remove();\n    await step('invoke(mark_frontend_ready)', () => invoke('mark_frontend_ready'));\n    await step('focusSearch()', () => focusSearch());\n    startupLog(`[startup/fe] +${ms()}ms WINDOW VISIBLE - skeleton removed`);\n\n    try {\n      homePrefix = await step('invoke(get_home_dir)', () => invoke('get_home_dir'));\n    } catch {\n      homePrefix = '';\n    }\n    startupLog(`[startup/fe] +${ms()}ms get_home_dir done`);\n\n    if (!localStorage.getItem('everything-fda-notice-v1')) {\n      showToast('macOS Full Disk Access permission may be required for full disk search.');\n      localStorage.setItem('everything-fda-notice-v1', '1');\n    }\n    flog(`[startup/fe] +${ms()}ms calling runSearch...`);\n    await runSearch();\n    flog(`[startup/fe] +${ms()}ms runSearch done`);\n\n    if (typeof ResizeObserver !== 'undefined') {\n      tableResizeObserver = new ResizeObserver(() => {\n        scheduleViewportHeightUpdate();\n      });\n      if (tableContainer) {\n        tableResizeObserver.observe(tableContainer);\n      } else if (tableAreaEl) {\n        tableResizeObserver.observe(tableAreaEl);\n      }\n    }\n\n    window.addEventListener('resize', scheduleViewportHeightUpdate);\n    window.addEventListener('click', onGlobalClick);\n\n    if (tableContainer) {\n      tableContainer.setAttribute('data-overlayscrollbars-initialize', '');\n      osInstance = OverlayScrollbars(tableContainer, {\n        scrollbars: {\n          theme: 'os-theme-dark',\n          autoHide: 'scroll',\n          autoHideDelay: 500,\n          clickScroll: true\n        }\n      });\n      osViewport = osInstance.elements().viewport;\n\n      let lastScrollY = 0;\n      let lastScrollX = 0;\n      let scrollTimeoutY = null;\n      let scrollTimeoutX = null;\n\n      const onScroll = () => {\n        scrollTop = osViewport.scrollTop;\n        headerScrollLeft = osViewport.scrollLeft;\n\n        if (scrollTop !== lastScrollY) {\n          tableContainer.classList.add('scrolling-y');\n          tableContainer.classList.remove('scrolling-x');\n          clearTimeout(scrollTimeoutY);\n          scrollTimeoutY = setTimeout(() => {\n            if (tableContainer) tableContainer.classList.remove('scrolling-y');\n          }, 1500);\n        }\n        if (headerScrollLeft !== lastScrollX) {\n          tableContainer.classList.add('scrolling-x');\n          tableContainer.classList.remove('scrolling-y');\n          clearTimeout(scrollTimeoutX);\n          scrollTimeoutX = setTimeout(() => {\n            if (tableContainer) tableContainer.classList.remove('scrolling-x');\n          }, 1500);\n        }\n        lastScrollY = scrollTop;\n        lastScrollX = headerScrollLeft;\n\n        const scrollBottom = scrollTop + osViewport.clientHeight;\n        if (scrollBottom >= totalHeight - rowHeight * 10) {\n          void loadMore();\n        }\n      };\n\n      osViewport.addEventListener('scroll', onScroll);\n      scrollCleanup = () => {\n        clearTimeout(scrollTimeoutY);\n        clearTimeout(scrollTimeoutX);\n        osViewport.removeEventListener('scroll', onScroll);\n      };\n    }\n\n    await step('runSearch()', () => runSearch());\n\n    statusRefreshTimer = setInterval(() => {\n      if (indexStatus.state === 'Indexing') {\n        void refreshStatus();\n      }\n    }, 1000);\n    startupLog(`[startup/fe] +${ms()}ms onMount complete`);\n    console.log(`[startup/fe] +${ms()}ms onMount complete`);\n  });\n\n  onDestroy(async () => {\n    clearTimeout(searchTimer);\n    clearTimeout(toastTimer);\n    clearInterval(statusRefreshTimer);\n    clearInterval(elapsedTimer);\n    resizeCleanup?.();\n\n    for (const unlisten of unlistenFns) {\n      unlisten();\n    }\n\n    tableResizeObserver?.disconnect();\n    tableResizeObserver = null;\n    if (viewportResizeRaf !== null) {\n      cancelAnimationFrame(viewportResizeRaf);\n      viewportResizeRaf = null;\n    }\n    window.removeEventListener('resize', scheduleViewportHeightUpdate);\n    window.removeEventListener('click', onGlobalClick);\n    scrollCleanup?.();\n    if (osInstance) {\n      osInstance.destroy();\n    }\n  });\n</script>\n\n<svelte:window on:keydown={handleKeydown} />\n\n<div class=\"app-shell\" data-theme={theme}>\n  <div class=\"title-bar\" role=\"presentation\" data-tauri-drag-region on:mousedown={onTitleBarMouseDown}>\n    <div class=\"title-left\"></div>\n    <div class=\"title-center\">\n      <svg class=\"title-icon\" viewBox=\"0 0 215 205\" fill-rule=\"evenodd\" aria-hidden=\"true\">\n        <path d=\"M85 0c46.9 0 85 38.1 85 85 0 20.1-7.2 38.5-19.2 52.7l40.7 40.8c5.8 5.8 5.8 15.2 0 21-5.8 5.8-15.2 5.8-21 0l-40.7-40.7c-13.6 9.7-30.4 15.2-44.8 15.2-46.9 0-85-42.1-85-89 0-46.9 38.1-85 85-85z m0 32c-29.3 0-53 23.7-53 53 0 29.3 23.7 53 53 53 29.3 0 53-23.7 53-53 0-29.3-23.7-53-53-53z\"/>\n      </svg>\n      <span class=\"title-text\">Everything</span>\n    </div>\n    <div class=\"title-right\"></div>\n  </div>\n\n  <header class=\"search-bar\">\n    <input\n      bind:this={searchInputEl}\n      class=\"search-input\"\n      type=\"text\"\n      bind:value={query}\n      on:input={scheduleSearch}\n      on:focus={clearSelection}\n      placeholder=\"Search file/folder names\"\n      autocomplete=\"off\"\n      spellcheck=\"false\"\n    />\n  </header>\n\n  <section class=\"table-area\" bind:this={tableAreaEl} style={tableGridStyle}>\n    <div class=\"table-header\">\n      <div class=\"table-header-track\">\n        <div class=\"col name\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('name')}>\n            Name{#if sortBy === 'name'}{@html sortIconHtml(sortDir)}{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'name'}\n            on:mousedown={(event) => startColumnResize(event, 'name')}\n            aria-label=\"Resize Name column\"\n          />\n        </div>\n\n        <div class=\"col path\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('dir')}>\n            Path{#if sortBy === 'dir'}{@html sortIconHtml(sortDir)}{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'path'}\n            on:mousedown={(event) => startColumnResize(event, 'path')}\n            aria-label=\"Resize Path column\"\n          />\n        </div>\n\n        <div class=\"col size\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('size')}>\n            Size{#if sortBy === 'size'}{@html sortIconHtml(sortDir)}{/if}\n          </button>\n        </div>\n\n        <div class=\"col modified\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('mtime')}>\n            Modified{#if sortBy === 'mtime'}{@html sortIconHtml(sortDir)}{/if}\n          </button>\n        </div>\n      </div>\n    </div>\n\n    <div\n      class=\"table-body\"\n      bind:this={tableContainer}\n      on:scroll={() => {\n        scrollTop = tableContainer.scrollTop;\n        headerScrollLeft = tableContainer.scrollLeft;\n        if (editing.active) void commitRename();\n        const scrollBottom = scrollTop + tableContainer.clientHeight;\n        if (scrollBottom >= totalHeight - rowHeight * 10) {\n          void loadMore();\n        }\n      }}\n    >\n      <div class=\"spacer\" style={`height:${totalHeight}px`}>\n        <div class=\"rows\" style={`transform: translateY(${translateY}px);`}>\n          {#each visibleRows as entry, localIndex}\n            {@const index = startIndex + localIndex}\n            <div\n              class=\"row {selectedIndices.has(index) ? 'selected' : ''}\"\n              on:mousedown={(event) => handleRowMouseDown(event, index)}\n              on:click={(event) => handleRowClick(event, index)}\n              on:keydown={(event) => handleRowA11yKeydown(event, index)}\n              on:dblclick={() => handleRowDoubleClick(index)}\n              on:contextmenu={(event) => handleRowContextMenu(event, index)}\n              role=\"row\"\n              tabindex=\"0\"\n            >\n              <div class=\"cell name\">\n                <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n                <span class=\"ellipsis\" class:name-editing={editing.active && editing.index === index}>{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n              </div>\n              <div class=\"cell path\"><span class=\"ellipsis\">{displayPath(entry.dir)}</span></div>\n              <div class=\"cell size\">{formatSize(entry)}</div>\n              <div class=\"cell modified\">{formatModified(entry)}</div>\n            </div>\n          {/each}\n        </div>\n      </div>\n    </div>\n  </section>\n\n  <footer class=\"status-bar\">\n    <div class=\"status-left\">\n      <span class=\"status-state\">\n        <span class=\"state-dot {indexStatus.state === 'Indexing' ? 'indexing' : indexStatus.state === 'Error' ? 'error' : 'ready'}\"></span>\n        {#if indexStatus.state === 'Indexing'}\n          Indexing{#if lastReadyCount > 0} ({Math.min(99, Math.round((scanned / lastReadyCount) * 100))}%){/if}{#if indexingElapsed} Â· {indexingElapsed}{/if}\n          {#if !indexStatus.isCatchup}\n            Â· {scanned.toLocaleString()} scanned\n          {/if}\n        {:else}\n          Index: {indexStatus.state}\n        {/if}\n      </span>\n      <span>{indexStatus.entriesCount.toLocaleString()} entries</span>\n      {#if indexingFinishedAt && indexStatus.state !== 'Indexing'}\n        <span>in {indexingFinishedAt}</span>\n      {/if}\n      {#if dbLatencyMs !== null && dbLastQuery}\n        <span>\"{dbLastQuery}\" {dbLatencyMs}ms Â· {totalResults} results</span>\n      {/if}\n      {#if searchModeLabel === 'spotlight' || searchModeLabel === 'spotlight_timeout'}\n        <span class=\"status-spotlight\">Spotlight fallback{#if searchModeLabel === 'spotlight_timeout'} (partial){/if}</span>\n      {/if}\n      {#if indexStatus.permissionErrors > 0}\n        <span class=\"status-warning\">{indexStatus.permissionErrors.toLocaleString()} permission errors</span>\n      {/if}\n      {#if indexStatus.message}\n        <span class={indexStatus.isCatchup ? 'index-progress' : 'status-error'}>{indexStatus.message}</span>\n      {/if}\n    </div>\n    <div class=\"status-right\">\n      <button class=\"status-btn\" on:click={cycleTheme} title=\"Switch theme\">\n        {theme === 'dark' ? 'â˜€ Light' : 'â—‘ Dark'}\n      </button>\n      <button\n        class=\"status-btn rebuild-btn\"\n        on:click={resetIndex}\n        disabled={indexStatus.state === 'Indexing'}\n        title={indexStatus.state === 'Indexing' ? 'Cannot reset while indexing is in progress.' : 'Reset and rebuild the index.'}\n      >\n        <svg class=\"rebuild-icon\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n          <path d=\"M23 4v6h-6\"/><path d=\"M20.49 15a9 9 0 1 1-2.12-9.36L23 10\"/>\n        </svg>\n        Rebuild Index\n      </button>\n    </div>\n  </footer>\n\n  {#if editing.active}\n    <div\n      class=\"rename-overlay\"\n      style=\"top:{renameOverlay.top}px; left:{renameOverlay.left}px; width:{renameOverlay.width}px;\"\n      role=\"presentation\"\n      on:mousedown|stopPropagation\n    >\n      <textarea\n        bind:this={renameInputEl}\n        class=\"rename-textarea\"\n        bind:value={editing.draftName}\n        on:input={autoResizeRenameInput}\n        on:click|stopPropagation\n        on:blur={commitRename}\n      />\n    </div>\n  {/if}\n\n  {#if contextMenu.visible}\n    <div class=\"context-menu\" style={`left:${contextMenu.x}px;top:${contextMenu.y}px;`}>\n      <button on:click={() => (closeContextMenu(), openSelected())}>Open</button>\n      <button on:click={async () => { closeContextMenu(); const e = primaryEntry(); if (e) await invoke('quick_look', { path: e.path }); }}>Quick Look</button>\n      <button on:click={() => (closeContextMenu(), openWithFallback())}>Open With... (Reveal in Finder)</button>\n      <button on:click={() => (closeContextMenu(), revealSelected())}>Reveal in Finder</button>\n      <button on:click={() => (closeContextMenu(), copySelectedPaths())}>Copy Path</button>\n      <button on:click={() => (closeContextMenu(), trashSelected())}>Move to Trash</button>\n      {#if selectedIndices.size === 1}\n        <button on:click={() => (closeContextMenu(), startRename())}>Rename</button>\n      {/if}\n    </div>\n  {/if}\n\n  {#if toast}\n    <div class=\"toast\">{toast}</div>\n  {/if}\n</div>\n\n<style>\n  :global(:root) {\n    color-scheme: light dark;\n    --bg-app: transparent;\n    --text-primary: #0d1826;\n    --text-muted: #48596c;\n    --bar-grad-top: rgba(255, 255, 255, 0.48);\n    --bar-grad-bottom: rgba(248, 250, 253, 0.42);\n    --surface-header: rgba(252, 252, 255, 0.40);\n    --surface: rgba(255, 255, 255, 0.22);\n    --border-soft: rgba(0, 0, 0, 0.07);\n    --border-input: rgba(0, 0, 0, 0.13);\n    --focus-ring: #6f96e6;\n    --row-border: rgba(0, 0, 0, 0.032);\n    --row-hover: rgba(0, 0, 0, 0.06);\n    --row-selected: rgba(0, 0, 0, 0.12);\n    --button-bg: rgba(255, 255, 255, 0.62);\n    --button-border: rgba(0, 0, 0, 0.10);\n    --button-text: #2c3e50;\n    --menu-bg: rgba(240, 241, 248, 0.90);\n    --menu-border: rgba(0, 0, 0, 0.06);\n    --menu-hover: rgba(255, 255, 255, 0.62);\n    --menu-text: #1a2a38;\n    --error-text: #b64545;\n    --warning-text: #8f6500;\n    --toast-bg: rgba(18, 22, 32, 0.90);\n    --toast-text: #ffffff;\n  }\n\n  @media (prefers-color-scheme: dark) {\n    :global(:root) {\n      --bg-app: transparent;\n      --text-primary: #e6e6ea;\n      --text-muted: #9494a4;\n      --bar-grad-top: rgba(38, 38, 46, 0.52);\n      --bar-grad-bottom: rgba(30, 30, 38, 0.46);\n      --surface-header: rgba(32, 32, 40, 0.46);\n      --surface: rgba(18, 18, 26, 0.32);\n      --border-soft: rgba(255, 255, 255, 0.065);\n      --border-input: rgba(255, 255, 255, 0.14);\n      --focus-ring: #5b8bd9;\n      --row-border: rgba(255, 255, 255, 0.026);\n      --row-hover: rgba(255, 255, 255, 0.08);\n      --row-selected: rgba(255, 255, 255, 0.14);\n      --button-bg: rgba(255, 255, 255, 0.072);\n      --button-border: rgba(255, 255, 255, 0.11);\n      --button-text: #d6d6e0;\n      --menu-bg: rgba(36, 36, 46, 0.90);\n      --menu-border: rgba(255, 255, 255, 0.066);\n      --menu-hover: rgba(255, 255, 255, 0.062);\n      --menu-text: #e0e0e8;\n      --error-text: #ff9d9d;\n      --warning-text: #e0c670;\n      --toast-bg: rgba(10, 10, 16, 0.93);\n      --toast-text: #f2f2f6;\n    }\n  }\n\n  /* â”€â”€ Theme: Dark â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme=\"dark\"]) {\n    color-scheme: dark;\n    --bg-app: #1E1E21;\n    --text-primary: #B8BDC5;\n    --text-muted: #94A3B8;\n    --bar-grad-top: #1E1E21;\n    --bar-grad-bottom: #1E1E21;\n    --surface-header: #1E1E21;\n    --surface: #1E1E21;\n    --bg-input: #161618;\n    --border-soft: #2A2A2D;\n    --border-input: rgba(255, 255, 255, 0.06);\n    --focus-ring: #4DA8FF;\n    --accent: #4DA8FF;\n    --row-border: rgba(255, 255, 255, 0.02);\n    --row-hover: #282828;\n    --row-selected: rgba(77, 168, 255, 0.10);\n    --button-bg: rgba(255, 255, 255, 0.05);\n    --button-border: #2A2A2D;\n    --button-text: #94A3B8;\n    --menu-bg: #252528;\n    --menu-border: #2A2A2D;\n    --menu-hover: rgba(255, 255, 255, 0.04);\n    --menu-text: #E2E8F0;\n    --error-text: #ff9d9d;\n    --warning-text: #e0c670;\n    --toast-bg: rgba(10, 10, 16, 0.93);\n    --toast-text: #f2f2f6;\n  }\n\n  /* â”€â”€ Theme: Light â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme=\"light\"]) {\n    color-scheme: light;\n    --bg-app: #F5F5F7;\n    --text-primary: #1C1C1E;\n    --text-muted: #6E6E7A;\n    --bar-grad-top: #F5F5F7;\n    --bar-grad-bottom: #F5F5F7;\n    --surface-header: #F5F5F7;\n    --surface: #F5F5F7;\n    --bg-input: #FFFFFF;\n    --border-soft: #D1D1D6;\n    --border-input: rgba(0, 0, 0, 0.10);\n    --focus-ring: #3A8BF5;\n    --accent: #3A8BF5;\n    --row-border: rgba(0, 0, 0, 0.04);\n    --row-hover: rgba(0, 0, 0, 0.04);\n    --row-selected: rgba(58, 139, 245, 0.10);\n    --button-bg: #FFFFFF;\n    --button-border: #D1D1D6;\n    --button-text: #3C3C43;\n    --menu-bg: #FFFFFF;\n    --menu-border: #D1D1D6;\n    --menu-hover: rgba(0, 0, 0, 0.05);\n    --menu-text: #1C1C1E;\n    --error-text: #D93025;\n    --warning-text: #B45309;\n    --toast-bg: rgba(255, 255, 255, 0.95);\n    --toast-text: #1C1C1E;\n  }\n\n  /* â”€â”€ Themed element overrides â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n  :global([data-theme]) {\n    background: var(--bg-app);\n  }\n\n  /* Search bar: flat, no gradient, no separator */\n  :global([data-theme]) .search-bar {\n    height: 44px;\n    padding: 0 16px;\n    background: var(--bg-app);\n    border-bottom: none;\n  }\n\n  :global([data-theme]) .search-input {\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n    font-family: 'JetBrains Mono', 'SF Mono', monospace;\n    font-size: 12px;\n    height: 34px;\n    border-radius: 8px;\n  }\n\n  /* Table header: flat bg, 16px edge padding */\n  :global([data-theme]) .table-header {\n    background: var(--bg-app);\n  }\n\n  :global([data-theme]) .col-button {\n    padding: 0 8px;\n  }\n\n  :global([data-theme]) .col.name .col-button {\n    padding-left: 16px;\n  }\n\n  /* Row cells: JetBrains Mono, 16px outer edges */\n  :global([data-theme]) .cell {\n    font-family: 'JetBrains Mono', monospace;\n  }\n\n  :global([data-theme]) .cell.name {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    padding-left: 16px;\n    font-size: 12px;\n    color: var(--text-primary);\n  }\n\n  :global([data-theme]) .cell.path {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.size {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.modified {\n    padding-right: 16px;\n    font-size: 11px;\n    white-space: nowrap;\n  }\n\n  :global([data-theme]) .row.selected {\n    box-shadow: inset 3px 0 0 var(--accent);\n  }\n\n  /* Dim path/size/date cells in themed mode */\n  :global([data-theme]) .cell.path,\n  :global([data-theme]) .cell.size,\n  :global([data-theme]) .cell.modified {\n    color: var(--text-muted);\n  }\n\n  :global(:root) {\n    background: transparent;\n  }\n\n  :global(html, body) {\n    margin: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    background: transparent;\n    color: var(--text-primary);\n    font-family: Inter, 'SF Pro Text', 'Segoe UI', Helvetica, Arial, sans-serif;\n  }\n\n  :global(#app) {\n    width: 100%;\n    height: 100%;\n  }\n\n  .app-shell {\n    display: grid;\n    grid-template-rows: auto auto 1fr auto;\n    height: 100%;\n    min-width: 0;\n  }\n\n  .title-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 44px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    cursor: default;\n    flex-shrink: 0;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-left {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-center {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-right {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-icon {\n    width: 14px;\n    height: 14px;\n    fill: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .title-text {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 13px;\n    font-weight: 500;\n    color: var(--text-primary);\n    letter-spacing: -0.01em;\n  }\n\n  .search-bar {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding: 8px;\n    background: linear-gradient(180deg, var(--bar-grad-top) 0%, var(--bar-grad-bottom) 100%);\n    border-bottom: 1px solid var(--border-soft);\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .search-input {\n    display: block;\n    box-sizing: border-box;\n    width: 100%;\n    min-width: 0;\n    flex: 1 1 auto;\n    height: 36px;\n    border: 1px solid var(--border-input);\n    border-radius: 14px;\n    padding: 0 10px;\n    font-size: 14px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    backdrop-filter: blur(12px) saturate(160%);\n    -webkit-backdrop-filter: blur(12px) saturate(160%);\n  }\n\n  .search-input::placeholder {\n    color: var(--text-muted);\n    opacity: 0.85;\n    font-size: 12px;\n  }\n\n  .search-input:focus {\n    outline: none;\n    border-color: var(--focus-ring);\n    box-shadow: 0 0 0 2px rgba(125, 169, 255, 0.25);\n  }\n\n  .table-area {\n    display: grid;\n    grid-template-rows: auto 1fr;\n    min-height: 0;\n    min-width: 0;\n  }\n\n  .table-header-track,\n  .row {\n    display: grid;\n    grid-template-columns: var(--col-name) var(--col-path) var(--col-size) var(--col-modified);\n    align-items: center;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .table-header {\n    height: 32px;\n    border-bottom: 1px solid var(--border-soft);\n    background: var(--surface-header);\n    user-select: none;\n    overflow: hidden;\n    flex-shrink: 0;\n  }\n\n  .table-header-track {\n    height: 100%;\n    transform: translateX(var(--header-offset, 0px));\n    will-change: transform;\n  }\n\n  .table-header .col {\n    position: relative;\n    min-width: 0;\n    height: 100%;\n  }\n\n  .col-button {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n    gap: 4px;\n    box-sizing: border-box;\n    padding: 0 8px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 11px;\n    font-weight: 600;\n    line-height: 1;\n    color: var(--text-muted);\n    text-align: left;\n    margin: 0;\n    border: none;\n    background: transparent;\n    cursor: pointer;\n  }\n\n  :global(.sort-icon) {\n    width: 10px;\n    height: 10px;\n    flex-shrink: 0;\n    color: var(--accent);\n  }\n\n  .col-resizer {\n    position: absolute;\n    top: 0;\n    right: -4px;\n    width: 8px;\n    height: 100%;\n    border: none;\n    padding: 0;\n    background: transparent;\n    cursor: col-resize;\n    z-index: 30;\n  }\n\n  .col-resizer::after {\n    content: '';\n    position: absolute;\n    top: 7px;\n    bottom: 7px;\n    left: 50%;\n    width: 1px;\n    transform: translateX(-50%);\n    background: var(--border-soft);\n    opacity: 0;\n    transition: opacity 0.15s ease;\n  }\n\n  .table-header .col:hover .col-resizer::after,\n  .col-resizer.active::after {\n    opacity: 1;\n  }\n\n  .table-body {\n    overflow: auto;\n    overflow-anchor: none;\n    min-height: 0;\n    min-width: 0;\n    background: var(--surface);\n  }\n\n  .spacer {\n    position: relative;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .rows {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .row {\n    height: 30px;\n    border-bottom: 1px solid var(--row-border);\n    cursor: default;\n    -webkit-user-select: none;\n    user-select: none;\n    outline: none;\n  }\n\n  .row:hover {\n    background: var(--row-hover);\n  }\n\n  .row.selected {\n    background: var(--row-selected);\n  }\n\n  .cell {\n    padding: 0 8px;\n    font-size: 12px;\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    min-width: 0;\n  }\n\n  .cell.size {\n    text-align: right;\n    font-variant-numeric: tabular-nums;\n  }\n\n  .ellipsis {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n\n  .hl {\n    background: none;\n    color: inherit;\n    font-weight: 700;\n  }\n\n  .file-icon {\n    width: 16px;\n    height: 16px;\n    flex: 0 0 auto;\n  }\n\n  .name-editing {\n    opacity: 0.25;\n  }\n\n  .rename-overlay {\n    position: fixed;\n    z-index: 100;\n    min-width: 120px;\n  }\n\n  .rename-textarea {\n    display: block;\n    width: 100%;\n    box-sizing: border-box;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 12px;\n    line-height: 18px;\n    padding: 5px 4px 5px 0;\n    border: 1.5px solid var(--focus-ring);\n    border-radius: 4px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    outline: none;\n    resize: none;\n    overflow: hidden;\n    box-shadow: 0 2px 14px rgba(0, 0, 0, 0.22), 0 0 0 3px rgba(77, 168, 255, 0.13);\n  }\n\n  .status-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 32px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    border-top: 1px solid var(--border-soft);\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 11px;\n    color: var(--text-muted);\n    white-space: nowrap;\n    overflow: hidden;\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .status-left {\n    display: flex;\n    align-items: center;\n    gap: 16px;\n    overflow: hidden;\n    min-width: 0;\n  }\n\n  .status-right {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    flex-shrink: 0;\n  }\n\n  .status-btn {\n    border: 1px solid var(--button-border);\n    border-radius: 5px;\n    background: var(--button-bg);\n    color: var(--button-text);\n    font-size: 11px;\n    height: 22px;\n    padding: 0 8px;\n    cursor: pointer;\n  }\n\n  .status-btn:hover {\n    filter: brightness(1.06);\n  }\n\n  .status-btn:disabled {\n    opacity: 0.55;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .status-state {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n  }\n\n  .state-dot {\n    width: 6px;\n    height: 6px;\n    border-radius: 50%;\n    flex-shrink: 0;\n  }\n\n  .state-dot.ready { background: #28C840; }\n  .state-dot.indexing { background: #FEBC2E; }\n  .state-dot.error { background: #FF5F57; }\n\n  .rebuild-btn {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 10px;\n    font-weight: 500;\n    border-radius: 4px;\n    padding: 0 10px;\n  }\n\n  .rebuild-btn:hover {\n    filter: brightness(1.1);\n  }\n\n  .rebuild-btn:disabled {\n    opacity: 0.5;\n  }\n\n  .rebuild-icon {\n    width: 11px;\n    height: 11px;\n    color: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .status-error {\n    color: var(--error-text);\n  }\n\n  .status-warning {\n    color: var(--warning-text);\n  }\n\n  .status-spotlight {\n    color: #f59e0b;\n    font-weight: 600;\n  }\n\n  .context-menu {\n    position: fixed;\n    z-index: 200;\n    width: 220px;\n    border: 1px solid var(--menu-border);\n    border-radius: 10px;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.16), inset 0 0 0 0.5px rgba(255, 255, 255, 0.18);\n    background: var(--menu-bg);\n    backdrop-filter: blur(28px) saturate(180%);\n    -webkit-backdrop-filter: blur(28px) saturate(180%);\n    overflow: hidden;\n  }\n\n  .context-menu button {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    padding: 8px 10px;\n    font-size: 12px;\n    color: var(--menu-text);\n  }\n\n  .context-menu button:hover {\n    background: var(--menu-hover);\n  }\n\n  .toast {\n    position: fixed;\n    right: 14px;\n    bottom: 18px;\n    background: var(--toast-bg);\n    color: var(--toast-text);\n    border-radius: 10px;\n    padding: 9px 12px;\n    font-size: 12px;\n    z-index: 250;\n    backdrop-filter: blur(20px) saturate(180%);\n    -webkit-backdrop-filter: blur(20px) saturate(180%);\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);\n  }\n\n  /* macOS Style OverlayScrollbars */\n  :global(.os-theme-dark) {\n    --os-size: 10px; /* Default width */\n    --os-handle-border-radius: 10px;\n    --os-track-border-radius: 10px;\n    \n    /* Handle colors */\n    --os-handle-bg: rgba(0, 0, 0, 0.25);\n    --os-handle-bg-hover: rgba(0, 0, 0, 0.35);\n    --os-handle-bg-active: rgba(0, 0, 0, 0.45);\n    \n    --os-handle-border: rgba(0, 0, 0, 0.25);\n    --os-handle-border-hover: rgba(0, 0, 0, 0.35);\n    --os-handle-border-active: rgba(0, 0, 0, 0.45);\n\n    /* Track background is transparent by default */\n    --os-track-bg: transparent;\n    --os-track-bg-hover: rgba(0, 0, 0, 0.02);\n    --os-track-bg-active: rgba(0, 0, 0, 0.04);\n\n    --os-track-border: transparent;\n    --os-track-border-hover: rgba(0, 0, 0, 0.02);\n    --os-track-border-active: rgba(0, 0, 0, 0.04);\n  }\n\n  @media (prefers-color-scheme: dark) {\n    :global(.os-theme-dark) {\n      --os-handle-bg: rgba(255, 255, 255, 0.25);\n      --os-handle-bg-hover: rgba(255, 255, 255, 0.35);\n      --os-handle-bg-active: rgba(255, 255, 255, 0.45);\n      \n      --os-handle-border: rgba(255, 255, 255, 0.25);\n      --os-handle-border-hover: rgba(255, 255, 255, 0.35);\n      --os-handle-border-active: rgba(255, 255, 255, 0.45);\n      \n      --os-track-bg-hover: rgba(255, 255, 255, 0.02);\n      --os-track-bg-active: rgba(255, 255, 255, 0.04);\n\n      --os-track-border-hover: rgba(255, 255, 255, 0.02);\n      --os-track-border-active: rgba(255, 255, 255, 0.04);\n    }\n  }\n\n  /* Ensure scrollbar hits the very edges of the container, ignoring intersection */\n  :global(.os-scrollbar.os-scrollbar-vertical) {\n    bottom: 0 !important;\n  }\n  :global(.os-scrollbar.os-scrollbar-horizontal) {\n    right: 0 !important;\n  }\n\n  /* Smooth transitions for size and track color, instant fade-in */\n  :global(.os-scrollbar) {\n    transition: width 0.3s ease, height 0.3s ease, opacity 0s, visibility 0s, background-color 0.3s ease !important;\n  }\n  \n  /* Gradual fade-out only when hiding */\n  :global(.os-scrollbar.os-scrollbar-auto-hide-hidden) {\n    transition: width 0.3s ease, height 0.3s ease, opacity 0.4s ease-in-out, visibility 0.4s ease-in-out, background-color 0.3s ease !important;\n  }\n\n  /* Make sure only the active axis stays visible during scrolling or mouse interaction */\n  :global(.scrolling-y .os-scrollbar-horizontal),\n  :global(.scrolling-x .os-scrollbar-vertical),\n  :global([data-overlayscrollbars-initialize]:has(.os-scrollbar-vertical:hover) .os-scrollbar-horizontal),\n  :global([data-overlayscrollbars-initialize]:has(.os-scrollbar-vertical.os-scrollbar-interacting) .os-scrollbar-horizontal),\n  :global([data-overlayscrollbars-initialize]:has(.os-scrollbar-horizontal:hover) .os-scrollbar-vertical),\n  :global([data-overlayscrollbars-initialize]:has(.os-scrollbar-horizontal.os-scrollbar-interacting) .os-scrollbar-vertical) {\n    opacity: 0 !important;\n    visibility: hidden !important;\n    transition: opacity 0.4s ease-in-out, visibility 0.4s ease-in-out !important;\n  }\n\n  :global(.os-scrollbar-track),\n  :global(.os-scrollbar-handle) {\n    transition: width 0.3s ease, height 0.3s ease, background-color 0.3s ease !important;\n  }\n\n  /* Expand size and show track background when hovering over the scrollbar */\n  :global(.os-scrollbar:hover),\n  :global(.os-scrollbar:active),\n  :global(.os-scrollbar.os-scrollbar-interacting) {\n    --os-size: 15px; /* Expanded width */\n    background-color: var(--os-track-bg-hover);\n    border-radius: var(--os-track-border-radius);\n  }\n\n  :global(.os-scrollbar.os-scrollbar-interacting) {\n    background-color: var(--os-track-bg-active);\n  }\n</style>\n","structuredPatch":[{"oldStart":1013,"oldLines":19,"newStart":1013,"newLines":19,"lines":[" ","     const entry = results[idx];"," ","-    // Calculate overlay position mathematically.","-    // Name cell text starts at: padding-left(16) + icon(16) + gap(6) = 38px from cell left.","-    // Textarea has padding-left: 0 and border: 1.5px, so text starts ~2px from overlay left.","-    if (tableContainer) {","-      const rect = tableContainer.getBoundingClientRect();","-      const cellLeft = rect.left - tableContainer.scrollLeft;","-      const textLeft = cellLeft + 38;","-      const cellRight = cellLeft + colWidths.name;","-      const rowTop = rect.top + idx * rowHeight - tableContainer.scrollTop;","+    // Measure overlay position from the actual rendered DOM elements.","+    const visibleIndex = idx - startIndex;","+    const rowEl = tableContainer?.querySelectorAll('.row')?.[visibleIndex];","+    const nameCell = rowEl?.querySelector('.cell.name');","+    const span = nameCell?.querySelector('.ellipsis');","+    if (rowEl && nameCell && span) {","+      const rowRect = rowEl.getBoundingClientRect();","+      const spanRect = span.getBoundingClientRect();","+      const nameCellRect = nameCell.getBoundingClientRect();","       renameOverlay = {","-        top: rowTop,","-        left: textLeft - 2,","-        width: cellRight - textLeft + 2 - 4","+        top: rowRect.top,","+        left: spanRect.left - 2,","+        width: nameCellRect.right - spanRect.left - 2 - 8","       };","     }"," "]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"2618c459-223c-4b08-9bc1-7f176b986393"}
{"parentUuid":"67d0690a-2685-44c4-bfd2-2903c02d5ffe","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_011X27qkZJWaGQ1RuNW8CLLX","type":"message","role":"assistant","content":[{"type":"text","text":"ë¹Œë“œ í™•ì¸í•©ë‹ˆë‹¤."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":573,"cache_read_input_tokens":122064,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":573},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMQ5T75jVcZUZwZ4mDoc","type":"assistant","uuid":"ab08e539-c151-4064-9547-bced8d51bf47","timestamp":"2026-02-21T14:48:44.247Z"}
{"parentUuid":"ab08e539-c151-4064-9547-bced8d51bf47","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_011X27qkZJWaGQ1RuNW8CLLX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018d9hfNkQkmKoeA94BNg1Rc","name":"Bash","input":{"command":"npm run lint 2>&1 | tail -5","description":"Run lint check","timeout":60000},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":573,"cache_read_input_tokens":122064,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":573},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMQ5T75jVcZUZwZ4mDoc","type":"assistant","uuid":"252156df-a0cb-46f3-9418-fadd4610ba95","timestamp":"2026-02-21T14:48:45.075Z"}
{"parentUuid":"252156df-a0cb-46f3-9418-fadd4610ba95","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018d9hfNkQkmKoeA94BNg1Rc","type":"tool_result","content":"    at onwarn (file:REDACTED.js:65550:7)\n    at file:///Users/al02402336/everything/node_modules/rollup/dist/es/shared/node-entry.js:20972:13\n    at Object.logger [as onLog] (file:///Users/al02402336/everything/node_modules/rollup/dist/es/shared/node-entry.js:22945:9)\n    at ModuleLoader.handleInvalidResolvedId (file:///Users/al02402336/everything/node_modules/rollup/dist/es/shared/node-entry.js:21689:26)\n    at file:///Users/al02402336/everything/node_modules/rollup/dist/es/shared/node-entry.js:21647:26","is_error":false}]},"uuid":"d2b8b3ba-860a-4c14-b9b1-f001ebaa277a","timestamp":"2026-02-21T14:48:46.482Z","toolUseResult":{"stdout":"    at onwarn (file:REDACTED.js:65550:7)\n    at file:///Users/al02402336/everything/node_modules/rollup/dist/es/shared/node-entry.js:20972:13\n    at Object.logger [as onLog] (file:///Users/al02402336/everything/node_modules/rollup/dist/es/shared/node-entry.js:22945:9)\n    at ModuleLoader.handleInvalidResolvedId (file:///Users/al02402336/everything/node_modules/rollup/dist/es/shared/node-entry.js:21689:26)\n    at file:///Users/al02402336/everything/node_modules/rollup/dist/es/shared/node-entry.js:21647:26","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"252156df-a0cb-46f3-9418-fadd4610ba95"}
{"parentUuid":"d2b8b3ba-860a-4c14-b9b1-f001ebaa277a","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01Arpc5eSpeqSH9KKtCDabq7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0189EbUkgS3FG7nodi3YQFjj","name":"Bash","input":{"command":"npm run lint 2>&1 | grep -E \"(error|warning|âœ“|âœ—|built)\" | tail -10","description":"Check for build errors or warnings","timeout":60000},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":456,"cache_read_input_tokens":122637,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":456},"output_tokens":19,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMQ5nTAnHKECrnzNYrvU","type":"assistant","uuid":"6c2d4b53-500c-4631-a76a-cd7146c6f287","timestamp":"2026-02-21T14:48:49.607Z"}
{"parentUuid":"6c2d4b53-500c-4631-a76a-cd7146c6f287","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0189EbUkgS3FG7nodi3YQFjj","type":"tool_result","content":"âœ“ 6 modules transformed.\nerror during build:","is_error":false}]},"uuid":"1f463d93-e42e-4a13-b332-592c9b4f562d","timestamp":"2026-02-21T14:48:50.877Z","toolUseResult":{"stdout":"âœ“ 6 modules transformed.\nerror during build:","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"6c2d4b53-500c-4631-a76a-cd7146c6f287"}
{"parentUuid":"1f463d93-e42e-4a13-b332-592c9b4f562d","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01DNHi6tKqEd3rsj4akrLQgM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014yV7AmKKqydZcSZjKobM4g","name":"Bash","input":{"command":"npm run lint 2>&1 | grep -A5 \"error during build\"","description":"Get full error details","timeout":60000},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":145,"cache_read_input_tokens":123093,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":145},"output_tokens":19,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMQ67PCfNnMsLqrbCr91","type":"assistant","uuid":"d1f88e83-0341-4f2c-9077-f1b43fb5f582","timestamp":"2026-02-21T14:48:53.884Z"}
{"parentUuid":"d1f88e83-0341-4f2c-9077-f1b43fb5f582","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014yV7AmKKqydZcSZjKobM4g","type":"tool_result","content":"error during build:\n[vite]: Rollup failed to resolve import \"overlayscrollbars/overlayscrollbars.css\" from \"/Users/al02402336/everything/src/App.svelte\".\nThis is most likely unintended because it can break your application at runtime.\nIf you do want to externalize this module explicitly add it to\n`build.rollupOptions.external`\n    at viteWarn (file:REDACTED.js:65855:17)","is_error":false}]},"uuid":"3a302862-ed09-4436-8b72-e10a6d25b126","timestamp":"2026-02-21T14:48:55.271Z","toolUseResult":{"stdout":"error during build:\n[vite]: Rollup failed to resolve import \"overlayscrollbars/overlayscrollbars.css\" from \"/Users/al02402336/everything/src/App.svelte\".\nThis is most likely unintended because it can break your application at runtime.\nIf you do want to externalize this module explicitly add it to\n`build.rollupOptions.external`\n    at viteWarn (file:REDACTED.js:65855:17)","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"d1f88e83-0341-4f2c-9077-f1b43fb5f582"}
{"parentUuid":"3a302862-ed09-4436-8b72-e10a6d25b126","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_0187TbEp8zPocmu2gq9DZkBv","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The error is about `overlayscrollbars` CSS import in the file - not related to my changes. This must be something the user added separately. Let me check if the build was passing before my changes or if this is a pre-existing issue.","signature":"EpEDCkYICxgCKkACITyKlJbipt+gu1BWRG0BEkd+CcU4PO/XGx7ro9EeC767qBBc1gv1+4HBkJW+0GEqrUJhjpS5KLbg9sFUt3CjEgydT38xRJ0NCyzYjZUaDPLuXUXrks7LxPRAdyIw3nRjV3A+wrE/ossmF8oV++biN/hVhKpd2z5pZZCqZKX5KD/VCSj9yeWtHvt9gdpmKvgBUR8JTBqAUQNaSxAorDSfTnSR7Y0PP9OK/2x9MzmpMpq3ZEf1zziNdrAGH9Qoug+F9zq5v/w0uKEQONj2yaqDcmFG69lHNLiVjpRl4pjjaY0P0KmVyaX14sosJ9KlDiJGS4TYcnALxp03sTEiawpIVv38XCsw8q325yowq8N96Q2dBq2AvjZhKH1hUKbAm1gDjs3z111LDhnKOVY1QG+kjZeqv5DxLB1kvuFRpNv5Rqwn/ad5wLraD9hjOoJ/rqZiEYnRGAOithkvH8KgP1sC+FVpvsCYOM9dFiF2kX5d2BVZjQ4FBnxw2FCDXFaYmJsVo6/JMYKwN6MYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":262,"cache_read_input_tokens":123238,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":262},"output_tokens":9,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMQ6RztQHZPvrE2LaAH6","type":"assistant","uuid":"76e6343e-67f7-43d8-b9c4-795c2b8a34b1","timestamp":"2026-02-21T14:48:58.065Z"}
{"parentUuid":"76e6343e-67f7-43d8-b9c4-795c2b8a34b1","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_0187TbEp8zPocmu2gq9DZkBv","type":"message","role":"assistant","content":[{"type":"text","text":"ë‚´ ë³€ê²½ê³¼ ë¬´ê´€í•œ ê¸°ì¡´ import ì˜¤ë¥˜ìž…ë‹ˆë‹¤. ì œ ìˆ˜ì • ì´ì „ë¶€í„° ì¡´ìž¬í•˜ë˜ ë¬¸ì œì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":262,"cache_read_input_tokens":123238,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":262},"output_tokens":9,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMQ6RztQHZPvrE2LaAH6","type":"assistant","uuid":"d01a89c7-bafb-461e-8b1f-e5172262800a","timestamp":"2026-02-21T14:48:59.262Z"}
{"parentUuid":"d01a89c7-bafb-461e-8b1f-e5172262800a","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_0187TbEp8zPocmu2gq9DZkBv","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01U4bcF6Hgo2bTtAfaTtmXdN","name":"Bash","input":{"command":"git stash && npm run lint 2>&1 | grep -E \"(error|âœ“|built)\" | tail -5","description":"Check if build error exists before my changes","timeout":60000},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":262,"cache_read_input_tokens":123238,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":262},"output_tokens":9,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMQ6RztQHZPvrE2LaAH6","type":"assistant","uuid":"040064fa-408c-4cab-abec-b6b81c391a12","timestamp":"2026-02-21T14:49:00.179Z"}
{"parentUuid":"040064fa-408c-4cab-abec-b6b81c391a12","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01U4bcF6Hgo2bTtAfaTtmXdN","type":"tool_result","content":"Saved working directory and index state WIP on main: ab1de36 Resolve merge conflicts: keep overlay titlebar, font imports, set_native_theme, scroll handler\nâœ“ 6 modules transformed.\nerror during build:","is_error":false}]},"uuid":"aecdc8b2-7dc9-4334-8c0d-125a3c9b8e2f","timestamp":"2026-02-21T14:49:03.022Z","toolUseResult":{"stdout":"Saved working directory and index state WIP on main: ab1de36 Resolve merge conflicts: keep overlay titlebar, font imports, set_native_theme, scroll handler\nâœ“ 6 modules transformed.\nerror during build:","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"040064fa-408c-4cab-abec-b6b81c391a12"}
{"parentUuid":"aecdc8b2-7dc9-4334-8c0d-125a3c9b8e2f","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01Si4wbEtLmrBb5hzmkEQNgt","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The stash reverted my changes - the system reminder shows the old code is back. And the build is still failing even without my changes. So the error is pre-existing (from the user's other changes). Let me restore my stash and see what's happening.","signature":"EqADCkYICxgCKkBvt3c9RFJ9K1zfvRnxsMueJ/xXxmC9IY/jlY6rsjqw9A2JuimxRc/qsqZ0mqbYBAO7ij+WON4ar6vn+RqPfHG+Egwmp7WcqCceCuzf7qoaDHDqG93P+d/Yvu0I/iIwYrP49m9+MqjtbXDGpo9VEl52wmCX6vFhcbke/yiN2cOhuWCmhSmA5zd3hlBRg6uQKocCvWMriT84kF8TgPs5MQOrOsdw13NOvBl/7/zDPIwXWcf2H0NSeP7JUvcT0QGN0/zftkLVL7KZqnlVOWLZ62/FM6o1dpOv66SSUL982l6nWipKeqzYOAlnpLJU4yQU9BlOJNmhiDSOLsPs2Wqs92orI9bmRpHluM8q57vjkjUE23rmdrDxY0sLR2oa52k8pstlhqASCX8Std3APFFRZ20FRZkVsle7Q1kILbw1s25V43JJ6pwTjQ3tIrbNn58jJmvHN9m0HHCEYyyCYcRGxVPRNBxZXX8UEcl2MdeWjRaMLT1arq7bD0Oj6A9mYUvpPs8ZuJhuisEfnZlfhnUhysXu4fbc8V4WGyIYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":805,"cache_read_input_tokens":123500,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":805},"output_tokens":9,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMQ72WYBvEdhVsBfZQMN","type":"assistant","uuid":"c08a2f15-eeef-4b0c-83d5-d06310145e4c","timestamp":"2026-02-21T14:49:06.298Z"}
{"parentUuid":"c08a2f15-eeef-4b0c-83d5-d06310145e4c","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01Si4wbEtLmrBb5hzmkEQNgt","type":"message","role":"assistant","content":[{"type":"text","text":"ë¹Œë“œ ì˜¤ë¥˜ëŠ” ë‚´ ë³€ê²½ ì´ì „ë¶€í„° ì¡´ìž¬. stashë¥¼ ë³µì›í•©ë‹ˆë‹¤."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":805,"cache_read_input_tokens":123500,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":805},"output_tokens":9,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMQ72WYBvEdhVsBfZQMN","type":"assistant","uuid":"afe69425-ca18-49c5-b5ce-154ea89e7984","timestamp":"2026-02-21T14:49:06.920Z"}
{"parentUuid":"afe69425-ca18-49c5-b5ce-154ea89e7984","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01Si4wbEtLmrBb5hzmkEQNgt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Q3DekKxhXgACaBkWf3CKGd","name":"Bash","input":{"command":"git stash pop","description":"Restore my changes"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":805,"cache_read_input_tokens":123500,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":805},"output_tokens":9,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMQ72WYBvEdhVsBfZQMN","type":"assistant","uuid":"5b7abec8-dd9f-4bd6-88d7-f242727eaf1c","timestamp":"2026-02-21T14:49:07.334Z"}
{"parentUuid":"5b7abec8-dd9f-4bd6-88d7-f242727eaf1c","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Q3DekKxhXgACaBkWf3CKGd","type":"tool_result","content":"On branch main\nYour branch is up to date with 'origin/main'.\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   src/App.svelte\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\tdoc/app_v2.pen\n\tdoc/image.png\n\tdoc/images/\n\tdoc/untitled.pen\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nDropped refs/stash@{0} (f872c5a5c4ceb77939a2c7c0975cd6082ec763c9)","is_error":false}]},"uuid":"93892468-79eb-41d2-9551-104800cc73b5","timestamp":"2026-02-21T14:49:08.691Z","toolUseResult":{"stdout":"On branch main\nYour branch is up to date with 'origin/main'.\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   src/App.svelte\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\tdoc/app_v2.pen\n\tdoc/image.png\n\tdoc/images/\n\tdoc/untitled.pen\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nDropped refs/stash@{0} (f872c5a5c4ceb77939a2c7c0975cd6082ec763c9)","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"5b7abec8-dd9f-4bd6-88d7-f242727eaf1c"}
{"parentUuid":"93892468-79eb-41d2-9551-104800cc73b5","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01XGxALvy1ijFTwL1bNCZFqu","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"OK, so the build error is pre-existing (unrelated to my changes). The `overlayscrollbars` import must have been added by the user separately. My changes are correct.\n\nNow let me verify my DOM-measurement change was restored properly.","signature":"EpIDCkYICxgCKkBffSxvSNALwfwg3MOBcK6CE0mqhZZt88jWLzmZHc6Z4l5gFpStXq+OGTXkj6DEi0Tfthl2H3ZcfCXGpDdSJKRrEgwD7XqS7iARzb570LgaDCPc+R7+q7YMY0ArXSIw7IgVYIy1IPE6OPQdmpoEbplXWXh2XOAjbvxkav1ZxudxCvWfQDCSXaFg00Wh6XLbKvkBJx1lgP18pu9rwHckJ9WJTUvo+J3+LPl88x5BvLS/N6Lk2S8vi9Pl3lQPj3URrzEupu4BdUn1MSj6AWL+LAae1iKPdhk3HUk+fYaYj3LbaZH3iBar8+VOQQQ8LnGHozcbypbe089KYzrqUyAmsMBJPFUDDrj9Dnhl1TLMgVMbSgnDYIpzClmiU6hkC5Lq98KJMYP020IInvWZwQWb8N2dQS1RSboRXXiG4MWZ0w7ixyKGtRXnNH4/3tVnXaZjfDPMhK19X3bKn2yp7lrFPdEIe6quCtxg3cPqfL6T0tpx64wNwLO1f7ISoW8+FKYNwCLjhvwyU6Kj1v/SGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":378,"cache_read_input_tokens":124305,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":378},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMQ7RrjEoXdVJHXy8dW9","type":"assistant","uuid":"6f6414b4-a61f-4da2-a28e-67bea2092264","timestamp":"2026-02-21T14:49:11.839Z"}
{"parentUuid":"6f6414b4-a61f-4da2-a28e-67bea2092264","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01XGxALvy1ijFTwL1bNCZFqu","type":"message","role":"assistant","content":[{"type":"text","text":"`overlayscrollbars` ì—ëŸ¬ëŠ” ë‚´ ë³€ê²½ ì „ë¶€í„° ìžˆë˜ ê¸°ì¡´ ë¬¸ì œìž…ë‹ˆë‹¤. ë‚´ ìˆ˜ì •ì´ ì œëŒ€ë¡œ ë³µì›ë˜ì—ˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":378,"cache_read_input_tokens":124305,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":378},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMQ7RrjEoXdVJHXy8dW9","type":"assistant","uuid":"b6e7e4d9-ba89-44b8-bd2d-456edbd884b4","timestamp":"2026-02-21T14:49:12.969Z"}
{"parentUuid":"b6e7e4d9-ba89-44b8-bd2d-456edbd884b4","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01XGxALvy1ijFTwL1bNCZFqu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018TUChTyxcPf23ABRfy8Kpd","name":"Read","input":{"file_path":"/Users/al02402336/everything/src/App.svelte","offset":1014,"limit":20},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":378,"cache_read_input_tokens":124305,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":378},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMQ7RrjEoXdVJHXy8dW9","type":"assistant","uuid":"1f498068-df5e-46e8-948a-202fbfead619","timestamp":"2026-02-21T14:49:13.787Z"}
{"parentUuid":"1f498068-df5e-46e8-948a-202fbfead619","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_018TUChTyxcPf23ABRfy8Kpd","toolUseID":"toolu_018TUChTyxcPf23ABRfy8Kpd","timestamp":"2026-02-21T14:49:13.816Z","uuid":"de7e2425-5c8c-45f4-ac78-aa1d84e25c22"}
{"parentUuid":"1f498068-df5e-46e8-948a-202fbfead619","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018TUChTyxcPf23ABRfy8Kpd","type":"tool_result","content":"  1014â†’    const entry = results[idx];\n  1015â†’\n  1016â†’    // Measure overlay position from the actual rendered DOM elements.\n  1017â†’    const visibleIndex = idx - startIndex;\n  1018â†’    const rowEl = tableContainer?.querySelectorAll('.row')?.[visibleIndex];\n  1019â†’    const nameCell = rowEl?.querySelector('.cell.name');\n  1020â†’    const span = nameCell?.querySelector('.ellipsis');\n  1021â†’    if (rowEl && nameCell && span) {\n  1022â†’      const rowRect = rowEl.getBoundingClientRect();\n  1023â†’      const spanRect = span.getBoundingClientRect();\n  1024â†’      const nameCellRect = nameCell.getBoundingClientRect();\n  1025â†’      renameOverlay = {\n  1026â†’        top: rowRect.top,\n  1027â†’        left: spanRect.left - 2,\n  1028â†’        width: nameCellRect.right - spanRect.left - 2 - 8\n  1029â†’      };\n  1030â†’    }\n  1031â†’\n  1032â†’    editing = {\n  1033â†’      active: true,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"4739fa8b-169e-4e67-89e1-aa240493649b","timestamp":"2026-02-21T14:49:13.815Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src/App.svelte","content":"    const entry = results[idx];\n\n    // Measure overlay position from the actual rendered DOM elements.\n    const visibleIndex = idx - startIndex;\n    const rowEl = tableContainer?.querySelectorAll('.row')?.[visibleIndex];\n    const nameCell = rowEl?.querySelector('.cell.name');\n    const span = nameCell?.querySelector('.ellipsis');\n    if (rowEl && nameCell && span) {\n      const rowRect = rowEl.getBoundingClientRect();\n      const spanRect = span.getBoundingClientRect();\n      const nameCellRect = nameCell.getBoundingClientRect();\n      renameOverlay = {\n        top: rowRect.top,\n        left: spanRect.left - 2,\n        width: nameCellRect.right - spanRect.left - 2 - 8\n      };\n    }\n\n    editing = {\n      active: true,","numLines":20,"startLine":1014,"totalLines":2506}},"sourceToolAssistantUUID":"1f498068-df5e-46e8-948a-202fbfead619"}
{"parentUuid":"4739fa8b-169e-4e67-89e1-aa240493649b","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_011Pux7cBzLnKZ5pAgm6kD4D","type":"message","role":"assistant","content":[{"type":"text","text":"ì •ìƒì ìœ¼ë¡œ ë³µì›ë˜ì—ˆìŠµë‹ˆë‹¤.\n\nìˆ˜ì • ë‚´ìš©:\n\nê¸°ì¡´ ìˆ˜í•™ ê³„ì‚° ë°©ì‹ (padding 16 + icon 16 + gap 6 = 38px ë“±ì„ ì§ì ‘ ë”í•˜ëŠ” ë°©ì‹)ì„ **ì‹¤ì œ DOM ì¸¡ì •**ìœ¼ë¡œ êµì²´í–ˆìŠµë‹ˆë‹¤.\n\n```\nrowRect.top    â†’ row divì˜ ì‹¤ì œ viewport Y ì¢Œí‘œ\nspanRect.left  â†’ íŒŒì¼ëª… spanì˜ ì‹¤ì œ viewport X ì¢Œí‘œ (padding/icon/gap ê³„ì‚° ì—†ì´ ì •í™•)\nnameCellRect.right â†’ ì´ë¦„ ì…€ ì˜¤ë¥¸ìª½ ëì˜ ì‹¤ì œ ì¢Œí‘œ\n```\n\nìˆ˜í•™ ê³„ì‚°ì€ CSSì—ì„œ ì •ì˜í•œ ê°’(padding-left: 16, icon: 16, gap: 6)ì´ ì‹¤ì œ ë Œë”ë§ê³¼ ì •í™•ížˆ ì¼ì¹˜í•´ì•¼ í•˜ëŠ”ë°, `[data-theme]` ì˜¤ë²„ë¼ì´ë“œë‚˜ ë””ë°”ì´ìŠ¤ í”½ì…€ ë¹„ìœ¨ ë“±ì—ì„œ ë¯¸ì„¸ ì˜¤ì°¨ê°€ ìƒê¸¸ ìˆ˜ ìžˆìŠµë‹ˆë‹¤. DOM ì¸¡ì •ì€ ë¸Œë¼ìš°ì €ê°€ ì‹¤ì œë¡œ ë Œë”ë§í•œ ìœ„ì¹˜ë¥¼ ê·¸ëŒ€ë¡œ ì½ì–´ì˜¤ë¯€ë¡œ í•­ìƒ ì •í™•í•©ë‹ˆë‹¤."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":618,"cache_read_input_tokens":124683,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":618},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMQ7oN3DzFegYqpfTwTh","type":"assistant","uuid":"06e4d2a8-c070-4941-8a19-7b51e036f281","timestamp":"2026-02-21T14:49:21.576Z"}
{"parentUuid":"06e4d2a8-c070-4941-8a19-7b51e036f281","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"entire hooks claude-code stop"},"parentToolUseID":"8653ee2e-df07-49c0-9911-3a6c05640d93","toolUseID":"8653ee2e-df07-49c0-9911-3a6c05640d93","timestamp":"2026-02-21T14:49:21.623Z","uuid":"1701f87f-2ddf-4ad0-9bfd-4bc48b8fbec7"}
{"parentUuid":"1701f87f-2ddf-4ad0-9bfd-4bc48b8fbec7","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"system","subtype":"stop_hook_summary","hookCount":1,"hookInfos":[{"command":"entire hooks claude-code stop","durationMs":3856}],"hookErrors":[],"preventedContinuation":false,"stopReason":"","hasOutput":true,"level":"suggestion","timestamp":"2026-02-21T14:49:25.479Z","uuid":"3c329b73-719d-4006-846b-3d62691ec180","toolUseID":"8653ee2e-df07-49c0-9911-3a6c05640d93"}
{"parentUuid":"3c329b73-719d-4006-846b-3d62691ec180","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"system","subtype":"turn_duration","durationMs":298087,"timestamp":"2026-02-21T14:49:25.481Z","uuid":"7b555d98-9626-4456-a333-8e2a0f48e35d","isMeta":false}
{"type":"file-history-snapshot","messageId":"8bebf628-2981-4dd8-857b-7cc5254c8d41","snapshot":{"messageId":"8bebf628-2981-4dd8-857b-7cc5254c8d41","trackedFileBackups":{"src/App.svelte":{"backupFileName":"f2ffc3f5647f6015@v3","version":3,"backupTime":"2026-02-21T14:51:22.782Z"}},"timestamp":"2026-02-21T14:51:22.782Z"},"isSnapshotUpdate":false}
{"parentUuid":"7b555d98-9626-4456-a333-8e2a0f48e35d","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":"ì•„ì§ rename ìž…ë ¥ë°•ìŠ¤ê°€ ëœ¨ë©´ì„œ í…ìŠ¤íŠ¸ê°€ ì¡°ê¸ˆ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì›€ì§ì—¬"},"uuid":"8bebf628-2981-4dd8-857b-7cc5254c8d41","timestamp":"2026-02-21T14:51:20.771Z","permissionMode":"bypassPermissions"}
{"parentUuid":"8bebf628-2981-4dd8-857b-7cc5254c8d41","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"type":"text","text":"[Request interrupted by user]"}]},"uuid":"7f2963c3-9c4d-46a6-8105-2d95398fd698","timestamp":"2026-02-21T14:51:49.049Z"}
{"type":"file-history-snapshot","messageId":"c11de54a-2d76-4d75-847d-c82976878651","snapshot":{"messageId":"c11de54a-2d76-4d75-847d-c82976878651","trackedFileBackups":{"src/App.svelte":{"backupFileName":"f2ffc3f5647f6015@v3","version":3,"backupTime":"2026-02-21T14:51:22.782Z"}},"timestamp":"2026-02-21T14:51:57.559Z"},"isSnapshotUpdate":false}
{"parentUuid":"7f2963c3-9c4d-46a6-8105-2d95398fd698","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":"ì•„ì§ rename ìž…ë ¥ë°•ìŠ¤ê°€ ëœ¨ë©´ì„œ í…ìŠ¤íŠ¸ê°€ ì¡°ê¸ˆ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì›€ì§ì—¬. 2~3px"},"uuid":"c11de54a-2d76-4d75-847d-c82976878651","timestamp":"2026-02-21T14:51:55.514Z","permissionMode":"bypassPermissions"}
{"parentUuid":"c11de54a-2d76-4d75-847d-c82976878651","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"type":"text","text":"[Request interrupted by user]"}]},"uuid":"039bcc3c-bad8-4564-89cc-2e3156eda1cb","timestamp":"2026-02-21T14:53:07.006Z"}
{"type":"file-history-snapshot","messageId":"412fa22c-9257-48b6-854f-5b6cb20755aa","snapshot":{"messageId":"412fa22c-9257-48b6-854f-5b6cb20755aa","trackedFileBackups":{"src/App.svelte":{"backupFileName":"f2ffc3f5647f6015@v4","version":4,"backupTime":"2026-02-22T07:29:26.391Z"}},"timestamp":"2026-02-22T07:29:26.390Z"},"isSnapshotUpdate":false}
{"parentUuid":"039bcc3c-bad8-4564-89cc-2e3156eda1cb","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":"reser í–ˆë”ë‹ˆ 1ë¶„ ë„˜ê²Œê±¸ë ¤. 50ì´ˆ ë¯¸ë§Œìœ¼ë¡œ ì¤„ì—¬ì¤˜"},"uuid":"412fa22c-9257-48b6-854f-5b6cb20755aa","timestamp":"2026-02-22T07:29:23.433Z","permissionMode":"bypassPermissions"}
{"parentUuid":"412fa22c-9257-48b6-854f-5b6cb20755aa","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"type":"text","text":"[Request interrupted by user]"}]},"uuid":"d558aca1-76c3-494c-93a5-ba06961725df","timestamp":"2026-02-22T07:29:37.431Z"}
{"type":"file-history-snapshot","messageId":"42171a04-0aa4-49b8-9cdb-9a3ff7f5b807","snapshot":{"messageId":"42171a04-0aa4-49b8-9cdb-9a3ff7f5b807","trackedFileBackups":{"src/App.svelte":{"backupFileName":"f2ffc3f5647f6015@v4","version":4,"backupTime":"2026-02-22T07:29:26.391Z"}},"timestamp":"2026-02-22T07:29:47.881Z"},"isSnapshotUpdate":false}
{"parentUuid":"d558aca1-76c3-494c-93a5-ba06961725df","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":"reset í–ˆë”ë‹ˆ 1ë¶„ ë„˜ê²Œê±¸ë ¤. 50ì´ˆ ë¯¸ë§Œìœ¼ë¡œ ì¤„ì—¬ì¤˜"},"uuid":"42171a04-0aa4-49b8-9cdb-9a3ff7f5b807","timestamp":"2026-02-22T07:29:45.538Z","permissionMode":"bypassPermissions"}
{"parentUuid":"42171a04-0aa4-49b8-9cdb-9a3ff7f5b807","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01AwBjGmBxph6Rj5C4ccgaJ2","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user wants to optimize the index reset/rebuild time to under 50 seconds. Let me look at the backend code to understand the indexing process.","signature":"ErkCCkYICxgCKkC+KNHzszF4F1RutL5GrdsEnWCGApMFobebah8hfDKfFZMnqndC10edy1Ednc7UgeeYX4yXaEnIj6sgKebgrPQuEgy0tpJLgI0wxsJl8EMaDKboqJtRuRlJgB/VYiIw7a/nvjBXzLn/9AeNl40HzSUfu/cr6McMXIYZ/Juqrt2d0rOvEORnm5RMB16rgvT2KqABDYfWNISWN+eK9G8qlkjeihV+i/AtYhkUwgCiayHs0WMAjkoLkbS49++dHMn63KmQd8O5vn/gP7abAZN9Dk6Eb+c9WZSfj6OTlK9JZ1+h1VrsRdO4kFpUXWUo8CUqQoG1eNwY14txE8aCfCUeXYS3lZwvlbEw/SUQ600ERKlTNNdHMWR6oS5XntBlQmyBrk9Zlx9ByWVshTgkxVwD7zjvLBgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":36,"cache_read_input_tokens":125810,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":36},"output_tokens":6,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNiRB7KKBJZcUY8qv4XB","type":"assistant","uuid":"4520cc90-90a9-4aff-abcc-910d5ae281ca","timestamp":"2026-02-22T07:29:51.074Z"}
{"parentUuid":"4520cc90-90a9-4aff-abcc-910d5ae281ca","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01AwBjGmBxph6Rj5C4ccgaJ2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Q4YKjC5JcRQFJWQgwmwGEx","name":"Read","input":{"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","offset":1,"limit":80},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":36,"cache_read_input_tokens":125810,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":36},"output_tokens":6,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNiRB7KKBJZcUY8qv4XB","type":"assistant","uuid":"d98b182c-5c23-44f0-a510-230c05d03280","timestamp":"2026-02-22T07:29:51.725Z"}
{"parentUuid":"d98b182c-5c23-44f0-a510-230c05d03280","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01Q4YKjC5JcRQFJWQgwmwGEx","toolUseID":"toolu_01Q4YKjC5JcRQFJWQgwmwGEx","timestamp":"2026-02-22T07:29:51.771Z","uuid":"6e016a66-7886-4936-94d2-496a3595c336"}
{"parentUuid":"d98b182c-5c23-44f0-a510-230c05d03280","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Q4YKjC5JcRQFJWQgwmwGEx","type":"tool_result","content":"     1â†’#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\n     2â†’\n     3â†’use std::{\n     4â†’    cmp::Ordering,\n     5â†’    collections::{HashMap, HashSet},\n     6â†’    fs,\n     7â†’    hash::{Hash, Hasher},\n     8â†’    io::{self, BufRead, BufReader, Write},\n     9â†’    path::{Path, PathBuf},\n    10â†’    process::{Command, Stdio},\n    11â†’    sync::{\n    12â†’        atomic::{AtomicBool, Ordering as AtomicOrdering},\n    13â†’        Arc, OnceLock,\n    14â†’    },\n    15â†’    time::{Duration, Instant, SystemTime, UNIX_EPOCH},\n    16â†’};\n    17â†’\n    18â†’use parking_lot::{Mutex, RwLock};\n    19â†’use rusqlite::{params, params_from_iter, types::Value as SqlValue, Connection};\n    20â†’use serde::Serialize;\n    21â†’use tauri::{AppHandle, Emitter, Manager, State};\n    22â†’#[cfg(target_os = \"macos\")]\n    23â†’use tauri_plugin_global_shortcut::{Code, GlobalShortcutExt, Modifiers, Shortcut};\n    24â†’#[cfg(target_os = \"windows\")]\n    25â†’use std::os::windows::process::CommandExt;\n    26â†’use walkdir::WalkDir;\n    27â†’\n    28â†’mod fd_search;\n    29â†’mod gitignore_filter;\n    30â†’#[cfg(target_os = \"macos\")]\n    31â†’mod mac;\n    32â†’mod mem_search;\n    33â†’mod query;\n    34â†’#[cfg(target_os = \"windows\")]\n    35â†’mod win;\n    36â†’use fd_search::{FdSearchCache, FdSearchResultDto};\n    37â†’use query::{escape_like, parse_query, SearchMode};\n    38â†’\n    39â†’const DEFAULT_LIMIT: u32 = 300;\n    40â†’const SHORT_QUERY_LIMIT: u32 = 100;\n    41â†’const MAX_LIMIT: u32 = 1000;\n    42â†’pub(crate) const BATCH_SIZE: usize = 10_000;\n    43â†’const RECENT_OP_TTL: Duration = Duration::from_secs(2);\n    44â†’pub(crate) const WATCH_DEBOUNCE: Duration = Duration::from_millis(300);\n    45â†’const NEGATIVE_CACHE_TTL: Duration = Duration::from_secs(60);\n    46â†’const NEGATIVE_CACHE_FALLBACK_WINDOW: Duration = Duration::from_millis(550);\n    47â†’const DB_VERSION: i32 = 4;\n    48â†’const DEFERRED_DIR_NAMES: &[&str] = &[\n    49â†’    \"Library\", \".Trash\", \".Trashes\",\n    50â†’    // Windows system directories (deferred when scan_root is C:\\)\n    51â†’    \"Windows\", \"Program Files\", \"Program Files (x86)\",\n    52â†’    \"$Recycle.Bin\", \"System Volume Information\", \"Recovery\", \"PerfLogs\",\n    53â†’];\n    54â†’const SHALLOW_SCAN_DEPTH: usize = 6;\n    55â†’fn jwalk_num_threads() -> usize {\n    56â†’    std::thread::available_parallelism()\n    57â†’        .map(|n| (n.get() / 2).max(4).min(16))\n    58â†’        .unwrap_or(8)\n    59â†’}\n    60â†’\n    61â†’pub(crate) const BUILTIN_SKIP_NAMES: &[&str] = &[\n    62â†’    \".git\",\n    63â†’    \"node_modules\",\n    64â†’    \".Trash\",\n    65â†’    \".Trashes\",\n    66â†’    \".npm\",\n    67â†’    \".cache\",\n    68â†’    \"CMakeFiles\",\n    69â†’    \".qtc_clangd\",\n    70â†’    \"__pycache__\",\n    71â†’    \".gradle\",\n    72â†’    \"DerivedData\",\n    73â†’];\n    74â†’\n    75â†’/// Path segments whose name ends with one of these suffixes are skipped.\n    76â†’/// e.g. \"*.build\" skips Xcode intermediate build directories like \"MyApp.build\".\n    77â†’pub(crate) const BUILTIN_SKIP_SUFFIXES: &[&str] = &[\n    78â†’    \".build\", // Xcode intermediate build dir (MyApp.build, Objects-normal, etc.)\n    79â†’];\n    80â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"7fa30f50-f291-4b08-971c-346174c7e2d1","timestamp":"2026-02-22T07:29:51.769Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src-tauri/src/main.rs","content":"#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\n\nuse std::{\n    cmp::Ordering,\n    collections::{HashMap, HashSet},\n    fs,\n    hash::{Hash, Hasher},\n    io::{self, BufRead, BufReader, Write},\n    path::{Path, PathBuf},\n    process::{Command, Stdio},\n    sync::{\n        atomic::{AtomicBool, Ordering as AtomicOrdering},\n        Arc, OnceLock,\n    },\n    time::{Duration, Instant, SystemTime, UNIX_EPOCH},\n};\n\nuse parking_lot::{Mutex, RwLock};\nuse rusqlite::{params, params_from_iter, types::Value as SqlValue, Connection};\nuse serde::Serialize;\nuse tauri::{AppHandle, Emitter, Manager, State};\n#[cfg(target_os = \"macos\")]\nuse tauri_plugin_global_shortcut::{Code, GlobalShortcutExt, Modifiers, Shortcut};\n#[cfg(target_os = \"windows\")]\nuse std::os::windows::process::CommandExt;\nuse walkdir::WalkDir;\n\nmod fd_search;\nmod gitignore_filter;\n#[cfg(target_os = \"macos\")]\nmod mac;\nmod mem_search;\nmod query;\n#[cfg(target_os = \"windows\")]\nmod win;\nuse fd_search::{FdSearchCache, FdSearchResultDto};\nuse query::{escape_like, parse_query, SearchMode};\n\nconst DEFAULT_LIMIT: u32 = 300;\nconst SHORT_QUERY_LIMIT: u32 = 100;\nconst MAX_LIMIT: u32 = 1000;\npub(crate) const BATCH_SIZE: usize = 10_000;\nconst RECENT_OP_TTL: Duration = Duration::from_secs(2);\npub(crate) const WATCH_DEBOUNCE: Duration = Duration::from_millis(300);\nconst NEGATIVE_CACHE_TTL: Duration = Duration::from_secs(60);\nconst NEGATIVE_CACHE_FALLBACK_WINDOW: Duration = Duration::from_millis(550);\nconst DB_VERSION: i32 = 4;\nconst DEFERRED_DIR_NAMES: &[&str] = &[\n    \"Library\", \".Trash\", \".Trashes\",\n    // Windows system directories (deferred when scan_root is C:\\)\n    \"Windows\", \"Program Files\", \"Program Files (x86)\",\n    \"$Recycle.Bin\", \"System Volume Information\", \"Recovery\", \"PerfLogs\",\n];\nconst SHALLOW_SCAN_DEPTH: usize = 6;\nfn jwalk_num_threads() -> usize {\n    std::thread::available_parallelism()\n        .map(|n| (n.get() / 2).max(4).min(16))\n        .unwrap_or(8)\n}\n\npub(crate) const BUILTIN_SKIP_NAMES: &[&str] = &[\n    \".git\",\n    \"node_modules\",\n    \".Trash\",\n    \".Trashes\",\n    \".npm\",\n    \".cache\",\n    \"CMakeFiles\",\n    \".qtc_clangd\",\n    \"__pycache__\",\n    \".gradle\",\n    \"DerivedData\",\n];\n\n/// Path segments whose name ends with one of these suffixes are skipped.\n/// e.g. \"*.build\" skips Xcode intermediate build directories like \"MyApp.build\".\npub(crate) const BUILTIN_SKIP_SUFFIXES: &[&str] = &[\n    \".build\", // Xcode intermediate build dir (MyApp.build, Objects-normal, etc.)\n];\n","numLines":80,"startLine":1,"totalLines":5753}},"sourceToolAssistantUUID":"d98b182c-5c23-44f0-a510-230c05d03280"}
{"parentUuid":"7fa30f50-f291-4b08-971c-346174c7e2d1","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01NJUvC8DEyKE8bbYzoh3UNf","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WyKpUwQ4jBZC145LAixorY","name":"Bash","input":{"command":"wc -l /Users/al02402336/everything/src-tauri/src/main.rs","description":"Check file length"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1530,"cache_read_input_tokens":125846,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1530},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNiRTZXJHkrtkq2Yms1X","type":"assistant","uuid":"c9b0d3cb-8e2c-4dc2-9ef9-96afea8404b1","timestamp":"2026-02-22T07:29:54.293Z"}
{"parentUuid":"c9b0d3cb-8e2c-4dc2-9ef9-96afea8404b1","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WyKpUwQ4jBZC145LAixorY","type":"tool_result","content":"    5752 /Users/al02402336/everything/src-tauri/src/main.rs","is_error":false}]},"uuid":"37d7ce85-cc7a-4262-a57b-217640efcfcc","timestamp":"2026-02-22T07:29:54.484Z","toolUseResult":{"stdout":"    5752 /Users/al02402336/everything/src-tauri/src/main.rs","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"c9b0d3cb-8e2c-4dc2-9ef9-96afea8404b1"}
{"parentUuid":"37d7ce85-cc7a-4262-a57b-217640efcfcc","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01MYBXkmCh9fEFRhsZdgPx1L","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","name":"Task","input":{"description":"Find indexing bottleneck","subagent_type":"Explore","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures)."},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":130,"cache_read_input_tokens":127376,"output_tokens":318,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":130,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYNiReyrsFoEHJYpiJyuX","type":"assistant","uuid":"1071234a-675f-428d-94f5-9eb92820631e","timestamp":"2026-02-22T07:30:02.026Z"}
{"parentUuid":"1071234a-675f-428d-94f5-9eb92820631e","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Task","command":"entire hooks claude-code pre-task"},"toolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"6e5c6f57-1e83-4863-9ef0-57ea1dc2fd10","timestamp":"2026-02-22T07:30:02.031Z"}
{"type":"queue-operation","operation":"enqueue","timestamp":"2026-02-22T07:30:03.257Z","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","content":"{\"task_id\":\"abf02c2\",\"tool_use_id\":\"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj\",\"description\":\"Find indexing bottleneck\",\"task_type\":\"local_agent\"}"}
{"parentUuid":"6e5c6f57-1e83-4863-9ef0-57ea1dc2fd10","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"type":"text","text":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures)."}]},"uuid":"6ada0a50-0d58-4d2f-bea8-b4d0d846a44b","timestamp":"2026-02-22T07:30:03.257Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"b905509f-7806-4706-bc42-c1b5a1ee85b2","timestamp":"2026-02-22T07:30:03.257Z"}
{"parentUuid":"b905509f-7806-4706-bc42-c1b5a1ee85b2","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-22T07:30:05.205Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_011jJoYUvMoNMnsUQP8KMi1x","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012Psdc95gwWCZiWLWnAeQa4","name":"Bash","input":{"command":"wc -l /Users/al02402336/everything/src-tauri/src/main.rs"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":21573,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":21573},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CYNiSJ7XNLM5fmvi5sKrj","uuid":"e270ae76-2603-4f2a-b59f-94fbb69c57b9"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"f326c5c2-91be-4428-b0fc-aac07223acaa","timestamp":"2026-02-22T07:30:05.206Z"}
{"parentUuid":"f326c5c2-91be-4428-b0fc-aac07223acaa","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012Psdc95gwWCZiWLWnAeQa4","type":"tool_result","content":"    5752 /Users/al02402336/everything/src-tauri/src/main.rs","is_error":false}]},"uuid":"c7c7d69f-b660-4d33-8cd0-4cece1cd5589","timestamp":"2026-02-22T07:30:05.341Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"ea503369-ca38-4c61-8668-65709981a10f","timestamp":"2026-02-22T07:30:05.343Z"}
{"parentUuid":"ea503369-ca38-4c61-8668-65709981a10f","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-22T07:30:07.684Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_016qKNqU6uV8CuFH2B1VRSwt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01J68FPj6baKKv2YRN6MCFg6","name":"Grep","input":{"pattern":"fn reset_index|fn.*full_index|fn run_index|fn.*index","type":"rust","path":"/Users/al02402336/everything/src-tauri/src","output_mode":"content"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":172,"cache_read_input_tokens":21573,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":172},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CYNiST2ocMuuyduDcdxut","uuid":"e9f2e75c-e83e-4ef8-b670-f86d03418016"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"3b204354-6014-4aa7-b44e-4eb76bc5e70b","timestamp":"2026-02-22T07:30:07.684Z"}
{"parentUuid":"3b204354-6014-4aa7-b44e-4eb76bc5e70b","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-22T07:30:08.158Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_016qKNqU6uV8CuFH2B1VRSwt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019DKE8udRFEr2DC5j3UjyRR","name":"Grep","input":{"pattern":"BATCH_SIZE|batch_size","type":"rust","path":"/Users/al02402336/everything/src-tauri/src","output_mode":"content"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":172,"cache_read_input_tokens":21573,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":172},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CYNiST2ocMuuyduDcdxut","uuid":"73f31971-b2f0-4624-bc24-9b29f8626932"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"dcd3c8b1-a056-4e19-87bf-42efbb90585f","timestamp":"2026-02-22T07:30:08.158Z"}
{"parentUuid":"dcd3c8b1-a056-4e19-87bf-42efbb90585f","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-22T07:30:08.590Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_016qKNqU6uV8CuFH2B1VRSwt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JtfTkru4rvCB6uQZd27V2V","name":"Grep","input":{"pattern":"PRAGMA|synchronous|journal_mode|WAL","type":"rust","path":"/Users/al02402336/everything/src-tauri/src","output_mode":"content"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":172,"cache_read_input_tokens":21573,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":172},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CYNiST2ocMuuyduDcdxut","uuid":"f114ee7f-7563-4441-8b29-bf397f31cb1b"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"c5251099-1955-4f66-ab24-d0449aa5ad2b","timestamp":"2026-02-22T07:30:08.590Z"}
{"parentUuid":"c5251099-1955-4f66-ab24-d0449aa5ad2b","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-22T07:30:09.005Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_016qKNqU6uV8CuFH2B1VRSwt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VMAXkrSWdaJTyy8TtA7mNm","name":"Grep","input":{"pattern":"index_progress|emit.*index","type":"rust","path":"/Users/al02402336/everything/src-tauri/src","output_mode":"content"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":172,"cache_read_input_tokens":21573,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":172},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CYNiST2ocMuuyduDcdxut","uuid":"a0b91a9b-13cd-4543-a6be-8191a0cef324"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"37c6b1dc-a70c-426d-8863-45bc696b5cc6","timestamp":"2026-02-22T07:30:09.005Z"}
{"parentUuid":"37c6b1dc-a70c-426d-8863-45bc696b5cc6","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01J68FPj6baKKv2YRN6MCFg6","type":"tool_result","content":"src-tauri/src/main.rs:411:pub(crate) fn set_indexing_pragmas(conn: &Connection) -> AppResult<()> {\nsrc-tauri/src/main.rs:1303:pub(crate) fn index_row_from_path_and_metadata(path: &Path, metadata: &fs::Metadata) -> Option<IndexRow> {\nsrc-tauri/src/main.rs:1347:fn index_row_from_path(path: &Path) -> Option<IndexRow> {\nsrc-tauri/src/main.rs:1352:fn index_row_from_walkdir_entry(entry: &walkdir::DirEntry) -> Option<IndexRow> {\nsrc-tauri/src/main.rs:1357:fn index_row_from_jwalk_entry(entry: &jwalk::DirEntry<((), ())>) -> Option<IndexRow> {\nsrc-tauri/src/main.rs:1383:fn entry_from_index_row(row: IndexRow) -> EntryDto {\nsrc-tauri/src/main.rs:1779:pub(crate) fn emit_index_state(app: &AppHandle, state: &str, message: Option<String>) {\nsrc-tauri/src/main.rs:1791:pub(crate) fn emit_index_updated(\nsrc-tauri/src/main.rs:1807:pub(crate) fn emit_index_progress(app: &AppHandle, scanned: u64, indexed: u64, current_path: String) {\nsrc-tauri/src/main.rs:1824:pub(crate) fn set_progress(state: &AppState, scanned: u64, indexed: u64, current_path: &str) {\nsrc-tauri/src/main.rs:1887:pub(crate) fn start_full_index_worker(app: AppHandle, state: AppState) -> AppResult<()> {\nsrc-tauri/src/main.rs:1892:pub(crate) fn start_full_index_worker_silent(app: AppHandle, state: AppState) -> AppResult<()> {\nsrc-tauri/src/main.rs:1896:fn start_full_index_worker_inner(app: AppHandle, state: AppState, silent: bool) -> AppResult<()> {\nsrc-tauri/src/main.rs:2001:fn run_incremental_index(app: &AppHandle, state: &AppState) -> AppResult<()> {\nsrc-tauri/src/main.rs:2043:fn run_incremental_index_inner(\nsrc-tauri/src/main.rs:2877:fn get_index_status(state: State<'_, AppState>) -> IndexStatusDto {\nsrc-tauri/src/main.rs:2924:fn start_full_index(app: AppHandle, state: State<'_, AppState>) -> AppResult<()> {\nsrc-tauri/src/main.rs:2937:async fn reset_index(app: AppHandle, state: State<'_, AppState>) -> AppResult<()> {\nsrc-tauri/src/mem_search.rs:131:pub fn search_mem_index(\nsrc-tauri/src/mem_search.rs:332:fn search_by_name_indexed(mem_index: &MemIndex, q_lower: &str, limit: u32) -> Vec<u32> {\nsrc-tauri/src/mem_search.rs:408:fn search_by_glob_indexed(mem_index: &MemIndex, name_like: &str, limit: u32) -> Vec<u32> {\nsrc-tauri/src/mem_search.rs:460:fn search_by_path_indexed(\nsrc-tauri/src/mem_search.rs:635:fn name_cmp_idx(mem_index: &MemIndex, a: u32, b: u32, sort_dir: &str) -> std::cmp::Ordering {\nsrc-tauri/src/mem_search.rs:641:fn relevance_rank_idx(mem_index: &MemIndex, idx: u32, q_lower: &str) -> u8 {\nsrc-tauri/src/win/nonadmin_indexer.rs:36:pub fn run_nonadmin_index(app: AppHandle, state: AppState) {\nsrc-tauri/src/win/mod.rs:26:pub fn start_windows_indexing(app: AppHandle, state: AppState) {"}]},"uuid":"f106436b-f591-4f46-978e-3d111f52dbdc","timestamp":"2026-02-22T07:30:09.597Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"be0b40ce-3419-4dbc-bff9-7c7c20c86060","timestamp":"2026-02-22T07:30:09.599Z"}
{"parentUuid":"be0b40ce-3419-4dbc-bff9-7c7c20c86060","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019DKE8udRFEr2DC5j3UjyRR","type":"tool_result","content":"src-tauri/src/main.rs:42:pub(crate) const BATCH_SIZE: usize = 10_000;\nsrc-tauri/src/main.rs:2068:    let mut batch: Vec<IndexRow> = Vec::with_capacity(BATCH_SIZE);\nsrc-tauri/src/main.rs:2069:    let mut stamp_batch: Vec<String> = Vec::with_capacity(BATCH_SIZE);\nsrc-tauri/src/main.rs:2138:    if stamp_batch.len() >= BATCH_SIZE {\nsrc-tauri/src/main.rs:2253:                        if batch.len() >= BATCH_SIZE {\nsrc-tauri/src/main.rs:2258:                        if stamp_batch.len() >= BATCH_SIZE {\nsrc-tauri/src/main.rs:2564:                    \"[watcher] DB busy, will retry in {}s: {} | batch_size={}\",\nsrc-tauri/src/main.rs:2576:                \"[watcher] process_watcher_paths ERROR: {} | batch_size={} indexing_active={}\",\nsrc-tauri/src/main.rs:4276:            for chunk in rows.chunks(BATCH_SIZE) {\nsrc-tauri/src/win/nonadmin_indexer.rs:21:const DB_BATCH_SIZE: usize = 50_000;\nsrc-tauri/src/win/nonadmin_indexer.rs:718:    for chunk in entries.chunks(DB_BATCH_SIZE) {\nsrc-tauri/src/win/search_catchup.rs:15:    should_skip_path, upsert_rows, AppResult, AppState, BATCH_SIZE,\nsrc-tauri/src/win/search_catchup.rs:173:    for chunk in to_upsert.chunks(BATCH_SIZE) {\nsrc-tauri/src/win/search_catchup.rs:311:        for chunk in to_upsert.chunks(BATCH_SIZE) {\nsrc-tauri/src/win/mft_indexer.rs:30:const MFT_BATCH_SIZE: usize = 50_000;\nsrc-tauri/src/win/mft_indexer.rs:576:    for chunk in entries.chunks(MFT_BATCH_SIZE) {"}]},"uuid":"15c9982a-e6a3-4fde-9963-0707cfe17d4d","timestamp":"2026-02-22T07:30:09.855Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"87f8eb5b-c9a2-4eba-a2dc-57cbae77fa19","timestamp":"2026-02-22T07:30:09.857Z"}
{"parentUuid":"87f8eb5b-c9a2-4eba-a2dc-57cbae77fa19","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VMAXkrSWdaJTyy8TtA7mNm","type":"tool_result","content":"src-tauri/src/main.rs:1779:pub(crate) fn emit_index_state(app: &AppHandle, state: &str, message: Option<String>) {\nsrc-tauri/src/main.rs:1791:pub(crate) fn emit_index_updated(\nsrc-tauri/src/main.rs:1807:pub(crate) fn emit_index_progress(app: &AppHandle, scanned: u64, indexed: u64, current_path: String) {\nsrc-tauri/src/main.rs:1809:        \"index_progress\",\nsrc-tauri/src/main.rs:1833:    emit_index_updated(\nsrc-tauri/src/main.rs:1877:    emit_index_state(app, \"Ready\", None);\nsrc-tauri/src/main.rs:1878:    emit_index_updated(app, count, last_updated.unwrap_or_else(now_epoch), 0);\nsrc-tauri/src/main.rs:1921:        emit_index_state(&app, \"Indexing\", None);\nsrc-tauri/src/main.rs:1933:                emit_index_state(&app, \"Error\", Some(err.clone()));\nsrc-tauri/src/main.rs:2265:                            emit_index_progress(app, scanned, indexed, current_path.clone());\nsrc-tauri/src/main.rs:2271:                                \"index_progress pass={} scanned={} indexed={} current_path={}\",\nsrc-tauri/src/main.rs:2348:    emit_index_progress(app, scanned, indexed, current_path.clone());\nsrc-tauri/src/main.rs:2400:    emit_index_progress(app, scanned, indexed, current_path);\nsrc-tauri/src/main.rs:2401:    emit_index_updated(app, entries_count, updated_at, permission_errors);\nsrc-tauri/src/main.rs:2402:    emit_index_state(\nsrc-tauri/src/main.rs:2591:            emit_index_state(app, \"Error\", Some(format!(\"Watcher update failed: {err}\")));\nsrc-tauri/src/main.rs:2628:                    emit_index_state(\nsrc-tauri/src/main.rs:2640:            emit_index_state(&app, \"Ready\", None);\nsrc-tauri/src/main.rs:2975:        emit_index_state(&app, \"Indexing\", None);\nsrc-tauri/src/main.rs:2976:        emit_index_updated(&app, 0, now_epoch(), 0);\nsrc-tauri/src/main.rs:5076:            emit_index_state(&app_handle, \"Error\", Some(err));\nsrc-tauri/src/win/nonadmin_indexer.rs:12:    db_connection, effective_ignore_rules, emit_index_progress, emit_index_state,\nsrc-tauri/src/win/nonadmin_indexer.rs:13:    emit_index_updated, get_meta, invalidate_search_caches, now_epoch,\nsrc-tauri/src/win/nonadmin_indexer.rs:14:    refresh_and_emit_status_counts, restore_normal_pragmas, set_indexing_pragmas,\nsrc-tauri/src/win/nonadmin_indexer.rs:63:    emit_index_state(&app, \"Indexing\", None);\nsrc-tauri/src/win/nonadmin_indexer.rs:132:        emit_index_progress(&app, scanned, indexed, String::new());\nsrc-tauri/src/win/nonadmin_indexer.rs:342:    emit_index_updated(&app, total_entries as u64, now_epoch(), 0);\nsrc-tauri/src/win/nonadmin_indexer.rs:343:    emit_index_state(&app, \"Ready\", None);\nsrc-tauri/src/win/nonadmin_indexer.rs:622:                        emit_index_progress(app, total_scanned, total_indexed, current);\nsrc-tauri/src/win/nonadmin_indexer.rs:625:                        emit_index_progress(app, scanned, indexed, current);\nsrc-tauri/src/win/nonadmin_indexer.rs:823:    emit_index_updated(app, entries_count, updated_at, 0);\nsrc-tauri/src/win/search_catchup.rs:13:    db_connection, delete_paths, emit_index_state, index_row_from_path_and_metadata,\nsrc-tauri/src/win/search_catchup.rs:238:            emit_index_state(\nsrc-tauri/src/win/mod.rs:140:                        crate::emit_index_state(&catchup_app, \"Ready\", None);\nsrc-tauri/src/win/mft_indexer.rs:17:    db_connection, emit_index_progress, emit_index_state, emit_index_updated,\nsrc-tauri/src/win/mft_indexer.rs:92:    emit_index_state(app, \"Indexing\", None);\nsrc-tauri/src/win/mft_indexer.rs:126:            emit_index_progress(app, 0, 0, msg);\nsrc-tauri/src/win/mft_indexer.rs:304:    emit_index_progress(app, scanned, indexed, String::new());\nsrc-tauri/src/win/mft_indexer.rs:305:    emit_index_updated(app, indexed, now_epoch(), 0);\nsrc-tauri/src/win/mft_indexer.rs:306:    emit_index_state(app, \"Ready\", None);\nsrc-tauri/src/win/mft_indexer.rs:308:        \"[win/mft +{}] progressive Ready emitted ({indexed} dirs)\",\nsrc-tauri/src/win/mft_indexer.rs:398:    emit_index_progress(app, scanned, indexed, String::new());\nsrc-tauri/src/win/mft_indexer.rs:399:    emit_index_updated(app, indexed, now_epoch(), 0);\nsrc-tauri/src/win/mft_indexer.rs:693:    emit_index_updated(app, entries_count, updated_at, 0);"}]},"uuid":"e9287cfd-0e8d-4b3c-be37-b8116e730d94","timestamp":"2026-02-22T07:30:10.120Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"03e00438-e154-4b4b-9de9-d37dad6bd49f","timestamp":"2026-02-22T07:30:10.121Z"}
{"parentUuid":"03e00438-e154-4b4b-9de9-d37dad6bd49f","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JtfTkru4rvCB6uQZd27V2V","type":"tool_result","content":"src-tauri/src/main.rs:387:        PRAGMA journal_mode=WAL;\nsrc-tauri/src/main.rs:388:        PRAGMA synchronous=NORMAL;\nsrc-tauri/src/main.rs:389:        PRAGMA temp_store=MEMORY;\nsrc-tauri/src/main.rs:390:        PRAGMA busy_timeout={busy_timeout_ms};\nsrc-tauri/src/main.rs:404:        \"PRAGMA cache_size = -32768;\nsrc-tauri/src/main.rs:405:         PRAGMA mmap_size = 268435456;\",\nsrc-tauri/src/main.rs:414:        PRAGMA synchronous = NORMAL;\nsrc-tauri/src/main.rs:415:        PRAGMA cache_size = -65536;\nsrc-tauri/src/main.rs:416:        PRAGMA mmap_size = 268435456;\nsrc-tauri/src/main.rs:417:        PRAGMA wal_autocheckpoint = 10000;\nsrc-tauri/src/main.rs:426:        PRAGMA synchronous = NORMAL;\nsrc-tauri/src/main.rs:427:        PRAGMA cache_size = -16384;\nsrc-tauri/src/main.rs:428:        PRAGMA mmap_size = 268435456;\nsrc-tauri/src/main.rs:429:        PRAGMA wal_autocheckpoint = 1000;\nsrc-tauri/src/main.rs:433:    conn.execute_batch(\"PRAGMA wal_checkpoint(TRUNCATE);\")\nsrc-tauri/src/main.rs:444:        .query_row(\"PRAGMA user_version\", [], |row| row.get(0))\nsrc-tauri/src/main.rs:457:        conn.execute_batch(&format!(\"PRAGMA user_version = {};\", DB_VERSION))\nsrc-tauri/src/win/nonadmin_indexer.rs:19:const JWALK_THREADS: usize = 8;\nsrc-tauri/src/win/nonadmin_indexer.rs:535:        .parallelism(jwalk::Parallelism::RayonNewPool(JWALK_THREADS))"}]},"uuid":"49c4dfee-4c81-4a86-80e4-984aeb49068c","timestamp":"2026-02-22T07:30:10.383Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"53dec1ab-9656-4ae9-baa0-31d882346ee3","timestamp":"2026-02-22T07:30:10.385Z"}
{"parentUuid":"53dec1ab-9656-4ae9-baa0-31d882346ee3","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-22T07:30:12.755Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_016he78aBHTWoohYoDgnxnUV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GzZJvgtQZoEBDERStjCX7r","name":"Read","input":{"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","offset":2937,"limit":100},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1623,"cache_creation_input_tokens":2820,"cache_read_input_tokens":21745,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2820},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CYNiSpkGELKcMcP5p71ud","uuid":"dd687485-7a82-45a9-b282-32a02d0f5460"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"4b28caec-b189-4c66-8f66-62e0bb155a2c","timestamp":"2026-02-22T07:30:12.755Z"}
{"parentUuid":"4b28caec-b189-4c66-8f66-62e0bb155a2c","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GzZJvgtQZoEBDERStjCX7r","type":"tool_result","content":"  2937â†’async fn reset_index(app: AppHandle, state: State<'_, AppState>) -> AppResult<()> {\n  2938â†’    let state = state.inner().clone();\n  2939â†’    tauri::async_runtime::spawn_blocking(move || {\n  2940â†’        if state.indexing_active.load(AtomicOrdering::Acquire) {\n  2941â†’            return Err(\"Cannot reset while indexing is in progress.\".to_string());\n  2942â†’        }\n  2943â†’\n  2944â†’        // Stop existing file watcher and wait for it to fully exit\n  2945â†’        state.watcher_stop.store(true, AtomicOrdering::Release);\n  2946â†’        let deadline = std::time::Instant::now() + std::time::Duration::from_secs(5);\n  2947â†’        while state.watcher_active.load(AtomicOrdering::Acquire) {\n  2948â†’            if std::time::Instant::now() >= deadline {\n  2949â†’                eprintln!(\"[reset] watcher did not stop within 5s, proceeding anyway\");\n  2950â†’                break;\n  2951â†’            }\n  2952â†’            std::thread::sleep(std::time::Duration::from_millis(50));\n  2953â†’        }\n  2954â†’\n  2955â†’        let conn = db_connection(&state.db_path)?;\n  2956â†’        conn.execute(\"DELETE FROM entries\", [])\n  2957â†’            .map_err(|e| e.to_string())?;\n  2958â†’        conn.execute(\"DELETE FROM meta\", [])\n  2959â†’            .map_err(|e| e.to_string())?;\n  2960â†’\n  2961â†’        {\n  2962â†’            let mut status = state.status.lock();\n  2963â†’            status.state = IndexState::Indexing;\n  2964â†’            status.entries_count = 0;\n  2965â†’            status.last_updated = None;\n  2966â†’            status.permission_errors = 0;\n  2967â†’            status.message = None;\n  2968â†’            status.scanned = 0;\n  2969â†’            status.indexed = 0;\n  2970â†’            status.current_path.clear();\n  2971â†’        }\n  2972â†’\n  2973â†’        invalidate_search_caches(&state);\n  2974â†’\n  2975â†’        emit_index_state(&app, \"Indexing\", None);\n  2976â†’        emit_index_updated(&app, 0, now_epoch(), 0);\n  2977â†’\n  2978â†’        // Allow new watcher to start\n  2979â†’        state.watcher_stop.store(false, AtomicOrdering::Release);\n  2980â†’\n  2981â†’        #[cfg(target_os = \"windows\")]\n  2982â†’        {\n  2983â†’            win::start_windows_indexing(app, state);\n  2984â†’            Ok(())\n  2985â†’        }\n  2986â†’        #[cfg(not(target_os = \"windows\"))]\n  2987â†’        {\n  2988â†’            start_full_index_worker(app, state)\n  2989â†’        }\n  2990â†’    })\n  2991â†’    .await\n  2992â†’    .map_err(|e| e.to_string())?\n  2993â†’}\n  2994â†’\n  2995â†’fn log_search(db_path: &Path, query: &str, mode: &str, results: &[EntryDto]) {\n  2996â†’    if !search_log_enabled() {\n  2997â†’        return;\n  2998â†’    }\n  2999â†’\n  3000â†’    let log_path = db_path.with_file_name(\"search.log\");\n  3001â†’    let Ok(mut f) = fs::OpenOptions::new()\n  3002â†’        .create(true)\n  3003â†’        .append(true)\n  3004â†’        .open(&log_path)\n  3005â†’    else {\n  3006â†’        return;\n  3007â†’    };\n  3008â†’    let top: Vec<&str> = results.iter().take(10).map(|e| e.name.as_str()).collect();\n  3009â†’    let _ = writeln!(\n  3010â†’        f,\n  3011â†’        \"[{}] Q={:?} MODE={} COUNT={} TOP={:?}\",\n  3012â†’        now_epoch(),\n  3013â†’        query,\n  3014â†’        mode,\n  3015â†’        results.len(),\n  3016â†’        top,\n  3017â†’    );\n  3018â†’}\n  3019â†’\n  3020â†’fn search_log_enabled() -> bool {\n  3021â†’    *SEARCH_LOG_ENABLED.get_or_init(|| env_truthy(\"FASTFIND_SEARCH_LOG\"))\n  3022â†’}\n  3023â†’\n  3024â†’/// Returns the total number of entries matching `query` without LIMIT/OFFSET.\n  3025â†’/// Returns `None` when the total is unknown or intentionally skipped.\n  3026â†’fn compute_total_count(\n  3027â†’    db_path: &Path,\n  3028â†’    home_dir: &Path,\n  3029â†’    execution: &SearchExecution,\n  3030â†’) -> Option<u32> {\n  3031â†’    // When fewer results than the limit were returned the total is exact.\n  3032â†’    if (execution.results.len() as u32) < execution.effective_limit {\n  3033â†’        return Some(\n  3034â†’            execution\n  3035â†’                .offset\n  3036â†’                .saturating_add(execution.results.len() as u32),\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"3b1d855d-4bef-4d1a-8f90-9a6376e3aed9","timestamp":"2026-02-22T07:30:12.767Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"ab75b1ad-c7d0-4480-a679-a7379bce8319","timestamp":"2026-02-22T07:30:12.851Z"}
{"parentUuid":"ab75b1ad-c7d0-4480-a679-a7379bce8319","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-22T07:30:13.037Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_016he78aBHTWoohYoDgnxnUV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GywFikjKLUvR9VGSWV4EFX","name":"Read","input":{"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","offset":1887,"limit":150},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1623,"cache_creation_input_tokens":2820,"cache_read_input_tokens":21745,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2820},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CYNiSpkGELKcMcP5p71ud","uuid":"b9fda9de-2fdf-4e74-aef8-e80fb8b402d5"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"cb618a2e-c2aa-4c28-ae62-43af7009c03d","timestamp":"2026-02-22T07:30:13.037Z"}
{"parentUuid":"cb618a2e-c2aa-4c28-ae62-43af7009c03d","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GywFikjKLUvR9VGSWV4EFX","type":"tool_result","content":"  1887â†’pub(crate) fn start_full_index_worker(app: AppHandle, state: AppState) -> AppResult<()> {\n  1888â†’    start_full_index_worker_inner(app, state, false)\n  1889â†’}\n  1890â†’\n  1891â†’#[cfg(target_os = \"windows\")]\n  1892â†’pub(crate) fn start_full_index_worker_silent(app: AppHandle, state: AppState) -> AppResult<()> {\n  1893â†’    start_full_index_worker_inner(app, state, true)\n  1894â†’}\n  1895â†’\n  1896â†’fn start_full_index_worker_inner(app: AppHandle, state: AppState, silent: bool) -> AppResult<()> {\n  1897â†’    if state\n  1898â†’        .indexing_active\n  1899â†’        .compare_exchange(false, true, AtomicOrdering::AcqRel, AtomicOrdering::Acquire)\n  1900â†’        .is_err()\n  1901â†’    {\n  1902â†’        perf_log(\"index_start_skipped already_active=true\");\n  1903â†’        return Ok(());\n  1904â†’    }\n  1905â†’\n  1906â†’    // Mark index as incomplete -- cleared when run_incremental_index succeeds\n  1907â†’    if let Ok(c) = db_connection(&state.db_path) {\n  1908â†’        let _ = set_meta(&c, \"index_complete\", \"0\");\n  1909â†’    }\n  1910â†’\n  1911â†’    if !silent {\n  1912â†’        {\n  1913â†’            let mut status = state.status.lock();\n  1914â†’            status.state = IndexState::Indexing;\n  1915â†’            status.message = None;\n  1916â†’            status.scanned = 0;\n  1917â†’            status.indexed = 0;\n  1918â†’            status.current_path.clear();\n  1919â†’        }\n  1920â†’\n  1921â†’        emit_index_state(&app, \"Indexing\", None);\n  1922â†’        perf_log(\"index_state=Indexing\");\n  1923â†’    } else {\n  1924â†’        perf_log(\"index_start silent=true (background reindex)\");\n  1925â†’    }\n  1926â†’\n  1927â†’    std::thread::spawn(move || {\n  1928â†’        let result = run_incremental_index(&app, &state);\n  1929â†’        if let Err(ref err) = result {\n  1930â†’            eprintln!(\"[index] run_incremental_index failed: {err}\");\n  1931â†’            if !silent {\n  1932â†’                set_state(&state, IndexState::Error, Some(err.clone()));\n  1933â†’                emit_index_state(&app, \"Error\", Some(err.clone()));\n  1934â†’            }\n  1935â†’            // Silent mode: keep Ready state, just log the error\n  1936â†’        }\n  1937â†’        state.indexing_active.store(false, AtomicOrdering::Release);\n  1938â†’    });\n  1939â†’\n  1940â†’    Ok(())\n  1941â†’}\n  1942â†’\n  1943â†’fn is_deferred_dir(path: &Path, home_dir: &Path) -> bool {\n  1944â†’    path.parent() == Some(home_dir)\n  1945â†’        && path\n  1946â†’            .file_name()\n  1947â†’            .and_then(|n| n.to_str())\n  1948â†’            .map(|name| DEFERRED_DIR_NAMES.contains(&name))\n  1949â†’            .unwrap_or(false)\n  1950â†’}\n  1951â†’\n  1952â†’fn preload_existing_entries(\n  1953â†’    conn: &Connection,\n  1954â†’    dir_prefix: &str,\n  1955â†’) -> HashMap<String, (Option<i64>, Option<i64>)> {\n  1956â†’    let like_pattern = format!(\"{}/%\", escape_like(dir_prefix));\n  1957â†’    let mut stmt = match conn.prepare(\n  1958â†’        \"SELECT path, mtime, size FROM entries WHERE path LIKE ?1 ESCAPE '\\\\' OR path = ?2\",\n  1959â†’    ) {\n  1960â†’        Ok(s) => s,\n  1961â†’        Err(_) => return HashMap::new(),\n  1962â†’    };\n  1963â†’\n  1964â†’    let mut map = HashMap::new();\n  1965â†’    let rows = match stmt.query_map(params![like_pattern, dir_prefix], |row| {\n  1966â†’        Ok((\n  1967â†’            row.get::<_, String>(0)?,\n  1968â†’            row.get::<_, Option<i64>>(1)?,\n  1969â†’            row.get::<_, Option<i64>>(2)?,\n  1970â†’        ))\n  1971â†’    }) {\n  1972â†’        Ok(r) => r,\n  1973â†’        Err(_) => return map,\n  1974â†’    };\n  1975â†’\n  1976â†’    for row in rows.flatten() {\n  1977â†’        map.insert(row.0, (row.1, row.2));\n  1978â†’    }\n  1979â†’    map\n  1980â†’}\n  1981â†’\n  1982â†’fn stamp_run_id_batch(conn: &mut Connection, paths: &[String], run_id: i64) -> AppResult<()> {\n  1983â†’    if paths.is_empty() {\n  1984â†’        return Ok(());\n  1985â†’    }\n  1986â†’\n  1987â†’    let tx = conn.transaction().map_err(|e| e.to_string())?;\n  1988â†’    {\n  1989â†’        let mut stmt = tx\n  1990â†’            .prepare(\"UPDATE entries SET run_id = ?1 WHERE path = ?2\")\n  1991â†’            .map_err(|e| e.to_string())?;\n  1992â†’        for path in paths {\n  1993â†’            stmt.execute(params![run_id, path])\n  1994â†’                .map_err(|e| e.to_string())?;\n  1995â†’        }\n  1996â†’    }\n  1997â†’    tx.commit().map_err(|e| e.to_string())?;\n  1998â†’    Ok(())\n  1999â†’}\n  2000â†’\n  2001â†’fn run_incremental_index(app: &AppHandle, state: &AppState) -> AppResult<()> {\n  2002â†’    let started = Instant::now();\n  2003â†’    perf_log(format!(\n  2004â†’        \"index_run_start home={} db={}\",\n  2005â†’        state.home_dir.to_string_lossy(),\n  2006â†’        state.db_path.to_string_lossy(),\n  2007â†’    ));\n  2008â†’\n  2009â†’    let mut conn = db_connection(&state.db_path)?;\n  2010â†’    set_indexing_pragmas(&conn)?;\n  2011â†’\n  2012â†’    let result = run_incremental_index_inner(app, state, &mut conn);\n  2013â†’\n  2014â†’    let _ = conn.execute_batch(\"ANALYZE\");\n  2015â†’    let _ = restore_normal_pragmas(&conn);\n  2016â†’\n  2017â†’    match &result {\n  2018â†’        Ok(_) => {\n  2019â†’            let _ = set_meta(&conn, \"index_complete\", \"1\");\n  2020â†’            let snapshot = state.status.lock().clone();\n  2021â†’            perf_log(format!(\n  2022â†’                \"index_run_done elapsed_ms={} scanned={} indexed={} entries={} permission_errors={} message={:?}\",\n  2023â†’                started.elapsed().as_millis(),\n  2024â†’                snapshot.scanned,\n  2025â†’                snapshot.indexed,\n  2026â†’                snapshot.entries_count,\n  2027â†’                snapshot.permission_errors,\n  2028â†’                snapshot.message,\n  2029â†’            ));\n  2030â†’        }\n  2031â†’        Err(err) => {\n  2032â†’            perf_log(format!(\n  2033â†’                \"index_run_error elapsed_ms={} err={}\",\n  2034â†’                started.elapsed().as_millis(),\n  2035â†’                err,\n  2036â†’            ));\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"7485b70a-8894-41d4-8bb4-a2778977e247","timestamp":"2026-02-22T07:30:13.054Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"696a6075-b958-47e0-af76-5bd137d30c9b","timestamp":"2026-02-22T07:30:13.197Z"}
{"parentUuid":"696a6075-b958-47e0-af76-5bd137d30c9b","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-22T07:30:13.360Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_016he78aBHTWoohYoDgnxnUV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KAvMRFsXLMA5ycrWdsXAzb","name":"Read","input":{"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","offset":1896,"limit":200},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1623,"cache_creation_input_tokens":2820,"cache_read_input_tokens":21745,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2820},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CYNiSpkGELKcMcP5p71ud","uuid":"769fa22d-7538-4671-8e23-f2a1d7768e02"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"dd647a1b-96ca-4d2b-93f7-fcd390659c58","timestamp":"2026-02-22T07:30:13.361Z"}
{"parentUuid":"dd647a1b-96ca-4d2b-93f7-fcd390659c58","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KAvMRFsXLMA5ycrWdsXAzb","type":"tool_result","content":"  1896â†’fn start_full_index_worker_inner(app: AppHandle, state: AppState, silent: bool) -> AppResult<()> {\n  1897â†’    if state\n  1898â†’        .indexing_active\n  1899â†’        .compare_exchange(false, true, AtomicOrdering::AcqRel, AtomicOrdering::Acquire)\n  1900â†’        .is_err()\n  1901â†’    {\n  1902â†’        perf_log(\"index_start_skipped already_active=true\");\n  1903â†’        return Ok(());\n  1904â†’    }\n  1905â†’\n  1906â†’    // Mark index as incomplete -- cleared when run_incremental_index succeeds\n  1907â†’    if let Ok(c) = db_connection(&state.db_path) {\n  1908â†’        let _ = set_meta(&c, \"index_complete\", \"0\");\n  1909â†’    }\n  1910â†’\n  1911â†’    if !silent {\n  1912â†’        {\n  1913â†’            let mut status = state.status.lock();\n  1914â†’            status.state = IndexState::Indexing;\n  1915â†’            status.message = None;\n  1916â†’            status.scanned = 0;\n  1917â†’            status.indexed = 0;\n  1918â†’            status.current_path.clear();\n  1919â†’        }\n  1920â†’\n  1921â†’        emit_index_state(&app, \"Indexing\", None);\n  1922â†’        perf_log(\"index_state=Indexing\");\n  1923â†’    } else {\n  1924â†’        perf_log(\"index_start silent=true (background reindex)\");\n  1925â†’    }\n  1926â†’\n  1927â†’    std::thread::spawn(move || {\n  1928â†’        let result = run_incremental_index(&app, &state);\n  1929â†’        if let Err(ref err) = result {\n  1930â†’            eprintln!(\"[index] run_incremental_index failed: {err}\");\n  1931â†’            if !silent {\n  1932â†’                set_state(&state, IndexState::Error, Some(err.clone()));\n  1933â†’                emit_index_state(&app, \"Error\", Some(err.clone()));\n  1934â†’            }\n  1935â†’            // Silent mode: keep Ready state, just log the error\n  1936â†’        }\n  1937â†’        state.indexing_active.store(false, AtomicOrdering::Release);\n  1938â†’    });\n  1939â†’\n  1940â†’    Ok(())\n  1941â†’}\n  1942â†’\n  1943â†’fn is_deferred_dir(path: &Path, home_dir: &Path) -> bool {\n  1944â†’    path.parent() == Some(home_dir)\n  1945â†’        && path\n  1946â†’            .file_name()\n  1947â†’            .and_then(|n| n.to_str())\n  1948â†’            .map(|name| DEFERRED_DIR_NAMES.contains(&name))\n  1949â†’            .unwrap_or(false)\n  1950â†’}\n  1951â†’\n  1952â†’fn preload_existing_entries(\n  1953â†’    conn: &Connection,\n  1954â†’    dir_prefix: &str,\n  1955â†’) -> HashMap<String, (Option<i64>, Option<i64>)> {\n  1956â†’    let like_pattern = format!(\"{}/%\", escape_like(dir_prefix));\n  1957â†’    let mut stmt = match conn.prepare(\n  1958â†’        \"SELECT path, mtime, size FROM entries WHERE path LIKE ?1 ESCAPE '\\\\' OR path = ?2\",\n  1959â†’    ) {\n  1960â†’        Ok(s) => s,\n  1961â†’        Err(_) => return HashMap::new(),\n  1962â†’    };\n  1963â†’\n  1964â†’    let mut map = HashMap::new();\n  1965â†’    let rows = match stmt.query_map(params![like_pattern, dir_prefix], |row| {\n  1966â†’        Ok((\n  1967â†’            row.get::<_, String>(0)?,\n  1968â†’            row.get::<_, Option<i64>>(1)?,\n  1969â†’            row.get::<_, Option<i64>>(2)?,\n  1970â†’        ))\n  1971â†’    }) {\n  1972â†’        Ok(r) => r,\n  1973â†’        Err(_) => return map,\n  1974â†’    };\n  1975â†’\n  1976â†’    for row in rows.flatten() {\n  1977â†’        map.insert(row.0, (row.1, row.2));\n  1978â†’    }\n  1979â†’    map\n  1980â†’}\n  1981â†’\n  1982â†’fn stamp_run_id_batch(conn: &mut Connection, paths: &[String], run_id: i64) -> AppResult<()> {\n  1983â†’    if paths.is_empty() {\n  1984â†’        return Ok(());\n  1985â†’    }\n  1986â†’\n  1987â†’    let tx = conn.transaction().map_err(|e| e.to_string())?;\n  1988â†’    {\n  1989â†’        let mut stmt = tx\n  1990â†’            .prepare(\"UPDATE entries SET run_id = ?1 WHERE path = ?2\")\n  1991â†’            .map_err(|e| e.to_string())?;\n  1992â†’        for path in paths {\n  1993â†’            stmt.execute(params![run_id, path])\n  1994â†’                .map_err(|e| e.to_string())?;\n  1995â†’        }\n  1996â†’    }\n  1997â†’    tx.commit().map_err(|e| e.to_string())?;\n  1998â†’    Ok(())\n  1999â†’}\n  2000â†’\n  2001â†’fn run_incremental_index(app: &AppHandle, state: &AppState) -> AppResult<()> {\n  2002â†’    let started = Instant::now();\n  2003â†’    perf_log(format!(\n  2004â†’        \"index_run_start home={} db={}\",\n  2005â†’        state.home_dir.to_string_lossy(),\n  2006â†’        state.db_path.to_string_lossy(),\n  2007â†’    ));\n  2008â†’\n  2009â†’    let mut conn = db_connection(&state.db_path)?;\n  2010â†’    set_indexing_pragmas(&conn)?;\n  2011â†’\n  2012â†’    let result = run_incremental_index_inner(app, state, &mut conn);\n  2013â†’\n  2014â†’    let _ = conn.execute_batch(\"ANALYZE\");\n  2015â†’    let _ = restore_normal_pragmas(&conn);\n  2016â†’\n  2017â†’    match &result {\n  2018â†’        Ok(_) => {\n  2019â†’            let _ = set_meta(&conn, \"index_complete\", \"1\");\n  2020â†’            let snapshot = state.status.lock().clone();\n  2021â†’            perf_log(format!(\n  2022â†’                \"index_run_done elapsed_ms={} scanned={} indexed={} entries={} permission_errors={} message={:?}\",\n  2023â†’                started.elapsed().as_millis(),\n  2024â†’                snapshot.scanned,\n  2025â†’                snapshot.indexed,\n  2026â†’                snapshot.entries_count,\n  2027â†’                snapshot.permission_errors,\n  2028â†’                snapshot.message,\n  2029â†’            ));\n  2030â†’        }\n  2031â†’        Err(err) => {\n  2032â†’            perf_log(format!(\n  2033â†’                \"index_run_error elapsed_ms={} err={}\",\n  2034â†’                started.elapsed().as_millis(),\n  2035â†’                err,\n  2036â†’            ));\n  2037â†’        }\n  2038â†’    }\n  2039â†’\n  2040â†’    result\n  2041â†’}\n  2042â†’\n  2043â†’fn run_incremental_index_inner(\n  2044â†’    app: &AppHandle,\n  2045â†’    state: &AppState,\n  2046â†’    conn: &mut Connection,\n  2047â†’) -> AppResult<()> {\n  2048â†’\n  2049â†’    let (runtime_ignored_roots, runtime_ignored_patterns) = effective_ignore_rules(\n  2050â†’        &state.home_dir,\n  2051â†’        &state.cwd,\n  2052â†’        state.path_ignores.as_ref(),\n  2053â†’        state.path_ignore_patterns.as_ref(),\n  2054â†’    );\n  2055â†’    let gi_filter = state.gitignore.get();\n  2056â†’\n  2057â†’    let last_run_id: i64 = get_meta(conn, \"last_run_id\")\n  2058â†’        .and_then(|v| v.parse().ok())\n  2059â†’        .unwrap_or(0);\n  2060â†’    let current_run_id = last_run_id + 1;\n  2061â†’    // Fresh index: DB was empty, skip preload/stamp, single unlimited-depth pass\n  2062â†’    let is_fresh = last_run_id == 0;\n  2063â†’\n  2064â†’    let mut scanned: u64 = 0;\n  2065â†’    let mut indexed: u64 = 0;\n  2066â†’    let mut permission_errors: u64 = 0;\n  2067â†’    let mut current_path = String::new();\n  2068â†’    let mut batch: Vec<IndexRow> = Vec::with_capacity(BATCH_SIZE);\n  2069â†’    let mut stamp_batch: Vec<String> = Vec::with_capacity(BATCH_SIZE);\n  2070â†’    let mut last_emit = Instant::now();\n  2071â†’    let mut last_perf_emit = Instant::now();\n  2072â†’\n  2073â†’    // Preload scan_root-level entries (direct children only, not recursive)\n  2074â†’    let scan_str = state.scan_root.to_string_lossy().to_string();\n  2075â†’    let root_existing = preload_existing_entries(conn, &scan_str);\n  2076â†’\n  2077â†’    // Index scan_root itself\n  2078â†’    if let Some(mut row) = index_row_from_path(&state.scan_root) {\n  2079â†’        scanned += 1;\n  2080â†’        row.run_id = current_run_id;\n  2081â†’        if let Some((old_mtime, old_size)) = root_existing.get(&row.path) {\n  2082â†’            if *old_mtime == row.mtime && *old_size == row.size {\n  2083â†’                stamp_batch.push(row.path);\n  2084â†’            } else {\n  2085â†’                batch.push(row);\n  2086â†’            }\n  2087â†’        } else {\n  2088â†’            batch.push(row);\n  2089â†’        }\n  2090â†’    }\n  2091â†’\n  2092â†’    // Partition direct children into priority vs deferred\n  2093â†’    let mut priority_roots: Vec<PathBuf> = Vec::new();\n  2094â†’    let mut deferred_roots: Vec<PathBuf> = Vec::new();\n  2095â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"2325e1c7-51cb-43b9-ab41-924011129ef3","timestamp":"2026-02-22T07:30:13.376Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"b5ebbb78-1b57-4f21-92ec-4158a014fdf0","timestamp":"2026-02-22T07:30:13.431Z"}
{"parentUuid":"b5ebbb78-1b57-4f21-92ec-4158a014fdf0","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-22T07:30:15.127Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_018o2tPuxqMvAWB9QJUYcaBo","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QNkBJh8mo9KtghtBnPwxy2","name":"Read","input":{"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","offset":2043,"limit":400},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":8864,"cache_read_input_tokens":24565,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":8864},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CYNiT3dATW6EAcwWxj6Xa","uuid":"d64fd440-6acb-43e2-8146-83d1236110fa"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"6c7d36c3-c99a-4a7d-8fd4-fe9928db5c5c","timestamp":"2026-02-22T07:30:15.127Z"}
{"parentUuid":"6c7d36c3-c99a-4a7d-8fd4-fe9928db5c5c","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QNkBJh8mo9KtghtBnPwxy2","type":"tool_result","content":"  2043â†’fn run_incremental_index_inner(\n  2044â†’    app: &AppHandle,\n  2045â†’    state: &AppState,\n  2046â†’    conn: &mut Connection,\n  2047â†’) -> AppResult<()> {\n  2048â†’\n  2049â†’    let (runtime_ignored_roots, runtime_ignored_patterns) = effective_ignore_rules(\n  2050â†’        &state.home_dir,\n  2051â†’        &state.cwd,\n  2052â†’        state.path_ignores.as_ref(),\n  2053â†’        state.path_ignore_patterns.as_ref(),\n  2054â†’    );\n  2055â†’    let gi_filter = state.gitignore.get();\n  2056â†’\n  2057â†’    let last_run_id: i64 = get_meta(conn, \"last_run_id\")\n  2058â†’        .and_then(|v| v.parse().ok())\n  2059â†’        .unwrap_or(0);\n  2060â†’    let current_run_id = last_run_id + 1;\n  2061â†’    // Fresh index: DB was empty, skip preload/stamp, single unlimited-depth pass\n  2062â†’    let is_fresh = last_run_id == 0;\n  2063â†’\n  2064â†’    let mut scanned: u64 = 0;\n  2065â†’    let mut indexed: u64 = 0;\n  2066â†’    let mut permission_errors: u64 = 0;\n  2067â†’    let mut current_path = String::new();\n  2068â†’    let mut batch: Vec<IndexRow> = Vec::with_capacity(BATCH_SIZE);\n  2069â†’    let mut stamp_batch: Vec<String> = Vec::with_capacity(BATCH_SIZE);\n  2070â†’    let mut last_emit = Instant::now();\n  2071â†’    let mut last_perf_emit = Instant::now();\n  2072â†’\n  2073â†’    // Preload scan_root-level entries (direct children only, not recursive)\n  2074â†’    let scan_str = state.scan_root.to_string_lossy().to_string();\n  2075â†’    let root_existing = preload_existing_entries(conn, &scan_str);\n  2076â†’\n  2077â†’    // Index scan_root itself\n  2078â†’    if let Some(mut row) = index_row_from_path(&state.scan_root) {\n  2079â†’        scanned += 1;\n  2080â†’        row.run_id = current_run_id;\n  2081â†’        if let Some((old_mtime, old_size)) = root_existing.get(&row.path) {\n  2082â†’            if *old_mtime == row.mtime && *old_size == row.size {\n  2083â†’                stamp_batch.push(row.path);\n  2084â†’            } else {\n  2085â†’                batch.push(row);\n  2086â†’            }\n  2087â†’        } else {\n  2088â†’            batch.push(row);\n  2089â†’        }\n  2090â†’    }\n  2091â†’\n  2092â†’    // Partition direct children into priority vs deferred\n  2093â†’    let mut priority_roots: Vec<PathBuf> = Vec::new();\n  2094â†’    let mut deferred_roots: Vec<PathBuf> = Vec::new();\n  2095â†’\n  2096â†’    if let Ok(entries) = fs::read_dir(&state.scan_root) {\n  2097â†’        for dir_entry in entries.flatten() {\n  2098â†’            let child_path = dir_entry.path();\n  2099â†’\n  2100â†’            if should_skip_path_ext(\n  2101â†’                &child_path,\n  2102â†’                &runtime_ignored_roots,\n  2103â†’                &runtime_ignored_patterns,\n  2104â†’                Some(&gi_filter),\n  2105â†’                None,\n  2106â†’            ) {\n  2107â†’                continue;\n  2108â†’            }\n  2109â†’\n  2110â†’            scanned += 1;\n  2111â†’            current_path = child_path.to_string_lossy().to_string();\n  2112â†’\n  2113â†’            if let Some(mut row) = index_row_from_path(&child_path) {\n  2114â†’                row.run_id = current_run_id;\n  2115â†’                if let Some((old_mtime, old_size)) = root_existing.get(&row.path) {\n  2116â†’                    if *old_mtime == row.mtime && *old_size == row.size {\n  2117â†’                        stamp_batch.push(row.path);\n  2118â†’                    } else {\n  2119â†’                        batch.push(row);\n  2120â†’                    }\n  2121â†’                } else {\n  2122â†’                    batch.push(row);\n  2123â†’                }\n  2124â†’            }\n  2125â†’\n  2126â†’            if child_path.is_dir() {\n  2127â†’                if is_deferred_dir(&child_path, &state.scan_root) {\n  2128â†’                    deferred_roots.push(child_path);\n  2129â†’                } else {\n  2130â†’                    priority_roots.push(child_path);\n  2131â†’                }\n  2132â†’            }\n  2133â†’        }\n  2134â†’    }\n  2135â†’\n  2136â†’\n  2137â†’    // Flush home-level stamp batch\n  2138â†’    if stamp_batch.len() >= BATCH_SIZE {\n  2139â†’        stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n  2140â†’        stamp_batch.clear();\n  2141â†’    }\n  2142â†’\n  2143â†’    priority_roots.sort();\n  2144â†’    deferred_roots.sort();\n  2145â†’\n  2146â†’    let roots: Vec<PathBuf> = priority_roots.into_iter().chain(deferred_roots).collect();\n  2147â†’    perf_log(format!(\n  2148â†’        \"index_scan_roots total={} priority+deferred\",\n  2149â†’        roots.len()\n  2150â†’    ));\n  2151â†’\n  2152â†’    // 2-pass indexing: shallow first (depth <= SHALLOW_SCAN_DEPTH), then deep\n  2153â†’    // Both passes use jwalk for parallel scanning\n  2154â†’    let arc_ignored_roots = Arc::new(runtime_ignored_roots.clone());\n  2155â†’    let arc_ignored_patterns = Arc::new(runtime_ignored_patterns.clone());\n  2156â†’\n  2157â†’\n  2158â†’    for pass in 0..2u8 {\n  2159â†’        // Fresh index: single unlimited-depth pass -- avoids double filesystem traversal\n  2160â†’        if pass == 1 && is_fresh {\n  2161â†’            break;\n  2162â†’        }\n  2163â†’        let pass_label = if pass == 0 { \"shallow\" } else { \"deep\" };\n  2164â†’        let pass_started = Instant::now();\n  2165â†’        let mut pass_scanned = 0u64;\n  2166â†’        let mut pass_indexed = 0u64;\n  2167â†’\n  2168â†’        for root in &roots {\n  2169â†’            let root_started = Instant::now();\n  2170â†’            let mut root_scanned = 0u64;\n  2171â†’            let mut root_indexed = 0u64;\n  2172â†’            let mut root_permission_errors = 0u64;\n  2173â†’            let root_str = root.to_string_lossy().to_string();\n  2174â†’\n  2175â†’            // Fresh index: DB is empty, preload is unnecessary\n  2176â†’            let existing = if is_fresh {\n  2177â†’                HashMap::new()\n  2178â†’            } else {\n  2179â†’                let e = preload_existing_entries(conn, &root_str);\n  2180â†’                e\n  2181â†’            };\n  2182â†’\n  2183â†’            let gi_ref = gi_filter.clone();\n  2184â†’            let skip_roots = arc_ignored_roots.clone();\n  2185â†’            let skip_patterns = arc_ignored_patterns.clone();\n  2186â†’\n  2187â†’            let mut builder = jwalk::WalkDir::new(root)\n  2188â†’                .follow_links(false)\n  2189â†’                .skip_hidden(false)\n  2190â†’                .parallelism(jwalk::Parallelism::RayonNewPool(jwalk_num_threads()));\n  2191â†’            // Fresh index: no depth limit -- walk everything in one pass\n  2192â†’            if pass == 0 && !is_fresh {\n  2193â†’                builder = builder.max_depth(SHALLOW_SCAN_DEPTH);\n  2194â†’            }\n  2195â†’            let walker = builder.process_read_dir(move |_depth, path, _state, children| {\n  2196â†’                children.retain(|entry_result| {\n  2197â†’                    entry_result\n  2198â†’                        .as_ref()\n  2199â†’                        .map(|entry| {\n  2200â†’                            let full_path = path.join(&entry.file_name);\n  2201â†’                            let is_dir = Some(entry.file_type.is_dir());\n  2202â†’                            !should_skip_path_ext(\n  2203â†’                                &full_path,\n  2204â†’                                &skip_roots,\n  2205â†’                                &skip_patterns,\n  2206â†’                                Some(&gi_ref),\n  2207â†’                                is_dir,\n  2208â†’                            )\n  2209â†’                        })\n  2210â†’                        .unwrap_or(false)\n  2211â†’                });\n  2212â†’            });\n  2213â†’\n  2214â†’            for result in walker {\n  2215â†’                match result {\n  2216â†’                    Ok(entry) => {\n  2217â†’                        let path = entry.path();\n  2218â†’                        if path == root.as_path() {\n  2219â†’                            continue;\n  2220â†’                        }\n  2221â†’\n  2222â†’                        // Pass 1 (incremental only): skip shallow entries already indexed in pass 0\n  2223â†’                        if pass == 1 && entry.depth <= SHALLOW_SCAN_DEPTH {\n  2224â†’                            continue;\n  2225â†’                        }\n  2226â†’\n  2227â†’                        scanned += 1;\n  2228â†’                        root_scanned += 1;\n  2229â†’                        current_path = path.to_string_lossy().to_string();\n  2230â†’\n  2231â†’                        if let Some(mut row) = index_row_from_jwalk_entry(&entry) {\n  2232â†’                            row.run_id = current_run_id;\n  2233â†’                            if is_fresh {\n  2234â†’                                // Fresh index: all entries are new, skip existing check\n  2235â†’                                indexed += 1;\n  2236â†’                                root_indexed += 1;\n  2237â†’                                batch.push(row);\n  2238â†’                            } else if let Some((old_mtime, old_size)) = existing.get(&row.path) {\n  2239â†’                                if *old_mtime == row.mtime && *old_size == row.size {\n  2240â†’                                    stamp_batch.push(row.path);\n  2241â†’                                } else {\n  2242â†’                                    indexed += 1;\n  2243â†’                                    root_indexed += 1;\n  2244â†’                                    batch.push(row);\n  2245â†’                                }\n  2246â†’                            } else {\n  2247â†’                                indexed += 1;\n  2248â†’                                root_indexed += 1;\n  2249â†’                                batch.push(row);\n  2250â†’                            }\n  2251â†’                        }\n  2252â†’\n  2253â†’                        if batch.len() >= BATCH_SIZE {\n  2254â†’                            upsert_rows(conn, &batch)?;\n  2255â†’                            batch.clear();\n  2256â†’                        }\n  2257â†’\n  2258â†’                        if stamp_batch.len() >= BATCH_SIZE {\n  2259â†’                            stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n  2260â†’                            stamp_batch.clear();\n  2261â†’                        }\n  2262â†’\n  2263â†’                        if last_emit.elapsed() >= Duration::from_millis(200) {\n  2264â†’                            set_progress(state, scanned, indexed, &current_path);\n  2265â†’                            emit_index_progress(app, scanned, indexed, current_path.clone());\n  2266â†’                            last_emit = Instant::now();\n  2267â†’                        }\n  2268â†’                        if perf_log_enabled() && last_perf_emit.elapsed() >= Duration::from_secs(1)\n  2269â†’                        {\n  2270â†’                            perf_log(format!(\n  2271â†’                                \"index_progress pass={} scanned={} indexed={} current_path={}\",\n  2272â†’                                pass_label, scanned, indexed, current_path\n  2273â†’                            ));\n  2274â†’                            last_perf_emit = Instant::now();\n  2275â†’                        }\n  2276â†’                    }\n  2277â†’                    Err(err) => {\n  2278â†’                        scanned += 1;\n  2279â†’                        root_scanned += 1;\n  2280â†’                        permission_errors += 1;\n  2281â†’                        root_permission_errors += 1;\n  2282â†’                        if permission_errors <= 20 || perf_log_enabled() {\n  2283â†’                            eprintln!(\"[index] permission error: {}\", err);\n  2284â†’                        }\n  2285â†’                    }\n  2286â†’                }\n  2287â†’            }\n  2288â†’\n  2289â†’            pass_scanned += root_scanned;\n  2290â†’            pass_indexed += root_indexed;\n  2291â†’\n  2292â†’            eprintln!(\"[timing]   walk_{} {} {}ms scanned={} indexed={} err={}\",\n  2293â†’                pass_label, root_str, root_started.elapsed().as_millis(),\n  2294â†’                root_scanned, root_indexed, root_permission_errors);\n  2295â†’            perf_log(format!(\n  2296â†’                \"index_root_done pass={} root={} elapsed_ms={} scanned={} indexed={} permission_errors={}\",\n  2297â†’                pass_label,\n  2298â†’                root.to_string_lossy(),\n  2299â†’                root_started.elapsed().as_millis(),\n  2300â†’                root_scanned,\n  2301â†’                root_indexed,\n  2302â†’                root_permission_errors,\n  2303â†’            ));\n  2304â†’        }\n  2305â†’\n  2306â†’        // Flush between passes\n  2307â†’        if !batch.is_empty() {\n  2308â†’            upsert_rows(conn, &batch)?;\n  2309â†’            batch.clear();\n  2310â†’        }\n  2311â†’        if !stamp_batch.is_empty() {\n  2312â†’            stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n  2313â†’            stamp_batch.clear();\n  2314â†’        }\n  2315â†’\n  2316â†’        perf_log(format!(\n  2317â†’            \"index_pass_done pass={} elapsed_ms={} scanned={} indexed={}\",\n  2318â†’            pass_label,\n  2319â†’            pass_started.elapsed().as_millis(),\n  2320â†’            pass_scanned,\n  2321â†’            pass_indexed,\n  2322â†’        ));\n  2323â†’\n  2324â†’        // After shallow pass (incremental only), emit progress so UI shows searchable state early\n  2325â†’        // Fresh index uses per-root emit above instead.\n  2326â†’        if pass == 0 && !is_fresh {\n  2327â†’            let _ = refresh_and_emit_status_counts(app, state);\n  2328â†’            let _ = app.emit(\n  2329â†’                \"index_updated\",\n  2330â†’                IndexUpdatedEvent {\n  2331â†’                    entries_count: state.status.lock().entries_count,\n  2332â†’                    last_updated: now_epoch(),\n  2333â†’                    permission_errors,\n  2334â†’                },\n  2335â†’            );\n  2336â†’        }\n  2337â†’    }\n  2338â†’\n  2339â†’    if !batch.is_empty() {\n  2340â†’        upsert_rows(conn, &batch)?;\n  2341â†’    }\n  2342â†’\n  2343â†’    if !stamp_batch.is_empty() {\n  2344â†’        stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n  2345â†’    }\n  2346â†’\n  2347â†’    set_progress(state, scanned, indexed, &current_path);\n  2348â†’    emit_index_progress(app, scanned, indexed, current_path.clone());\n  2349â†’\n  2350â†’    // Remove entries not seen in this run (deleted files)\n  2351â†’    // Fresh index: DB was empty before this run, no stale entries possible\n  2352â†’    let deleted_count: i64 = if is_fresh {\n  2353â†’        0\n  2354â†’    } else {\n  2355â†’        let count = conn\n  2356â†’            .query_row(\n  2357â†’                \"SELECT COUNT(*) FROM entries WHERE run_id < ?1\",\n  2358â†’                params![current_run_id],\n  2359â†’                |row| row.get(0),\n  2360â†’            )\n  2361â†’            .unwrap_or(0);\n  2362â†’        conn.execute(\n  2363â†’            \"DELETE FROM entries WHERE run_id < ?1\",\n  2364â†’            params![current_run_id],\n  2365â†’        )\n  2366â†’        .map_err(|e| e.to_string())?;\n  2367â†’        count\n  2368â†’    };\n  2369â†’\n  2370â†’    set_meta(conn, \"last_run_id\", &current_run_id.to_string())?;\n  2371â†’\n  2372â†’    if deleted_count > 0 || indexed > 0 {\n  2373â†’        invalidate_search_caches(state);\n  2374â†’    }\n  2375â†’\n  2376â†’    let (entries_count, last_updated) = update_status_counts(state)?;\n  2377â†’    // Persist cached counts for instant startup next time\n  2378â†’    let _ = set_meta(conn, \"cached_entries_count\", &entries_count.to_string());\n  2379â†’    if let Some(lu) = last_updated {\n  2380â†’        let _ = set_meta(conn, \"cached_last_updated\", &lu.to_string());\n  2381â†’    }\n  2382â†’    let updated_at = last_updated.unwrap_or_else(now_epoch);\n  2383â†’\n  2384â†’    {\n  2385â†’        let mut status = state.status.lock();\n  2386â†’        status.state = IndexState::Ready;\n  2387â†’        status.permission_errors = permission_errors;\n  2388â†’        status.scanned = scanned;\n  2389â†’        status.indexed = indexed;\n  2390â†’        status.current_path = current_path.clone();\n  2391â†’        status.message = if permission_errors > 0 {\n  2392â†’            Some(format!(\n  2393â†’                \"{} permission/access error(s) occurred.\",\n  2394â†’                permission_errors\n  2395â†’            ))\n  2396â†’        } else {\n  2397â†’            None\n  2398â†’        };\n  2399â†’    }\n  2400â†’    emit_index_progress(app, scanned, indexed, current_path);\n  2401â†’    emit_index_updated(app, entries_count, updated_at, permission_errors);\n  2402â†’    emit_index_state(\n  2403â†’        app,\n  2404â†’        \"Ready\",\n  2405â†’        if permission_errors > 0 {\n  2406â†’            Some(format!(\"{} permission/access error(s)\", permission_errors))\n  2407â†’        } else {\n  2408â†’            None\n  2409â†’        },\n  2410â†’    );\n  2411â†’    perf_log(format!(\n  2412â†’        \"index_state=Ready scanned={} indexed={} deleted={} entries={} permission_errors={}\",\n  2413â†’        scanned, indexed, deleted_count, entries_count, permission_errors\n  2414â†’    ));\n  2415â†’\n  2416â†’    Ok(())\n  2417â†’}\n  2418â†’\n  2419â†’fn trim_recent_ops(ops: &mut Vec<RecentOp>) {\n  2420â†’    let now = Instant::now();\n  2421â†’    ops.retain(|op| now.duration_since(op.at) <= RECENT_OP_TTL);\n  2422â†’}\n  2423â†’\n  2424â†’fn remember_op(\n  2425â†’    state: &AppState,\n  2426â†’    op_type: &'static str,\n  2427â†’    old_path: Option<String>,\n  2428â†’    new_path: Option<String>,\n  2429â†’) {\n  2430â†’    let mut ops = state.recent_ops.lock();\n  2431â†’    trim_recent_ops(&mut ops);\n  2432â†’    ops.push(RecentOp {\n  2433â†’        old_path,\n  2434â†’        new_path,\n  2435â†’        op_type,\n  2436â†’        at: Instant::now(),\n  2437â†’    });\n  2438â†’}\n  2439â†’\n  2440â†’#[cfg(any(target_os = \"macos\", target_os = \"windows\"))]\n  2441â†’pub(crate) fn is_recently_touched(state: &AppState, path: &str) -> bool {\n  2442â†’    let mut ops = state.recent_ops.lock();\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"b1be1a8e-0f07-4cbb-af87-03f9196cb075","timestamp":"2026-02-22T07:30:15.133Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"76f625fa-0955-4bef-85d9-6838b48ca50e","timestamp":"2026-02-22T07:30:15.152Z"}
{"parentUuid":"76f625fa-0955-4bef-85d9-6838b48ca50e","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-22T07:30:16.896Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01JAncqsJkeyeZccU6gsH5ME","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FpP747tTGZxuGvntfKKtoD","name":"Read","input":{"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","offset":411,"limit":50},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":5944,"cache_read_input_tokens":33429,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":5944},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CYNiTAyBq7v9VuvCrgRuz","uuid":"c75fed94-0504-47c0-a620-1528ca4ab46a"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"b84349bd-a512-40b7-a85c-80d53a28fb4f","timestamp":"2026-02-22T07:30:16.896Z"}
{"parentUuid":"b84349bd-a512-40b7-a85c-80d53a28fb4f","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FpP747tTGZxuGvntfKKtoD","type":"tool_result","content":"   411â†’pub(crate) fn set_indexing_pragmas(conn: &Connection) -> AppResult<()> {\n   412â†’    conn.execute_batch(\n   413â†’        r#\"\n   414â†’        PRAGMA synchronous = NORMAL;\n   415â†’        PRAGMA cache_size = -65536;\n   416â†’        PRAGMA mmap_size = 268435456;\n   417â†’        PRAGMA wal_autocheckpoint = 10000;\n   418â†’        \"#,\n   419â†’    )\n   420â†’    .map_err(|e| e.to_string())\n   421â†’}\n   422â†’\n   423â†’pub(crate) fn restore_normal_pragmas(conn: &Connection) -> AppResult<()> {\n   424â†’    conn.execute_batch(\n   425â†’        r#\"\n   426â†’        PRAGMA synchronous = NORMAL;\n   427â†’        PRAGMA cache_size = -16384;\n   428â†’        PRAGMA mmap_size = 268435456;\n   429â†’        PRAGMA wal_autocheckpoint = 1000;\n   430â†’        \"#,\n   431â†’    )\n   432â†’    .map_err(|e| e.to_string())?;\n   433â†’    conn.execute_batch(\"PRAGMA wal_checkpoint(TRUNCATE);\")\n   434â†’        .map_err(|e| e.to_string())?;\n   435â†’    Ok(())\n   436â†’}\n   437â†’\n   438â†’fn init_db(db_path: &Path) -> AppResult<()> {\n   439â†’    let t = Instant::now();\n   440â†’    let conn = db_connection(db_path)?;\n   441â†’    eprintln!(\"[init_db] +{}ms db_connection opened\", t.elapsed().as_millis());\n   442â†’\n   443â†’    let current_version: i32 = conn\n   444â†’        .query_row(\"PRAGMA user_version\", [], |row| row.get(0))\n   445â†’        .unwrap_or(0);\n   446â†’    if current_version != DB_VERSION {\n   447â†’        conn.execute_batch(\n   448â†’            r#\"\n   449â†’            DROP TRIGGER IF EXISTS entries_ai;\n   450â†’            DROP TRIGGER IF EXISTS entries_ad;\n   451â†’            DROP TRIGGER IF EXISTS entries_au;\n   452â†’            DROP TABLE IF EXISTS entries_fts;\n   453â†’            DROP TABLE IF EXISTS entries;\n   454â†’            \"#,\n   455â†’        )\n   456â†’        .map_err(|e| e.to_string())?;\n   457â†’        conn.execute_batch(&format!(\"PRAGMA user_version = {};\", DB_VERSION))\n   458â†’            .map_err(|e| e.to_string())?;\n   459â†’    }\n   460â†’    eprintln!(\"[init_db] +{}ms version check done (v={})\", t.elapsed().as_millis(), current_version);\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"d6771081-3962-40bf-b67f-962c39936557","timestamp":"2026-02-22T07:30:16.914Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"26884939-cb33-4418-8fe4-0b4aecc92540","timestamp":"2026-02-22T07:30:17.055Z"}
{"parentUuid":"26884939-cb33-4418-8fe4-0b4aecc92540","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-22T07:30:17.293Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01JAncqsJkeyeZccU6gsH5ME","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013rKTJcNV5o9PbJMCnUCeco","name":"Read","input":{"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","offset":374,"limit":80},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":5944,"cache_read_input_tokens":33429,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":5944},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CYNiTAyBq7v9VuvCrgRuz","uuid":"e7fdd162-4122-4b3e-ac24-b857ba3dd7bc"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"6312a020-1b04-4b86-9c97-fab9431b52c0","timestamp":"2026-02-22T07:30:17.293Z"}
{"parentUuid":"6312a020-1b04-4b86-9c97-fab9431b52c0","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013rKTJcNV5o9PbJMCnUCeco","type":"tool_result","content":"   374â†’    *PERF_LOG_ENABLED.get_or_init(|| env_truthy(\"FASTFIND_PERF_LOG\") || bench_mode_enabled())\n   375â†’}\n   376â†’\n   377â†’pub(crate) fn perf_log(message: impl AsRef<str>) {\n   378â†’    if perf_log_enabled() {\n   379â†’        eprintln!(\"[perf] {}\", message.as_ref());\n   380â†’    }\n   381â†’}\n   382â†’\n   383â†’fn db_connection_with_timeout(db_path: &Path, busy_timeout_ms: u32) -> AppResult<Connection> {\n   384â†’    let conn = Connection::open(db_path).map_err(|e| e.to_string())?;\n   385â†’    conn.execute_batch(&format!(\n   386â†’        r#\"\n   387â†’        PRAGMA journal_mode=WAL;\n   388â†’        PRAGMA synchronous=NORMAL;\n   389â†’        PRAGMA temp_store=MEMORY;\n   390â†’        PRAGMA busy_timeout={busy_timeout_ms};\n   391â†’        \"#,\n   392â†’    ))\n   393â†’    .map_err(|e| e.to_string())?;\n   394â†’    Ok(conn)\n   395â†’}\n   396â†’\n   397â†’pub(crate) fn db_connection(db_path: &Path) -> AppResult<Connection> {\n   398â†’    db_connection_with_timeout(db_path, 3000)\n   399â†’}\n   400â†’\n   401â†’fn db_connection_for_search(db_path: &Path) -> AppResult<Connection> {\n   402â†’    let conn = db_connection_with_timeout(db_path, 500)?;\n   403â†’    conn.execute_batch(\n   404â†’        \"PRAGMA cache_size = -32768;\n   405â†’         PRAGMA mmap_size = 268435456;\",\n   406â†’    )\n   407â†’    .map_err(|e| e.to_string())?;\n   408â†’    Ok(conn)\n   409â†’}\n   410â†’\n   411â†’pub(crate) fn set_indexing_pragmas(conn: &Connection) -> AppResult<()> {\n   412â†’    conn.execute_batch(\n   413â†’        r#\"\n   414â†’        PRAGMA synchronous = NORMAL;\n   415â†’        PRAGMA cache_size = -65536;\n   416â†’        PRAGMA mmap_size = 268435456;\n   417â†’        PRAGMA wal_autocheckpoint = 10000;\n   418â†’        \"#,\n   419â†’    )\n   420â†’    .map_err(|e| e.to_string())\n   421â†’}\n   422â†’\n   423â†’pub(crate) fn restore_normal_pragmas(conn: &Connection) -> AppResult<()> {\n   424â†’    conn.execute_batch(\n   425â†’        r#\"\n   426â†’        PRAGMA synchronous = NORMAL;\n   427â†’        PRAGMA cache_size = -16384;\n   428â†’        PRAGMA mmap_size = 268435456;\n   429â†’        PRAGMA wal_autocheckpoint = 1000;\n   430â†’        \"#,\n   431â†’    )\n   432â†’    .map_err(|e| e.to_string())?;\n   433â†’    conn.execute_batch(\"PRAGMA wal_checkpoint(TRUNCATE);\")\n   434â†’        .map_err(|e| e.to_string())?;\n   435â†’    Ok(())\n   436â†’}\n   437â†’\n   438â†’fn init_db(db_path: &Path) -> AppResult<()> {\n   439â†’    let t = Instant::now();\n   440â†’    let conn = db_connection(db_path)?;\n   441â†’    eprintln!(\"[init_db] +{}ms db_connection opened\", t.elapsed().as_millis());\n   442â†’\n   443â†’    let current_version: i32 = conn\n   444â†’        .query_row(\"PRAGMA user_version\", [], |row| row.get(0))\n   445â†’        .unwrap_or(0);\n   446â†’    if current_version != DB_VERSION {\n   447â†’        conn.execute_batch(\n   448â†’            r#\"\n   449â†’            DROP TRIGGER IF EXISTS entries_ai;\n   450â†’            DROP TRIGGER IF EXISTS entries_ad;\n   451â†’            DROP TRIGGER IF EXISTS entries_au;\n   452â†’            DROP TABLE IF EXISTS entries_fts;\n   453â†’            DROP TABLE IF EXISTS entries;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"563bfdb6-c104-469c-8960-c49cb3370937","timestamp":"2026-02-22T07:30:17.302Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"415e6c84-6eb6-46ba-984a-5e370563cf4f","timestamp":"2026-02-22T07:30:17.607Z"}
{"parentUuid":"415e6c84-6eb6-46ba-984a-5e370563cf4f","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-22T07:30:18.010Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01JAncqsJkeyeZccU6gsH5ME","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01P33J6VskijSq1GnW1M991a","name":"Grep","input":{"pattern":"fn upsert_rows|fn restore_normal_pragmas","type":"rust","path":"/Users/al02402336/everything/src-tauri/src/main.rs","output_mode":"content","context":5},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":5944,"cache_read_input_tokens":33429,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":5944},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CYNiTAyBq7v9VuvCrgRuz","uuid":"b7974db8-929f-4ece-b484-d35cf54c560a"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"57bbf8c6-7d1b-40d3-ade0-e967b48e9652","timestamp":"2026-02-22T07:30:18.010Z"}
{"parentUuid":"57bbf8c6-7d1b-40d3-ade0-e967b48e9652","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01P33J6VskijSq1GnW1M991a","type":"tool_result","content":"418-        \"#,\n419-    )\n420-    .map_err(|e| e.to_string())\n421-}\n422-\n423:pub(crate) fn restore_normal_pragmas(conn: &Connection) -> AppResult<()> {\n424-    conn.execute_batch(\n425-        r#\"\n426-        PRAGMA synchronous = NORMAL;\n427-        PRAGMA cache_size = -16384;\n428-        PRAGMA mmap_size = 268435456;\n--\n1676-\n1677-    sort_entries_with_relevance(&mut entries, trimmed, sort_by, sort_dir);\n1678-    entries\n1679-}\n1680-\n1681:pub(crate) fn upsert_rows(conn: &mut Connection, rows: &[IndexRow]) -> AppResult<usize> {\n1682-    if rows.is_empty() {\n1683-        return Ok(0);\n1684-    }\n1685-\n1686-    let tx = conn.transaction().map_err(|e| e.to_string())?;"}]},"uuid":"7da98f54-1f86-4393-af0e-d4170f97c3d6","timestamp":"2026-02-22T07:30:18.679Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"55e1816b-d7a0-491d-85c5-9ee4af6ef36e","timestamp":"2026-02-22T07:30:18.682Z"}
{"parentUuid":"55e1816b-d7a0-491d-85c5-9ee4af6ef36e","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-22T07:30:20.167Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01TrjbQtJjHkspE8qmyPgf61","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BANYQ5SoX8N2eZH3mnkpi1","name":"Read","input":{"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","offset":1681,"limit":150},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":2748,"cache_read_input_tokens":39373,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2748},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CYNiTS4YKodzQQjTc1xyo","uuid":"14dcb03d-75ad-427f-8c14-5d8037f2b07b"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"f04cb6d9-01eb-450e-ade1-60c52440a43c","timestamp":"2026-02-22T07:30:20.167Z"}
{"parentUuid":"f04cb6d9-01eb-450e-ade1-60c52440a43c","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BANYQ5SoX8N2eZH3mnkpi1","type":"tool_result","content":"  1681â†’pub(crate) fn upsert_rows(conn: &mut Connection, rows: &[IndexRow]) -> AppResult<usize> {\n  1682â†’    if rows.is_empty() {\n  1683â†’        return Ok(0);\n  1684â†’    }\n  1685â†’\n  1686â†’    let tx = conn.transaction().map_err(|e| e.to_string())?;\n  1687â†’    {\n  1688â†’        let mut stmt = tx\n  1689â†’            .prepare(\n  1690â†’                r#\"\n  1691â†’                INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n  1692â†’                VALUES(?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)\n  1693â†’                ON CONFLICT(path) DO UPDATE SET\n  1694â†’                  name = excluded.name,\n  1695â†’                  dir = excluded.dir,\n  1696â†’                  is_dir = excluded.is_dir,\n  1697â†’                  ext = excluded.ext,\n  1698â†’                  mtime = excluded.mtime,\n  1699â†’                  size = excluded.size,\n  1700â†’                  indexed_at = excluded.indexed_at,\n  1701â†’                  run_id = excluded.run_id\n  1702â†’                \"#,\n  1703â†’            )\n  1704â†’            .map_err(|e| e.to_string())?;\n  1705â†’\n  1706â†’        for row in rows {\n  1707â†’            stmt.execute(params![\n  1708â†’                row.path,\n  1709â†’                row.name,\n  1710â†’                row.dir,\n  1711â†’                row.is_dir,\n  1712â†’                row.ext,\n  1713â†’                row.mtime,\n  1714â†’                row.size,\n  1715â†’                row.indexed_at,\n  1716â†’                row.run_id\n  1717â†’            ])\n  1718â†’            .map_err(|e| e.to_string())?;\n  1719â†’        }\n  1720â†’    }\n  1721â†’    tx.commit().map_err(|e| e.to_string())?;\n  1722â†’    Ok(rows.len())\n  1723â†’}\n  1724â†’\n  1725â†’pub(crate) fn delete_paths(conn: &mut Connection, raw_paths: &[String]) -> AppResult<usize> {\n  1726â†’    if raw_paths.is_empty() {\n  1727â†’        return Ok(0);\n  1728â†’    }\n  1729â†’\n  1730â†’    let tx = conn.transaction().map_err(|e| e.to_string())?;\n  1731â†’    let mut deleted = 0;\n  1732â†’\n  1733â†’    {\n  1734â†’        let mut stmt_exact = tx\n  1735â†’            .prepare(\"DELETE FROM entries WHERE path = ?1\")\n  1736â†’            .map_err(|e| e.to_string())?;\n  1737â†’        let mut stmt_children = tx\n  1738â†’            .prepare(\"DELETE FROM entries WHERE path >= ?1 AND path < ?2\")\n  1739â†’            .map_err(|e| e.to_string())?;\n  1740â†’\n  1741â†’        for path in raw_paths {\n  1742â†’            let is_root = path == \"/\" || path == \"\\\\\";\n  1743â†’            let normalized = if is_root {\n  1744â†’                path.clone()\n  1745â†’            } else {\n  1746â†’                path.trim_end_matches(&['/', '\\\\'][..]).to_string()\n  1747â†’            };\n  1748â†’\n  1749â†’            if normalized.is_empty() {\n  1750â†’                continue;\n  1751â†’            }\n  1752â†’\n  1753â†’            if is_root {\n  1754â†’                deleted += tx\n  1755â†’                    .execute(\"DELETE FROM entries\", [])\n  1756â†’                    .map_err(|e| e.to_string())?;\n  1757â†’                continue;\n  1758â†’            }\n  1759â†’\n  1760â†’            deleted += stmt_exact\n  1761â†’                .execute(params![&normalized])\n  1762â†’                .map_err(|e| e.to_string())?;\n  1763â†’\n  1764â†’            // Delete children using B-tree range scan: path >= \"{normalized}{sep}\" AND path < \"{normalized}\\x7F\"\n  1765â†’            // \\x7F (127) is higher than both '/' (47) and '\\' (92), so this captures all children.\n  1766â†’            let sep = std::path::MAIN_SEPARATOR;\n  1767â†’            let range_start = format!(\"{normalized}{sep}\");\n  1768â†’            let range_end = format!(\"{normalized}\\x7F\");\n  1769â†’            deleted += stmt_children\n  1770â†’                .execute(params![&range_start, &range_end])\n  1771â†’                .map_err(|e| e.to_string())?;\n  1772â†’        }\n  1773â†’    }\n  1774â†’\n  1775â†’    tx.commit().map_err(|e| e.to_string())?;\n  1776â†’    Ok(deleted)\n  1777â†’}\n  1778â†’\n  1779â†’pub(crate) fn emit_index_state(app: &AppHandle, state: &str, message: Option<String>) {\n  1780â†’    let is_catchup = message.as_ref().map_or(false, |m| m.starts_with(\"Catchup:\"));\n  1781â†’    let _ = app.emit(\n  1782â†’        \"index_state\",\n  1783â†’        IndexStateEvent {\n  1784â†’            state: state.to_string(),\n  1785â†’            message,\n  1786â†’            is_catchup,\n  1787â†’        },\n  1788â†’    );\n  1789â†’}\n  1790â†’\n  1791â†’pub(crate) fn emit_index_updated(\n  1792â†’    app: &AppHandle,\n  1793â†’    entries_count: u64,\n  1794â†’    last_updated: i64,\n  1795â†’    permission_errors: u64,\n  1796â†’) {\n  1797â†’    let _ = app.emit(\n  1798â†’        \"index_updated\",\n  1799â†’        IndexUpdatedEvent {\n  1800â†’            entries_count,\n  1801â†’            last_updated,\n  1802â†’            permission_errors,\n  1803â†’        },\n  1804â†’    );\n  1805â†’}\n  1806â†’\n  1807â†’pub(crate) fn emit_index_progress(app: &AppHandle, scanned: u64, indexed: u64, current_path: String) {\n  1808â†’    let _ = app.emit(\n  1809â†’        \"index_progress\",\n  1810â†’        IndexProgressEvent {\n  1811â†’            scanned,\n  1812â†’            indexed,\n  1813â†’            current_path,\n  1814â†’        },\n  1815â†’    );\n  1816â†’}\n  1817â†’\n  1818â†’pub(crate) fn set_state(state: &AppState, next: IndexState, message: Option<String>) {\n  1819â†’    let mut status = state.status.lock();\n  1820â†’    status.state = next;\n  1821â†’    status.message = message;\n  1822â†’}\n  1823â†’\n  1824â†’pub(crate) fn set_progress(state: &AppState, scanned: u64, indexed: u64, current_path: &str) {\n  1825â†’    let mut status = state.status.lock();\n  1826â†’    status.scanned = scanned;\n  1827â†’    status.indexed = indexed;\n  1828â†’    status.current_path = current_path.to_string();\n  1829â†’}\n  1830â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"9f1c7fae-5d4a-4a51-a1dc-53983291cd96","timestamp":"2026-02-22T07:30:20.179Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"06068b14-9663-4215-a231-1ee9c4e8bf0e","timestamp":"2026-02-22T07:30:20.215Z"}
{"parentUuid":"06068b14-9663-4215-a231-1ee9c4e8bf0e","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-22T07:30:22.340Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01C1pwDHWmMhhoPisf2nfekw","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01B17S4afqmvWwyVyToA4TfJ","name":"Grep","input":{"pattern":"CREATE TABLE entries|CREATE TABLE entries_fts|CREATE TRIGGER|entries_ai|entries_au|entries_ad","type":"rust","path":"/Users/al02402336/everything/src-tauri/src/main.rs","output_mode":"content","context":3},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":2252,"cache_read_input_tokens":42121,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2252},"output_tokens":4,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CYNiTYmN7xnKcCrpgCX2x","uuid":"969ec25b-4b2b-4d4e-91c6-ceab7160c311"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"371adb11-37ea-4997-96e5-f8a3a0c65635","timestamp":"2026-02-22T07:30:22.340Z"}
{"parentUuid":"371adb11-37ea-4997-96e5-f8a3a0c65635","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01B17S4afqmvWwyVyToA4TfJ","type":"tool_result","content":"446-    if current_version != DB_VERSION {\n447-        conn.execute_batch(\n448-            r#\"\n449:            DROP TRIGGER IF EXISTS entries_ai;\n450:            DROP TRIGGER IF EXISTS entries_ad;\n451:            DROP TRIGGER IF EXISTS entries_au;\n452-            DROP TABLE IF EXISTS entries_fts;\n453-            DROP TABLE IF EXISTS entries;\n454-            \"#,"}]},"uuid":"3860583b-5c59-464e-86d7-0d226491fdcb","timestamp":"2026-02-22T07:30:22.999Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"bb4958f3-446b-48e6-9829-d4b973326fff","timestamp":"2026-02-22T07:30:23.001Z"}
{"parentUuid":"bb4958f3-446b-48e6-9829-d4b973326fff","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-22T07:30:24.340Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01KcBqZMcZppqgyxprwE7wtV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01ExDGJdAdpMkJLDZoe4nB25","name":"Read","input":{"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","offset":438,"limit":200},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":438,"cache_read_input_tokens":44373,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":438},"output_tokens":18,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CYNiTkWo5kG33rst5sboZ","uuid":"e92412b6-3633-4b2a-a781-97add829bbb8"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"d8e1ad7f-d80d-4960-b8fd-32864f8338e9","timestamp":"2026-02-22T07:30:24.341Z"}
{"parentUuid":"d8e1ad7f-d80d-4960-b8fd-32864f8338e9","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01ExDGJdAdpMkJLDZoe4nB25","type":"tool_result","content":"   438â†’fn init_db(db_path: &Path) -> AppResult<()> {\n   439â†’    let t = Instant::now();\n   440â†’    let conn = db_connection(db_path)?;\n   441â†’    eprintln!(\"[init_db] +{}ms db_connection opened\", t.elapsed().as_millis());\n   442â†’\n   443â†’    let current_version: i32 = conn\n   444â†’        .query_row(\"PRAGMA user_version\", [], |row| row.get(0))\n   445â†’        .unwrap_or(0);\n   446â†’    if current_version != DB_VERSION {\n   447â†’        conn.execute_batch(\n   448â†’            r#\"\n   449â†’            DROP TRIGGER IF EXISTS entries_ai;\n   450â†’            DROP TRIGGER IF EXISTS entries_ad;\n   451â†’            DROP TRIGGER IF EXISTS entries_au;\n   452â†’            DROP TABLE IF EXISTS entries_fts;\n   453â†’            DROP TABLE IF EXISTS entries;\n   454â†’            \"#,\n   455â†’        )\n   456â†’        .map_err(|e| e.to_string())?;\n   457â†’        conn.execute_batch(&format!(\"PRAGMA user_version = {};\", DB_VERSION))\n   458â†’            .map_err(|e| e.to_string())?;\n   459â†’    }\n   460â†’    eprintln!(\"[init_db] +{}ms version check done (v={})\", t.elapsed().as_millis(), current_version);\n   461â†’\n   462â†’    conn.execute_batch(\n   463â†’        r#\"\n   464â†’        CREATE TABLE IF NOT EXISTS entries (\n   465â†’          id INTEGER PRIMARY KEY,\n   466â†’          path TEXT NOT NULL UNIQUE,\n   467â†’          name TEXT NOT NULL,\n   468â†’          dir TEXT NOT NULL,\n   469â†’          is_dir INTEGER NOT NULL,\n   470â†’          ext TEXT,\n   471â†’          mtime INTEGER,\n   472â†’          size INTEGER,\n   473â†’          indexed_at INTEGER NOT NULL,\n   474â†’          run_id INTEGER NOT NULL DEFAULT 0\n   475â†’        );\n   476â†’\n   477â†’        CREATE INDEX IF NOT EXISTS idx_entries_dir_ext_name_nocase ON entries(dir, ext, name COLLATE NOCASE);\n   478â†’        CREATE INDEX IF NOT EXISTS idx_entries_mtime ON entries(mtime);\n   479â†’        CREATE INDEX IF NOT EXISTS idx_entries_name_nocase ON entries(name COLLATE NOCASE);\n   480â†’        CREATE INDEX IF NOT EXISTS idx_entries_ext_name ON entries(ext, name COLLATE NOCASE);\n   481â†’\n   482â†’        CREATE TABLE IF NOT EXISTS meta (\n   483â†’          key TEXT PRIMARY KEY,\n   484â†’          value TEXT NOT NULL\n   485â†’        );\n   486â†’        \"#,\n   487â†’    )\n   488â†’    .map_err(|e| e.to_string())?;\n   489â†’    eprintln!(\"[init_db] +{}ms schema ensured\", t.elapsed().as_millis());\n   490â†’\n   491â†’    let legacy_index_migration_key = \"migration_drop_idx_entries_dir_name_nocase_v1\";\n   492â†’    let migrated = get_meta(&conn, legacy_index_migration_key)\n   493â†’        .map(|v| v == \"1\")\n   494â†’        .unwrap_or(false);\n   495â†’    if !migrated {\n   496â†’        conn.execute_batch(\"DROP INDEX IF EXISTS idx_entries_dir_name_nocase;\")\n   497â†’            .map_err(|e| e.to_string())?;\n   498â†’        set_meta(&conn, legacy_index_migration_key, \"1\")?;\n   499â†’    }\n   500â†’    eprintln!(\"[init_db] +{}ms total\", t.elapsed().as_millis());\n   501â†’\n   502â†’    Ok(())\n   503â†’}\n   504â†’\n   505â†’pub(crate) fn get_meta(conn: &Connection, key: &str) -> Option<String> {\n   506â†’    conn.query_row(\n   507â†’        \"SELECT value FROM meta WHERE key = ?1\",\n   508â†’        params![key],\n   509â†’        |row| row.get(0),\n   510â†’    )\n   511â†’    .ok()\n   512â†’}\n   513â†’\n   514â†’pub(crate) fn set_meta(conn: &Connection, key: &str, value: &str) -> AppResult<()> {\n   515â†’    conn.execute(\n   516â†’        \"INSERT OR REPLACE INTO meta(key, value) VALUES(?1, ?2)\",\n   517â†’        params![key, value],\n   518â†’    )\n   519â†’    .map_err(|e| e.to_string())?;\n   520â†’    Ok(())\n   521â†’}\n   522â†’\n   523â†’fn update_counts(state: &AppState) -> AppResult<(u64, Option<i64>)> {\n   524â†’    let conn = db_connection(&state.db_path)?;\n   525â†’\n   526â†’    let entries_count = conn\n   527â†’        .query_row(\"SELECT COUNT(*) FROM entries\", [], |row| {\n   528â†’            row.get::<_, i64>(0)\n   529â†’        })\n   530â†’        .map_err(|e| e.to_string())?\n   531â†’        .max(0) as u64;\n   532â†’\n   533â†’    let last_updated = conn\n   534â†’        .query_row(\"SELECT MAX(indexed_at) FROM entries\", [], |row| {\n   535â†’            row.get::<_, Option<i64>>(0)\n   536â†’        })\n   537â†’        .map_err(|e| e.to_string())?;\n   538â†’\n   539â†’    Ok((entries_count, last_updated))\n   540â†’}\n   541â†’\n   542â†’pub(crate) fn update_status_counts(state: &AppState) -> AppResult<(u64, Option<i64>)> {\n   543â†’    let (entries_count, last_updated) = update_counts(state)?;\n   544â†’    let mut status = state.status.lock();\n   545â†’    status.entries_count = entries_count;\n   546â†’    status.last_updated = last_updated;\n   547â†’    Ok((entries_count, last_updated))\n   548â†’}\n   549â†’\n   550â†’pub(crate) fn invalidate_search_caches(state: &AppState) {\n   551â†’    state.fd_search_cache.lock().take();\n   552â†’    state.negative_name_cache.lock().clear();\n   553â†’}\n   554â†’\n   555â†’fn prune_negative_name_cache(cache: &mut HashMap<String, NegativeNameEntry>) {\n   556â†’    let now = Instant::now();\n   557â†’    cache.retain(|_, entry| now.duration_since(entry.created_at) <= NEGATIVE_CACHE_TTL);\n   558â†’}\n   559â†’\n   560â†’fn negative_name_cache_lookup(state: &AppState, query: &str) -> Option<NegativeCacheHit> {\n   561â†’    if query.is_empty() {\n   562â†’        return None;\n   563â†’    }\n   564â†’    let q = query.to_lowercase();\n   565â†’    let now = Instant::now();\n   566â†’    let mut cache = state.negative_name_cache.lock();\n   567â†’    prune_negative_name_cache(&mut cache);\n   568â†’    cache\n   569â†’        .iter()\n   570â†’        .filter(|(key, _)| q.contains(key.as_str()))\n   571â†’        .max_by_key(|(key, _)| key.len())\n   572â†’        .map(|(key, entry)| NegativeCacheHit {\n   573â†’            query_lower: key.clone(),\n   574â†’            age: now.duration_since(entry.created_at),\n   575â†’            fallback_checked: entry.fallback_checked,\n   576â†’        })\n   577â†’}\n   578â†’\n   579â†’fn remember_negative_name_query(state: &AppState, query: &str) {\n   580â†’    if query.is_empty() {\n   581â†’        return;\n   582â†’    }\n   583â†’    let normalized = query.to_lowercase();\n   584â†’    let mut cache = state.negative_name_cache.lock();\n   585â†’    prune_negative_name_cache(&mut cache);\n   586â†’\n   587â†’    if cache.contains_key(&normalized) {\n   588â†’        return;\n   589â†’    }\n   590â†’\n   591â†’    cache.insert(\n   592â†’        normalized,\n   593â†’        NegativeNameEntry {\n   594â†’            created_at: Instant::now(),\n   595â†’            fallback_checked: false,\n   596â†’        },\n   597â†’    );\n   598â†’    const MAX_NEGATIVE_CACHE: usize = 512;\n   599â†’    if cache.len() > MAX_NEGATIVE_CACHE {\n   600â†’        let mut entries: Vec<_> =\n   601â†’            cache.iter().map(|(k, v)| (k.clone(), v.created_at)).collect();\n   602â†’        entries.sort_by_key(|(_, t)| *t);\n   603â†’        let drop_count = cache.len() - MAX_NEGATIVE_CACHE;\n   604â†’        for (key, _) in entries.into_iter().take(drop_count) {\n   605â†’            cache.remove(&key);\n   606â†’        }\n   607â†’    }\n   608â†’}\n   609â†’\n   610â†’fn remove_negative_name_query(state: &AppState, query: &str) {\n   611â†’    if query.is_empty() {\n   612â†’        return;\n   613â†’    }\n   614â†’    let normalized = query.to_lowercase();\n   615â†’    state.negative_name_cache.lock().remove(&normalized);\n   616â†’}\n   617â†’\n   618â†’fn mark_negative_name_fallback_checked(state: &AppState, query_lower: &str) {\n   619â†’    let mut cache = state.negative_name_cache.lock();\n   620â†’    if let Some(entry) = cache.get_mut(query_lower) {\n   621â†’        entry.fallback_checked = true;\n   622â†’    }\n   623â†’}\n   624â†’\n   625â†’fn sort_clause(sort_by: &str, sort_dir: &str, prefix: &str) -> String {\n   626â†’    match (sort_by, sort_dir) {\n   627â†’        (\"name\", \"desc\") => {\n   628â†’            format!(\"{prefix}name COLLATE NOCASE DESC, {prefix}path COLLATE NOCASE DESC\")\n   629â†’        }\n   630â†’        (\"mtime\", \"asc\") => {\n   631â†’            format!(\"COALESCE({prefix}mtime, 0) ASC, {prefix}name COLLATE NOCASE ASC\")\n   632â†’        }\n   633â†’        (\"mtime\", \"desc\") => {\n   634â†’            format!(\"COALESCE({prefix}mtime, 0) DESC, {prefix}name COLLATE NOCASE ASC\")\n   635â†’        }\n   636â†’        (\"dir\", \"asc\") => {\n   637â†’            format!(\"{prefix}dir COLLATE NOCASE ASC, {prefix}name COLLATE NOCASE ASC\")\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"a3baf213-f4ee-423a-9cdb-86276dfc259a","timestamp":"2026-02-22T07:30:24.357Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"afb0f6a5-539c-46e0-8dfe-649858a75ec3","timestamp":"2026-02-22T07:30:24.385Z"}
{"parentUuid":"afb0f6a5-539c-46e0-8dfe-649858a75ec3","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-22T07:30:27.229Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01WBU8DDx2CvzhBRjEpunzkb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011kBEdxJ16nvM4bwiq1gD6D","name":"Grep","input":{"pattern":"CREATE VIRTUAL TABLE|fts5|tokenize|entries_fts","type":"rust","path":"/Users/al02402336/everything/src-tauri/src/main.rs","output_mode":"content","context":5},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3075,"cache_read_input_tokens":44811,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3075},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CYNiTrTV93SzfMDerE77t","uuid":"f9193caa-d080-4307-a5e5-a3a0ee8faae4"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"1772f9af-6002-45ad-81a5-c52c1fae2700","timestamp":"2026-02-22T07:30:27.229Z"}
{"parentUuid":"1772f9af-6002-45ad-81a5-c52c1fae2700","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011kBEdxJ16nvM4bwiq1gD6D","type":"tool_result","content":"447-        conn.execute_batch(\n448-            r#\"\n449-            DROP TRIGGER IF EXISTS entries_ai;\n450-            DROP TRIGGER IF EXISTS entries_ad;\n451-            DROP TRIGGER IF EXISTS entries_au;\n452:            DROP TABLE IF EXISTS entries_fts;\n453-            DROP TABLE IF EXISTS entries;\n454-            \"#,\n455-        )\n456-        .map_err(|e| e.to_string())?;\n457-        conn.execute_batch(&format!(\"PRAGMA user_version = {};\", DB_VERSION))"}]},"uuid":"7d6b36b2-32fc-4b97-8873-f95cd7b05176","timestamp":"2026-02-22T07:30:27.888Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"785c76ad-3e70-4e9d-867c-192bcc3c6e12","timestamp":"2026-02-22T07:30:27.889Z"}
{"parentUuid":"785c76ad-3e70-4e9d-867c-192bcc3c6e12","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-22T07:30:29.311Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_016HjbkzZbAxNNpn6PL5FNxF","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BmQ7yoCVVBuvSg2LCi56qG","name":"Bash","input":{"command":"grep -n \"CREATE VIRTUAL TABLE\\|CREATE.*TRIGGER.*entries\" /Users/al02402336/everything/src-tauri/src/main.rs | head -30"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":352,"cache_read_input_tokens":47886,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":352},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CYNiU7SPJiTZ2iAhHYvTJ","uuid":"ca776199-e86e-45a4-b2d9-e09ccf67e8a1"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"7d80d38c-5311-473b-a0bb-fc458aa1b1be","timestamp":"2026-02-22T07:30:29.312Z"}
{"parentUuid":"7d80d38c-5311-473b-a0bb-fc458aa1b1be","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BmQ7yoCVVBuvSg2LCi56qG","type":"tool_result","content":"","is_error":false}]},"uuid":"759647e8-106b-4269-bb70-0ad831023748","timestamp":"2026-02-22T07:30:29.476Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"0205daee-d0f6-4705-bffd-26f061ff2b7b","timestamp":"2026-02-22T07:30:29.479Z"}
{"parentUuid":"0205daee-d0f6-4705-bffd-26f061ff2b7b","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-22T07:30:31.525Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_019RKSQ3vBKjfQML7J4c8uKP","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016hCkAKUjeYuVZuRh8d8sH9","name":"Bash","input":{"command":"find /Users/al02402336/everything/src-tauri/src -name \"*.rs\" -type f | head -10"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":149,"cache_read_input_tokens":48238,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":149},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CYNiUEEAuJnGf9zGX1obN","uuid":"c37cdce4-d3c4-47ac-b1fb-170f7f69668f"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"64c10594-ff94-48e3-9065-f92e5f762877","timestamp":"2026-02-22T07:30:31.525Z"}
{"parentUuid":"64c10594-ff94-48e3-9065-f92e5f762877","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016hCkAKUjeYuVZuRh8d8sH9","type":"tool_result","content":"/Users/al02402336/everything/src-tauri/src/mem_search.rs\n/Users/al02402336/everything/src-tauri/src/fd_search.rs\n/Users/al02402336/everything/src-tauri/src/win/context_menu.rs\n/Users/al02402336/everything/src-tauri/src/win/com_guard.rs\n/Users/al02402336/everything/src-tauri/src/win/mft_indexer.rs\n/Users/al02402336/everything/src-tauri/src/win/icon.rs\n/Users/al02402336/everything/src-tauri/src/win/mod.rs\n/Users/al02402336/everything/src-tauri/src/win/path_resolver.rs\n/Users/al02402336/everything/src-tauri/src/win/rdcw_watcher.rs\n/Users/al02402336/everything/src-tauri/src/win/search_catchup.rs","is_error":false}]},"uuid":"c6cfea2b-a153-4dd1-b60f-901553ad2d43","timestamp":"2026-02-22T07:30:31.668Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"207e8525-3085-4ca5-b5b6-7748e52fda3a","timestamp":"2026-02-22T07:30:31.670Z"}
{"parentUuid":"207e8525-3085-4ca5-b5b6-7748e52fda3a","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-22T07:30:32.742Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01TabGmm3ariw6WbzAVw3NSA","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VLYFXD8NoABWABxhTdmJdi","name":"Bash","input":{"command":"grep -n \"CREATE VIRTUAL TABLE\" /Users/al02402336/everything/src-tauri/src/*.rs"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":387,"cache_read_input_tokens":48387,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":387},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CYNiUPbEfZEGPhyL2YsXf","uuid":"6ceb6203-d522-4ee6-be63-9a1232cdf56d"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"22035465-8c92-414d-905e-bbf1aaa65768","timestamp":"2026-02-22T07:30:32.742Z"}
{"parentUuid":"22035465-8c92-414d-905e-bbf1aaa65768","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VLYFXD8NoABWABxhTdmJdi","type":"tool_result","content":"","is_error":false}]},"uuid":"efe6e19e-9df2-4d8a-9190-b184893e5bc9","timestamp":"2026-02-22T07:30:33.542Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"562493bf-1d78-4a66-b95f-7c22ae171591","timestamp":"2026-02-22T07:30:33.544Z"}
{"parentUuid":"562493bf-1d78-4a66-b95f-7c22ae171591","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-22T07:30:34.884Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01WFx2xJx1xhozDfpwavafwR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UzdsyuKf3SmKisjBLjV6rR","name":"Bash","input":{"command":"grep -i \"fts\\|virtual\" /Users/al02402336/everything/src-tauri/src/main.rs | head -20"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":123,"cache_read_input_tokens":48774,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":123},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CYNiUY3EgijuRjWnT17GQ","uuid":"d6350c30-4ed5-4b9b-abc1-7203530dd718"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"b2f28475-ecba-49c9-8849-67a83a028eff","timestamp":"2026-02-22T07:30:34.884Z"}
{"parentUuid":"b2f28475-ecba-49c9-8849-67a83a028eff","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UzdsyuKf3SmKisjBLjV6rR","type":"tool_result","content":"            DROP TABLE IF EXISTS entries_fts;","is_error":false}]},"uuid":"85c25436-ff01-43ce-8980-b4a576a3e498","timestamp":"2026-02-22T07:30:35.039Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"8fe07dff-18bc-4d4b-a595-5541c898ab58","timestamp":"2026-02-22T07:30:35.040Z"}
{"parentUuid":"8fe07dff-18bc-4d4b-a595-5541c898ab58","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-22T07:30:38.127Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01C1xarW7Usxqp7U2ziQcoqi","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0156Fa6WM594nPmUFrT6thG2","name":"Bash","input":{"command":"grep -n \"FROM entries\" /Users/al02402336/everything/src-tauri/src/main.rs | head -15"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":264,"cache_read_input_tokens":48897,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":264},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CYNiUeEoPzPtuYY1WRJeH","uuid":"0b34a4af-591b-4c4f-a54f-ac27626d9d86"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"2f74fd3d-406d-4087-a597-5f8f3466760d","timestamp":"2026-02-22T07:30:38.127Z"}
{"parentUuid":"2f74fd3d-406d-4087-a597-5f8f3466760d","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0156Fa6WM594nPmUFrT6thG2","type":"tool_result","content":"527:        .query_row(\"SELECT COUNT(*) FROM entries\", [], |row| {\n534:        .query_row(\"SELECT MAX(indexed_at) FROM entries\", [], |row| {\n729:        \"SELECT path FROM entries WHERE name = ?1 COLLATE NOCASE AND is_dir = 1 AND path LIKE ?2 ESCAPE '\\\\' LIMIT ?3\",\n1141:            conn.execute(\"DELETE FROM entries\", [])\n1149:            \"DELETE FROM entries WHERE path = ?1 OR path LIKE ?2 ESCAPE '\\\\'\",\n1735:            .prepare(\"DELETE FROM entries WHERE path = ?1\")\n1738:            .prepare(\"DELETE FROM entries WHERE path >= ?1 AND path < ?2\")\n1755:                    .execute(\"DELETE FROM entries\", [])\n1958:        \"SELECT path, mtime, size FROM entries WHERE path LIKE ?1 ESCAPE '\\\\' OR path = ?2\",\n2357:                \"SELECT COUNT(*) FROM entries WHERE run_id < ?1\",\n2363:            \"DELETE FROM entries WHERE run_id < ?1\",\n2956:        conn.execute(\"DELETE FROM entries\", [])\n3058:            .query_row(\"SELECT COUNT(*) FROM entries\", [], |r| r.get(0))\n3065:                    \"SELECT COUNT(*) FROM entries WHERE name LIKE ?1 ESCAPE '\\\\'\",\n3075:                    \"SELECT COUNT(*) FROM entries WHERE name LIKE ?1 ESCAPE '\\\\'\",","is_error":false}]},"uuid":"53acf203-d0e3-4216-bed5-b5f7c473d377","timestamp":"2026-02-22T07:30:38.274Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"65f3bd61-d50a-4002-a609-17d6b575b9f2","timestamp":"2026-02-22T07:30:38.297Z"}
{"parentUuid":"65f3bd61-d50a-4002-a609-17d6b575b9f2","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-22T07:30:39.702Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01MKi7feZvKhC6qKaRjULtd3","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DW1PrjQhPE6VfEE7ZGVjR8","name":"Read","input":{"file_path":"/Users/al02402336/everything/CLAUDE.md"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":496,"cache_read_input_tokens":49161,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":496},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CYNiUt6z1uf5biu5Fry6E","uuid":"38f27753-4c66-4b9b-820f-d3229d0fd209"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"4ded2866-7ca1-430a-9f83-31f8b158b509","timestamp":"2026-02-22T07:30:39.702Z"}
{"parentUuid":"4ded2866-7ca1-430a-9f83-31f8b158b509","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DW1PrjQhPE6VfEE7ZGVjR8","type":"tool_result","content":"     1â†’# CLAUDE.md\n     2â†’\n     3â†’This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.\n     4â†’\n     5â†’## Project Overview\n     6â†’\n     7â†’Everything â€” an ultrafast file/folder name search app for macOS and Windows. Indexes the filesystem into SQLite, providing sub-50ms search response. UI messages and spec are in Korean.\n     8â†’\n     9â†’**Stack:** Tauri v2 + Rust (backend) + Svelte 4 (frontend) + SQLite (LIKE-based search)\n    10â†’\n    11â†’## Build & Development Commands\n    12â†’\n    13â†’```bash\n    14â†’# Dev server (Vite on :1420 + Tauri window)\n    15â†’npm run tauri dev\n    16â†’\n    17â†’# Production build\n    18â†’npm run tauri build\n    19â†’\n    20â†’# Lint (frontend build + cargo check)\n    21â†’npm run lint\n    22â†’\n    23â†’# Rust tests (query module)\n    24â†’cargo test --manifest-path src-tauri/Cargo.toml\n    25â†’\n    26â†’# Run a single Rust test\n    27â†’cargo test --manifest-path src-tauri/Cargo.toml <test_name>\n    28â†’\n    29â†’# Frontend only (no Tauri shell)\n    30â†’npm run dev\n    31â†’```\n    32â†’\n    33â†’## Architecture\n    34â†’\n    35â†’### Backend (Rust) â€” `src-tauri/src/`\n    36â†’\n    37â†’- **`main.rs`** â€” Core backend: app state, SQLite schema init, indexer (jwalk), search (LIKE-based multi-mode), file actions (open/reveal/trash/rename), Tauri command handlers\n    38â†’- **`query.rs`** â€” Search query parser: classifies input into `SearchMode` variants (`Empty`, `NameSearch`, `GlobName`, `ExtSearch`, `PathSearch`). Handles glob-to-LIKE conversion and LIKE escaping. Has unit tests.\n    39â†’- **`fd_search.rs`** â€” jwalk-based live filesystem search\n    40â†’- **`mem_search.rs`** â€” In-memory compact entry search\n    41â†’- **`gitignore_filter.rs`** â€” Recursive .gitignore discovery and matching\n    42â†’- **`mac/`** â€” macOS-specific: FSEvents watcher (direct fsevent-sys binding), Spotlight search fallback (mdfind)\n    43â†’- **`win/`** â€” Windows-specific: MFT indexer (NTFS metadata scan), USN journal watcher, ReadDirectoryChangesW fallback, Shell icon loading (IShellItemImageFactory), native Explorer context menu, offline catchup (Windows Search / mtime scan)\n    44â†’\n    45â†’### Frontend (Svelte) â€” `src/`\n    46â†’\n    47â†’- **`App.svelte`** â€” Single-component UI: search input, virtual-scrolled result table, inline rename, context menu, keyboard shortcuts, icon cache, status bar. Communicates with backend via `invoke()` (Tauri IPC). Detects platform via `get_platform()` for conditional behavior.\n    48â†’- **`main.js`** â€” Svelte mount point.\n    49â†’\n    50â†’### Data Flow\n    51â†’\n    52â†’1. App start â†’ scan filesystem â†’ batch upsert into `entries` table (SQLite WAL mode)\n    53â†’   - macOS: jwalk incremental scan of `$HOME`\n    54â†’   - Windows: NTFS MFT scan of `C:\\`\n    55â†’2. User types â†’ Svelte calls `search` command â†’ Rust queries LIKE-based multi-mode â†’ returns `EntryDto[]`\n    56â†’3. If results are sparse, a live scan (jwalk) runs in a background thread\n    57â†’4. File watcher detects changes â†’ upsert/delete affected paths\n    58â†’   - macOS: FSEvents (direct fsevent-sys, supports event ID replay)\n    59â†’   - Windows: USN Change Journal â†’ ReadDirectoryChangesW fallback\n    60â†’\n    61â†’### Key Design Decisions\n    62â†’\n    63â†’- **Search modes:** Query containing `/` or `\\` â†’ path search; containing `*` or `?` â†’ glob-to-LIKE; simple `*.ext` â†’ extension lookup; otherwise â†’ 3-phase name search (exact â†’ prefix â†’ contains)\n    64â†’- **Sort:** Backend SQL `ORDER BY` (name/mtime/dir Ã— asc/desc), not relevance\n    65â†’- **Recent ops cache:** 2-second TTL LRU prevents watcher from re-processing app-initiated rename/trash operations\n    66â†’- **Icons:** macOS: NSWorkspace via swift subprocess, cached by extension. Windows: IShellItemImageFactory (per-file for exe/lnk) + SHGetFileInfo (extension-based fallback)\n    67â†’- **Virtual scroll:** Fixed 28px row height, renders only visible rows Â± buffer rows\n    68â†’- **Indexing root:** macOS: `$HOME`, Windows: `C:\\`. Skips `.git`, `node_modules`, platform-specific noisy directories\n    69â†’- **Context menu:** macOS: custom frontend menu. Windows: native Explorer context menu via Shell API\n    70â†’\n    71â†’### Tauri IPC Commands\n    72â†’\n    73â†’`get_index_status`, `get_platform`, `start_full_index`, `reset_index`, `search`, `open`, `open_with`, `reveal_in_finder`, `copy_paths`, `move_to_trash`, `rename`, `get_file_icon`, `show_context_menu` (Windows only)\n    74â†’\n    75â†’### Backend Events (â†’ Frontend)\n    76â†’\n    77â†’`index_progress`, `index_state`, `index_updated`, `focus_search` (macOS)\n    78â†’\n    79â†’## Design Spec\n    80â†’\n    81â†’Full product spec is at `doc/spec.md` (English) and `doc/spec_KR.md` (Korean). Key SLOs: search p95 < 30ms backend, < 50ms with UI render. Default result limit 300 (100 for single-char queries, max 1000).\n    82â†’\n    83â†’## Conventions\n    84â†’\n    85â†’- Rust error handling: `AppResult<T> = Result<T, String>` â€” errors are string-mapped for Tauri IPC\n    86â†’- Serde: all DTOs use `#[serde(rename_all = \"camelCase\")]`\n    87â†’- DB version tracked via `PRAGMA user_version`; version bump clears all entries and re-indexes\n    88â†’- Batch size for DB writes: 10,000 rows (macOS), 50,000 rows (Windows MFT)\n    89â†’- Frontend state is plain Svelte reactive variables (no stores)\n    90â†’- Platform-specific code uses `#[cfg(target_os = \"macos\")]` / `#[cfg(target_os = \"windows\")]` conditional compilation\n    91â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"2fa8230c-3fba-4698-b01a-8fa5401832b6","timestamp":"2026-02-22T07:30:39.719Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"0d39331d-95ad-4448-a22f-505b69526dca","timestamp":"2026-02-22T07:30:39.722Z"}
{"parentUuid":"0d39331d-95ad-4448-a22f-505b69526dca","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-22T07:30:42.554Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_016ShTSCrQJC6L25CWhpWaky","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LiKbEKkRH9mxo2xzLTc1Cm","name":"Read","input":{"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","offset":"1, 2924","limit":50},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1953,"cache_read_input_tokens":49657,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1953},"output_tokens":4,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CYNiV1M466Xa3UMAbV3ei","uuid":"8851a587-1ab3-40b2-a5d1-45aaba457de1"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"c611a4d4-9935-48a7-82bf-921a537e895b","timestamp":"2026-02-22T07:30:42.554Z"}
{"parentUuid":"c611a4d4-9935-48a7-82bf-921a537e895b","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>InputValidationError: Read failed due to the following issue:\nThe parameter `offset` type is expected as `number` but provided as `string`</tool_use_error>","is_error":true,"tool_use_id":"toolu_01LiKbEKkRH9mxo2xzLTc1Cm"}]},"uuid":"42ccfc52-7572-48c4-bfcd-20d5ea212b2a","timestamp":"2026-02-22T07:30:42.555Z","toolUseResult":"InputValidationError: [\n  {\n    \"expected\": \"number\",\n    \"code\": \"invalid_type\",\n    \"path\": [\n      \"offset\"\n    ],\n    \"message\": \"Invalid input: expected number, received string\"\n  }\n]"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"b59dff72-eb3d-48ed-be45-00addab747a4","timestamp":"2026-02-22T07:30:42.556Z"}
{"parentUuid":"b59dff72-eb3d-48ed-be45-00addab747a4","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-22T07:30:42.897Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_016ShTSCrQJC6L25CWhpWaky","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019Wn482FskcGDN8NuC9CEdm","name":"Read","input":{"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","offset":2924,"limit":20},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1953,"cache_read_input_tokens":49657,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1953},"output_tokens":4,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CYNiV1M466Xa3UMAbV3ei","uuid":"2110b75c-a4c1-4d31-8eb9-7ddf30d2eb58"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"385f5348-d3da-4c86-ae65-bf4eda24c24e","timestamp":"2026-02-22T07:30:42.898Z"}
{"parentUuid":"385f5348-d3da-4c86-ae65-bf4eda24c24e","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>Sibling tool call errored</tool_use_error>","is_error":true,"tool_use_id":"toolu_019Wn482FskcGDN8NuC9CEdm"}]},"uuid":"04fbf327-d71c-4207-a97b-be670266d8ba","timestamp":"2026-02-22T07:30:42.898Z","toolUseResult":"Sibling tool call errored"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"0d0ce4d7-64e3-492d-8a6f-4581702723ef","timestamp":"2026-02-22T07:30:42.899Z"}
{"parentUuid":"0d0ce4d7-64e3-492d-8a6f-4581702723ef","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-22T07:30:44.153Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_019XKG8bxLHXLsC5m4YvBDMT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01F1opa8TsW2QZ9mtjcJAx8A","name":"Read","input":{"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","offset":2924,"limit":20},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":379,"cache_read_input_tokens":51610,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":379},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CYNiVE1JT5PRq5RtcCWEL","uuid":"71c5f957-25e6-446c-b776-1a68a45b8551"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"a9a19687-7413-4110-a7d6-3c53bfc20793","timestamp":"2026-02-22T07:30:44.154Z"}
{"parentUuid":"a9a19687-7413-4110-a7d6-3c53bfc20793","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01F1opa8TsW2QZ9mtjcJAx8A","type":"tool_result","content":"  2924â†’fn start_full_index(app: AppHandle, state: State<'_, AppState>) -> AppResult<()> {\n  2925â†’    #[cfg(target_os = \"windows\")]\n  2926â†’    {\n  2927â†’        win::start_windows_indexing(app, state.inner().clone());\n  2928â†’        Ok(())\n  2929â†’    }\n  2930â†’    #[cfg(not(target_os = \"windows\"))]\n  2931â†’    {\n  2932â†’        start_full_index_worker(app, state.inner().clone())\n  2933â†’    }\n  2934â†’}\n  2935â†’\n  2936â†’#[tauri::command]\n  2937â†’async fn reset_index(app: AppHandle, state: State<'_, AppState>) -> AppResult<()> {\n  2938â†’    let state = state.inner().clone();\n  2939â†’    tauri::async_runtime::spawn_blocking(move || {\n  2940â†’        if state.indexing_active.load(AtomicOrdering::Acquire) {\n  2941â†’            return Err(\"Cannot reset while indexing is in progress.\".to_string());\n  2942â†’        }\n  2943â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"ffbdd1da-0c1d-461d-b344-0825669f103b","timestamp":"2026-02-22T07:30:44.171Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"64754080-9632-4649-ba49-8a96fbdbc6ff","timestamp":"2026-02-22T07:30:44.175Z"}
{"parentUuid":"64754080-9632-4649-ba49-8a96fbdbc6ff","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-22T07:30:45.526Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Gm29n4DM8REjLwX87N3uai","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01J9xwK2gCdir95PfvaiJV3z","name":"Read","input":{"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","offset":1,"limit":100},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":536,"cache_read_input_tokens":51989,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":536},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CYNiVK4QjePncUBRedsrW","uuid":"fff33e70-e839-4d54-81a8-2cc5d454ea11"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"c117e919-8767-42ec-b091-985319a766e0","timestamp":"2026-02-22T07:30:45.527Z"}
{"parentUuid":"c117e919-8767-42ec-b091-985319a766e0","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01J9xwK2gCdir95PfvaiJV3z","type":"tool_result","content":"     1â†’#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\n     2â†’\n     3â†’use std::{\n     4â†’    cmp::Ordering,\n     5â†’    collections::{HashMap, HashSet},\n     6â†’    fs,\n     7â†’    hash::{Hash, Hasher},\n     8â†’    io::{self, BufRead, BufReader, Write},\n     9â†’    path::{Path, PathBuf},\n    10â†’    process::{Command, Stdio},\n    11â†’    sync::{\n    12â†’        atomic::{AtomicBool, Ordering as AtomicOrdering},\n    13â†’        Arc, OnceLock,\n    14â†’    },\n    15â†’    time::{Duration, Instant, SystemTime, UNIX_EPOCH},\n    16â†’};\n    17â†’\n    18â†’use parking_lot::{Mutex, RwLock};\n    19â†’use rusqlite::{params, params_from_iter, types::Value as SqlValue, Connection};\n    20â†’use serde::Serialize;\n    21â†’use tauri::{AppHandle, Emitter, Manager, State};\n    22â†’#[cfg(target_os = \"macos\")]\n    23â†’use tauri_plugin_global_shortcut::{Code, GlobalShortcutExt, Modifiers, Shortcut};\n    24â†’#[cfg(target_os = \"windows\")]\n    25â†’use std::os::windows::process::CommandExt;\n    26â†’use walkdir::WalkDir;\n    27â†’\n    28â†’mod fd_search;\n    29â†’mod gitignore_filter;\n    30â†’#[cfg(target_os = \"macos\")]\n    31â†’mod mac;\n    32â†’mod mem_search;\n    33â†’mod query;\n    34â†’#[cfg(target_os = \"windows\")]\n    35â†’mod win;\n    36â†’use fd_search::{FdSearchCache, FdSearchResultDto};\n    37â†’use query::{escape_like, parse_query, SearchMode};\n    38â†’\n    39â†’const DEFAULT_LIMIT: u32 = 300;\n    40â†’const SHORT_QUERY_LIMIT: u32 = 100;\n    41â†’const MAX_LIMIT: u32 = 1000;\n    42â†’pub(crate) const BATCH_SIZE: usize = 10_000;\n    43â†’const RECENT_OP_TTL: Duration = Duration::from_secs(2);\n    44â†’pub(crate) const WATCH_DEBOUNCE: Duration = Duration::from_millis(300);\n    45â†’const NEGATIVE_CACHE_TTL: Duration = Duration::from_secs(60);\n    46â†’const NEGATIVE_CACHE_FALLBACK_WINDOW: Duration = Duration::from_millis(550);\n    47â†’const DB_VERSION: i32 = 4;\n    48â†’const DEFERRED_DIR_NAMES: &[&str] = &[\n    49â†’    \"Library\", \".Trash\", \".Trashes\",\n    50â†’    // Windows system directories (deferred when scan_root is C:\\)\n    51â†’    \"Windows\", \"Program Files\", \"Program Files (x86)\",\n    52â†’    \"$Recycle.Bin\", \"System Volume Information\", \"Recovery\", \"PerfLogs\",\n    53â†’];\n    54â†’const SHALLOW_SCAN_DEPTH: usize = 6;\n    55â†’fn jwalk_num_threads() -> usize {\n    56â†’    std::thread::available_parallelism()\n    57â†’        .map(|n| (n.get() / 2).max(4).min(16))\n    58â†’        .unwrap_or(8)\n    59â†’}\n    60â†’\n    61â†’pub(crate) const BUILTIN_SKIP_NAMES: &[&str] = &[\n    62â†’    \".git\",\n    63â†’    \"node_modules\",\n    64â†’    \".Trash\",\n    65â†’    \".Trashes\",\n    66â†’    \".npm\",\n    67â†’    \".cache\",\n    68â†’    \"CMakeFiles\",\n    69â†’    \".qtc_clangd\",\n    70â†’    \"__pycache__\",\n    71â†’    \".gradle\",\n    72â†’    \"DerivedData\",\n    73â†’];\n    74â†’\n    75â†’/// Path segments whose name ends with one of these suffixes are skipped.\n    76â†’/// e.g. \"*.build\" skips Xcode intermediate build directories like \"MyApp.build\".\n    77â†’pub(crate) const BUILTIN_SKIP_SUFFIXES: &[&str] = &[\n    78â†’    \".build\", // Xcode intermediate build dir (MyApp.build, Objects-normal, etc.)\n    79â†’];\n    80â†’\n    81â†’pub(crate) const BUILTIN_SKIP_PATHS: &[&str] = &[\n    82â†’    // macOS\n    83â†’    \"Library/Caches\",\n    84â†’    \"Library/Developer/CoreSimulator\",\n    85â†’    \"Library/Logs\",\n    86â†’    // Cross-platform\n    87â†’    \".vscode/extensions\",\n    88â†’    // Windows: noisy system directories under AppData\n    89â†’    \"AppData/Local/Temp\",\n    90â†’    \"AppData/Local/Microsoft\",\n    91â†’    \"AppData/Local/Google\",\n    92â†’    \"AppData/Local/Packages\",\n    93â†’];\n    94â†’\n    95â†’type AppResult<T> = Result<T, String>;\n    96â†’static SEARCH_LOG_ENABLED: OnceLock<bool> = OnceLock::new();\n    97â†’static PERF_LOG_ENABLED: OnceLock<bool> = OnceLock::new();\n    98â†’static BENCH_MODE_ENABLED: OnceLock<bool> = OnceLock::new();\n    99â†’static STARTUP_T0: OnceLock<Instant> = OnceLock::new();\n   100â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"3585805d-341c-4814-a321-65c688d59ea6","timestamp":"2026-02-22T07:30:45.536Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"2faaa90c-d1eb-4bc6-a41c-84591acf3b15","timestamp":"2026-02-22T07:30:45.589Z"}
{"parentUuid":"2faaa90c-d1eb-4bc6-a41c-84591acf3b15","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-22T07:30:47.372Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01UkTLa8jafr1ccaoiUQamni","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GpCPZHeh3fxfqeLbFM7drJ","name":"Read","input":{"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","offset":1807,"limit":30},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1838,"cache_read_input_tokens":52525,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1838},"output_tokens":4,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CYNiVR8XphBEirPoDf4ra","uuid":"a605368c-b2f9-427c-b416-ac36e9b11773"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"d2532445-a581-4dea-9240-743c897681f5","timestamp":"2026-02-22T07:30:47.372Z"}
{"parentUuid":"d2532445-a581-4dea-9240-743c897681f5","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GpCPZHeh3fxfqeLbFM7drJ","type":"tool_result","content":"  1807â†’pub(crate) fn emit_index_progress(app: &AppHandle, scanned: u64, indexed: u64, current_path: String) {\n  1808â†’    let _ = app.emit(\n  1809â†’        \"index_progress\",\n  1810â†’        IndexProgressEvent {\n  1811â†’            scanned,\n  1812â†’            indexed,\n  1813â†’            current_path,\n  1814â†’        },\n  1815â†’    );\n  1816â†’}\n  1817â†’\n  1818â†’pub(crate) fn set_state(state: &AppState, next: IndexState, message: Option<String>) {\n  1819â†’    let mut status = state.status.lock();\n  1820â†’    status.state = next;\n  1821â†’    status.message = message;\n  1822â†’}\n  1823â†’\n  1824â†’pub(crate) fn set_progress(state: &AppState, scanned: u64, indexed: u64, current_path: &str) {\n  1825â†’    let mut status = state.status.lock();\n  1826â†’    status.scanned = scanned;\n  1827â†’    status.indexed = indexed;\n  1828â†’    status.current_path = current_path.to_string();\n  1829â†’}\n  1830â†’\n  1831â†’fn emit_status_counts(app: &AppHandle, state: &AppState) {\n  1832â†’    let status = state.status.lock();\n  1833â†’    emit_index_updated(\n  1834â†’        app,\n  1835â†’        status.entries_count,\n  1836â†’        status.last_updated.unwrap_or_else(now_epoch),\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"000d529c-3c1c-468f-979b-cf24ede2ffa3","timestamp":"2026-02-22T07:30:47.382Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2"},"toolUseID":"agent_msg_01MYBXkmCh9fEFRhsZdgPx1L","parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","uuid":"24cd8525-392c-47b5-b19f-038e6a405076","timestamp":"2026-02-22T07:30:47.401Z"}
{"parentUuid":"24cd8525-392c-47b5-b19f-038e6a405076","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Task","command":"entire hooks claude-code post-task"},"parentToolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","toolUseID":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","timestamp":"2026-02-22T07:31:18.996Z","uuid":"3e5de206-47c6-469e-a97a-718b0d6616d3"}
{"parentUuid":"1071234a-675f-428d-94f5-9eb92820631e","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AiEmYpb8Pm6Y6ZmghWb3nj","type":"tool_result","content":[{"type":"text","text":"Perfect! Now I have all the information I need. Let me compile my findings:\n\n## Complete Index/Reset Flow Analysis\n\nBased on my investigation of `/Users/al02402336/everything/src-tauri/src/main.rs` (5752 lines), here is the full understanding of the index and reset flow:\n\n---\n\n### 1. **`reset_index` Tauri Command** (lines 2937â€“2993)\n\nThe `reset_index` command:\n- **Runs async** via `spawn_blocking()` in Tauri's runtime\n- **Stops active indexing** by setting `watcher_stop` flag and polling `watcher_active` (5s timeout)\n- **Clears the database:**\n  ```rust\n  DELETE FROM entries;\n  DELETE FROM meta;\n  ```\n- **Resets status state:** clears `scanned`, `indexed`, `current_path`, `entries_count`, `last_updated`, `permission_errors`\n- **Invalidates search caches** via `invalidate_search_caches()`\n- **Re-enables watcher** by clearing the stop flag\n- **Starts fresh indexing:** calls `start_full_index_worker()` (macOS) or `win::start_windows_indexing()` (Windows)\n\n---\n\n### 2. **Full Indexing Flow** â€“ Entry Points\n\n**`start_full_index_worker()`** (lines 1887â€“1889):\n- Wrapper that calls `start_full_index_worker_inner(app, state, silent: false)`\n\n**`start_full_index_worker_inner()`** (lines 1896â€“1941):\n- **Atomically sets** `indexing_active` flag via `compare_exchange()` â€” skips if already indexing\n- **Marks index incomplete:** sets meta `index_complete = \"0\"` (cleared on success)\n- **Updates status to Indexing** (unless silent mode)\n- **Emits `index_state` event** with \"Indexing\" state\n- **Spawns new thread** that calls `run_incremental_index()`\n- On error, emits \"Error\" state (unless silent)\n- **Finally releases** `indexing_active` flag\n\n---\n\n### 3. **Main Indexing Function: `run_incremental_index_inner()`** (lines 2043â€“2417)\n\n**Outer wrapper `run_incremental_index()`** (lines 2001â€“2041):\n- Opens DB connection\n- **Applies indexing pragmas** via `set_indexing_pragmas(&conn)`\n- Calls `run_incremental_index_inner()`\n- **Runs `ANALYZE`** on DB\n- **Restores normal pragmas** via `restore_normal_pragmas()`\n- Sets `index_complete = \"1\"` on success\n- Logs detailed performance metrics\n\n**Core logic in `run_incremental_index_inner()`:**\n\n1. **Initialization** (lines 2057â€“2071):\n   - Loads last `run_id` from meta (defaults to 0)\n   - Increments to `current_run_id`\n   - **Detects fresh index:** `is_fresh = (last_run_id == 0)`\n   - Initializes counters: `scanned`, `indexed`, `permission_errors`, batches for upsert + stamp\n\n2. **Home-level scan** (lines 2073â€“2134):\n   - Preloads existing entries at scan_root (direct children only)\n   - Indexes scan_root itself\n   - Scans direct children, partitions into:\n     - `priority_roots` â€” normal directories\n     - `deferred_roots` â€” Library, .Trash, Windows system dirs\n   - **Stamps unchanged entries** (if mtime/size match) to `stamp_batch`\n   - **Pushes changed/new entries** to `batch`\n   - Flushes stamp batch when â‰¥ BATCH_SIZE\n\n3. **Two-pass walker** (lines 2158â€“2337):\n   - **Pass 0 (shallow):** max_depth = SHALLOW_SCAN_DEPTH (6) for incremental; unlimited for fresh\n   - **Pass 1 (deep):** depth > 6, skipped for fresh index\n   - Uses **jwalk parallel walker** with `parallelism = RayonNewPool(n)` where `n = (cpu_count/2).clamp(4, 16)`\n   - **Per-directory processing:**\n     - Filters entries via `should_skip_path_ext()` (skips .git, node_modules, etc.)\n     - **Fresh index:** all entries go to batch immediately\n     - **Incremental:** compares mtime/size; stamps if unchanged, upserts if changed\n   - **Batch flushes:**\n     - When `batch.len() â‰¥ BATCH_SIZE (10_000)` â†’ calls `upsert_rows()`\n     - When `stamp_batch.len() â‰¥ BATCH_SIZE` â†’ calls `stamp_run_id_batch()`\n   - **Progress emission:**\n     - Every 200ms: emits `index_progress` event + updates status\n     - Perf log every 1s if enabled\n   - **Error handling:** tracks permission errors, logs up to 20 per run\n\n4. **Cleanup between passes** (lines 2306â€“2336):\n   - Flushes remaining batches\n   - Logs pass metrics\n   - After shallow pass (incremental only): emits `index_updated` event so UI shows searchable state early\n\n5. **Stale entry removal** (lines 2350â€“2374):\n   - **Fresh index:** skips deletion (DB was empty)\n   - **Incremental:** deletes entries where `run_id < current_run_id` (those not seen in this run = deleted files)\n   - Increments `deleted_count` counter\n   - Invalidates search caches if any deletes or new entries\n\n6. **Final status update** (lines 2376â€“2416):\n   - Counts total entries, gets latest `indexed_at`\n   - **Caches counts** in meta table for instant startup\n   - Updates status lock with: state=Ready, counts, permission_errors message\n   - **Final three events:**\n     - `index_progress` (final scanned/indexed/path)\n     - `index_updated` (entry count, timestamp, errors)\n     - `index_state` (Ready, with error message if permission_errors > 0)\n   - Perf logs summary\n\n---\n\n### 4. **DB Write Batch Logic**\n\n**Constant** (line 42):\n```rust\npub(crate) const BATCH_SIZE: usize = 10_000;\n```\n\n**`upsert_rows()`** (lines 1681â€“1723):\n- Takes `&mut Connection` and `&[IndexRow]` slice\n- **Wraps in transaction**\n- **Uses INSERT OR REPLACE:**\n  ```sql\n  INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n  VALUES(?1..?9)\n  ON CONFLICT(path) DO UPDATE SET\n    name = excluded.name,\n    dir = excluded.dir,\n    is_dir = excluded.is_dir,\n    ext = excluded.ext,\n    mtime = excluded.mtime,\n    size = excluded.size,\n    indexed_at = excluded.indexed_at,\n    run_id = excluded.run_id\n  ```\n- Executes **once per row** within transaction (single prepared stmt, many execute calls)\n- Commits transaction at end\n\n**`stamp_run_id_batch()`** (lines 1982â€“1999):\n- Updates entries' `run_id` for unchanged files\n- Wraps in transaction\n- One UPDATE per path in batch\n\n---\n\n### 5. **FTS5 Triggers & Sync**\n\n**No explicit FTS5 virtual table found in main.rs.** Instead, search uses **LIKE-based queries**:\n- Schema (lines 462â€“488) creates only base `entries` table + 4 indices\n- No FTS5 virtual table or triggers in initialization\n- Search uses `LIKE` with escape patterns and multi-mode classification (via `query.rs`)\n- The CLAUDE.md (project instructions) notes: \"SQLite (LIKE-based search)\" â€” not FTS5\n\n**Dropped FTS5 artifacts:**\n- Lines 449â€“451 drop old triggers `entries_ai`, `entries_au`, `entries_ad` during version migration\n- Line 452 drops old `entries_fts` table\n- These are **legacy code preserved for DB schema versioning** (version bump clears and re-indexes)\n\n---\n\n### 6. **PRAGMA Settings Applied at Index Time**\n\n**Initial connection setup** (lines 383â€“395) via `db_connection_with_timeout()`:\n```sql\nPRAGMA journal_mode=WAL;\nPRAGMA synchronous=NORMAL;\nPRAGMA temp_store=MEMORY;\nPRAGMA busy_timeout={ms};  -- 3000ms for indexing, 500ms for search\n```\n\n**Indexing-specific pragmas** (lines 411â€“421) via `set_indexing_pragmas()`:\n```sql\nPRAGMA synchronous = NORMAL;\nPRAGMA cache_size = -65536;         -- 64MB cache\nPRAGMA mmap_size = 268435456;       -- 256MB memory-map\nPRAGMA wal_autocheckpoint = 10000;  -- Checkpoint after 10K pages\n```\n\n**Restore post-indexing** (lines 423â€“435) via `restore_normal_pragmas()`:\n```sql\nPRAGMA synchronous = NORMAL;\nPRAGMA cache_size = -16384;         -- 16MB cache (smaller)\nPRAGMA mmap_size = 268435456;       -- 256MB memory-map (kept)\nPRAGMA wal_autocheckpoint = 1000;   -- Checkpoint after 1K pages\nPRAGMA wal_checkpoint(TRUNCATE);    -- Truncate WAL after checkpoint\n```\n\n**Search-specific pragmas** (lines 401â€“408):\n```sql\nPRAGMA cache_size = -32768;         -- 32MB for search\nPRAGMA mmap_size = 268435456;       -- 256MB memory-map\n```\n\n---\n\n### 7. **`index_progress` Event Emission**\n\n**Frequency:**\n- **Every 200ms** during scanning (line 2263) via `if last_emit.elapsed() >= Duration::from_millis(200)`\n- **Final emit** at end of indexing (line 2348)\n- Perf log fires every 1s if `FASTFIND_PERF_LOG` enabled (lines 2268â€“2275)\n\n**Payload** (line 1810â€“1814):\n```rust\nIndexProgressEvent {\n    scanned: u64,      // Total filesystem entries scanned\n    indexed: u64,      // Total entries added/updated\n    current_path: String,  // Current path being processed\n}\n```\n\n---\n\n### 8. **Concurrent/Parallel Structure**\n\n**Single-threaded indexing logic** with **parallel filesystem walk**:\n- Main thread: `start_full_index_worker_inner()` spawns `std::thread::spawn()`\n- Worker thread runs `run_incremental_index()` (blocking)\n- **Filesystem walk uses jwalk parallel:**\n  ```rust\n  jwalk::WalkDir::new(root)\n    .parallelism(jwalk::Parallelism::RayonNewPool(jwalk_num_threads()))\n  ```\n- **Thread count:** `(cpu_count / 2).clamp(4, 16)` (lines 55â€“59)\n- **Entries collected into in-memory batches**, then serialized to DB sequentially\n- **No parallel DB writes** â€” single connection, sequential transactions\n\n---\n\n### Key Summary Table\n\n| Aspect | Details |\n|--------|---------|\n| **Batch size** | 10,000 rows (macOS) |\n| **Indexing pragmas** | cache=65MB, mmap=256MB, autocheckpoint=10K |\n| **Normal pragmas** | cache=16MB, mmap=256MB, autocheckpoint=1K |\n| **WAL mode** | Enabled; truncate on restoration |\n| **Progress events** | Every 200ms; payload: (scanned, indexed, current_path) |\n| **FTS5 usage** | **None** â€” dropped legacy artifacts; LIKE-based search |\n| **Two-pass scan** | Shallow (depthâ‰¤6) then deep; fresh index uses single unlimited pass |\n| **Parallelism** | jwalk rayon pool (4â€“16 threads); serial DB writes |\n| **Fresh vs incremental** | Fresh: skips preload/stamp, single pass. Incremental: 2-pass, mtime/size checks |\n| **Stale cleanup** | Delete entries where run_id < current_run_id |\n| **Icon loading** | **Not during indexing** â€” deferred to search/display |\n\n---\n\nThis is a sophisticated **incremental indexer** with WAL-mode writes, parallel filesystem scanning, and run-ID-based change tracking for efficient re-indexing."},{"type":"text","text":"agentId: abf02c2 (for resuming to continue this agent's work if needed)\n<usage>total_tokens: 58218\ntool_uses: 27\nduration_ms: 75737</usage>"}]}]},"uuid":"1e0542de-d2fe-412a-828a-952b855699bd","timestamp":"2026-02-22T07:31:18.994Z","toolUseResult":{"status":"completed","prompt":"In /Users/al02402336/everything/src-tauri/src/main.rs (5752 lines), find the full index/reset flow. I need to understand:\n1. The `reset_index` Tauri command and what it does\n2. The main indexing function (likely `run_full_index` or similar) â€” the entire body\n3. The DB write batch logic (BATCH_SIZE = 10_000)\n4. How FTS5 triggers/sync works during indexing\n5. Any PRAGMA settings applied at index time (WAL, synchronous, etc.)\n6. The `index_progress` event emission â€” how often it fires\n7. Whether icon loading or any other work happens during indexing\n8. Any parallel/concurrent structure in the indexer\n\nSearch for: reset_index, full_index, run_index, batch, fts, pragma, synchronous, journal, upsert, insert_or_replace. Show full function bodies (not just signatures).","agentId":"abf02c2","content":[{"type":"text","text":"Perfect! Now I have all the information I need. Let me compile my findings:\n\n## Complete Index/Reset Flow Analysis\n\nBased on my investigation of `/Users/al02402336/everything/src-tauri/src/main.rs` (5752 lines), here is the full understanding of the index and reset flow:\n\n---\n\n### 1. **`reset_index` Tauri Command** (lines 2937â€“2993)\n\nThe `reset_index` command:\n- **Runs async** via `spawn_blocking()` in Tauri's runtime\n- **Stops active indexing** by setting `watcher_stop` flag and polling `watcher_active` (5s timeout)\n- **Clears the database:**\n  ```rust\n  DELETE FROM entries;\n  DELETE FROM meta;\n  ```\n- **Resets status state:** clears `scanned`, `indexed`, `current_path`, `entries_count`, `last_updated`, `permission_errors`\n- **Invalidates search caches** via `invalidate_search_caches()`\n- **Re-enables watcher** by clearing the stop flag\n- **Starts fresh indexing:** calls `start_full_index_worker()` (macOS) or `win::start_windows_indexing()` (Windows)\n\n---\n\n### 2. **Full Indexing Flow** â€“ Entry Points\n\n**`start_full_index_worker()`** (lines 1887â€“1889):\n- Wrapper that calls `start_full_index_worker_inner(app, state, silent: false)`\n\n**`start_full_index_worker_inner()`** (lines 1896â€“1941):\n- **Atomically sets** `indexing_active` flag via `compare_exchange()` â€” skips if already indexing\n- **Marks index incomplete:** sets meta `index_complete = \"0\"` (cleared on success)\n- **Updates status to Indexing** (unless silent mode)\n- **Emits `index_state` event** with \"Indexing\" state\n- **Spawns new thread** that calls `run_incremental_index()`\n- On error, emits \"Error\" state (unless silent)\n- **Finally releases** `indexing_active` flag\n\n---\n\n### 3. **Main Indexing Function: `run_incremental_index_inner()`** (lines 2043â€“2417)\n\n**Outer wrapper `run_incremental_index()`** (lines 2001â€“2041):\n- Opens DB connection\n- **Applies indexing pragmas** via `set_indexing_pragmas(&conn)`\n- Calls `run_incremental_index_inner()`\n- **Runs `ANALYZE`** on DB\n- **Restores normal pragmas** via `restore_normal_pragmas()`\n- Sets `index_complete = \"1\"` on success\n- Logs detailed performance metrics\n\n**Core logic in `run_incremental_index_inner()`:**\n\n1. **Initialization** (lines 2057â€“2071):\n   - Loads last `run_id` from meta (defaults to 0)\n   - Increments to `current_run_id`\n   - **Detects fresh index:** `is_fresh = (last_run_id == 0)`\n   - Initializes counters: `scanned`, `indexed`, `permission_errors`, batches for upsert + stamp\n\n2. **Home-level scan** (lines 2073â€“2134):\n   - Preloads existing entries at scan_root (direct children only)\n   - Indexes scan_root itself\n   - Scans direct children, partitions into:\n     - `priority_roots` â€” normal directories\n     - `deferred_roots` â€” Library, .Trash, Windows system dirs\n   - **Stamps unchanged entries** (if mtime/size match) to `stamp_batch`\n   - **Pushes changed/new entries** to `batch`\n   - Flushes stamp batch when â‰¥ BATCH_SIZE\n\n3. **Two-pass walker** (lines 2158â€“2337):\n   - **Pass 0 (shallow):** max_depth = SHALLOW_SCAN_DEPTH (6) for incremental; unlimited for fresh\n   - **Pass 1 (deep):** depth > 6, skipped for fresh index\n   - Uses **jwalk parallel walker** with `parallelism = RayonNewPool(n)` where `n = (cpu_count/2).clamp(4, 16)`\n   - **Per-directory processing:**\n     - Filters entries via `should_skip_path_ext()` (skips .git, node_modules, etc.)\n     - **Fresh index:** all entries go to batch immediately\n     - **Incremental:** compares mtime/size; stamps if unchanged, upserts if changed\n   - **Batch flushes:**\n     - When `batch.len() â‰¥ BATCH_SIZE (10_000)` â†’ calls `upsert_rows()`\n     - When `stamp_batch.len() â‰¥ BATCH_SIZE` â†’ calls `stamp_run_id_batch()`\n   - **Progress emission:**\n     - Every 200ms: emits `index_progress` event + updates status\n     - Perf log every 1s if enabled\n   - **Error handling:** tracks permission errors, logs up to 20 per run\n\n4. **Cleanup between passes** (lines 2306â€“2336):\n   - Flushes remaining batches\n   - Logs pass metrics\n   - After shallow pass (incremental only): emits `index_updated` event so UI shows searchable state early\n\n5. **Stale entry removal** (lines 2350â€“2374):\n   - **Fresh index:** skips deletion (DB was empty)\n   - **Incremental:** deletes entries where `run_id < current_run_id` (those not seen in this run = deleted files)\n   - Increments `deleted_count` counter\n   - Invalidates search caches if any deletes or new entries\n\n6. **Final status update** (lines 2376â€“2416):\n   - Counts total entries, gets latest `indexed_at`\n   - **Caches counts** in meta table for instant startup\n   - Updates status lock with: state=Ready, counts, permission_errors message\n   - **Final three events:**\n     - `index_progress` (final scanned/indexed/path)\n     - `index_updated` (entry count, timestamp, errors)\n     - `index_state` (Ready, with error message if permission_errors > 0)\n   - Perf logs summary\n\n---\n\n### 4. **DB Write Batch Logic**\n\n**Constant** (line 42):\n```rust\npub(crate) const BATCH_SIZE: usize = 10_000;\n```\n\n**`upsert_rows()`** (lines 1681â€“1723):\n- Takes `&mut Connection` and `&[IndexRow]` slice\n- **Wraps in transaction**\n- **Uses INSERT OR REPLACE:**\n  ```sql\n  INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n  VALUES(?1..?9)\n  ON CONFLICT(path) DO UPDATE SET\n    name = excluded.name,\n    dir = excluded.dir,\n    is_dir = excluded.is_dir,\n    ext = excluded.ext,\n    mtime = excluded.mtime,\n    size = excluded.size,\n    indexed_at = excluded.indexed_at,\n    run_id = excluded.run_id\n  ```\n- Executes **once per row** within transaction (single prepared stmt, many execute calls)\n- Commits transaction at end\n\n**`stamp_run_id_batch()`** (lines 1982â€“1999):\n- Updates entries' `run_id` for unchanged files\n- Wraps in transaction\n- One UPDATE per path in batch\n\n---\n\n### 5. **FTS5 Triggers & Sync**\n\n**No explicit FTS5 virtual table found in main.rs.** Instead, search uses **LIKE-based queries**:\n- Schema (lines 462â€“488) creates only base `entries` table + 4 indices\n- No FTS5 virtual table or triggers in initialization\n- Search uses `LIKE` with escape patterns and multi-mode classification (via `query.rs`)\n- The CLAUDE.md (project instructions) notes: \"SQLite (LIKE-based search)\" â€” not FTS5\n\n**Dropped FTS5 artifacts:**\n- Lines 449â€“451 drop old triggers `entries_ai`, `entries_au`, `entries_ad` during version migration\n- Line 452 drops old `entries_fts` table\n- These are **legacy code preserved for DB schema versioning** (version bump clears and re-indexes)\n\n---\n\n### 6. **PRAGMA Settings Applied at Index Time**\n\n**Initial connection setup** (lines 383â€“395) via `db_connection_with_timeout()`:\n```sql\nPRAGMA journal_mode=WAL;\nPRAGMA synchronous=NORMAL;\nPRAGMA temp_store=MEMORY;\nPRAGMA busy_timeout={ms};  -- 3000ms for indexing, 500ms for search\n```\n\n**Indexing-specific pragmas** (lines 411â€“421) via `set_indexing_pragmas()`:\n```sql\nPRAGMA synchronous = NORMAL;\nPRAGMA cache_size = -65536;         -- 64MB cache\nPRAGMA mmap_size = 268435456;       -- 256MB memory-map\nPRAGMA wal_autocheckpoint = 10000;  -- Checkpoint after 10K pages\n```\n\n**Restore post-indexing** (lines 423â€“435) via `restore_normal_pragmas()`:\n```sql\nPRAGMA synchronous = NORMAL;\nPRAGMA cache_size = -16384;         -- 16MB cache (smaller)\nPRAGMA mmap_size = 268435456;       -- 256MB memory-map (kept)\nPRAGMA wal_autocheckpoint = 1000;   -- Checkpoint after 1K pages\nPRAGMA wal_checkpoint(TRUNCATE);    -- Truncate WAL after checkpoint\n```\n\n**Search-specific pragmas** (lines 401â€“408):\n```sql\nPRAGMA cache_size = -32768;         -- 32MB for search\nPRAGMA mmap_size = 268435456;       -- 256MB memory-map\n```\n\n---\n\n### 7. **`index_progress` Event Emission**\n\n**Frequency:**\n- **Every 200ms** during scanning (line 2263) via `if last_emit.elapsed() >= Duration::from_millis(200)`\n- **Final emit** at end of indexing (line 2348)\n- Perf log fires every 1s if `FASTFIND_PERF_LOG` enabled (lines 2268â€“2275)\n\n**Payload** (line 1810â€“1814):\n```rust\nIndexProgressEvent {\n    scanned: u64,      // Total filesystem entries scanned\n    indexed: u64,      // Total entries added/updated\n    current_path: String,  // Current path being processed\n}\n```\n\n---\n\n### 8. **Concurrent/Parallel Structure**\n\n**Single-threaded indexing logic** with **parallel filesystem walk**:\n- Main thread: `start_full_index_worker_inner()` spawns `std::thread::spawn()`\n- Worker thread runs `run_incremental_index()` (blocking)\n- **Filesystem walk uses jwalk parallel:**\n  ```rust\n  jwalk::WalkDir::new(root)\n    .parallelism(jwalk::Parallelism::RayonNewPool(jwalk_num_threads()))\n  ```\n- **Thread count:** `(cpu_count / 2).clamp(4, 16)` (lines 55â€“59)\n- **Entries collected into in-memory batches**, then serialized to DB sequentially\n- **No parallel DB writes** â€” single connection, sequential transactions\n\n---\n\n### Key Summary Table\n\n| Aspect | Details |\n|--------|---------|\n| **Batch size** | 10,000 rows (macOS) |\n| **Indexing pragmas** | cache=65MB, mmap=256MB, autocheckpoint=10K |\n| **Normal pragmas** | cache=16MB, mmap=256MB, autocheckpoint=1K |\n| **WAL mode** | Enabled; truncate on restoration |\n| **Progress events** | Every 200ms; payload: (scanned, indexed, current_path) |\n| **FTS5 usage** | **None** â€” dropped legacy artifacts; LIKE-based search |\n| **Two-pass scan** | Shallow (depthâ‰¤6) then deep; fresh index uses single unlimited pass |\n| **Parallelism** | jwalk rayon pool (4â€“16 threads); serial DB writes |\n| **Fresh vs incremental** | Fresh: skips preload/stamp, single pass. Incremental: 2-pass, mtime/size checks |\n| **Stale cleanup** | Delete entries where run_id < current_run_id |\n| **Icon loading** | **Not during indexing** â€” deferred to search/display |\n\n---\n\nThis is a sophisticated **incremental indexer** with WAL-mode writes, parallel filesystem scanning, and run-ID-based change tracking for efficient re-indexing."}],"totalDurationMs":75737,"totalTokens":58218,"totalToolUseCount":27,"usage":{"input_tokens":0,"cache_creation_input_tokens":668,"cache_read_input_tokens":54363,"output_tokens":3187,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":668,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"sourceToolAssistantUUID":"1071234a-675f-428d-94f5-9eb92820631e"}
{"parentUuid":"1e0542de-d2fe-412a-828a-952b855699bd","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01XJB74BVXZkcd7QkfPSBfq1","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Now I understand the indexing flow. The exploration reveals that the current code uses:\n1. A two-pass scan (shallow + deep) for incremental indexes\n2. A single unlimited-depth pass for fresh indexes\n3. jwalk parallel walker with (cpu_count/2).clamp(4,16) threads\n4. Batch size of 10,000 rows\n5. WAL mode with 64MB cache during indexing\n6. Progress events every 200ms\n\nFor reset_index: it DELETE FROM entries, DELETE FROM meta, then starts a fresh index. Fresh index = single unlimited-depth pass, all entries go to batch.\n\n\nThe reset is taking over a minute when the user needs it under 50 seconds. I need to identify whether the bottleneck is the filesystem traversal itself or the database writes. Since they're using LIKE-based search now instead of FTS5, there's no full-text index sync overhead to worry about. The main candidates are the filesystem walk across a potentially large home directory or the write performance. I'm considering whether disabling synchronous writes during indexing could help speed things up. Changing to `PRAGMA synchronous = OFF` during indexing would be much faster (no fsync), with the risk that if the machine crashes during indexing, the DB could be corrupt. But since we can always re-index, this is acceptable.\n\n**Option 2: Increase batch size**\nCurrently 10,000 rows per batch. Increasing to 50,000 would reduce transaction overhead.\n\n**Option 3: Reduce number of DB transactions**\nCurrently does one transaction per batch. Could do a single big transaction for the entire index.\n\n**Option 4: Skip DELETE on reset, use run_id approach for fresh index**\nInstead of DELETE FROM entries (which triggers WAL write for all rows), just:\n1. Reset run_id counter to 0 and bump to a new run_id\n2. After indexing, delete entries with old run_id\n\nLooking at the reset logic more carefully, I see the issue: when resetting the index, it clears the entire database with DELETE statements before re-inserting everything fresh, which is expensive since each DELETE creates WAL entries. A better approach would be to either increment the schema version to trigger a fresh index on next open, or use DROP TABLE and RECREATE which is much faster in SQLite. the filesystem walk is probably the main bottleneck â€” scanning 500,000 files at 10 threads would take around 10 seconds alone, and then database writes with fsync overhead add another 250-500ms on top of that.\n\nSo I'm considering a few optimization paths: disabling fsync during indexing since we can always re-index if something crashes, wrapping the entire index operation in a single transaction instead of batching, bumping up the thread count beyond 16, or rethinking the reset strategy to avoid the expensive DELETE operation.\n\nFor reset specifically, I could drop and recreate the table instead of deleting rows, or use a run_id flag to mark stale entries. I could also skip unnecessary work like icon cache clearing, temporarily drop indexes during bulk inserts to speed things up, or increase the batch size from 10,000 to something much larger to reduce transaction overhead.\n\nWait, I'm realizing the actual bottleneck hereâ€”on macOS it's probably the filesystem scan combined with database syncing, but this codebase actually dropped FTS5 entirely, so we're just doing regular LIKE-based searches and standard table inserts.\n\nLet me verify that FTS5 was actually removed by checking the exploration results and the actual code. The exploration mentions legacy trigger drops and the entries_fts table being removed, but I should look at the reset_index command, the pragma settings, the upsert logic, and the total entry count to understand what's really taking so long.","signature":"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"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3565,"cache_read_input_tokens":127506,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3565},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNiY1AUG3KuQpksg9y6P","type":"assistant","uuid":"a6b003ee-5618-47dc-acb7-f4b0939e5e5a","timestamp":"2026-02-22T07:32:00.646Z"}
{"parentUuid":"a6b003ee-5618-47dc-acb7-f4b0939e5e5a","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01XJB74BVXZkcd7QkfPSBfq1","type":"message","role":"assistant","content":[{"type":"text","text":"í•µì‹¬ ì½”ë“œë¥¼ ì§ì ‘ ì½ê² ìŠµë‹ˆë‹¤."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3565,"cache_read_input_tokens":127506,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3565},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNiY1AUG3KuQpksg9y6P","type":"assistant","uuid":"f812c663-a9ab-45ce-b871-b30c9eef78e8","timestamp":"2026-02-22T07:32:00.654Z"}
{"parentUuid":"f812c663-a9ab-45ce-b871-b30c9eef78e8","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01XJB74BVXZkcd7QkfPSBfq1","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YRd6H35kHMfZTj7wQy1Jqv","name":"Bash","input":{"command":"grep -n \"fn reset_index\\|fn set_indexing_pragmas\\|fn restore_normal_pragmas\\|fn upsert_rows\\|fn run_incremental_index\\|fn start_full_index\\|DELETE FROM entries\\|DROP TABLE\\|DROP INDEX\\|CREATE INDEX\\|PRAGMA synchronous\\|PRAGMA cache_size\\|PRAGMA journal\\|wal_autocheckpoint\\|BATCH_SIZE\\|batch_size\\|fn db_connection\" /Users/al02402336/everything/src-tauri/src/main.rs | head -60","description":"Find key function locations"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3565,"cache_read_input_tokens":127506,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3565},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNiY1AUG3KuQpksg9y6P","type":"assistant","uuid":"27eb3068-6a2c-4db7-adf4-113dea79b3d0","timestamp":"2026-02-22T07:32:02.694Z"}
{"parentUuid":"27eb3068-6a2c-4db7-adf4-113dea79b3d0","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YRd6H35kHMfZTj7wQy1Jqv","type":"tool_result","content":"42:pub(crate) const BATCH_SIZE: usize = 10_000;\n383:fn db_connection_with_timeout(db_path: &Path, busy_timeout_ms: u32) -> AppResult<Connection> {\n387:        PRAGMA journal_mode=WAL;\n388:        PRAGMA synchronous=NORMAL;\n397:pub(crate) fn db_connection(db_path: &Path) -> AppResult<Connection> {\n401:fn db_connection_for_search(db_path: &Path) -> AppResult<Connection> {\n404:        \"PRAGMA cache_size = -32768;\n411:pub(crate) fn set_indexing_pragmas(conn: &Connection) -> AppResult<()> {\n414:        PRAGMA synchronous = NORMAL;\n415:        PRAGMA cache_size = -65536;\n417:        PRAGMA wal_autocheckpoint = 10000;\n423:pub(crate) fn restore_normal_pragmas(conn: &Connection) -> AppResult<()> {\n426:        PRAGMA synchronous = NORMAL;\n427:        PRAGMA cache_size = -16384;\n429:        PRAGMA wal_autocheckpoint = 1000;\n452:            DROP TABLE IF EXISTS entries_fts;\n453:            DROP TABLE IF EXISTS entries;\n477:        CREATE INDEX IF NOT EXISTS idx_entries_dir_ext_name_nocase ON entries(dir, ext, name COLLATE NOCASE);\n478:        CREATE INDEX IF NOT EXISTS idx_entries_mtime ON entries(mtime);\n479:        CREATE INDEX IF NOT EXISTS idx_entries_name_nocase ON entries(name COLLATE NOCASE);\n480:        CREATE INDEX IF NOT EXISTS idx_entries_ext_name ON entries(ext, name COLLATE NOCASE);\n496:        conn.execute_batch(\"DROP INDEX IF EXISTS idx_entries_dir_name_nocase;\")\n1141:            conn.execute(\"DELETE FROM entries\", [])\n1149:            \"DELETE FROM entries WHERE path = ?1 OR path LIKE ?2 ESCAPE '\\\\'\",\n1681:pub(crate) fn upsert_rows(conn: &mut Connection, rows: &[IndexRow]) -> AppResult<usize> {\n1735:            .prepare(\"DELETE FROM entries WHERE path = ?1\")\n1738:            .prepare(\"DELETE FROM entries WHERE path >= ?1 AND path < ?2\")\n1755:                    .execute(\"DELETE FROM entries\", [])\n1887:pub(crate) fn start_full_index_worker(app: AppHandle, state: AppState) -> AppResult<()> {\n1892:pub(crate) fn start_full_index_worker_silent(app: AppHandle, state: AppState) -> AppResult<()> {\n1896:fn start_full_index_worker_inner(app: AppHandle, state: AppState, silent: bool) -> AppResult<()> {\n2001:fn run_incremental_index(app: &AppHandle, state: &AppState) -> AppResult<()> {\n2043:fn run_incremental_index_inner(\n2068:    let mut batch: Vec<IndexRow> = Vec::with_capacity(BATCH_SIZE);\n2069:    let mut stamp_batch: Vec<String> = Vec::with_capacity(BATCH_SIZE);\n2138:    if stamp_batch.len() >= BATCH_SIZE {\n2253:                        if batch.len() >= BATCH_SIZE {\n2258:                        if stamp_batch.len() >= BATCH_SIZE {\n2363:            \"DELETE FROM entries WHERE run_id < ?1\",\n2564:                    \"[watcher] DB busy, will retry in {}s: {} | batch_size={}\",\n2576:                \"[watcher] process_watcher_paths ERROR: {} | batch_size={} indexing_active={}\",\n2924:fn start_full_index(app: AppHandle, state: State<'_, AppState>) -> AppResult<()> {\n2937:async fn reset_index(app: AppHandle, state: State<'_, AppState>) -> AppResult<()> {\n2956:        conn.execute(\"DELETE FROM entries\", [])\n4276:            for chunk in rows.chunks(BATCH_SIZE) {","is_error":false}]},"uuid":"d9884770-aa8f-4de1-b62d-587079bda657","timestamp":"2026-02-22T07:32:02.899Z","toolUseResult":{"stdout":"42:pub(crate) const BATCH_SIZE: usize = 10_000;\n383:fn db_connection_with_timeout(db_path: &Path, busy_timeout_ms: u32) -> AppResult<Connection> {\n387:        PRAGMA journal_mode=WAL;\n388:        PRAGMA synchronous=NORMAL;\n397:pub(crate) fn db_connection(db_path: &Path) -> AppResult<Connection> {\n401:fn db_connection_for_search(db_path: &Path) -> AppResult<Connection> {\n404:        \"PRAGMA cache_size = -32768;\n411:pub(crate) fn set_indexing_pragmas(conn: &Connection) -> AppResult<()> {\n414:        PRAGMA synchronous = NORMAL;\n415:        PRAGMA cache_size = -65536;\n417:        PRAGMA wal_autocheckpoint = 10000;\n423:pub(crate) fn restore_normal_pragmas(conn: &Connection) -> AppResult<()> {\n426:        PRAGMA synchronous = NORMAL;\n427:        PRAGMA cache_size = -16384;\n429:        PRAGMA wal_autocheckpoint = 1000;\n452:            DROP TABLE IF EXISTS entries_fts;\n453:            DROP TABLE IF EXISTS entries;\n477:        CREATE INDEX IF NOT EXISTS idx_entries_dir_ext_name_nocase ON entries(dir, ext, name COLLATE NOCASE);\n478:        CREATE INDEX IF NOT EXISTS idx_entries_mtime ON entries(mtime);\n479:        CREATE INDEX IF NOT EXISTS idx_entries_name_nocase ON entries(name COLLATE NOCASE);\n480:        CREATE INDEX IF NOT EXISTS idx_entries_ext_name ON entries(ext, name COLLATE NOCASE);\n496:        conn.execute_batch(\"DROP INDEX IF EXISTS idx_entries_dir_name_nocase;\")\n1141:            conn.execute(\"DELETE FROM entries\", [])\n1149:            \"DELETE FROM entries WHERE path = ?1 OR path LIKE ?2 ESCAPE '\\\\'\",\n1681:pub(crate) fn upsert_rows(conn: &mut Connection, rows: &[IndexRow]) -> AppResult<usize> {\n1735:            .prepare(\"DELETE FROM entries WHERE path = ?1\")\n1738:            .prepare(\"DELETE FROM entries WHERE path >= ?1 AND path < ?2\")\n1755:                    .execute(\"DELETE FROM entries\", [])\n1887:pub(crate) fn start_full_index_worker(app: AppHandle, state: AppState) -> AppResult<()> {\n1892:pub(crate) fn start_full_index_worker_silent(app: AppHandle, state: AppState) -> AppResult<()> {\n1896:fn start_full_index_worker_inner(app: AppHandle, state: AppState, silent: bool) -> AppResult<()> {\n2001:fn run_incremental_index(app: &AppHandle, state: &AppState) -> AppResult<()> {\n2043:fn run_incremental_index_inner(\n2068:    let mut batch: Vec<IndexRow> = Vec::with_capacity(BATCH_SIZE);\n2069:    let mut stamp_batch: Vec<String> = Vec::with_capacity(BATCH_SIZE);\n2138:    if stamp_batch.len() >= BATCH_SIZE {\n2253:                        if batch.len() >= BATCH_SIZE {\n2258:                        if stamp_batch.len() >= BATCH_SIZE {\n2363:            \"DELETE FROM entries WHERE run_id < ?1\",\n2564:                    \"[watcher] DB busy, will retry in {}s: {} | batch_size={}\",\n2576:                \"[watcher] process_watcher_paths ERROR: {} | batch_size={} indexing_active={}\",\n2924:fn start_full_index(app: AppHandle, state: State<'_, AppState>) -> AppResult<()> {\n2937:async fn reset_index(app: AppHandle, state: State<'_, AppState>) -> AppResult<()> {\n2956:        conn.execute(\"DELETE FROM entries\", [])\n4276:            for chunk in rows.chunks(BATCH_SIZE) {","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"27eb3068-6a2c-4db7-adf4-113dea79b3d0"}
{"parentUuid":"d9884770-aa8f-4de1-b62d-587079bda657","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_013awshXEfqGeYR9Zqo59snh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017icJAedH4pK1t3BGnEY4b3","name":"Read","input":{"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","offset":2937,"limit":60},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2937,"cache_read_input_tokens":131071,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2937},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNib7zKjXSo7YUuZEJFw","type":"assistant","uuid":"3072eb6d-d2e4-48e1-955f-56a6d4d1423d","timestamp":"2026-02-22T07:32:05.505Z"}
{"parentUuid":"3072eb6d-d2e4-48e1-955f-56a6d4d1423d","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_017icJAedH4pK1t3BGnEY4b3","toolUseID":"toolu_017icJAedH4pK1t3BGnEY4b3","timestamp":"2026-02-22T07:32:05.554Z","uuid":"2cc00dff-e112-4408-9753-2ec3c2acfd80"}
{"parentUuid":"3072eb6d-d2e4-48e1-955f-56a6d4d1423d","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017icJAedH4pK1t3BGnEY4b3","type":"tool_result","content":"  2937â†’async fn reset_index(app: AppHandle, state: State<'_, AppState>) -> AppResult<()> {\n  2938â†’    let state = state.inner().clone();\n  2939â†’    tauri::async_runtime::spawn_blocking(move || {\n  2940â†’        if state.indexing_active.load(AtomicOrdering::Acquire) {\n  2941â†’            return Err(\"Cannot reset while indexing is in progress.\".to_string());\n  2942â†’        }\n  2943â†’\n  2944â†’        // Stop existing file watcher and wait for it to fully exit\n  2945â†’        state.watcher_stop.store(true, AtomicOrdering::Release);\n  2946â†’        let deadline = std::time::Instant::now() + std::time::Duration::from_secs(5);\n  2947â†’        while state.watcher_active.load(AtomicOrdering::Acquire) {\n  2948â†’            if std::time::Instant::now() >= deadline {\n  2949â†’                eprintln!(\"[reset] watcher did not stop within 5s, proceeding anyway\");\n  2950â†’                break;\n  2951â†’            }\n  2952â†’            std::thread::sleep(std::time::Duration::from_millis(50));\n  2953â†’        }\n  2954â†’\n  2955â†’        let conn = db_connection(&state.db_path)?;\n  2956â†’        conn.execute(\"DELETE FROM entries\", [])\n  2957â†’            .map_err(|e| e.to_string())?;\n  2958â†’        conn.execute(\"DELETE FROM meta\", [])\n  2959â†’            .map_err(|e| e.to_string())?;\n  2960â†’\n  2961â†’        {\n  2962â†’            let mut status = state.status.lock();\n  2963â†’            status.state = IndexState::Indexing;\n  2964â†’            status.entries_count = 0;\n  2965â†’            status.last_updated = None;\n  2966â†’            status.permission_errors = 0;\n  2967â†’            status.message = None;\n  2968â†’            status.scanned = 0;\n  2969â†’            status.indexed = 0;\n  2970â†’            status.current_path.clear();\n  2971â†’        }\n  2972â†’\n  2973â†’        invalidate_search_caches(&state);\n  2974â†’\n  2975â†’        emit_index_state(&app, \"Indexing\", None);\n  2976â†’        emit_index_updated(&app, 0, now_epoch(), 0);\n  2977â†’\n  2978â†’        // Allow new watcher to start\n  2979â†’        state.watcher_stop.store(false, AtomicOrdering::Release);\n  2980â†’\n  2981â†’        #[cfg(target_os = \"windows\")]\n  2982â†’        {\n  2983â†’            win::start_windows_indexing(app, state);\n  2984â†’            Ok(())\n  2985â†’        }\n  2986â†’        #[cfg(not(target_os = \"windows\"))]\n  2987â†’        {\n  2988â†’            start_full_index_worker(app, state)\n  2989â†’        }\n  2990â†’    })\n  2991â†’    .await\n  2992â†’    .map_err(|e| e.to_string())?\n  2993â†’}\n  2994â†’\n  2995â†’fn log_search(db_path: &Path, query: &str, mode: &str, results: &[EntryDto]) {\n  2996â†’    if !search_log_enabled() {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"ea77fb7d-cf42-424d-8c8d-bb5f482fd31f","timestamp":"2026-02-22T07:32:05.552Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src-tauri/src/main.rs","content":"async fn reset_index(app: AppHandle, state: State<'_, AppState>) -> AppResult<()> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        if state.indexing_active.load(AtomicOrdering::Acquire) {\n            return Err(\"Cannot reset while indexing is in progress.\".to_string());\n        }\n\n        // Stop existing file watcher and wait for it to fully exit\n        state.watcher_stop.store(true, AtomicOrdering::Release);\n        let deadline = std::time::Instant::now() + std::time::Duration::from_secs(5);\n        while state.watcher_active.load(AtomicOrdering::Acquire) {\n            if std::time::Instant::now() >= deadline {\n                eprintln!(\"[reset] watcher did not stop within 5s, proceeding anyway\");\n                break;\n            }\n            std::thread::sleep(std::time::Duration::from_millis(50));\n        }\n\n        let conn = db_connection(&state.db_path)?;\n        conn.execute(\"DELETE FROM entries\", [])\n            .map_err(|e| e.to_string())?;\n        conn.execute(\"DELETE FROM meta\", [])\n            .map_err(|e| e.to_string())?;\n\n        {\n            let mut status = state.status.lock();\n            status.state = IndexState::Indexing;\n            status.entries_count = 0;\n            status.last_updated = None;\n            status.permission_errors = 0;\n            status.message = None;\n            status.scanned = 0;\n            status.indexed = 0;\n            status.current_path.clear();\n        }\n\n        invalidate_search_caches(&state);\n\n        emit_index_state(&app, \"Indexing\", None);\n        emit_index_updated(&app, 0, now_epoch(), 0);\n\n        // Allow new watcher to start\n        state.watcher_stop.store(false, AtomicOrdering::Release);\n\n        #[cfg(target_os = \"windows\")]\n        {\n            win::start_windows_indexing(app, state);\n            Ok(())\n        }\n        #[cfg(not(target_os = \"windows\"))]\n        {\n            start_full_index_worker(app, state)\n        }\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\nfn log_search(db_path: &Path, query: &str, mode: &str, results: &[EntryDto]) {\n    if !search_log_enabled() {","numLines":60,"startLine":2937,"totalLines":5753}},"sourceToolAssistantUUID":"3072eb6d-d2e4-48e1-955f-56a6d4d1423d"}
{"parentUuid":"ea77fb7d-cf42-424d-8c8d-bb5f482fd31f","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_0152Q2dDcni4bBYA4Xuo34XN","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BmhPxiJ94npa3iLPXdTpDt","name":"Read","input":{"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","offset":383,"limit":55},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1100,"cache_read_input_tokens":134008,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1100},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNibKQfTCFK3TgfMBNYN","type":"assistant","uuid":"0a42aaee-983f-4f2d-a571-85a9f1392eb7","timestamp":"2026-02-22T07:32:08.151Z"}
{"parentUuid":"0a42aaee-983f-4f2d-a571-85a9f1392eb7","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01BmhPxiJ94npa3iLPXdTpDt","toolUseID":"toolu_01BmhPxiJ94npa3iLPXdTpDt","timestamp":"2026-02-22T07:32:08.174Z","uuid":"6ca9838a-a25a-46d3-9459-156483841f9d"}
{"parentUuid":"0a42aaee-983f-4f2d-a571-85a9f1392eb7","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BmhPxiJ94npa3iLPXdTpDt","type":"tool_result","content":"   383â†’fn db_connection_with_timeout(db_path: &Path, busy_timeout_ms: u32) -> AppResult<Connection> {\n   384â†’    let conn = Connection::open(db_path).map_err(|e| e.to_string())?;\n   385â†’    conn.execute_batch(&format!(\n   386â†’        r#\"\n   387â†’        PRAGMA journal_mode=WAL;\n   388â†’        PRAGMA synchronous=NORMAL;\n   389â†’        PRAGMA temp_store=MEMORY;\n   390â†’        PRAGMA busy_timeout={busy_timeout_ms};\n   391â†’        \"#,\n   392â†’    ))\n   393â†’    .map_err(|e| e.to_string())?;\n   394â†’    Ok(conn)\n   395â†’}\n   396â†’\n   397â†’pub(crate) fn db_connection(db_path: &Path) -> AppResult<Connection> {\n   398â†’    db_connection_with_timeout(db_path, 3000)\n   399â†’}\n   400â†’\n   401â†’fn db_connection_for_search(db_path: &Path) -> AppResult<Connection> {\n   402â†’    let conn = db_connection_with_timeout(db_path, 500)?;\n   403â†’    conn.execute_batch(\n   404â†’        \"PRAGMA cache_size = -32768;\n   405â†’         PRAGMA mmap_size = 268435456;\",\n   406â†’    )\n   407â†’    .map_err(|e| e.to_string())?;\n   408â†’    Ok(conn)\n   409â†’}\n   410â†’\n   411â†’pub(crate) fn set_indexing_pragmas(conn: &Connection) -> AppResult<()> {\n   412â†’    conn.execute_batch(\n   413â†’        r#\"\n   414â†’        PRAGMA synchronous = NORMAL;\n   415â†’        PRAGMA cache_size = -65536;\n   416â†’        PRAGMA mmap_size = 268435456;\n   417â†’        PRAGMA wal_autocheckpoint = 10000;\n   418â†’        \"#,\n   419â†’    )\n   420â†’    .map_err(|e| e.to_string())\n   421â†’}\n   422â†’\n   423â†’pub(crate) fn restore_normal_pragmas(conn: &Connection) -> AppResult<()> {\n   424â†’    conn.execute_batch(\n   425â†’        r#\"\n   426â†’        PRAGMA synchronous = NORMAL;\n   427â†’        PRAGMA cache_size = -16384;\n   428â†’        PRAGMA mmap_size = 268435456;\n   429â†’        PRAGMA wal_autocheckpoint = 1000;\n   430â†’        \"#,\n   431â†’    )\n   432â†’    .map_err(|e| e.to_string())?;\n   433â†’    conn.execute_batch(\"PRAGMA wal_checkpoint(TRUNCATE);\")\n   434â†’        .map_err(|e| e.to_string())?;\n   435â†’    Ok(())\n   436â†’}\n   437â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"74fbce78-baf2-48b8-aadc-cf440c805e36","timestamp":"2026-02-22T07:32:08.172Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src-tauri/src/main.rs","content":"fn db_connection_with_timeout(db_path: &Path, busy_timeout_ms: u32) -> AppResult<Connection> {\n    let conn = Connection::open(db_path).map_err(|e| e.to_string())?;\n    conn.execute_batch(&format!(\n        r#\"\n        PRAGMA journal_mode=WAL;\n        PRAGMA synchronous=NORMAL;\n        PRAGMA temp_store=MEMORY;\n        PRAGMA busy_timeout={busy_timeout_ms};\n        \"#,\n    ))\n    .map_err(|e| e.to_string())?;\n    Ok(conn)\n}\n\npub(crate) fn db_connection(db_path: &Path) -> AppResult<Connection> {\n    db_connection_with_timeout(db_path, 3000)\n}\n\nfn db_connection_for_search(db_path: &Path) -> AppResult<Connection> {\n    let conn = db_connection_with_timeout(db_path, 500)?;\n    conn.execute_batch(\n        \"PRAGMA cache_size = -32768;\n         PRAGMA mmap_size = 268435456;\",\n    )\n    .map_err(|e| e.to_string())?;\n    Ok(conn)\n}\n\npub(crate) fn set_indexing_pragmas(conn: &Connection) -> AppResult<()> {\n    conn.execute_batch(\n        r#\"\n        PRAGMA synchronous = NORMAL;\n        PRAGMA cache_size = -65536;\n        PRAGMA mmap_size = 268435456;\n        PRAGMA wal_autocheckpoint = 10000;\n        \"#,\n    )\n    .map_err(|e| e.to_string())\n}\n\npub(crate) fn restore_normal_pragmas(conn: &Connection) -> AppResult<()> {\n    conn.execute_batch(\n        r#\"\n        PRAGMA synchronous = NORMAL;\n        PRAGMA cache_size = -16384;\n        PRAGMA mmap_size = 268435456;\n        PRAGMA wal_autocheckpoint = 1000;\n        \"#,\n    )\n    .map_err(|e| e.to_string())?;\n    conn.execute_batch(\"PRAGMA wal_checkpoint(TRUNCATE);\")\n        .map_err(|e| e.to_string())?;\n    Ok(())\n}\n","numLines":55,"startLine":383,"totalLines":5753}},"sourceToolAssistantUUID":"0a42aaee-983f-4f2d-a571-85a9f1392eb7"}
{"parentUuid":"74fbce78-baf2-48b8-aadc-cf440c805e36","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01PBfJSB3qbFbsMHsqCBNWA8","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XCM3GLLDwXYj5ktCYmXpJY","name":"Read","input":{"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","offset":1681,"limit":55},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":955,"cache_read_input_tokens":135108,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":955},"output_tokens":18,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNibWzvLcC31LtT9eSyQ","type":"assistant","uuid":"d828bb36-6957-4ae4-bf30-2a41c1766a28","timestamp":"2026-02-22T07:32:10.467Z"}
{"parentUuid":"d828bb36-6957-4ae4-bf30-2a41c1766a28","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01XCM3GLLDwXYj5ktCYmXpJY","toolUseID":"toolu_01XCM3GLLDwXYj5ktCYmXpJY","timestamp":"2026-02-22T07:32:10.503Z","uuid":"4090ce14-ae32-4cc5-8f6f-31940075ed5d"}
{"parentUuid":"d828bb36-6957-4ae4-bf30-2a41c1766a28","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XCM3GLLDwXYj5ktCYmXpJY","type":"tool_result","content":"  1681â†’pub(crate) fn upsert_rows(conn: &mut Connection, rows: &[IndexRow]) -> AppResult<usize> {\n  1682â†’    if rows.is_empty() {\n  1683â†’        return Ok(0);\n  1684â†’    }\n  1685â†’\n  1686â†’    let tx = conn.transaction().map_err(|e| e.to_string())?;\n  1687â†’    {\n  1688â†’        let mut stmt = tx\n  1689â†’            .prepare(\n  1690â†’                r#\"\n  1691â†’                INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n  1692â†’                VALUES(?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)\n  1693â†’                ON CONFLICT(path) DO UPDATE SET\n  1694â†’                  name = excluded.name,\n  1695â†’                  dir = excluded.dir,\n  1696â†’                  is_dir = excluded.is_dir,\n  1697â†’                  ext = excluded.ext,\n  1698â†’                  mtime = excluded.mtime,\n  1699â†’                  size = excluded.size,\n  1700â†’                  indexed_at = excluded.indexed_at,\n  1701â†’                  run_id = excluded.run_id\n  1702â†’                \"#,\n  1703â†’            )\n  1704â†’            .map_err(|e| e.to_string())?;\n  1705â†’\n  1706â†’        for row in rows {\n  1707â†’            stmt.execute(params![\n  1708â†’                row.path,\n  1709â†’                row.name,\n  1710â†’                row.dir,\n  1711â†’                row.is_dir,\n  1712â†’                row.ext,\n  1713â†’                row.mtime,\n  1714â†’                row.size,\n  1715â†’                row.indexed_at,\n  1716â†’                row.run_id\n  1717â†’            ])\n  1718â†’            .map_err(|e| e.to_string())?;\n  1719â†’        }\n  1720â†’    }\n  1721â†’    tx.commit().map_err(|e| e.to_string())?;\n  1722â†’    Ok(rows.len())\n  1723â†’}\n  1724â†’\n  1725â†’pub(crate) fn delete_paths(conn: &mut Connection, raw_paths: &[String]) -> AppResult<usize> {\n  1726â†’    if raw_paths.is_empty() {\n  1727â†’        return Ok(0);\n  1728â†’    }\n  1729â†’\n  1730â†’    let tx = conn.transaction().map_err(|e| e.to_string())?;\n  1731â†’    let mut deleted = 0;\n  1732â†’\n  1733â†’    {\n  1734â†’        let mut stmt_exact = tx\n  1735â†’            .prepare(\"DELETE FROM entries WHERE path = ?1\")\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"1cef7409-e82c-4d39-b31d-8a5ef3bef2ea","timestamp":"2026-02-22T07:32:10.501Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src-tauri/src/main.rs","content":"pub(crate) fn upsert_rows(conn: &mut Connection, rows: &[IndexRow]) -> AppResult<usize> {\n    if rows.is_empty() {\n        return Ok(0);\n    }\n\n    let tx = conn.transaction().map_err(|e| e.to_string())?;\n    {\n        let mut stmt = tx\n            .prepare(\n                r#\"\n                INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n                VALUES(?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)\n                ON CONFLICT(path) DO UPDATE SET\n                  name = excluded.name,\n                  dir = excluded.dir,\n                  is_dir = excluded.is_dir,\n                  ext = excluded.ext,\n                  mtime = excluded.mtime,\n                  size = excluded.size,\n                  indexed_at = excluded.indexed_at,\n                  run_id = excluded.run_id\n                \"#,\n            )\n            .map_err(|e| e.to_string())?;\n\n        for row in rows {\n            stmt.execute(params![\n                row.path,\n                row.name,\n                row.dir,\n                row.is_dir,\n                row.ext,\n                row.mtime,\n                row.size,\n                row.indexed_at,\n                row.run_id\n            ])\n            .map_err(|e| e.to_string())?;\n        }\n    }\n    tx.commit().map_err(|e| e.to_string())?;\n    Ok(rows.len())\n}\n\npub(crate) fn delete_paths(conn: &mut Connection, raw_paths: &[String]) -> AppResult<usize> {\n    if raw_paths.is_empty() {\n        return Ok(0);\n    }\n\n    let tx = conn.transaction().map_err(|e| e.to_string())?;\n    let mut deleted = 0;\n\n    {\n        let mut stmt_exact = tx\n            .prepare(\"DELETE FROM entries WHERE path = ?1\")","numLines":55,"startLine":1681,"totalLines":5753}},"sourceToolAssistantUUID":"d828bb36-6957-4ae4-bf30-2a41c1766a28"}
{"parentUuid":"1cef7409-e82c-4d39-b31d-8a5ef3bef2ea","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01BdcwJoUt6Cd5yGxuZ1VZiL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Aa5RkcbdY4NxRvJWpTWQgF","name":"Read","input":{"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","offset":440,"limit":60},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":950,"cache_read_input_tokens":136063,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":950},"output_tokens":18,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNibgjohoHBcCQ6mavjU","type":"assistant","uuid":"ee60b812-94d8-409d-a941-7f7de08437ce","timestamp":"2026-02-22T07:32:12.524Z"}
{"parentUuid":"ee60b812-94d8-409d-a941-7f7de08437ce","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01Aa5RkcbdY4NxRvJWpTWQgF","toolUseID":"toolu_01Aa5RkcbdY4NxRvJWpTWQgF","timestamp":"2026-02-22T07:32:12.538Z","uuid":"873aece4-6841-4609-b90f-a19b16c07132"}
{"parentUuid":"ee60b812-94d8-409d-a941-7f7de08437ce","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Aa5RkcbdY4NxRvJWpTWQgF","type":"tool_result","content":"   440â†’    let conn = db_connection(db_path)?;\n   441â†’    eprintln!(\"[init_db] +{}ms db_connection opened\", t.elapsed().as_millis());\n   442â†’\n   443â†’    let current_version: i32 = conn\n   444â†’        .query_row(\"PRAGMA user_version\", [], |row| row.get(0))\n   445â†’        .unwrap_or(0);\n   446â†’    if current_version != DB_VERSION {\n   447â†’        conn.execute_batch(\n   448â†’            r#\"\n   449â†’            DROP TRIGGER IF EXISTS entries_ai;\n   450â†’            DROP TRIGGER IF EXISTS entries_ad;\n   451â†’            DROP TRIGGER IF EXISTS entries_au;\n   452â†’            DROP TABLE IF EXISTS entries_fts;\n   453â†’            DROP TABLE IF EXISTS entries;\n   454â†’            \"#,\n   455â†’        )\n   456â†’        .map_err(|e| e.to_string())?;\n   457â†’        conn.execute_batch(&format!(\"PRAGMA user_version = {};\", DB_VERSION))\n   458â†’            .map_err(|e| e.to_string())?;\n   459â†’    }\n   460â†’    eprintln!(\"[init_db] +{}ms version check done (v={})\", t.elapsed().as_millis(), current_version);\n   461â†’\n   462â†’    conn.execute_batch(\n   463â†’        r#\"\n   464â†’        CREATE TABLE IF NOT EXISTS entries (\n   465â†’          id INTEGER PRIMARY KEY,\n   466â†’          path TEXT NOT NULL UNIQUE,\n   467â†’          name TEXT NOT NULL,\n   468â†’          dir TEXT NOT NULL,\n   469â†’          is_dir INTEGER NOT NULL,\n   470â†’          ext TEXT,\n   471â†’          mtime INTEGER,\n   472â†’          size INTEGER,\n   473â†’          indexed_at INTEGER NOT NULL,\n   474â†’          run_id INTEGER NOT NULL DEFAULT 0\n   475â†’        );\n   476â†’\n   477â†’        CREATE INDEX IF NOT EXISTS idx_entries_dir_ext_name_nocase ON entries(dir, ext, name COLLATE NOCASE);\n   478â†’        CREATE INDEX IF NOT EXISTS idx_entries_mtime ON entries(mtime);\n   479â†’        CREATE INDEX IF NOT EXISTS idx_entries_name_nocase ON entries(name COLLATE NOCASE);\n   480â†’        CREATE INDEX IF NOT EXISTS idx_entries_ext_name ON entries(ext, name COLLATE NOCASE);\n   481â†’\n   482â†’        CREATE TABLE IF NOT EXISTS meta (\n   483â†’          key TEXT PRIMARY KEY,\n   484â†’          value TEXT NOT NULL\n   485â†’        );\n   486â†’        \"#,\n   487â†’    )\n   488â†’    .map_err(|e| e.to_string())?;\n   489â†’    eprintln!(\"[init_db] +{}ms schema ensured\", t.elapsed().as_millis());\n   490â†’\n   491â†’    let legacy_index_migration_key = \"migration_drop_idx_entries_dir_name_nocase_v1\";\n   492â†’    let migrated = get_meta(&conn, legacy_index_migration_key)\n   493â†’        .map(|v| v == \"1\")\n   494â†’        .unwrap_or(false);\n   495â†’    if !migrated {\n   496â†’        conn.execute_batch(\"DROP INDEX IF EXISTS idx_entries_dir_name_nocase;\")\n   497â†’            .map_err(|e| e.to_string())?;\n   498â†’        set_meta(&conn, legacy_index_migration_key, \"1\")?;\n   499â†’    }\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"1205b072-9b8b-43c7-b221-0de6c2784d83","timestamp":"2026-02-22T07:32:12.537Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src-tauri/src/main.rs","content":"    let conn = db_connection(db_path)?;\n    eprintln!(\"[init_db] +{}ms db_connection opened\", t.elapsed().as_millis());\n\n    let current_version: i32 = conn\n        .query_row(\"PRAGMA user_version\", [], |row| row.get(0))\n        .unwrap_or(0);\n    if current_version != DB_VERSION {\n        conn.execute_batch(\n            r#\"\n            DROP TRIGGER IF EXISTS entries_ai;\n            DROP TRIGGER IF EXISTS entries_ad;\n            DROP TRIGGER IF EXISTS entries_au;\n            DROP TABLE IF EXISTS entries_fts;\n            DROP TABLE IF EXISTS entries;\n            \"#,\n        )\n        .map_err(|e| e.to_string())?;\n        conn.execute_batch(&format!(\"PRAGMA user_version = {};\", DB_VERSION))\n            .map_err(|e| e.to_string())?;\n    }\n    eprintln!(\"[init_db] +{}ms version check done (v={})\", t.elapsed().as_millis(), current_version);\n\n    conn.execute_batch(\n        r#\"\n        CREATE TABLE IF NOT EXISTS entries (\n          id INTEGER PRIMARY KEY,\n          path TEXT NOT NULL UNIQUE,\n          name TEXT NOT NULL,\n          dir TEXT NOT NULL,\n          is_dir INTEGER NOT NULL,\n          ext TEXT,\n          mtime INTEGER,\n          size INTEGER,\n          indexed_at INTEGER NOT NULL,\n          run_id INTEGER NOT NULL DEFAULT 0\n        );\n\n        CREATE INDEX IF NOT EXISTS idx_entries_dir_ext_name_nocase ON entries(dir, ext, name COLLATE NOCASE);\n        CREATE INDEX IF NOT EXISTS idx_entries_mtime ON entries(mtime);\n        CREATE INDEX IF NOT EXISTS idx_entries_name_nocase ON entries(name COLLATE NOCASE);\n        CREATE INDEX IF NOT EXISTS idx_entries_ext_name ON entries(ext, name COLLATE NOCASE);\n\n        CREATE TABLE IF NOT EXISTS meta (\n          key TEXT PRIMARY KEY,\n          value TEXT NOT NULL\n        );\n        \"#,\n    )\n    .map_err(|e| e.to_string())?;\n    eprintln!(\"[init_db] +{}ms schema ensured\", t.elapsed().as_millis());\n\n    let legacy_index_migration_key = \"migration_drop_idx_entries_dir_name_nocase_v1\";\n    let migrated = get_meta(&conn, legacy_index_migration_key)\n        .map(|v| v == \"1\")\n        .unwrap_or(false);\n    if !migrated {\n        conn.execute_batch(\"DROP INDEX IF EXISTS idx_entries_dir_name_nocase;\")\n            .map_err(|e| e.to_string())?;\n        set_meta(&conn, legacy_index_migration_key, \"1\")?;\n    }","numLines":60,"startLine":440,"totalLines":5753}},"sourceToolAssistantUUID":"ee60b812-94d8-409d-a941-7f7de08437ce"}
{"parentUuid":"1205b072-9b8b-43c7-b221-0de6c2784d83","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01329TFXym4FTYrrnmbs1iWz","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Now I have a clear picture. Let me identify the bottlenecks:\n\n1. **`reset_index` uses `DELETE FROM entries`** â€” For a large table (e.g., 500k rows), DELETE writes a WAL journal entry for each row. This could take 10-20 seconds by itself on a large home directory. A much faster approach would be to DROP TABLE + recreate (but that requires careful schema recreation, including all indexes).\n\n   Actually, the fastest way in SQLite to clear a table is `DELETE FROM entries` with `synchronous=OFF`. Or even faster: close the DB, delete the DB file, reopen. But there's a simpler trick for SQLite: use `DROP TABLE IF EXISTS entries; CREATE TABLE entries(...)`. \n\nThis deletes the table in O(1) and recreation is fast.\n\n2. **`synchronous = NORMAL`** â€” Each transaction commit requires waiting for one fsync. For a fresh index with many batches (50+ batches at 10k per batch for 500k files), each commit takes ~5-10ms, totaling 250-500ms. Not the main bottleneck but changing to `PRAGMA synchronous = OFF` would eliminate fsync entirely.\n\n3. **4 indexes on the table** â€” Each INSERT also updates 4 indexes. During bulk INSERT for fresh indexing, it would be much faster to drop the indexes before bulk loading and recreate them afterward.\n\n4. **BATCH_SIZE = 10,000** â€” Each batch is one transaction. 500k files = 50 transactions. Increasing batch size to 50,000 would reduce to 10 transactions.\n\nThe most impactful optimization is reworking `reset_index` to drop and recreate the table instead of deleting rows, disable synchronous writes during the bulk load, and drop indexes before inserting all rows at once rather than maintaining them through 50 separate transactions.\n\nNow I need to look at the indexing function to see where these changes fit.\n\nActually, I should reconsider the approach here. For incremental indexing during normal operation, dropping and recreating indexes would be too disruptive. But for a fresh index reset, it's the right move.\n\nSince `run_incremental_index_inner` already has an `is_fresh` flag, I can conditionally apply these optimizations: drop indexes and disable synchronous writes at the start of a fresh index, then recreate them and restore normal synchronous mode at the end.\n\nFor the reset function specifically, I should replace the DELETE statements with a drop-and-recreate approach instead.\n\nImplementing the reset optimization...\n\nActually, I need to be careful here. If I drop the tables and recreate them in `reset_index`, the indexes won't exist afterward since `init_db` creates them with `CREATE INDEX IF NOT EXISTS`. So I need to ensure the indexing path actually creates those indexes when starting fresh, rather than assuming they're already there.\n\nLet me focus on the most impactful optimizations: dropping indexes before bulk inserts and recreating them after, disabling synchronous mode during fresh indexing, and using a larger batch size when `is_fresh` is true. I should trace through where these changes fit in `run_incremental_index_inner` and `run_incremental_index`.","signature":"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"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1078,"cache_read_input_tokens":137013,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1078},"output_tokens":10,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNibqVAWgUSYr9ws9NBp","type":"assistant","uuid":"907df04e-18de-4495-a477-72e432667199","timestamp":"2026-02-22T07:32:45.901Z"}
{"parentUuid":"907df04e-18de-4495-a477-72e432667199","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01329TFXym4FTYrrnmbs1iWz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Hoh5jRvNqp2BNENpg9YgVr","name":"Read","input":{"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","offset":2001,"limit":65},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1078,"cache_read_input_tokens":137013,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1078},"output_tokens":10,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNibqVAWgUSYr9ws9NBp","type":"assistant","uuid":"54cc8054-0f25-4936-8984-d927cbb68034","timestamp":"2026-02-22T07:32:46.571Z"}
{"parentUuid":"54cc8054-0f25-4936-8984-d927cbb68034","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01Hoh5jRvNqp2BNENpg9YgVr","toolUseID":"toolu_01Hoh5jRvNqp2BNENpg9YgVr","timestamp":"2026-02-22T07:32:46.618Z","uuid":"94d770a9-a787-416f-8f6a-109b7e976c0c"}
{"parentUuid":"54cc8054-0f25-4936-8984-d927cbb68034","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Hoh5jRvNqp2BNENpg9YgVr","type":"tool_result","content":"  2001â†’fn run_incremental_index(app: &AppHandle, state: &AppState) -> AppResult<()> {\n  2002â†’    let started = Instant::now();\n  2003â†’    perf_log(format!(\n  2004â†’        \"index_run_start home={} db={}\",\n  2005â†’        state.home_dir.to_string_lossy(),\n  2006â†’        state.db_path.to_string_lossy(),\n  2007â†’    ));\n  2008â†’\n  2009â†’    let mut conn = db_connection(&state.db_path)?;\n  2010â†’    set_indexing_pragmas(&conn)?;\n  2011â†’\n  2012â†’    let result = run_incremental_index_inner(app, state, &mut conn);\n  2013â†’\n  2014â†’    let _ = conn.execute_batch(\"ANALYZE\");\n  2015â†’    let _ = restore_normal_pragmas(&conn);\n  2016â†’\n  2017â†’    match &result {\n  2018â†’        Ok(_) => {\n  2019â†’            let _ = set_meta(&conn, \"index_complete\", \"1\");\n  2020â†’            let snapshot = state.status.lock().clone();\n  2021â†’            perf_log(format!(\n  2022â†’                \"index_run_done elapsed_ms={} scanned={} indexed={} entries={} permission_errors={} message={:?}\",\n  2023â†’                started.elapsed().as_millis(),\n  2024â†’                snapshot.scanned,\n  2025â†’                snapshot.indexed,\n  2026â†’                snapshot.entries_count,\n  2027â†’                snapshot.permission_errors,\n  2028â†’                snapshot.message,\n  2029â†’            ));\n  2030â†’        }\n  2031â†’        Err(err) => {\n  2032â†’            perf_log(format!(\n  2033â†’                \"index_run_error elapsed_ms={} err={}\",\n  2034â†’                started.elapsed().as_millis(),\n  2035â†’                err,\n  2036â†’            ));\n  2037â†’        }\n  2038â†’    }\n  2039â†’\n  2040â†’    result\n  2041â†’}\n  2042â†’\n  2043â†’fn run_incremental_index_inner(\n  2044â†’    app: &AppHandle,\n  2045â†’    state: &AppState,\n  2046â†’    conn: &mut Connection,\n  2047â†’) -> AppResult<()> {\n  2048â†’\n  2049â†’    let (runtime_ignored_roots, runtime_ignored_patterns) = effective_ignore_rules(\n  2050â†’        &state.home_dir,\n  2051â†’        &state.cwd,\n  2052â†’        state.path_ignores.as_ref(),\n  2053â†’        state.path_ignore_patterns.as_ref(),\n  2054â†’    );\n  2055â†’    let gi_filter = state.gitignore.get();\n  2056â†’\n  2057â†’    let last_run_id: i64 = get_meta(conn, \"last_run_id\")\n  2058â†’        .and_then(|v| v.parse().ok())\n  2059â†’        .unwrap_or(0);\n  2060â†’    let current_run_id = last_run_id + 1;\n  2061â†’    // Fresh index: DB was empty, skip preload/stamp, single unlimited-depth pass\n  2062â†’    let is_fresh = last_run_id == 0;\n  2063â†’\n  2064â†’    let mut scanned: u64 = 0;\n  2065â†’    let mut indexed: u64 = 0;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"e2a79ba5-8ae9-4353-b634-2f0878852952","timestamp":"2026-02-22T07:32:46.616Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src-tauri/src/main.rs","content":"fn run_incremental_index(app: &AppHandle, state: &AppState) -> AppResult<()> {\n    let started = Instant::now();\n    perf_log(format!(\n        \"index_run_start home={} db={}\",\n        state.home_dir.to_string_lossy(),\n        state.db_path.to_string_lossy(),\n    ));\n\n    let mut conn = db_connection(&state.db_path)?;\n    set_indexing_pragmas(&conn)?;\n\n    let result = run_incremental_index_inner(app, state, &mut conn);\n\n    let _ = conn.execute_batch(\"ANALYZE\");\n    let _ = restore_normal_pragmas(&conn);\n\n    match &result {\n        Ok(_) => {\n            let _ = set_meta(&conn, \"index_complete\", \"1\");\n            let snapshot = state.status.lock().clone();\n            perf_log(format!(\n                \"index_run_done elapsed_ms={} scanned={} indexed={} entries={} permission_errors={} message={:?}\",\n                started.elapsed().as_millis(),\n                snapshot.scanned,\n                snapshot.indexed,\n                snapshot.entries_count,\n                snapshot.permission_errors,\n                snapshot.message,\n            ));\n        }\n        Err(err) => {\n            perf_log(format!(\n                \"index_run_error elapsed_ms={} err={}\",\n                started.elapsed().as_millis(),\n                err,\n            ));\n        }\n    }\n\n    result\n}\n\nfn run_incremental_index_inner(\n    app: &AppHandle,\n    state: &AppState,\n    conn: &mut Connection,\n) -> AppResult<()> {\n\n    let (runtime_ignored_roots, runtime_ignored_patterns) = effective_ignore_rules(\n        &state.home_dir,\n        &state.cwd,\n        state.path_ignores.as_ref(),\n        state.path_ignore_patterns.as_ref(),\n    );\n    let gi_filter = state.gitignore.get();\n\n    let last_run_id: i64 = get_meta(conn, \"last_run_id\")\n        .and_then(|v| v.parse().ok())\n        .unwrap_or(0);\n    let current_run_id = last_run_id + 1;\n    // Fresh index: DB was empty, skip preload/stamp, single unlimited-depth pass\n    let is_fresh = last_run_id == 0;\n\n    let mut scanned: u64 = 0;\n    let mut indexed: u64 = 0;","numLines":65,"startLine":2001,"totalLines":5753}},"sourceToolAssistantUUID":"54cc8054-0f25-4936-8984-d927cbb68034"}
{"parentUuid":"e2a79ba5-8ae9-4353-b634-2f0878852952","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01FYgk588cpf8zYBuauJdFsz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Vj7pZbJ37txHdUDa69rKYX","name":"Read","input":{"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","offset":2064,"limit":100},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2584,"cache_read_input_tokens":138091,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2584},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNieM7SQf4KMs1z6jRqT","type":"assistant","uuid":"dbdb7afd-71ac-47f8-b22d-8f08bc85ad08","timestamp":"2026-02-22T07:32:49.926Z"}
{"parentUuid":"dbdb7afd-71ac-47f8-b22d-8f08bc85ad08","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01Vj7pZbJ37txHdUDa69rKYX","toolUseID":"toolu_01Vj7pZbJ37txHdUDa69rKYX","timestamp":"2026-02-22T07:32:49.969Z","uuid":"812f9d41-38a9-4e67-a62a-7c7cb429aec7"}
{"parentUuid":"dbdb7afd-71ac-47f8-b22d-8f08bc85ad08","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Vj7pZbJ37txHdUDa69rKYX","type":"tool_result","content":"  2064â†’    let mut scanned: u64 = 0;\n  2065â†’    let mut indexed: u64 = 0;\n  2066â†’    let mut permission_errors: u64 = 0;\n  2067â†’    let mut current_path = String::new();\n  2068â†’    let mut batch: Vec<IndexRow> = Vec::with_capacity(BATCH_SIZE);\n  2069â†’    let mut stamp_batch: Vec<String> = Vec::with_capacity(BATCH_SIZE);\n  2070â†’    let mut last_emit = Instant::now();\n  2071â†’    let mut last_perf_emit = Instant::now();\n  2072â†’\n  2073â†’    // Preload scan_root-level entries (direct children only, not recursive)\n  2074â†’    let scan_str = state.scan_root.to_string_lossy().to_string();\n  2075â†’    let root_existing = preload_existing_entries(conn, &scan_str);\n  2076â†’\n  2077â†’    // Index scan_root itself\n  2078â†’    if let Some(mut row) = index_row_from_path(&state.scan_root) {\n  2079â†’        scanned += 1;\n  2080â†’        row.run_id = current_run_id;\n  2081â†’        if let Some((old_mtime, old_size)) = root_existing.get(&row.path) {\n  2082â†’            if *old_mtime == row.mtime && *old_size == row.size {\n  2083â†’                stamp_batch.push(row.path);\n  2084â†’            } else {\n  2085â†’                batch.push(row);\n  2086â†’            }\n  2087â†’        } else {\n  2088â†’            batch.push(row);\n  2089â†’        }\n  2090â†’    }\n  2091â†’\n  2092â†’    // Partition direct children into priority vs deferred\n  2093â†’    let mut priority_roots: Vec<PathBuf> = Vec::new();\n  2094â†’    let mut deferred_roots: Vec<PathBuf> = Vec::new();\n  2095â†’\n  2096â†’    if let Ok(entries) = fs::read_dir(&state.scan_root) {\n  2097â†’        for dir_entry in entries.flatten() {\n  2098â†’            let child_path = dir_entry.path();\n  2099â†’\n  2100â†’            if should_skip_path_ext(\n  2101â†’                &child_path,\n  2102â†’                &runtime_ignored_roots,\n  2103â†’                &runtime_ignored_patterns,\n  2104â†’                Some(&gi_filter),\n  2105â†’                None,\n  2106â†’            ) {\n  2107â†’                continue;\n  2108â†’            }\n  2109â†’\n  2110â†’            scanned += 1;\n  2111â†’            current_path = child_path.to_string_lossy().to_string();\n  2112â†’\n  2113â†’            if let Some(mut row) = index_row_from_path(&child_path) {\n  2114â†’                row.run_id = current_run_id;\n  2115â†’                if let Some((old_mtime, old_size)) = root_existing.get(&row.path) {\n  2116â†’                    if *old_mtime == row.mtime && *old_size == row.size {\n  2117â†’                        stamp_batch.push(row.path);\n  2118â†’                    } else {\n  2119â†’                        batch.push(row);\n  2120â†’                    }\n  2121â†’                } else {\n  2122â†’                    batch.push(row);\n  2123â†’                }\n  2124â†’            }\n  2125â†’\n  2126â†’            if child_path.is_dir() {\n  2127â†’                if is_deferred_dir(&child_path, &state.scan_root) {\n  2128â†’                    deferred_roots.push(child_path);\n  2129â†’                } else {\n  2130â†’                    priority_roots.push(child_path);\n  2131â†’                }\n  2132â†’            }\n  2133â†’        }\n  2134â†’    }\n  2135â†’\n  2136â†’\n  2137â†’    // Flush home-level stamp batch\n  2138â†’    if stamp_batch.len() >= BATCH_SIZE {\n  2139â†’        stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n  2140â†’        stamp_batch.clear();\n  2141â†’    }\n  2142â†’\n  2143â†’    priority_roots.sort();\n  2144â†’    deferred_roots.sort();\n  2145â†’\n  2146â†’    let roots: Vec<PathBuf> = priority_roots.into_iter().chain(deferred_roots).collect();\n  2147â†’    perf_log(format!(\n  2148â†’        \"index_scan_roots total={} priority+deferred\",\n  2149â†’        roots.len()\n  2150â†’    ));\n  2151â†’\n  2152â†’    // 2-pass indexing: shallow first (depth <= SHALLOW_SCAN_DEPTH), then deep\n  2153â†’    // Both passes use jwalk for parallel scanning\n  2154â†’    let arc_ignored_roots = Arc::new(runtime_ignored_roots.clone());\n  2155â†’    let arc_ignored_patterns = Arc::new(runtime_ignored_patterns.clone());\n  2156â†’\n  2157â†’\n  2158â†’    for pass in 0..2u8 {\n  2159â†’        // Fresh index: single unlimited-depth pass -- avoids double filesystem traversal\n  2160â†’        if pass == 1 && is_fresh {\n  2161â†’            break;\n  2162â†’        }\n  2163â†’        let pass_label = if pass == 0 { \"shallow\" } else { \"deep\" };\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"ca97791e-971d-4256-9636-d921558345f4","timestamp":"2026-02-22T07:32:49.967Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src-tauri/src/main.rs","content":"    let mut scanned: u64 = 0;\n    let mut indexed: u64 = 0;\n    let mut permission_errors: u64 = 0;\n    let mut current_path = String::new();\n    let mut batch: Vec<IndexRow> = Vec::with_capacity(BATCH_SIZE);\n    let mut stamp_batch: Vec<String> = Vec::with_capacity(BATCH_SIZE);\n    let mut last_emit = Instant::now();\n    let mut last_perf_emit = Instant::now();\n\n    // Preload scan_root-level entries (direct children only, not recursive)\n    let scan_str = state.scan_root.to_string_lossy().to_string();\n    let root_existing = preload_existing_entries(conn, &scan_str);\n\n    // Index scan_root itself\n    if let Some(mut row) = index_row_from_path(&state.scan_root) {\n        scanned += 1;\n        row.run_id = current_run_id;\n        if let Some((old_mtime, old_size)) = root_existing.get(&row.path) {\n            if *old_mtime == row.mtime && *old_size == row.size {\n                stamp_batch.push(row.path);\n            } else {\n                batch.push(row);\n            }\n        } else {\n            batch.push(row);\n        }\n    }\n\n    // Partition direct children into priority vs deferred\n    let mut priority_roots: Vec<PathBuf> = Vec::new();\n    let mut deferred_roots: Vec<PathBuf> = Vec::new();\n\n    if let Ok(entries) = fs::read_dir(&state.scan_root) {\n        for dir_entry in entries.flatten() {\n            let child_path = dir_entry.path();\n\n            if should_skip_path_ext(\n                &child_path,\n                &runtime_ignored_roots,\n                &runtime_ignored_patterns,\n                Some(&gi_filter),\n                None,\n            ) {\n                continue;\n            }\n\n            scanned += 1;\n            current_path = child_path.to_string_lossy().to_string();\n\n            if let Some(mut row) = index_row_from_path(&child_path) {\n                row.run_id = current_run_id;\n                if let Some((old_mtime, old_size)) = root_existing.get(&row.path) {\n                    if *old_mtime == row.mtime && *old_size == row.size {\n                        stamp_batch.push(row.path);\n                    } else {\n                        batch.push(row);\n                    }\n                } else {\n                    batch.push(row);\n                }\n            }\n\n            if child_path.is_dir() {\n                if is_deferred_dir(&child_path, &state.scan_root) {\n                    deferred_roots.push(child_path);\n                } else {\n                    priority_roots.push(child_path);\n                }\n            }\n        }\n    }\n\n\n    // Flush home-level stamp batch\n    if stamp_batch.len() >= BATCH_SIZE {\n        stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n        stamp_batch.clear();\n    }\n\n    priority_roots.sort();\n    deferred_roots.sort();\n\n    let roots: Vec<PathBuf> = priority_roots.into_iter().chain(deferred_roots).collect();\n    perf_log(format!(\n        \"index_scan_roots total={} priority+deferred\",\n        roots.len()\n    ));\n\n    // 2-pass indexing: shallow first (depth <= SHALLOW_SCAN_DEPTH), then deep\n    // Both passes use jwalk for parallel scanning\n    let arc_ignored_roots = Arc::new(runtime_ignored_roots.clone());\n    let arc_ignored_patterns = Arc::new(runtime_ignored_patterns.clone());\n\n\n    for pass in 0..2u8 {\n        // Fresh index: single unlimited-depth pass -- avoids double filesystem traversal\n        if pass == 1 && is_fresh {\n            break;\n        }\n        let pass_label = if pass == 0 { \"shallow\" } else { \"deep\" };","numLines":100,"startLine":2064,"totalLines":5753}},"sourceToolAssistantUUID":"dbdb7afd-71ac-47f8-b22d-8f08bc85ad08"}
{"parentUuid":"ca97791e-971d-4256-9636-d921558345f4","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01Vq9ZhxFa4jq4Y61r2QkVTM","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Now I have a clear picture. Let me plan the optimizations:\n\n**Bottlenecks identified:**\n1. `reset_index` uses `DELETE FROM entries` â€” O(n) with journal entry per row\n2. During fresh index: 4 indexes updated for every row inserted (massive overhead for bulk insert)\n3. `synchronous = NORMAL` â€” each transaction commit requires fsync\n4. `BATCH_SIZE = 10,000` â€” many small transactions\n\n**Optimizations plan:**\n\n### 1. `reset_index`: Use DROP TABLE instead of DELETE\n\nInstead of `DELETE FROM entries` (O(n) with WAL write per row), use:\n\n\nClearing the entries table and vacuuming the database...\n\nThe challenge is that `init_db` creates indexes with `CREATE INDEX IF NOT EXISTS`, so after dropping and recreating the table, I need to ensure indexes are rebuilt. The simplest approach is to drop the entire database file and let `init_db` recreate everything from scratch, or use a version bump trick to trigger schema recreation. Alternatively, I can clear the entries table and vacuum in a single batch operation to avoid the per-row overhead.\n\nActually, the most efficient solution is to disable synchronous writes temporarily while clearing the table, then re-enable themâ€”this avoids the fsync overhead that makes DELETE slow on large tables.\n\nBut I'm realizing there's a deeper issue: even with synchronous disabled, deleting 500k rows in WAL mode still generates a massive write-ahead log. A better approach might be to close the connection entirely, delete the database file, and let the initialization function recreate it fresh. The challenge is coordinating that across all active connections. Alternatively, I could set a flag to trigger a full database rebuild on the next index runâ€”close the current connection, delete the file, and reopen it.\n\nFor a fresh index specifically, the most practical optimization is dropping all four secondary indexes before the bulk insert, then recreating them afterward. This avoids the overhead of updating indexes during insertion.\n\nDropping and recreating indexes...\n\nBeyond that, I should also consider setting `synchronous=OFF` during the indexing phase since we can always re-index if something goes wrong, and bumping the batch size up to 50,000 for fresh indexes to reduce transaction overhead. For the reset operation, instead of doing a full DELETE followed by reindexing, I could use `synchronous=OFF` before the deletion to speed that up as well.\n\nLet me start implementing these changes: I'll add the pragma toggle in `reset_index`, drop and recreate indexes around the insert loop when doing a fresh index, switch to `synchronous=OFF` in the indexing pragmas, and potentially explore using a larger batch size for fresh operations.\n\nActually, the cleanest approach is to set `synchronous=OFF` globally during indexing since we can always re-index if something goes wrong, then apply targeted optimizations for fresh indexes specificallyâ€”dropping indexes upfront, using larger batches, and running ANALYZE after all inserts complete.\n\nNow I'm checking where ANALYZE fits into the flow...\n\nSetting `synchronous=OFF` with a larger cache during the reset's DELETE phase...\n\nConfiguring pragmas for faster deletes... SQLite doesn't even wait for data to be written to disk. This means if the power cuts while deleting, the DB could be in a weird state. But since this is a reset anyway and we're about to re-build, it's fine.\n\nNow I'm planning the precise code changes. First, I'll speed up the `reset_index` function by disabling synchronous mode and increasing the cache size before deleting from both tables. Then I need to change the indexing pragmas to use `synchronous=OFF` instead of `NORMAL`, which should significantly speed up inserts by skipping the fsync calls on each commit. Finally, for fresh indexes, I'll drop all the existing indexes before inserting data and recreate them afterward.\n\nBut I'm realizing there's a scope issue hereâ€”the `is_fresh` flag is computed inside `run_incremental_index_inner`, so I can't access it in the outer `run_incremental_index` function to know when to recreate the indexes.\n\nThe cleanest solution is to handle the index drop and recreation directly within the inner function itself: drop them at the start when `is_fresh` is detected, then recreate them after all the inserts complete. The main risk is if indexing fails partway through, we'd be left with an incomplete table and no indexes, but since the outer function runs ANALYZE anyway and the app would trigger a full re-index on the next startup, this should be acceptable.\n\nFor the batch size optimization, I'm increasing it by a factor of five specifically during fresh indexing operations to speed up the initial load.\n\nNow I'm narrowing down to the most impactful changes: disabling synchronous mode for faster commits, dropping indexes before a fresh index run and recreating them after, and applying the same synchronous optimization to the reset operation. Let me estimate the performance gainsâ€”the synchronous mode change should save some fsync overhead, but the real win comes from eliminating index maintenance during the bulk insert phase. indexes Ã— 500k rows = 2M BTREE operations saved. This could be 20-40 seconds.\n- With reset using `synchronous=OFF`: The DELETE itself might be slow because each row deletion is journaled. Actually, in WAL mode, DELETE FROM entries doesn't need to journal each row â€” it creates a WAL frame for each modified page. With 500k rows at ~50 bytes each = 25MB, that's ~6000 pages Ã— 4KB = lots of WAL writes. With synchronous=OFF, no fsync needed, so this should be fast.\n\nThe most impactful change might be: for `reset_index`, instead of `DELETE FROM entries`, do a schema recreation via `PRAGMA user_version = 99; PRAGMA user_version = 4;` or just increment DB_VERSION temporarily. But that would trigger `init_db`'s schema recreation path, which does DROP TABLE anyway.\n\nActually, the cleanest approach is to just close the connection, delete the database file entirely, and let `init_db` recreate it fresh on the next connection. I can drop the current connection and then remove the file before reinitializing. the file stays until all handles are closed). This approach is risky, so I'm going to abandon it and take a simpler, safer route instead. I'll set `synchronous=OFF` in `reset_index` to speed up the DELETE operation, apply the same pragma during indexing, drop the secondary indexes upfront when doing a fresh index and recreate them after all inserts finish, and increase the batch size for fresh indexing to flush data less frequently.\n\nNow I need to locate the exact places in the code where `BATCH_SIZE` is referenced in the walk loop and figure out where to insert the index recreation logic at the end of `run_incremental_index_inner`, probably right before the final status events are emitted.","signature":"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"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1767,"cache_read_input_tokens":140675,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1767},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNiebJDe2T5tsFzVh9Hq","type":"assistant","uuid":"1c782912-767c-4dd2-8933-958138041b92","timestamp":"2026-02-22T07:34:05.233Z"}
{"parentUuid":"1c782912-767c-4dd2-8933-958138041b92","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01Vq9ZhxFa4jq4Y61r2QkVTM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UGwNwzBwcCKByYpXFRdxGZ","name":"Read","input":{"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","offset":2340,"limit":100},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1767,"cache_read_input_tokens":140675,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1767},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNiebJDe2T5tsFzVh9Hq","type":"assistant","uuid":"b5cb25d2-22fb-4394-8203-278f989baaa5","timestamp":"2026-02-22T07:34:05.593Z"}
{"parentUuid":"b5cb25d2-22fb-4394-8203-278f989baaa5","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01UGwNwzBwcCKByYpXFRdxGZ","toolUseID":"toolu_01UGwNwzBwcCKByYpXFRdxGZ","timestamp":"2026-02-22T07:34:05.647Z","uuid":"226106ab-016d-4d30-8ad8-d34d6a43a59b"}
{"parentUuid":"b5cb25d2-22fb-4394-8203-278f989baaa5","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UGwNwzBwcCKByYpXFRdxGZ","type":"tool_result","content":"  2340â†’        upsert_rows(conn, &batch)?;\n  2341â†’    }\n  2342â†’\n  2343â†’    if !stamp_batch.is_empty() {\n  2344â†’        stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n  2345â†’    }\n  2346â†’\n  2347â†’    set_progress(state, scanned, indexed, &current_path);\n  2348â†’    emit_index_progress(app, scanned, indexed, current_path.clone());\n  2349â†’\n  2350â†’    // Remove entries not seen in this run (deleted files)\n  2351â†’    // Fresh index: DB was empty before this run, no stale entries possible\n  2352â†’    let deleted_count: i64 = if is_fresh {\n  2353â†’        0\n  2354â†’    } else {\n  2355â†’        let count = conn\n  2356â†’            .query_row(\n  2357â†’                \"SELECT COUNT(*) FROM entries WHERE run_id < ?1\",\n  2358â†’                params![current_run_id],\n  2359â†’                |row| row.get(0),\n  2360â†’            )\n  2361â†’            .unwrap_or(0);\n  2362â†’        conn.execute(\n  2363â†’            \"DELETE FROM entries WHERE run_id < ?1\",\n  2364â†’            params![current_run_id],\n  2365â†’        )\n  2366â†’        .map_err(|e| e.to_string())?;\n  2367â†’        count\n  2368â†’    };\n  2369â†’\n  2370â†’    set_meta(conn, \"last_run_id\", &current_run_id.to_string())?;\n  2371â†’\n  2372â†’    if deleted_count > 0 || indexed > 0 {\n  2373â†’        invalidate_search_caches(state);\n  2374â†’    }\n  2375â†’\n  2376â†’    let (entries_count, last_updated) = update_status_counts(state)?;\n  2377â†’    // Persist cached counts for instant startup next time\n  2378â†’    let _ = set_meta(conn, \"cached_entries_count\", &entries_count.to_string());\n  2379â†’    if let Some(lu) = last_updated {\n  2380â†’        let _ = set_meta(conn, \"cached_last_updated\", &lu.to_string());\n  2381â†’    }\n  2382â†’    let updated_at = last_updated.unwrap_or_else(now_epoch);\n  2383â†’\n  2384â†’    {\n  2385â†’        let mut status = state.status.lock();\n  2386â†’        status.state = IndexState::Ready;\n  2387â†’        status.permission_errors = permission_errors;\n  2388â†’        status.scanned = scanned;\n  2389â†’        status.indexed = indexed;\n  2390â†’        status.current_path = current_path.clone();\n  2391â†’        status.message = if permission_errors > 0 {\n  2392â†’            Some(format!(\n  2393â†’                \"{} permission/access error(s) occurred.\",\n  2394â†’                permission_errors\n  2395â†’            ))\n  2396â†’        } else {\n  2397â†’            None\n  2398â†’        };\n  2399â†’    }\n  2400â†’    emit_index_progress(app, scanned, indexed, current_path);\n  2401â†’    emit_index_updated(app, entries_count, updated_at, permission_errors);\n  2402â†’    emit_index_state(\n  2403â†’        app,\n  2404â†’        \"Ready\",\n  2405â†’        if permission_errors > 0 {\n  2406â†’            Some(format!(\"{} permission/access error(s)\", permission_errors))\n  2407â†’        } else {\n  2408â†’            None\n  2409â†’        },\n  2410â†’    );\n  2411â†’    perf_log(format!(\n  2412â†’        \"index_state=Ready scanned={} indexed={} deleted={} entries={} permission_errors={}\",\n  2413â†’        scanned, indexed, deleted_count, entries_count, permission_errors\n  2414â†’    ));\n  2415â†’\n  2416â†’    Ok(())\n  2417â†’}\n  2418â†’\n  2419â†’fn trim_recent_ops(ops: &mut Vec<RecentOp>) {\n  2420â†’    let now = Instant::now();\n  2421â†’    ops.retain(|op| now.duration_since(op.at) <= RECENT_OP_TTL);\n  2422â†’}\n  2423â†’\n  2424â†’fn remember_op(\n  2425â†’    state: &AppState,\n  2426â†’    op_type: &'static str,\n  2427â†’    old_path: Option<String>,\n  2428â†’    new_path: Option<String>,\n  2429â†’) {\n  2430â†’    let mut ops = state.recent_ops.lock();\n  2431â†’    trim_recent_ops(&mut ops);\n  2432â†’    ops.push(RecentOp {\n  2433â†’        old_path,\n  2434â†’        new_path,\n  2435â†’        op_type,\n  2436â†’        at: Instant::now(),\n  2437â†’    });\n  2438â†’}\n  2439â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"ed6d92e2-9d98-4d76-869f-822c035c29b7","timestamp":"2026-02-22T07:34:05.644Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src-tauri/src/main.rs","content":"        upsert_rows(conn, &batch)?;\n    }\n\n    if !stamp_batch.is_empty() {\n        stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n    }\n\n    set_progress(state, scanned, indexed, &current_path);\n    emit_index_progress(app, scanned, indexed, current_path.clone());\n\n    // Remove entries not seen in this run (deleted files)\n    // Fresh index: DB was empty before this run, no stale entries possible\n    let deleted_count: i64 = if is_fresh {\n        0\n    } else {\n        let count = conn\n            .query_row(\n                \"SELECT COUNT(*) FROM entries WHERE run_id < ?1\",\n                params![current_run_id],\n                |row| row.get(0),\n            )\n            .unwrap_or(0);\n        conn.execute(\n            \"DELETE FROM entries WHERE run_id < ?1\",\n            params![current_run_id],\n        )\n        .map_err(|e| e.to_string())?;\n        count\n    };\n\n    set_meta(conn, \"last_run_id\", &current_run_id.to_string())?;\n\n    if deleted_count > 0 || indexed > 0 {\n        invalidate_search_caches(state);\n    }\n\n    let (entries_count, last_updated) = update_status_counts(state)?;\n    // Persist cached counts for instant startup next time\n    let _ = set_meta(conn, \"cached_entries_count\", &entries_count.to_string());\n    if let Some(lu) = last_updated {\n        let _ = set_meta(conn, \"cached_last_updated\", &lu.to_string());\n    }\n    let updated_at = last_updated.unwrap_or_else(now_epoch);\n\n    {\n        let mut status = state.status.lock();\n        status.state = IndexState::Ready;\n        status.permission_errors = permission_errors;\n        status.scanned = scanned;\n        status.indexed = indexed;\n        status.current_path = current_path.clone();\n        status.message = if permission_errors > 0 {\n            Some(format!(\n                \"{} permission/access error(s) occurred.\",\n                permission_errors\n            ))\n        } else {\n            None\n        };\n    }\n    emit_index_progress(app, scanned, indexed, current_path);\n    emit_index_updated(app, entries_count, updated_at, permission_errors);\n    emit_index_state(\n        app,\n        \"Ready\",\n        if permission_errors > 0 {\n            Some(format!(\"{} permission/access error(s)\", permission_errors))\n        } else {\n            None\n        },\n    );\n    perf_log(format!(\n        \"index_state=Ready scanned={} indexed={} deleted={} entries={} permission_errors={}\",\n        scanned, indexed, deleted_count, entries_count, permission_errors\n    ));\n\n    Ok(())\n}\n\nfn trim_recent_ops(ops: &mut Vec<RecentOp>) {\n    let now = Instant::now();\n    ops.retain(|op| now.duration_since(op.at) <= RECENT_OP_TTL);\n}\n\nfn remember_op(\n    state: &AppState,\n    op_type: &'static str,\n    old_path: Option<String>,\n    new_path: Option<String>,\n) {\n    let mut ops = state.recent_ops.lock();\n    trim_recent_ops(&mut ops);\n    ops.push(RecentOp {\n        old_path,\n        new_path,\n        op_type,\n        at: Instant::now(),\n    });\n}\n","numLines":100,"startLine":2340,"totalLines":5753}},"sourceToolAssistantUUID":"b5cb25d2-22fb-4394-8203-278f989baaa5"}
{"parentUuid":"ed6d92e2-9d98-4d76-869f-822c035c29b7","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01NXNMwoUdiEks4gBpgCW97N","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Now I have a clear picture of the entire flow. Let me plan the changes:\n\n**Changes to make:**\n\n1. **`reset_index`**: Add `synchronous=OFF` before the DELETE to speed it up. The connection is dropped immediately after, so restoring is not needed.\n\n2. **`set_indexing_pragmas`**: Change `synchronous = NORMAL` to `synchronous = OFF`. This eliminates fsync per commit during all indexing, which can be significant with many batches.\n\n3. **`run_incremental_index_inner`**: For fresh index (is_fresh):\n   - Drop 4 secondary indexes BEFORE the main walk (inserts don't need to maintain indexes)\n   - Recreate them AFTER all inserts complete (before final status emit)\n\n4. **Batch size for fresh index**: Use a larger batch when is_fresh.\n\nNow I need to examine the walk loop more carefully to identify exactly where the BATCH_SIZE comparisons happen and how to implement these changes.","signature":"EqIICkYICxgCKkAP3yhmyM+Yk4+UEBL4z8pQBayqlvhKmSBAenIM0Fay9QZlU+UvdomeG7fj4ujgw2ofPZhfKBe/OhtqBQBpTjVKEgzNRlF2O9tmXE3HojcaDLtgxQu9p4xuuBN8CSIwheD7N3i4/OqeVHbFk66+tV3l1YJgsto+F+8h4pBgTyggt9aY5PJzTFUPgJHs2urlKokHIkkPyJSrohzPeZFnBMKhjEdZJevACGUlhreA5qCuweeMWG/x0w6tItbVaAtsPb6Au1Ud/A/uHCag1JNGSDrlYO/mVi3idAslPhLaf19dsp1JjEJVke1FE6uNSLKNa6mHfxBMBH7WoKD0VijPRmV6JheGmNTVHmQIZwY66BY8s8ppuBvIN27HJi6GnDexTonTQE8ZipcMtHv2RtdvSMdwKqNikYgHJhgecWKAo/TjBvZEBrOSXLPoz6XjqpVMwdo+K4JRFIo8aKqSYU10EQuCGfM+EhXPjKempxKP0bnKliT2dUP/0I2ZvmpuxOWTws+y/WOLl6ukDJm6XAO/ZI/8yQ3GpvoI8ESwsXYijJLpqIBJA5LL7/qE25aGpClUxsrWG9Uoi8rUsFeF77DUuwPm2i947wftunnB0HIQvIdkauziyUQtrpiSMLTkGNJdxbEoaM+oUWhtwszJULJEqMbt7weZVeYpK8HgYOBQSRO8ohqTUIrkVRbc1Y7DDRpn8Sfhzw4hKTnK9niJW9vKsx63lWHCQdK5DyRn5x1eQu8RDO4E028nI/QhPDJ6/8D59UazAfyQpoAeFDd2vTdqu/ZN78NX5TdiakGny79IbxvVlVABWH8ThWBCyh5g1F2hJxt91DveVwnBNx+/gtUsiOFZ1FashI869x8RRgJpjs8zZP4NK7gMRfgTD2n+9QnHHLNt3V9rdHdYhF1pZCaMJDTvMxtJaQi/153hqDmCBfexsQRtu69iuBE7rrHQlbdp8Zuf4n0g8DSpw0xbrTFxB2bPnkzJCpZ9jX0i94Yg/VWM7Hy4c03yNRjNyAkjH/KQ6qYmupXV9SLHNGXnGkklEIN0DcuVOGPpfNy7WA8xCv3QDp/CZEkYcMxaPbvJKouHFgKXb6e6QIEFyCqa7jEhXaHuDC+usfSdAy71T+MNFDROVnelDboToqwR3I3rxM2wS6gMcd5jAfRSDtvefLcGlfwP6w9M0bUQNlFqCIFvaxKF7KgwIgfcq+yYPqDLLHUtxpTXAdh3hamkIxseCXTUw1tcnE//jbvEZoJhC24O5aHl9OWSGpD9ImR7T1nxozHaZzN/CApy45y/ot+9meIC1RgZjQm+uO5IyKOobgK4o7BfQfdVNUjr5L/MC7avhEsysUF9SltEsSYwRhMzDOkrJjVyYRU7PxSycGmu1z+X4JZcLD5jgkrvCJWZlb4YAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":5375,"cache_read_input_tokens":142442,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":5375},"output_tokens":10,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNikBUBA6qyXr1TnraEU","type":"assistant","uuid":"548f82ea-a394-4e43-b9f0-1993d3cf6a56","timestamp":"2026-02-22T07:34:14.996Z"}
{"parentUuid":"548f82ea-a394-4e43-b9f0-1993d3cf6a56","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01NXNMwoUdiEks4gBpgCW97N","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01C1Q78xW3Uxhxh8WxtboYpu","name":"Read","input":{"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","offset":2230,"limit":110},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":5375,"cache_read_input_tokens":142442,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":5375},"output_tokens":10,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNikBUBA6qyXr1TnraEU","type":"assistant","uuid":"0b79b7f4-49d2-4aa6-b4f6-3de342783985","timestamp":"2026-02-22T07:34:15.136Z"}
{"parentUuid":"0b79b7f4-49d2-4aa6-b4f6-3de342783985","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01C1Q78xW3Uxhxh8WxtboYpu","toolUseID":"toolu_01C1Q78xW3Uxhxh8WxtboYpu","timestamp":"2026-02-22T07:34:15.176Z","uuid":"44adfca9-39e1-4782-bf1c-11372ec5d459"}
{"parentUuid":"0b79b7f4-49d2-4aa6-b4f6-3de342783985","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01C1Q78xW3Uxhxh8WxtboYpu","type":"tool_result","content":"  2230â†’\n  2231â†’                        if let Some(mut row) = index_row_from_jwalk_entry(&entry) {\n  2232â†’                            row.run_id = current_run_id;\n  2233â†’                            if is_fresh {\n  2234â†’                                // Fresh index: all entries are new, skip existing check\n  2235â†’                                indexed += 1;\n  2236â†’                                root_indexed += 1;\n  2237â†’                                batch.push(row);\n  2238â†’                            } else if let Some((old_mtime, old_size)) = existing.get(&row.path) {\n  2239â†’                                if *old_mtime == row.mtime && *old_size == row.size {\n  2240â†’                                    stamp_batch.push(row.path);\n  2241â†’                                } else {\n  2242â†’                                    indexed += 1;\n  2243â†’                                    root_indexed += 1;\n  2244â†’                                    batch.push(row);\n  2245â†’                                }\n  2246â†’                            } else {\n  2247â†’                                indexed += 1;\n  2248â†’                                root_indexed += 1;\n  2249â†’                                batch.push(row);\n  2250â†’                            }\n  2251â†’                        }\n  2252â†’\n  2253â†’                        if batch.len() >= BATCH_SIZE {\n  2254â†’                            upsert_rows(conn, &batch)?;\n  2255â†’                            batch.clear();\n  2256â†’                        }\n  2257â†’\n  2258â†’                        if stamp_batch.len() >= BATCH_SIZE {\n  2259â†’                            stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n  2260â†’                            stamp_batch.clear();\n  2261â†’                        }\n  2262â†’\n  2263â†’                        if last_emit.elapsed() >= Duration::from_millis(200) {\n  2264â†’                            set_progress(state, scanned, indexed, &current_path);\n  2265â†’                            emit_index_progress(app, scanned, indexed, current_path.clone());\n  2266â†’                            last_emit = Instant::now();\n  2267â†’                        }\n  2268â†’                        if perf_log_enabled() && last_perf_emit.elapsed() >= Duration::from_secs(1)\n  2269â†’                        {\n  2270â†’                            perf_log(format!(\n  2271â†’                                \"index_progress pass={} scanned={} indexed={} current_path={}\",\n  2272â†’                                pass_label, scanned, indexed, current_path\n  2273â†’                            ));\n  2274â†’                            last_perf_emit = Instant::now();\n  2275â†’                        }\n  2276â†’                    }\n  2277â†’                    Err(err) => {\n  2278â†’                        scanned += 1;\n  2279â†’                        root_scanned += 1;\n  2280â†’                        permission_errors += 1;\n  2281â†’                        root_permission_errors += 1;\n  2282â†’                        if permission_errors <= 20 || perf_log_enabled() {\n  2283â†’                            eprintln!(\"[index] permission error: {}\", err);\n  2284â†’                        }\n  2285â†’                    }\n  2286â†’                }\n  2287â†’            }\n  2288â†’\n  2289â†’            pass_scanned += root_scanned;\n  2290â†’            pass_indexed += root_indexed;\n  2291â†’\n  2292â†’            eprintln!(\"[timing]   walk_{} {} {}ms scanned={} indexed={} err={}\",\n  2293â†’                pass_label, root_str, root_started.elapsed().as_millis(),\n  2294â†’                root_scanned, root_indexed, root_permission_errors);\n  2295â†’            perf_log(format!(\n  2296â†’                \"index_root_done pass={} root={} elapsed_ms={} scanned={} indexed={} permission_errors={}\",\n  2297â†’                pass_label,\n  2298â†’                root.to_string_lossy(),\n  2299â†’                root_started.elapsed().as_millis(),\n  2300â†’                root_scanned,\n  2301â†’                root_indexed,\n  2302â†’                root_permission_errors,\n  2303â†’            ));\n  2304â†’        }\n  2305â†’\n  2306â†’        // Flush between passes\n  2307â†’        if !batch.is_empty() {\n  2308â†’            upsert_rows(conn, &batch)?;\n  2309â†’            batch.clear();\n  2310â†’        }\n  2311â†’        if !stamp_batch.is_empty() {\n  2312â†’            stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n  2313â†’            stamp_batch.clear();\n  2314â†’        }\n  2315â†’\n  2316â†’        perf_log(format!(\n  2317â†’            \"index_pass_done pass={} elapsed_ms={} scanned={} indexed={}\",\n  2318â†’            pass_label,\n  2319â†’            pass_started.elapsed().as_millis(),\n  2320â†’            pass_scanned,\n  2321â†’            pass_indexed,\n  2322â†’        ));\n  2323â†’\n  2324â†’        // After shallow pass (incremental only), emit progress so UI shows searchable state early\n  2325â†’        // Fresh index uses per-root emit above instead.\n  2326â†’        if pass == 0 && !is_fresh {\n  2327â†’            let _ = refresh_and_emit_status_counts(app, state);\n  2328â†’            let _ = app.emit(\n  2329â†’                \"index_updated\",\n  2330â†’                IndexUpdatedEvent {\n  2331â†’                    entries_count: state.status.lock().entries_count,\n  2332â†’                    last_updated: now_epoch(),\n  2333â†’                    permission_errors,\n  2334â†’                },\n  2335â†’            );\n  2336â†’        }\n  2337â†’    }\n  2338â†’\n  2339â†’    if !batch.is_empty() {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"5af5ab68-3bac-4b2b-950d-0ee8526d80d6","timestamp":"2026-02-22T07:34:15.175Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src-tauri/src/main.rs","content":"\n                        if let Some(mut row) = index_row_from_jwalk_entry(&entry) {\n                            row.run_id = current_run_id;\n                            if is_fresh {\n                                // Fresh index: all entries are new, skip existing check\n                                indexed += 1;\n                                root_indexed += 1;\n                                batch.push(row);\n                            } else if let Some((old_mtime, old_size)) = existing.get(&row.path) {\n                                if *old_mtime == row.mtime && *old_size == row.size {\n                                    stamp_batch.push(row.path);\n                                } else {\n                                    indexed += 1;\n                                    root_indexed += 1;\n                                    batch.push(row);\n                                }\n                            } else {\n                                indexed += 1;\n                                root_indexed += 1;\n                                batch.push(row);\n                            }\n                        }\n\n                        if batch.len() >= BATCH_SIZE {\n                            upsert_rows(conn, &batch)?;\n                            batch.clear();\n                        }\n\n                        if stamp_batch.len() >= BATCH_SIZE {\n                            stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n                            stamp_batch.clear();\n                        }\n\n                        if last_emit.elapsed() >= Duration::from_millis(200) {\n                            set_progress(state, scanned, indexed, &current_path);\n                            emit_index_progress(app, scanned, indexed, current_path.clone());\n                            last_emit = Instant::now();\n                        }\n                        if perf_log_enabled() && last_perf_emit.elapsed() >= Duration::from_secs(1)\n                        {\n                            perf_log(format!(\n                                \"index_progress pass={} scanned={} indexed={} current_path={}\",\n                                pass_label, scanned, indexed, current_path\n                            ));\n                            last_perf_emit = Instant::now();\n                        }\n                    }\n                    Err(err) => {\n                        scanned += 1;\n                        root_scanned += 1;\n                        permission_errors += 1;\n                        root_permission_errors += 1;\n                        if permission_errors <= 20 || perf_log_enabled() {\n                            eprintln!(\"[index] permission error: {}\", err);\n                        }\n                    }\n                }\n            }\n\n            pass_scanned += root_scanned;\n            pass_indexed += root_indexed;\n\n            eprintln!(\"[timing]   walk_{} {} {}ms scanned={} indexed={} err={}\",\n                pass_label, root_str, root_started.elapsed().as_millis(),\n                root_scanned, root_indexed, root_permission_errors);\n            perf_log(format!(\n                \"index_root_done pass={} root={} elapsed_ms={} scanned={} indexed={} permission_errors={}\",\n                pass_label,\n                root.to_string_lossy(),\n                root_started.elapsed().as_millis(),\n                root_scanned,\n                root_indexed,\n                root_permission_errors,\n            ));\n        }\n\n        // Flush between passes\n        if !batch.is_empty() {\n            upsert_rows(conn, &batch)?;\n            batch.clear();\n        }\n        if !stamp_batch.is_empty() {\n            stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n            stamp_batch.clear();\n        }\n\n        perf_log(format!(\n            \"index_pass_done pass={} elapsed_ms={} scanned={} indexed={}\",\n            pass_label,\n            pass_started.elapsed().as_millis(),\n            pass_scanned,\n            pass_indexed,\n        ));\n\n        // After shallow pass (incremental only), emit progress so UI shows searchable state early\n        // Fresh index uses per-root emit above instead.\n        if pass == 0 && !is_fresh {\n            let _ = refresh_and_emit_status_counts(app, state);\n            let _ = app.emit(\n                \"index_updated\",\n                IndexUpdatedEvent {\n                    entries_count: state.status.lock().entries_count,\n                    last_updated: now_epoch(),\n                    permission_errors,\n                },\n            );\n        }\n    }\n\n    if !batch.is_empty() {","numLines":110,"startLine":2230,"totalLines":5753}},"sourceToolAssistantUUID":"0b79b7f4-49d2-4aa6-b4f6-3de342783985"}
{"parentUuid":"5af5ab68-3bac-4b2b-950d-0ee8526d80d6","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_016WNksCxZZj7n1t8hyYi5uJ","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Now I have a complete picture. Let me implement the changes:\n\n**Changes:**\n\n1. **`reset_index`**: Add `PRAGMA synchronous=OFF; PRAGMA cache_size=-131072;` before DELETE. This makes DELETE on a large table much faster. We don't need to restore since we drop the connection.\n\n2. **`set_indexing_pragmas`**: Change `synchronous = NORMAL` to `synchronous = OFF`.\n\n3. **`run_incremental_index_inner`**: \n   - When `is_fresh`: drop 4 secondary indexes right after detecting `is_fresh`\n   - When `is_fresh`: use larger batch (BATCH_SIZE * 5 = 50,000)\n   - After all inserts complete, recreate the 4 indexes before the metadata update, so they're ready before ANALYZE runs in the outer function\n   \n   The cleanest approach is to detect whether we're doing a fresh index in the outer `run_incremental_index` function by checking the `last_run_id` value, then conditionally recreate the indexes right before calling ANALYZE.\n\nI'll drop the secondary indexes upfront if it's a fresh run to speed up bulk inserts, then recreate them afterward once the inner indexing completes successfully.\n\nRecreating indexes...\n\nNow I'm verifying the logic: `is_fresh` gets set based on whether `last_run_id` is 0, and after `reset_index` clears the database including metadata, `get_meta` will return 0, so `is_fresh` will correctly be true in the outer function. I should check if the inner function also uses `is_fresh` to avoid any conflicts. I'm realizing that for a fresh index, the entries table is empty after the reset, so `preload_existing_entries` would just return immediately without needing the indexesâ€”and since there are no preloaded entries, everything goes straight to the batch without any stamp logic. For the batch size, I should use a conditional variable in the inner function to flush more aggressively on fresh indexes.\n\nNow I need to check the order of operations: `is_fresh` gets computed at line 2062, but the batch vectors are initialized at lines 2068-2069, so I need to move those allocations after `is_fresh` is determined so I can use the right capacity. I need to use a conditional variable to set the batch capacity based on whether this is a fresh index run, then apply that same capacity value to the stamp batch flush checks throughout the code.\n\nNow I'm outlining the actual code changes needed: updating the synchronous pragma from NORMAL to OFF in the indexing setup, and adding cache size configuration before the DELETE operations in the reset function.\n\nWriting the implementation... Still writing index logic...","signature":"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"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2009,"cache_read_input_tokens":147817,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2009},"output_tokens":10,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNiksv24J6A9Nh81Ewdn","type":"assistant","uuid":"8cc99b83-3c8f-495a-9b85-a09730c17128","timestamp":"2026-02-22T07:34:58.001Z"}
{"parentUuid":"8cc99b83-3c8f-495a-9b85-a09730c17128","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_016WNksCxZZj7n1t8hyYi5uJ","type":"message","role":"assistant","content":[{"type":"text","text":"3ã¤ã®ãƒœãƒˆãƒ«ãƒãƒƒã‚¯ã‚’ç¢ºèªã—ã¾ã—ãŸ:\n1. `reset_index`ì˜ `DELETE FROM entries` â€” ìˆ˜ì‹­ë§Œ í–‰ì„ WALì— ê¸°ë¡í•˜ë©° ëŠë¦¼\n2. `synchronous=NORMAL` â€” ë°°ì¹˜ë§ˆë‹¤ fsync ëŒ€ê¸°\n3. ìƒˆ ì¸ë±ìŠ¤ ì‚½ìž… ì‹œ 4ê°œì˜ secondary indexê°€ ë§¤ rowë§ˆë‹¤ ê°±ì‹ \n\nì´ ì„¸ ê°€ì§€ë¥¼ ìˆ˜ì •í•©ë‹ˆë‹¤."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2009,"cache_read_input_tokens":147817,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2009},"output_tokens":10,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNiksv24J6A9Nh81Ewdn","type":"assistant","uuid":"c6b0f424-4465-407a-92e7-0b7131644679","timestamp":"2026-02-22T07:35:00.438Z"}
{"type":"file-history-snapshot","messageId":"1b63c29d-e8c3-40c3-9981-f18a4941a0ab","snapshot":{"messageId":"42171a04-0aa4-49b8-9cdb-9a3ff7f5b807","trackedFileBackups":{"src/App.svelte":{"backupFileName":"f2ffc3f5647f6015@v4","version":4,"backupTime":"2026-02-22T07:29:26.391Z"},"src-tauri/src/main.rs":{"backupFileName":"d5d8131157dfe6bc@v1","version":1,"backupTime":"2026-02-22T07:35:03.651Z"}},"timestamp":"2026-02-22T07:29:47.881Z"},"isSnapshotUpdate":true}
{"parentUuid":"c6b0f424-4465-407a-92e7-0b7131644679","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_016WNksCxZZj7n1t8hyYi5uJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Spt8BNjxzec6ZjiMgqayCR","name":"Edit","input":{"replace_all":false,"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","old_string":"pub(crate) fn set_indexing_pragmas(conn: &Connection) -> AppResult<()> {\n    conn.execute_batch(\n        r#\"\n        PRAGMA synchronous = NORMAL;\n        PRAGMA cache_size = -65536;\n        PRAGMA mmap_size = 268435456;\n        PRAGMA wal_autocheckpoint = 10000;\n        \"#,\n    )\n    .map_err(|e| e.to_string())\n}","new_string":"pub(crate) fn set_indexing_pragmas(conn: &Connection) -> AppResult<()> {\n    conn.execute_batch(\n        r#\"\n        PRAGMA synchronous = OFF;\n        PRAGMA cache_size = -131072;\n        PRAGMA mmap_size = 536870912;\n        PRAGMA wal_autocheckpoint = 0;\n        \"#,\n    )\n    .map_err(|e| e.to_string())\n}"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2009,"cache_read_input_tokens":147817,"output_tokens":3142,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":2009,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYNiksv24J6A9Nh81Ewdn","type":"assistant","uuid":"1b63c29d-e8c3-40c3-9981-f18a4941a0ab","timestamp":"2026-02-22T07:35:03.645Z"}
{"parentUuid":"1b63c29d-e8c3-40c3-9981-f18a4941a0ab","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01Spt8BNjxzec6ZjiMgqayCR","toolUseID":"toolu_01Spt8BNjxzec6ZjiMgqayCR","timestamp":"2026-02-22T07:35:03.661Z","uuid":"9d7032e2-7a1e-4561-9f57-0d10d78efb85"}
{"parentUuid":"1b63c29d-e8c3-40c3-9981-f18a4941a0ab","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Spt8BNjxzec6ZjiMgqayCR","type":"tool_result","content":"The file /Users/al02402336/everything/src-tauri/src/main.rs has been updated successfully."}]},"uuid":"166770d0-3426-421f-bf19-81475cb16506","timestamp":"2026-02-22T07:35:03.659Z","toolUseResult":{"filePath":"/Users/al02402336/everything/src-tauri/src/main.rs","oldString":"pub(crate) fn set_indexing_pragmas(conn: &Connection) -> AppResult<()> {\n    conn.execute_batch(\n        r#\"\n        PRAGMA synchronous = NORMAL;\n        PRAGMA cache_size = -65536;\n        PRAGMA mmap_size = 268435456;\n        PRAGMA wal_autocheckpoint = 10000;\n        \"#,\n    )\n    .map_err(|e| e.to_string())\n}","newString":"pub(crate) fn set_indexing_pragmas(conn: &Connection) -> AppResult<()> {\n    conn.execute_batch(\n        r#\"\n        PRAGMA synchronous = OFF;\n        PRAGMA cache_size = -131072;\n        PRAGMA mmap_size = 536870912;\n        PRAGMA wal_autocheckpoint = 0;\n        \"#,\n    )\n    .map_err(|e| e.to_string())\n}","originalFile":"#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\n\nuse std::{\n    cmp::Ordering,\n    collections::{HashMap, HashSet},\n    fs,\n    hash::{Hash, Hasher},\n    io::{self, BufRead, BufReader, Write},\n    path::{Path, PathBuf},\n    process::{Command, Stdio},\n    sync::{\n        atomic::{AtomicBool, Ordering as AtomicOrdering},\n        Arc, OnceLock,\n    },\n    time::{Duration, Instant, SystemTime, UNIX_EPOCH},\n};\n\nuse parking_lot::{Mutex, RwLock};\nuse rusqlite::{params, params_from_iter, types::Value as SqlValue, Connection};\nuse serde::Serialize;\nuse tauri::{AppHandle, Emitter, Manager, State};\n#[cfg(target_os = \"macos\")]\nuse tauri_plugin_global_shortcut::{Code, GlobalShortcutExt, Modifiers, Shortcut};\n#[cfg(target_os = \"windows\")]\nuse std::os::windows::process::CommandExt;\nuse walkdir::WalkDir;\n\nmod fd_search;\nmod gitignore_filter;\n#[cfg(target_os = \"macos\")]\nmod mac;\nmod mem_search;\nmod query;\n#[cfg(target_os = \"windows\")]\nmod win;\nuse fd_search::{FdSearchCache, FdSearchResultDto};\nuse query::{escape_like, parse_query, SearchMode};\n\nconst DEFAULT_LIMIT: u32 = 300;\nconst SHORT_QUERY_LIMIT: u32 = 100;\nconst MAX_LIMIT: u32 = 1000;\npub(crate) const BATCH_SIZE: usize = 10_000;\nconst RECENT_OP_TTL: Duration = Duration::from_secs(2);\npub(crate) const WATCH_DEBOUNCE: Duration = Duration::from_millis(300);\nconst NEGATIVE_CACHE_TTL: Duration = Duration::from_secs(60);\nconst NEGATIVE_CACHE_FALLBACK_WINDOW: Duration = Duration::from_millis(550);\nconst DB_VERSION: i32 = 4;\nconst DEFERRED_DIR_NAMES: &[&str] = &[\n    \"Library\", \".Trash\", \".Trashes\",\n    // Windows system directories (deferred when scan_root is C:\\)\n    \"Windows\", \"Program Files\", \"Program Files (x86)\",\n    \"$Recycle.Bin\", \"System Volume Information\", \"Recovery\", \"PerfLogs\",\n];\nconst SHALLOW_SCAN_DEPTH: usize = 6;\nfn jwalk_num_threads() -> usize {\n    std::thread::available_parallelism()\n        .map(|n| (n.get() / 2).max(4).min(16))\n        .unwrap_or(8)\n}\n\npub(crate) const BUILTIN_SKIP_NAMES: &[&str] = &[\n    \".git\",\n    \"node_modules\",\n    \".Trash\",\n    \".Trashes\",\n    \".npm\",\n    \".cache\",\n    \"CMakeFiles\",\n    \".qtc_clangd\",\n    \"__pycache__\",\n    \".gradle\",\n    \"DerivedData\",\n];\n\n/// Path segments whose name ends with one of these suffixes are skipped.\n/// e.g. \"*.build\" skips Xcode intermediate build directories like \"MyApp.build\".\npub(crate) const BUILTIN_SKIP_SUFFIXES: &[&str] = &[\n    \".build\", // Xcode intermediate build dir (MyApp.build, Objects-normal, etc.)\n];\n\npub(crate) const BUILTIN_SKIP_PATHS: &[&str] = &[\n    // macOS\n    \"Library/Caches\",\n    \"Library/Developer/CoreSimulator\",\n    \"Library/Logs\",\n    // Cross-platform\n    \".vscode/extensions\",\n    // Windows: noisy system directories under AppData\n    \"AppData/Local/Temp\",\n    \"AppData/Local/Microsoft\",\n    \"AppData/Local/Google\",\n    \"AppData/Local/Packages\",\n];\n\ntype AppResult<T> = Result<T, String>;\nstatic SEARCH_LOG_ENABLED: OnceLock<bool> = OnceLock::new();\nstatic PERF_LOG_ENABLED: OnceLock<bool> = OnceLock::new();\nstatic BENCH_MODE_ENABLED: OnceLock<bool> = OnceLock::new();\nstatic STARTUP_T0: OnceLock<Instant> = OnceLock::new();\n\nfn startup_elapsed_ms() -> u128 {\n    STARTUP_T0\n        .get()\n        .map(|started| started.elapsed().as_millis())\n        .unwrap_or(0)\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct EntryDto {\n    pub path: String,\n    pub name: String,\n    pub dir: String,\n    pub is_dir: bool,\n    pub ext: Option<String>,\n    pub size: Option<i64>,\n    pub mtime: Option<i64>,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct IndexStatusDto {\n    state: String,\n    entries_count: u64,\n    last_updated: Option<i64>,\n    permission_errors: u64,\n    message: Option<String>,\n    scanned: u64,\n    indexed: u64,\n    current_path: String,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct IndexProgressEvent {\n    scanned: u64,\n    indexed: u64,\n    current_path: String,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct IndexStateEvent {\n    state: String,\n    message: Option<String>,\n    is_catchup: bool,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct IndexUpdatedEvent {\n    entries_count: u64,\n    last_updated: i64,\n    permission_errors: u64,\n}\n\n#[derive(Debug, Clone)]\nstruct SearchExecution {\n    query: String,\n    sort_by: String,\n    sort_dir: String,\n    effective_limit: u32,\n    offset: u32,\n    mode_label: String,\n    results: Vec<EntryDto>,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct SearchResultDto {\n    entries: Vec<EntryDto>,\n    mode_label: String,\n    /// Total number of results matching the query (ignoring LIMIT/OFFSET).\n    total_count: u32,\n    /// True when total_count is exact. False means frontend should treat it as unknown.\n    total_known: bool,\n}\n\n#[allow(dead_code)]\n#[derive(Debug, Clone)]\nstruct BenchCase {\n    id: &'static str,\n    query: &'static str,\n    sort_by: &'static str,\n    sort_dir: &'static str,\n    limit: u32,\n    offset: u32,\n    expected_min_results: usize,\n}\n\n#[allow(dead_code)]\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct BenchCaseResult {\n    id: String,\n    query: String,\n    mode: String,\n    sort_by: String,\n    sort_dir: String,\n    limit: u32,\n    offset: u32,\n    elapsed_ms: f64,\n    result_count: usize,\n    expected_min_results: usize,\n    passed: bool,\n    top_results: Vec<String>,\n    error: Option<String>,\n}\n\n#[allow(dead_code)]\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct BenchReport {\n    run_label: String,\n    started_at: i64,\n    completed_at: i64,\n    home_dir: String,\n    db_path: String,\n    index_wait_ms: u128,\n    index_scanned: u64,\n    index_indexed: u64,\n    index_entries_count: u64,\n    index_permission_errors: u64,\n    index_message: Option<String>,\n    search_iterations: u32,\n    search_results: Vec<BenchCaseResult>,\n}\n\n#[derive(Debug, Clone)]\npub(crate) enum IndexState {\n    Ready,\n    Indexing,\n    Error,\n}\n\nimpl IndexState {\n    fn as_str(&self) -> &'static str {\n        match self {\n            Self::Ready => \"Ready\",\n            Self::Indexing => \"Indexing\",\n            Self::Error => \"Error\",\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct IndexStatus {\n    pub(crate) state: IndexState,\n    pub(crate) entries_count: u64,\n    pub(crate) last_updated: Option<i64>,\n    pub(crate) permission_errors: u64,\n    pub(crate) message: Option<String>,\n    pub(crate) scanned: u64,\n    pub(crate) indexed: u64,\n    pub(crate) current_path: String,\n}\n\nimpl Default for IndexStatus {\n    fn default() -> Self {\n        Self {\n            state: IndexState::Indexing,\n            entries_count: 0,\n            last_updated: None,\n            permission_errors: 0,\n            message: None,\n            scanned: 0,\n            indexed: 0,\n            current_path: String::new(),\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\n#[allow(dead_code)]\npub(crate) struct RecentOp {\n    old_path: Option<String>,\n    new_path: Option<String>,\n    op_type: &'static str,\n    at: Instant,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub(crate) enum IgnorePattern {\n    AnySegment(String),\n    Glob(String),\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct IgnoreRulesCache {\n    roots: Vec<PathBuf>,\n    patterns: Vec<IgnorePattern>,\n    pathignore_mtime: Option<SystemTime>,\n    gitignore_mtime: Option<SystemTime>,\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct AppState {\n    pub(crate) db_path: PathBuf,\n    pub(crate) home_dir: PathBuf,\n    pub(crate) scan_root: PathBuf,\n    pub(crate) cwd: PathBuf,\n    pub(crate) path_ignores: Arc<Vec<PathBuf>>,\n    pub(crate) path_ignore_patterns: Arc<Vec<IgnorePattern>>,\n    pub(crate) db_ready: Arc<AtomicBool>,\n    pub(crate) indexing_active: Arc<AtomicBool>,\n    pub(crate) status: Arc<Mutex<IndexStatus>>,\n    pub(crate) recent_ops: Arc<Mutex<Vec<RecentOp>>>,\n    pub(crate) icon_cache: Arc<Mutex<HashMap<String, Vec<u8>>>>,\n    pub(crate) fd_search_cache: Arc<Mutex<Option<FdSearchCache>>>,\n    pub(crate) negative_name_cache: Arc<Mutex<HashMap<String, NegativeNameEntry>>>,\n    pub(crate) ignore_cache: Arc<Mutex<Option<IgnoreRulesCache>>>,\n    pub(crate) gitignore: Arc<gitignore_filter::LazyGitignoreFilter>,\n    /// In-memory index for instant search while DB upsert runs in background.\n    /// Set by MFT scan, cleared after background DB upsert completes.\n    pub(crate) mem_index: Arc<RwLock<Option<Arc<mem_search::MemIndex>>>>,\n    /// Signal to stop the file watcher (RDCW / USN). Set to true on reset_index.\n    pub(crate) watcher_stop: Arc<AtomicBool>,\n    /// Set to true while a file watcher event loop is running.\n    pub(crate) watcher_active: Arc<AtomicBool>,\n    /// Set to true once frontend onMount has completed enough to accept user input.\n    pub(crate) frontend_ready: Arc<AtomicBool>,\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct NegativeNameEntry {\n    created_at: Instant,\n    fallback_checked: bool,\n}\n\n#[derive(Debug, Clone)]\nstruct NegativeCacheHit {\n    query_lower: String,\n    age: Duration,\n    fallback_checked: bool,\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct IndexRow {\n    pub(crate) path: String,\n    pub(crate) name: String,\n    pub(crate) dir: String,\n    pub(crate) is_dir: i64,\n    pub(crate) ext: Option<String>,\n    pub(crate) mtime: Option<i64>,\n    pub(crate) size: Option<i64>,\n    pub(crate) indexed_at: i64,\n    pub(crate) run_id: i64,\n}\n\npub(crate) fn now_epoch() -> i64 {\n    SystemTime::now()\n        .duration_since(UNIX_EPOCH)\n        .map(|d| d.as_secs() as i64)\n        .unwrap_or_default()\n}\n\nfn env_truthy(key: &str) -> bool {\n    std::env::var(key)\n        .ok()\n        .map(|value| {\n            matches!(\n                value.trim().to_ascii_lowercase().as_str(),\n                \"1\" | \"true\" | \"yes\" | \"on\"\n            )\n        })\n        .unwrap_or(false)\n}\n\nfn bench_mode_enabled() -> bool {\n    *BENCH_MODE_ENABLED.get_or_init(|| env_truthy(\"EVERYTHING_BENCH\"))\n}\n\nfn perf_log_enabled() -> bool {\n    *PERF_LOG_ENABLED.get_or_init(|| env_truthy(\"FASTFIND_PERF_LOG\") || bench_mode_enabled())\n}\n\npub(crate) fn perf_log(message: impl AsRef<str>) {\n    if perf_log_enabled() {\n        eprintln!(\"[perf] {}\", message.as_ref());\n    }\n}\n\nfn db_connection_with_timeout(db_path: &Path, busy_timeout_ms: u32) -> AppResult<Connection> {\n    let conn = Connection::open(db_path).map_err(|e| e.to_string())?;\n    conn.execute_batch(&format!(\n        r#\"\n        PRAGMA journal_mode=WAL;\n        PRAGMA synchronous=NORMAL;\n        PRAGMA temp_store=MEMORY;\n        PRAGMA busy_timeout={busy_timeout_ms};\n        \"#,\n    ))\n    .map_err(|e| e.to_string())?;\n    Ok(conn)\n}\n\npub(crate) fn db_connection(db_path: &Path) -> AppResult<Connection> {\n    db_connection_with_timeout(db_path, 3000)\n}\n\nfn db_connection_for_search(db_path: &Path) -> AppResult<Connection> {\n    let conn = db_connection_with_timeout(db_path, 500)?;\n    conn.execute_batch(\n        \"PRAGMA cache_size = -32768;\n         PRAGMA mmap_size = 268435456;\",\n    )\n    .map_err(|e| e.to_string())?;\n    Ok(conn)\n}\n\npub(crate) fn set_indexing_pragmas(conn: &Connection) -> AppResult<()> {\n    conn.execute_batch(\n        r#\"\n        PRAGMA synchronous = NORMAL;\n        PRAGMA cache_size = -65536;\n        PRAGMA mmap_size = 268435456;\n        PRAGMA wal_autocheckpoint = 10000;\n        \"#,\n    )\n    .map_err(|e| e.to_string())\n}\n\npub(crate) fn restore_normal_pragmas(conn: &Connection) -> AppResult<()> {\n    conn.execute_batch(\n        r#\"\n        PRAGMA synchronous = NORMAL;\n        PRAGMA cache_size = -16384;\n        PRAGMA mmap_size = 268435456;\n        PRAGMA wal_autocheckpoint = 1000;\n        \"#,\n    )\n    .map_err(|e| e.to_string())?;\n    conn.execute_batch(\"PRAGMA wal_checkpoint(TRUNCATE);\")\n        .map_err(|e| e.to_string())?;\n    Ok(())\n}\n\nfn init_db(db_path: &Path) -> AppResult<()> {\n    let t = Instant::now();\n    let conn = db_connection(db_path)?;\n    eprintln!(\"[init_db] +{}ms db_connection opened\", t.elapsed().as_millis());\n\n    let current_version: i32 = conn\n        .query_row(\"PRAGMA user_version\", [], |row| row.get(0))\n        .unwrap_or(0);\n    if current_version != DB_VERSION {\n        conn.execute_batch(\n            r#\"\n            DROP TRIGGER IF EXISTS entries_ai;\n            DROP TRIGGER IF EXISTS entries_ad;\n            DROP TRIGGER IF EXISTS entries_au;\n            DROP TABLE IF EXISTS entries_fts;\n            DROP TABLE IF EXISTS entries;\n            \"#,\n        )\n        .map_err(|e| e.to_string())?;\n        conn.execute_batch(&format!(\"PRAGMA user_version = {};\", DB_VERSION))\n            .map_err(|e| e.to_string())?;\n    }\n    eprintln!(\"[init_db] +{}ms version check done (v={})\", t.elapsed().as_millis(), current_version);\n\n    conn.execute_batch(\n        r#\"\n        CREATE TABLE IF NOT EXISTS entries (\n          id INTEGER PRIMARY KEY,\n          path TEXT NOT NULL UNIQUE,\n          name TEXT NOT NULL,\n          dir TEXT NOT NULL,\n          is_dir INTEGER NOT NULL,\n          ext TEXT,\n          mtime INTEGER,\n          size INTEGER,\n          indexed_at INTEGER NOT NULL,\n          run_id INTEGER NOT NULL DEFAULT 0\n        );\n\n        CREATE INDEX IF NOT EXISTS idx_entries_dir_ext_name_nocase ON entries(dir, ext, name COLLATE NOCASE);\n        CREATE INDEX IF NOT EXISTS idx_entries_mtime ON entries(mtime);\n        CREATE INDEX IF NOT EXISTS idx_entries_name_nocase ON entries(name COLLATE NOCASE);\n        CREATE INDEX IF NOT EXISTS idx_entries_ext_name ON entries(ext, name COLLATE NOCASE);\n\n        CREATE TABLE IF NOT EXISTS meta (\n          key TEXT PRIMARY KEY,\n          value TEXT NOT NULL\n        );\n        \"#,\n    )\n    .map_err(|e| e.to_string())?;\n    eprintln!(\"[init_db] +{}ms schema ensured\", t.elapsed().as_millis());\n\n    let legacy_index_migration_key = \"migration_drop_idx_entries_dir_name_nocase_v1\";\n    let migrated = get_meta(&conn, legacy_index_migration_key)\n        .map(|v| v == \"1\")\n        .unwrap_or(false);\n    if !migrated {\n        conn.execute_batch(\"DROP INDEX IF EXISTS idx_entries_dir_name_nocase;\")\n            .map_err(|e| e.to_string())?;\n        set_meta(&conn, legacy_index_migration_key, \"1\")?;\n    }\n    eprintln!(\"[init_db] +{}ms total\", t.elapsed().as_millis());\n\n    Ok(())\n}\n\npub(crate) fn get_meta(conn: &Connection, key: &str) -> Option<String> {\n    conn.query_row(\n        \"SELECT value FROM meta WHERE key = ?1\",\n        params![key],\n        |row| row.get(0),\n    )\n    .ok()\n}\n\npub(crate) fn set_meta(conn: &Connection, key: &str, value: &str) -> AppResult<()> {\n    conn.execute(\n        \"INSERT OR REPLACE INTO meta(key, value) VALUES(?1, ?2)\",\n        params![key, value],\n    )\n    .map_err(|e| e.to_string())?;\n    Ok(())\n}\n\nfn update_counts(state: &AppState) -> AppResult<(u64, Option<i64>)> {\n    let conn = db_connection(&state.db_path)?;\n\n    let entries_count = conn\n        .query_row(\"SELECT COUNT(*) FROM entries\", [], |row| {\n            row.get::<_, i64>(0)\n        })\n        .map_err(|e| e.to_string())?\n        .max(0) as u64;\n\n    let last_updated = conn\n        .query_row(\"SELECT MAX(indexed_at) FROM entries\", [], |row| {\n            row.get::<_, Option<i64>>(0)\n        })\n        .map_err(|e| e.to_string())?;\n\n    Ok((entries_count, last_updated))\n}\n\npub(crate) fn update_status_counts(state: &AppState) -> AppResult<(u64, Option<i64>)> {\n    let (entries_count, last_updated) = update_counts(state)?;\n    let mut status = state.status.lock();\n    status.entries_count = entries_count;\n    status.last_updated = last_updated;\n    Ok((entries_count, last_updated))\n}\n\npub(crate) fn invalidate_search_caches(state: &AppState) {\n    state.fd_search_cache.lock().take();\n    state.negative_name_cache.lock().clear();\n}\n\nfn prune_negative_name_cache(cache: &mut HashMap<String, NegativeNameEntry>) {\n    let now = Instant::now();\n    cache.retain(|_, entry| now.duration_since(entry.created_at) <= NEGATIVE_CACHE_TTL);\n}\n\nfn negative_name_cache_lookup(state: &AppState, query: &str) -> Option<NegativeCacheHit> {\n    if query.is_empty() {\n        return None;\n    }\n    let q = query.to_lowercase();\n    let now = Instant::now();\n    let mut cache = state.negative_name_cache.lock();\n    prune_negative_name_cache(&mut cache);\n    cache\n        .iter()\n        .filter(|(key, _)| q.contains(key.as_str()))\n        .max_by_key(|(key, _)| key.len())\n        .map(|(key, entry)| NegativeCacheHit {\n            query_lower: key.clone(),\n            age: now.duration_since(entry.created_at),\n            fallback_checked: entry.fallback_checked,\n        })\n}\n\nfn remember_negative_name_query(state: &AppState, query: &str) {\n    if query.is_empty() {\n        return;\n    }\n    let normalized = query.to_lowercase();\n    let mut cache = state.negative_name_cache.lock();\n    prune_negative_name_cache(&mut cache);\n\n    if cache.contains_key(&normalized) {\n        return;\n    }\n\n    cache.insert(\n        normalized,\n        NegativeNameEntry {\n            created_at: Instant::now(),\n            fallback_checked: false,\n        },\n    );\n    const MAX_NEGATIVE_CACHE: usize = 512;\n    if cache.len() > MAX_NEGATIVE_CACHE {\n        let mut entries: Vec<_> =\n            cache.iter().map(|(k, v)| (k.clone(), v.created_at)).collect();\n        entries.sort_by_key(|(_, t)| *t);\n        let drop_count = cache.len() - MAX_NEGATIVE_CACHE;\n        for (key, _) in entries.into_iter().take(drop_count) {\n            cache.remove(&key);\n        }\n    }\n}\n\nfn remove_negative_name_query(state: &AppState, query: &str) {\n    if query.is_empty() {\n        return;\n    }\n    let normalized = query.to_lowercase();\n    state.negative_name_cache.lock().remove(&normalized);\n}\n\nfn mark_negative_name_fallback_checked(state: &AppState, query_lower: &str) {\n    let mut cache = state.negative_name_cache.lock();\n    if let Some(entry) = cache.get_mut(query_lower) {\n        entry.fallback_checked = true;\n    }\n}\n\nfn sort_clause(sort_by: &str, sort_dir: &str, prefix: &str) -> String {\n    match (sort_by, sort_dir) {\n        (\"name\", \"desc\") => {\n            format!(\"{prefix}name COLLATE NOCASE DESC, {prefix}path COLLATE NOCASE DESC\")\n        }\n        (\"mtime\", \"asc\") => {\n            format!(\"COALESCE({prefix}mtime, 0) ASC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        (\"mtime\", \"desc\") => {\n            format!(\"COALESCE({prefix}mtime, 0) DESC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        (\"dir\", \"asc\") => {\n            format!(\"{prefix}dir COLLATE NOCASE ASC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        (\"dir\", \"desc\") => {\n            format!(\"{prefix}dir COLLATE NOCASE DESC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        (\"size\", \"asc\") => {\n            format!(\"{prefix}size IS NULL ASC, {prefix}size ASC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        (\"size\", \"desc\") => {\n            format!(\"{prefix}size IS NULL ASC, {prefix}size DESC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        _ => format!(\"{prefix}name COLLATE NOCASE ASC, {prefix}path COLLATE NOCASE ASC\"),\n    }\n}\n\nfn contains_glob_meta(s: &str) -> bool {\n    s.contains('*') || s.contains('?')\n}\n\n/// Detect if a LIKE pattern is a pure extension filter (e.g. `%.rs`).\n/// Returns the lowercase extension if matched, None otherwise.\nfn extract_ext_from_like(like_pattern: &str) -> Option<String> {\n    let rest = like_pattern.strip_prefix('%')?;\n    let ext = rest.strip_prefix('.')?;\n    if ext.is_empty()\n        || ext.contains('%')\n        || ext.contains('_')\n        || ext.contains('\\\\')\n        || ext.contains('/')\n        || ext.contains('.')\n    {\n        return None;\n    }\n    Some(ext.to_lowercase())\n}\n\nfn normalize_hint_to_native(dir_hint: &str) -> (String, bool) {\n    let native = dir_hint.replace('/', &std::path::MAIN_SEPARATOR.to_string());\n    let is_abs = Path::new(&native).is_absolute();\n    (native, is_abs)\n}\n\nfn last_segment(dir_hint: &str) -> &str {\n    dir_hint\n        .rsplit(|c| c == '/' || c == '\\\\')\n        .find(|seg| !seg.is_empty())\n        .unwrap_or(dir_hint)\n}\n\nfn resolve_dir_hint(home_dir: &Path, dir_hint: &str) -> Option<PathBuf> {\n    if dir_hint.is_empty() || contains_glob_meta(dir_hint) {\n        return None;\n    }\n\n    let candidate = if dir_hint == \"~\" {\n        home_dir.to_path_buf()\n    } else if let Some(rest) = dir_hint.strip_prefix(\"~/\") {\n        home_dir.join(rest)\n    } else {\n        let (native_hint, is_absolute) = normalize_hint_to_native(dir_hint);\n        if is_absolute {\n            PathBuf::from(native_hint)\n        } else {\n            home_dir.join(native_hint)\n        }\n    };\n\n    if candidate.is_dir() {\n        Some(candidate)\n    } else {\n        None\n    }\n}\n\nconst RESOLVE_DIRS_MAX: usize = 20;\n\nfn resolve_dirs_from_db(conn: &Connection, dir_hint: &str) -> Vec<String> {\n    if dir_hint.is_empty() || contains_glob_meta(dir_hint) {\n        return Vec::new();\n    }\n    let last_seg = last_segment(dir_hint);\n    let sep = std::path::MAIN_SEPARATOR;\n    let (native_hint, is_absolute) = normalize_hint_to_native(dir_hint);\n    let sep_str = sep.to_string();\n    let escaped_sep = escape_like(&sep_str);\n    let path_pattern = if is_absolute {\n        format!(\"%{}\", escape_like(&native_hint))\n    } else {\n        format!(\"%{escaped_sep}{}\", escape_like(&native_hint))\n    };\n    let fetch_limit = (RESOLVE_DIRS_MAX + 1) as i64;\n    let mut stmt = match conn.prepare(\n        \"SELECT path FROM entries WHERE name = ?1 COLLATE NOCASE AND is_dir = 1 AND path LIKE ?2 ESCAPE '\\\\' LIMIT ?3\",\n    ) {\n        Ok(s) => s,\n        Err(_) => return Vec::new(),\n    };\n    let rows = match stmt.query_map(params![last_seg, path_pattern, fetch_limit], |row| {\n        row.get::<_, String>(0)\n    }) {\n        Ok(r) => r,\n        Err(_) => return Vec::new(),\n    };\n    let dirs: Vec<String> = rows.filter_map(|r| r.ok()).collect();\n    if dirs.len() > RESOLVE_DIRS_MAX {\n        return Vec::new();\n    }\n    dirs\n}\n\nfn normalize_slashes(s: String) -> String {\n    s.replace('\\\\', \"/\")\n}\n\nfn resolve_ignore_path(raw: &str, base_dir: &Path, home_dir: &Path) -> Option<PathBuf> {\n    let trimmed = raw.trim();\n    if trimmed.is_empty() || trimmed.starts_with('#') || trimmed.starts_with('!') {\n        return None;\n    }\n\n    let mut path = if trimmed == \"~\" {\n        home_dir.to_path_buf()\n    } else if let Some(rest) = trimmed.strip_prefix(\"~/\") {\n        home_dir.join(rest)\n    } else {\n        PathBuf::from(trimmed)\n    };\n\n    if !path.is_absolute() {\n        path = base_dir.join(path);\n    }\n\n    Some(fs::canonicalize(&path).unwrap_or(path))\n}\n\nfn normalize_ignore_pattern(raw: &str, base_dir: &Path, home_dir: &Path) -> String {\n    let trimmed = raw.trim().trim_end_matches('/').to_string();\n    if trimmed == \"~\" {\n        return normalize_slashes(home_dir.to_string_lossy().to_string());\n    }\n    if let Some(rest) = trimmed.strip_prefix(\"~/\") {\n        return normalize_slashes(home_dir.join(rest).to_string_lossy().to_string());\n    }\n    if trimmed.starts_with('/') || trimmed.starts_with(\"**/\") {\n        return trimmed;\n    }\n    normalize_slashes(base_dir.join(&trimmed).to_string_lossy().to_string())\n}\n\nfn parse_ignore_pattern(raw: &str, base_dir: &Path, home_dir: &Path) -> Option<IgnorePattern> {\n    let trimmed = raw.trim().trim_end_matches('/');\n    if trimmed.is_empty() {\n        return None;\n    }\n\n    if let Some(segment) = trimmed.strip_prefix(\"**/\") {\n        if !segment.is_empty() && !segment.contains('/') && !contains_glob_meta(segment) {\n            return Some(IgnorePattern::AnySegment(segment.to_string()));\n        }\n    }\n\n    Some(IgnorePattern::Glob(normalize_ignore_pattern(\n        trimmed, base_dir, home_dir,\n    )))\n}\n\nfn ignore_pattern_key(pattern: &IgnorePattern) -> String {\n    match pattern {\n        IgnorePattern::AnySegment(segment) => format!(\"seg:{segment}\"),\n        IgnorePattern::Glob(glob) => format!(\"glob:{glob}\"),\n    }\n}\n\nfn find_file_upward(start: &Path, file_name: &str) -> Option<PathBuf> {\n    let mut current = Some(start);\n    while let Some(dir) = current {\n        let candidate = dir.join(file_name);\n        if candidate.is_file() {\n            return Some(candidate);\n        }\n        current = dir.parent();\n    }\n    None\n}\n\nfn find_git_root(start: &Path) -> Option<PathBuf> {\n    let mut current = Some(start);\n    while let Some(dir) = current {\n        let marker = dir.join(\".git\");\n        if marker.is_dir() || marker.is_file() {\n            return Some(dir.to_path_buf());\n        }\n        current = dir.parent();\n    }\n    None\n}\n\nfn load_pathignore_rules(home_dir: &Path, cwd: &Path) -> (Vec<PathBuf>, Vec<IgnorePattern>) {\n    let mut files = Vec::new();\n    if let Some(file) = find_file_upward(cwd, \".pathignore\") {\n        files.push(file);\n    } else {\n        files.push(cwd.join(\".pathignore\"));\n    }\n    let home_file = home_dir.join(\".pathignore\");\n    if !files.iter().any(|p| p == &home_file) {\n        files.push(home_file);\n    }\n\n    let mut roots = Vec::new();\n    let mut patterns = Vec::new();\n    let mut seen_roots = HashSet::new();\n    let mut seen_patterns = HashSet::new();\n\n    for file in files {\n        let Ok(contents) = fs::read_to_string(&file) else {\n            continue;\n        };\n        let base_dir = file.parent().unwrap_or_else(|| Path::new(\"/\"));\n        for line in contents.lines() {\n            let trimmed = line.trim();\n            if trimmed.is_empty() || trimmed.starts_with('#') || trimmed.starts_with('!') {\n                continue;\n            }\n\n            if contains_glob_meta(trimmed) {\n                let Some(pattern) = parse_ignore_pattern(trimmed, base_dir, home_dir) else {\n                    continue;\n                };\n                let key = ignore_pattern_key(&pattern);\n                if seen_patterns.insert(key) {\n                    patterns.push(pattern);\n                }\n                continue;\n            }\n\n            let Some(path) = resolve_ignore_path(trimmed, base_dir, home_dir) else {\n                continue;\n            };\n\n            let key = path.to_string_lossy().to_string();\n            if seen_roots.insert(key) {\n                roots.push(path);\n            }\n        }\n    }\n\n    (roots, patterns)\n}\n\nfn load_gitignore_roots(home_dir: &Path, cwd: &Path) -> Vec<PathBuf> {\n    let gitignore = if let Some(root) = find_git_root(cwd) {\n        root.join(\".gitignore\")\n    } else if let Some(file) = find_file_upward(&cwd, \".gitignore\") {\n        file\n    } else {\n        return Vec::new();\n    };\n    let contents = match fs::read_to_string(&gitignore) {\n        Ok(contents) => contents,\n        Err(_) => return Vec::new(),\n    };\n\n    let mut roots = Vec::new();\n    let mut seen = HashSet::new();\n\n    for line in contents.lines() {\n        let trimmed = line.trim();\n        if trimmed.is_empty() || trimmed.starts_with('#') || trimmed.starts_with('!') {\n            continue;\n        }\n        if contains_glob_meta(trimmed) || trimmed.contains('[') {\n            continue;\n        }\n\n        let normalized = trimmed.trim_start_matches('/').trim_end_matches('/');\n        if normalized.is_empty() {\n            continue;\n        }\n\n        let Some(path) = resolve_ignore_path(normalized, &cwd, home_dir) else {\n            continue;\n        };\n\n        let key = path.to_string_lossy().to_string();\n        if seen.insert(key) {\n            roots.push(path);\n        }\n    }\n\n    roots\n}\n\n#[cfg(target_os = \"macos\")]\nfn macos_tcc_ignore_roots(home_dir: &Path) -> Vec<PathBuf> {\n    let library = home_dir.join(\"Library\");\n    let app_support = library.join(\"Application Support\");\n    let caches = library.join(\"Caches\");\n\n    let dirs: Vec<PathBuf> = vec![\n        home_dir.join(\".Trash\"),\n        library.join(\"Accounts\"),\n        library.join(\"AppleMediaServices\"),\n        library.join(\"Assistant\").join(\"SiriVocabulary\"),\n        library.join(\"Autosave Information\"),\n        library.join(\"Biome\"),\n        library.join(\"Calendars\"),\n        library.join(\"com.apple.aiml.instrumentation\"),\n        library.join(\"ContainerManager\"),\n        library.join(\"Cookies\"),\n        library.join(\"CoreFollowUp\"),\n        library.join(\"Daemon Containers\"),\n        library.join(\"DoNotDisturb\"),\n        library.join(\"DuetExpertCenter\"),\n        library.join(\"Group Containers\"),\n        library.join(\"HomeKit\"),\n        library.join(\"Developer\").join(\"Xcode\").join(\"DerivedData\"),\n        library.join(\"IdentityServices\"),\n        library.join(\"IntelligencePlatform\"),\n        library.join(\"Mail\"),\n        library.join(\"Messages\"),\n        library.join(\"Metadata\").join(\"CoreSpotlight\"),\n        library.join(\"PersonalizationPortrait\"),\n        library.join(\"Reminders\"),\n        library.join(\"Safari\"),\n        library.join(\"Sharing\"),\n        library.join(\"Shortcuts\"),\n        library.join(\"StatusKit\"),\n        library.join(\"Suggestions\"),\n        library.join(\"Trial\"),\n        library.join(\"Weather\"),\n        app_support.join(\"AddressBook\"),\n        app_support.join(\"CallHistoryDB\"),\n        app_support.join(\"CallHistoryTransactions\"),\n        app_support.join(\"CloudDocs\"),\n        app_support.join(\"com.apple.avfoundation\"),\n        app_support.join(\"com.apple.sharedfilelist\"),\n        app_support.join(\"com.apple.TCC\"),\n        app_support.join(\"DifferentialPrivacy\"),\n        app_support.join(\"FaceTime\"),\n        app_support.join(\"FileProvider\"),\n        app_support.join(\"Knowledge\"),\n        caches.join(\"CloudKit\"),\n        caches.join(\"com.apple.ap.adprivacyd\"),\n        caches.join(\"com.apple.containermanagerd\"),\n        caches.join(\"com.apple.findmy.fmfcore\"),\n        caches.join(\"com.apple.findmy.fmipcore\"),\n        caches.join(\"com.apple.homed\"),\n        caches.join(\"com.apple.HomeKit\"),\n        caches.join(\"com.apple.Safari\"),\n        caches.join(\"FamilyCircle\"),\n    ];\n\n    dirs.into_iter().filter(|p| p.exists()).collect()\n}\n\n#[cfg(not(target_os = \"macos\"))]\nfn macos_tcc_ignore_roots(_home_dir: &Path) -> Vec<PathBuf> {\n    Vec::new()\n}\n\n/// Directories under home that generate heavy background I/O on Windows\n/// (browser caches, Windows Update temp files, UWP package state, etc.).\n/// Pruning these from the MFT subtree eliminates noisy USN records.\n#[cfg(target_os = \"windows\")]\nfn windows_noisy_roots(home_dir: &Path) -> Vec<PathBuf> {\n    let local = home_dir.join(\"AppData\").join(\"Local\");\n    let dirs = vec![\n        local.join(\"Temp\"),\n        local.join(\"Microsoft\"),\n        local.join(\"Google\"),\n        local.join(\"Packages\"),\n        // C:\\ system directories (Windows is deferred, not excluded)\n        PathBuf::from(\"C:\\\\$Recycle.Bin\"),\n        PathBuf::from(\"C:\\\\System Volume Information\"),\n        PathBuf::from(\"C:\\\\Recovery\"),\n        PathBuf::from(\"C:\\\\PerfLogs\"),\n    ];\n    dirs.into_iter().filter(|p| p.exists()).collect()\n}\n\n#[cfg(not(target_os = \"windows\"))]\nfn windows_noisy_roots(_home_dir: &Path) -> Vec<PathBuf> {\n    Vec::new()\n}\n\npub(crate) fn effective_ignore_rules(\n    home_dir: &Path,\n    cwd: &Path,\n    base_roots: &[PathBuf],\n    base_patterns: &[IgnorePattern],\n) -> (Vec<PathBuf>, Vec<IgnorePattern>) {\n    let mut roots = base_roots.to_vec();\n    let mut patterns = base_patterns.to_vec();\n    let mut seen: HashSet<String> = roots\n        .iter()\n        .map(|p| p.to_string_lossy().to_string())\n        .collect();\n    let mut seen_patterns: HashSet<String> = patterns.iter().map(ignore_pattern_key).collect();\n\n    let (pathignore_roots, pathignore_patterns) = load_pathignore_rules(home_dir, cwd);\n    for root in pathignore_roots\n        .into_iter()\n        .chain(load_gitignore_roots(home_dir, cwd).into_iter())\n        .chain(macos_tcc_ignore_roots(home_dir).into_iter())\n        .chain(windows_noisy_roots(home_dir).into_iter())\n    {\n        let key = root.to_string_lossy().to_string();\n        if seen.insert(key) {\n            roots.push(root);\n        }\n    }\n\n    for pattern in pathignore_patterns\n        .into_iter()\n        .chain(builtin_ignore_patterns(home_dir))\n    {\n        let key = ignore_pattern_key(&pattern);\n        if seen_patterns.insert(key) {\n            patterns.push(pattern);\n        }\n    }\n\n    (roots, patterns)\n}\n\nfn builtin_ignore_patterns(home_dir: &Path) -> Vec<IgnorePattern> {\n    let home = normalize_slashes(home_dir.to_string_lossy().to_string());\n    vec![\n        // ~/Library/Application Support/*/Cache*\n        IgnorePattern::Glob(format!(\"{home}/Library/Application Support/*/Cache*\")),\n        // ~/Library/Application Support/*/Code Cache\n        IgnorePattern::Glob(format!(\"{home}/Library/Application Support/*/Code Cache\")),\n        // ~/.rustup/toolchains/*/share/doc\n        IgnorePattern::Glob(format!(\"{home}/.rustup/toolchains/*/share/doc\")),\n        // ~/.pyenv/versions/*/lib\n        IgnorePattern::Glob(format!(\"{home}/.pyenv/versions/*/lib\")),\n    ]\n}\n\npub(crate) fn cached_effective_ignore_rules(state: &AppState) -> (Vec<PathBuf>, Vec<IgnorePattern>) {\n    let home_dir = &state.home_dir;\n    let cwd = &state.cwd;\n\n    let pathignore_mtime = find_file_upward(cwd, \".pathignore\")\n        .or_else(|| Some(home_dir.join(\".pathignore\")))\n        .and_then(|p| fs::metadata(&p).ok())\n        .and_then(|m| m.modified().ok());\n\n    let gitignore_mtime = find_git_root(cwd)\n        .map(|root| root.join(\".gitignore\"))\n        .or_else(|| find_file_upward(cwd, \".gitignore\"))\n        .and_then(|p| fs::metadata(&p).ok())\n        .and_then(|m| m.modified().ok());\n\n    let mut cache = state.ignore_cache.lock();\n    if let Some(ref cached) = *cache {\n        if cached.pathignore_mtime == pathignore_mtime && cached.gitignore_mtime == gitignore_mtime\n        {\n            return (cached.roots.clone(), cached.patterns.clone());\n        }\n    }\n\n    let (roots, patterns) = effective_ignore_rules(\n        home_dir,\n        cwd,\n        state.path_ignores.as_ref(),\n        state.path_ignore_patterns.as_ref(),\n    );\n\n    *cache = Some(IgnoreRulesCache {\n        roots: roots.clone(),\n        patterns: patterns.clone(),\n        pathignore_mtime,\n        gitignore_mtime,\n    });\n\n    (roots, patterns)\n}\n\nfn ignore_rules_fingerprint(roots: &[PathBuf], patterns: &[IgnorePattern]) -> u64 {\n    let mut hasher = std::collections::hash_map::DefaultHasher::new();\n    for root in roots {\n        normalize_slashes(root.to_string_lossy().to_string()).hash(&mut hasher);\n    }\n    for pattern in patterns {\n        ignore_pattern_key(pattern).hash(&mut hasher);\n    }\n    hasher.finish()\n}\n\nfn purge_ignored_entries(db_path: &Path, ignored_roots: &[PathBuf]) -> AppResult<()> {\n    if ignored_roots.is_empty() {\n        return Ok(());\n    }\n\n    let conn = db_connection(db_path)?;\n    for root in ignored_roots {\n        let root_str = root.to_string_lossy().to_string();\n        if root_str.is_empty() {\n            continue;\n        }\n\n        if root_str == \"/\" {\n            conn.execute(\"DELETE FROM entries\", [])\n                .map_err(|e| e.to_string())?;\n            break;\n        }\n\n        let prefix = root_str.trim_end_matches('/');\n        let descendant_like = format!(\"{}%\", escape_like(&format!(\"{prefix}/\")));\n        conn.execute(\n            \"DELETE FROM entries WHERE path = ?1 OR path LIKE ?2 ESCAPE '\\\\'\",\n            params![prefix, descendant_like],\n        )\n        .map_err(|e| e.to_string())?;\n    }\n\n    Ok(())\n}\n\nfn glob_match_path(pattern: &str, text: &str) -> bool {\n    let pat = pattern.as_bytes();\n    let txt = text.as_bytes();\n    let (pn, tn) = (pat.len(), txt.len());\n\n    let mut px = 0usize;\n    let mut tx = 0usize;\n    let mut star_px = usize::MAX;\n    let mut star_tx = 0usize;\n    let mut star_is_double = false;\n\n    while tx < tn {\n        if px < pn && px + 1 < pn && pat[px] == b'*' && pat[px + 1] == b'*' {\n            star_px = px;\n            star_tx = tx;\n            star_is_double = true;\n            px += 2;\n        } else if px < pn && pat[px] == b'*' {\n            star_px = px;\n            star_tx = tx;\n            star_is_double = false;\n            px += 1;\n        } else if px < pn && (pat[px] == b'?' && txt[tx] != b'/') {\n            px += 1;\n            tx += 1;\n        } else if px < pn && pat[px] == txt[tx] {\n            px += 1;\n            tx += 1;\n        } else if star_px != usize::MAX {\n            star_tx += 1;\n            if !star_is_double && txt[star_tx - 1] == b'/' {\n                return false;\n            }\n            px = if star_is_double {\n                star_px + 2\n            } else {\n                star_px + 1\n            };\n            tx = star_tx;\n        } else {\n            return false;\n        }\n    }\n\n    while px < pn && pat[px] == b'*' {\n        px += 1;\n    }\n\n    px == pn\n}\n\npub(crate) fn matches_ignore_pattern(path: &str, pattern: &IgnorePattern) -> bool {\n    match pattern {\n        IgnorePattern::AnySegment(segment) => {\n            let suffix = format!(\"/{segment}\");\n            let infix = format!(\"/{segment}/\");\n            path.ends_with(&suffix) || path.contains(&infix)\n        }\n        IgnorePattern::Glob(glob) => {\n            let mut cur = path;\n            loop {\n                if glob_match_path(glob, cur) {\n                    return true;\n                }\n\n                if cur == \"/\" {\n                    break;\n                }\n\n                let Some(pos) = cur.rfind('/') else {\n                    break;\n                };\n\n                cur = if pos == 0 { \"/\" } else { &cur[..pos] };\n            }\n            false\n        }\n    }\n}\n\npub(crate) fn should_skip_path(\n    path: &Path,\n    ignored_roots: &[PathBuf],\n    ignored_patterns: &[IgnorePattern],\n) -> bool {\n    should_skip_path_ext(path, ignored_roots, ignored_patterns, None, None)\n}\n\npub(crate) fn should_skip_path_ext(\n    path: &Path,\n    ignored_roots: &[PathBuf],\n    ignored_patterns: &[IgnorePattern],\n    gitignore: Option<&gitignore_filter::GitignoreFilter>,\n    is_dir_hint: Option<bool>,\n) -> bool {\n    let s = normalize_slashes(path.to_string_lossy().to_string());\n\n    // Single-component builtin names: check path segments\n    if s.split('/').any(|seg| {\n        BUILTIN_SKIP_NAMES.contains(&seg)\n            || BUILTIN_SKIP_SUFFIXES.iter().any(|suf| seg.ends_with(suf))\n    }) {\n        return true;\n    }\n\n    // Multi-component builtin paths\n    if BUILTIN_SKIP_PATHS.iter().any(|pat| {\n        let infix = format!(\"/{pat}/\");\n        let suffix = format!(\"/{pat}\");\n        s.contains(&infix) || s.ends_with(&suffix)\n    }) {\n        return true;\n    }\n\n    if ignored_roots\n        .iter()\n        .any(|root| path == root || path.starts_with(root))\n    {\n        return true;\n    }\n    if ignored_patterns\n        .iter()\n        .any(|pattern| matches_ignore_pattern(&s, pattern))\n    {\n        return true;\n    }\n    if let Some(gi) = gitignore {\n        let is_dir = is_dir_hint.unwrap_or_else(|| path.is_dir());\n        if gi.is_ignored(path, is_dir) {\n            return true;\n        }\n    }\n    false\n}\n\nfn extension_for(path: &Path, is_dir: bool) -> Option<String> {\n    if is_dir {\n        return None;\n    }\n\n    path.extension()\n        .and_then(|ext| ext.to_str())\n        .map(|ext| ext.to_lowercase())\n}\n\npub(crate) fn index_row_from_path_and_metadata(path: &Path, metadata: &fs::Metadata) -> Option<IndexRow> {\n    let is_dir = metadata.is_dir();\n\n    let name = path\n        .file_name()\n        .map(|v| v.to_string_lossy().to_string())\n        .or_else(|| {\n            if path == Path::new(\"/\") {\n                Some(\"/\".to_string())\n            } else {\n                None\n            }\n        })?;\n\n    let dir = path\n        .parent()\n        .map(|p| p.to_string_lossy().to_string())\n        .unwrap_or_else(|| \"/\".to_string());\n\n    let mtime = metadata\n        .modified()\n        .ok()\n        .and_then(|m| m.duration_since(UNIX_EPOCH).ok())\n        .map(|d| d.as_secs() as i64);\n\n    let size = if metadata.is_file() {\n        Some(metadata.len() as i64)\n    } else {\n        None\n    };\n\n    Some(IndexRow {\n        path: path.to_string_lossy().to_string(),\n        name,\n        dir,\n        is_dir: if is_dir { 1 } else { 0 },\n        ext: extension_for(path, is_dir),\n        mtime,\n        size,\n        indexed_at: now_epoch(),\n        run_id: 0,\n    })\n}\n\nfn index_row_from_path(path: &Path) -> Option<IndexRow> {\n    let metadata = fs::symlink_metadata(path).ok()?;\n    index_row_from_path_and_metadata(path, &metadata)\n}\n\nfn index_row_from_walkdir_entry(entry: &walkdir::DirEntry) -> Option<IndexRow> {\n    let metadata = entry.metadata().ok()?;\n    index_row_from_path_and_metadata(entry.path(), &metadata)\n}\n\nfn index_row_from_jwalk_entry(entry: &jwalk::DirEntry<((), ())>) -> Option<IndexRow> {\n    let metadata = entry.metadata().ok()?;\n    index_row_from_path_and_metadata(&entry.path(), &metadata)\n}\n\nfn collect_rows_recursive(\n    root: &Path,\n    ignored_roots: &[PathBuf],\n    ignored_patterns: &[IgnorePattern],\n) -> Vec<IndexRow> {\n    let mut rows = Vec::new();\n\n    let iter = WalkDir::new(root)\n        .follow_links(false)\n        .into_iter()\n        .filter_entry(|entry| !should_skip_path(entry.path(), ignored_roots, ignored_patterns));\n\n    for entry in iter.flatten() {\n        if let Some(row) = index_row_from_walkdir_entry(&entry) {\n            rows.push(row);\n        }\n    }\n\n    rows\n}\n\nfn entry_from_index_row(row: IndexRow) -> EntryDto {\n    EntryDto {\n        path: row.path,\n        name: row.name,\n        dir: row.dir,\n        is_dir: row.is_dir == 1,\n        ext: row.ext,\n        size: row.size,\n        mtime: row.mtime,\n    }\n}\n\npub fn entry_from_path(path: &Path) -> Option<EntryDto> {\n    index_row_from_path(path).map(entry_from_index_row)\n}\n\nfn entry_cmp(a: &EntryDto, b: &EntryDto, sort_by: &str, sort_dir: &str) -> Ordering {\n    match sort_by {\n        \"mtime\" => {\n            let lhs = a.mtime.unwrap_or(0);\n            let rhs = b.mtime.unwrap_or(0);\n            let primary = if sort_dir == \"desc\" {\n                rhs.cmp(&lhs)\n            } else {\n                lhs.cmp(&rhs)\n            };\n\n            if primary != Ordering::Equal {\n                return primary;\n            }\n\n            a.name\n                .to_lowercase()\n                .cmp(&b.name.to_lowercase())\n                .then(a.path.to_lowercase().cmp(&b.path.to_lowercase()))\n        }\n        \"dir\" => {\n            let lhs = a.dir.to_lowercase();\n            let rhs = b.dir.to_lowercase();\n            let primary = if sort_dir == \"desc\" {\n                rhs.cmp(&lhs)\n            } else {\n                lhs.cmp(&rhs)\n            };\n            if primary != Ordering::Equal {\n                return primary;\n            }\n            a.name.to_lowercase().cmp(&b.name.to_lowercase())\n        }\n        \"size\" => {\n            let lhs = a.size.unwrap_or(0);\n            let rhs = b.size.unwrap_or(0);\n            let primary = if sort_dir == \"desc\" {\n                rhs.cmp(&lhs)\n            } else {\n                lhs.cmp(&rhs)\n            };\n            if primary != Ordering::Equal {\n                return primary;\n            }\n            a.name\n                .to_lowercase()\n                .cmp(&b.name.to_lowercase())\n                .then(a.path.to_lowercase().cmp(&b.path.to_lowercase()))\n        }\n        _ => {\n            let lhs_name = a.name.to_lowercase();\n            let rhs_name = b.name.to_lowercase();\n            let primary = if sort_dir == \"desc\" {\n                rhs_name.cmp(&lhs_name)\n            } else {\n                lhs_name.cmp(&rhs_name)\n            };\n\n            if primary != Ordering::Equal {\n                return primary;\n            }\n\n            let lhs_path = a.path.to_lowercase();\n            let rhs_path = b.path.to_lowercase();\n            if sort_dir == \"desc\" {\n                rhs_path.cmp(&lhs_path)\n            } else {\n                lhs_path.cmp(&rhs_path)\n            }\n        }\n    }\n}\n\nfn relevance_rank(entry: &EntryDto, query_lower: &str, path_suffix: &str) -> u8 {\n    if query_lower.is_empty() {\n        return 255;\n    }\n\n    let name = entry.name.to_lowercase();\n    let path = entry.path.to_lowercase();\n\n    if name == query_lower {\n        return 0;\n    }\n    if name.starts_with(query_lower) {\n        return 1;\n    }\n    if name.contains(query_lower) {\n        return 2;\n    }\n    if path.ends_with(path_suffix) {\n        return 3;\n    }\n    if path.contains(query_lower) {\n        return 4;\n    }\n\n    5\n}\n\nfn path_depth(path: &str) -> usize {\n    Path::new(path).components().count()\n}\n\npub fn sort_entries(entries: &mut Vec<EntryDto>, sort_by: &str, sort_dir: &str) {\n    entries.sort_by(|a, b| entry_cmp(a, b, sort_by, sort_dir));\n}\n\nfn sort_entries_with_relevance(\n    entries: &mut Vec<EntryDto>,\n    query: &str,\n    sort_by: &str,\n    sort_dir: &str,\n) {\n    let query_lower = query.trim().to_lowercase();\n    if query_lower.is_empty() {\n        sort_entries(entries, sort_by, sort_dir);\n        return;\n    }\n    let path_suffix = format!(\"/{query_lower}\");\n\n    entries.sort_by(|a, b| {\n        let ra = relevance_rank(a, &query_lower, &path_suffix);\n        let rb = relevance_rank(b, &query_lower, &path_suffix);\n        if ra != rb {\n            return ra.cmp(&rb);\n        }\n\n        // For highly-relevant matches, prefer shallower paths first\n        // so `~/name` ranks above deep descendants with the same name.\n        if ra <= 3 {\n            let da = path_depth(&a.path);\n            let db = path_depth(&b.path);\n            if da != db {\n                return da.cmp(&db);\n            }\n        }\n\n        entry_cmp(a, b, sort_by, sort_dir)\n    });\n}\n\nfn filter_ignored_entries(\n    entries: Vec<EntryDto>,\n    ignored_roots: &[PathBuf],\n    ignored_patterns: &[IgnorePattern],\n) -> Vec<EntryDto> {\n    entries\n        .into_iter()\n        .filter(|entry| !should_skip_path(Path::new(&entry.path), ignored_roots, ignored_patterns))\n        .collect()\n}\n\nfn find_search(\n    home_dir: &Path,\n    ignored_roots: &[PathBuf],\n    ignored_patterns: &[IgnorePattern],\n    query: &str,\n    limit: usize,\n    sort_by: &str,\n    sort_dir: &str,\n) -> Vec<EntryDto> {\n    let trimmed = query.trim();\n    if trimmed.is_empty() || limit == 0 {\n        return Vec::new();\n    }\n\n    let mut search_root = home_dir.to_path_buf();\n    let mut dir_filter_pattern: Option<String> = None;\n    let mut name_filter_pattern: Option<String> = None;\n    let mut name_filter_glob = false;\n\n    if trimmed.contains('/') {\n        let last_slash = trimmed.rfind('/').unwrap();\n        let dir_part = trimmed[..last_slash].trim();\n        let name_part = trimmed[last_slash + 1..].trim();\n\n        if !dir_part.is_empty() {\n            let mut hinted = if dir_part == \"~\" {\n                Some(home_dir.to_path_buf())\n            } else if let Some(rest) = dir_part.strip_prefix(\"~/\") {\n                Some(home_dir.join(rest))\n            } else {\n                let p = PathBuf::from(dir_part);\n                if p.is_absolute() {\n                    Some(p)\n                } else if !dir_part.contains('*')\n                    && !dir_part.contains('?')\n                    && !dir_part.contains('[')\n                {\n                    Some(home_dir.join(dir_part))\n                } else {\n                    None\n                }\n            };\n\n            if let Some(path) = hinted.take() {\n                if path.exists() && path.is_dir() {\n                    search_root = path;\n                } else {\n                    dir_filter_pattern = Some(format!(\"*{}/*\", dir_part));\n                }\n            } else {\n                dir_filter_pattern = Some(format!(\"*{}/*\", dir_part));\n            }\n        }\n\n        if !name_part.is_empty() {\n            if name_part.contains('*') || name_part.contains('?') {\n                name_filter_pattern = Some(name_part.to_string());\n                name_filter_glob = true;\n            } else {\n                name_filter_pattern = Some(format!(\"*{}*\", name_part));\n            }\n        }\n    } else if trimmed.contains('*') || trimmed.contains('?') {\n        name_filter_pattern = Some(trimmed.to_string());\n        name_filter_glob = true;\n    } else {\n        name_filter_pattern = Some(format!(\"*{}*\", trimmed));\n    }\n\n    let mut cmd = Command::new(\"find\");\n    cmd.arg(&search_root);\n\n    if search_root == home_dir {\n        cmd.args([\"-maxdepth\", \"8\"]);\n    }\n\n    if let Some(dir_pattern) = dir_filter_pattern.as_deref() {\n        cmd.args([\"-ipath\", dir_pattern]);\n    }\n    if let Some(name_pattern) = name_filter_pattern.as_deref() {\n        cmd.args([\"-iname\", name_pattern]);\n    }\n    if name_filter_glob {\n        cmd.args([\"-type\", \"f\"]);\n    }\n\n    cmd.args([\"!\", \"-path\", \"*/.git/*\"])\n        .args([\"!\", \"-path\", \"*/node_modules/*\"])\n        .args([\"!\", \"-path\", \"*/.Trash/*\"])\n        .args([\"!\", \"-path\", \"*/.Trashes/*\"])\n        .args([\"!\", \"-path\", \"*/Library/Caches/*\"])\n        .stdout(Stdio::piped())\n        .stderr(Stdio::null());\n\n    let mut child = match cmd.spawn() {\n        Ok(c) => c,\n        Err(_) => return Vec::new(),\n    };\n\n    let stdout = match child.stdout.take() {\n        Some(s) => s,\n        None => return Vec::new(),\n    };\n\n    let reader = BufReader::new(stdout);\n    let mut entries = Vec::with_capacity(limit);\n\n    for line in reader.lines() {\n        let Ok(line) = line else { continue };\n        let path = PathBuf::from(&line);\n        if should_skip_path(&path, ignored_roots, ignored_patterns) {\n            continue;\n        }\n\n        if let Some(entry) = entry_from_path(&path) {\n            entries.push(entry);\n            if entries.len() >= limit {\n                break;\n            }\n        }\n    }\n\n    let _ = child.kill();\n    let _ = child.wait();\n\n    sort_entries_with_relevance(&mut entries, trimmed, sort_by, sort_dir);\n    entries\n}\n\npub(crate) fn upsert_rows(conn: &mut Connection, rows: &[IndexRow]) -> AppResult<usize> {\n    if rows.is_empty() {\n        return Ok(0);\n    }\n\n    let tx = conn.transaction().map_err(|e| e.to_string())?;\n    {\n        let mut stmt = tx\n            .prepare(\n                r#\"\n                INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n                VALUES(?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)\n                ON CONFLICT(path) DO UPDATE SET\n                  name = excluded.name,\n                  dir = excluded.dir,\n                  is_dir = excluded.is_dir,\n                  ext = excluded.ext,\n                  mtime = excluded.mtime,\n                  size = excluded.size,\n                  indexed_at = excluded.indexed_at,\n                  run_id = excluded.run_id\n                \"#,\n            )\n            .map_err(|e| e.to_string())?;\n\n        for row in rows {\n            stmt.execute(params![\n                row.path,\n                row.name,\n                row.dir,\n                row.is_dir,\n                row.ext,\n                row.mtime,\n                row.size,\n                row.indexed_at,\n                row.run_id\n            ])\n            .map_err(|e| e.to_string())?;\n        }\n    }\n    tx.commit().map_err(|e| e.to_string())?;\n    Ok(rows.len())\n}\n\npub(crate) fn delete_paths(conn: &mut Connection, raw_paths: &[String]) -> AppResult<usize> {\n    if raw_paths.is_empty() {\n        return Ok(0);\n    }\n\n    let tx = conn.transaction().map_err(|e| e.to_string())?;\n    let mut deleted = 0;\n\n    {\n        let mut stmt_exact = tx\n            .prepare(\"DELETE FROM entries WHERE path = ?1\")\n            .map_err(|e| e.to_string())?;\n        let mut stmt_children = tx\n            .prepare(\"DELETE FROM entries WHERE path >= ?1 AND path < ?2\")\n            .map_err(|e| e.to_string())?;\n\n        for path in raw_paths {\n            let is_root = path == \"/\" || path == \"\\\\\";\n            let normalized = if is_root {\n                path.clone()\n            } else {\n                path.trim_end_matches(&['/', '\\\\'][..]).to_string()\n            };\n\n            if normalized.is_empty() {\n                continue;\n            }\n\n            if is_root {\n                deleted += tx\n                    .execute(\"DELETE FROM entries\", [])\n                    .map_err(|e| e.to_string())?;\n                continue;\n            }\n\n            deleted += stmt_exact\n                .execute(params![&normalized])\n                .map_err(|e| e.to_string())?;\n\n            // Delete children using B-tree range scan: path >= \"{normalized}{sep}\" AND path < \"{normalized}\\x7F\"\n            // \\x7F (127) is higher than both '/' (47) and '\\' (92), so this captures all children.\n            let sep = std::path::MAIN_SEPARATOR;\n            let range_start = format!(\"{normalized}{sep}\");\n            let range_end = format!(\"{normalized}\\x7F\");\n            deleted += stmt_children\n                .execute(params![&range_start, &range_end])\n                .map_err(|e| e.to_string())?;\n        }\n    }\n\n    tx.commit().map_err(|e| e.to_string())?;\n    Ok(deleted)\n}\n\npub(crate) fn emit_index_state(app: &AppHandle, state: &str, message: Option<String>) {\n    let is_catchup = message.as_ref().map_or(false, |m| m.starts_with(\"Catchup:\"));\n    let _ = app.emit(\n        \"index_state\",\n        IndexStateEvent {\n            state: state.to_string(),\n            message,\n            is_catchup,\n        },\n    );\n}\n\npub(crate) fn emit_index_updated(\n    app: &AppHandle,\n    entries_count: u64,\n    last_updated: i64,\n    permission_errors: u64,\n) {\n    let _ = app.emit(\n        \"index_updated\",\n        IndexUpdatedEvent {\n            entries_count,\n            last_updated,\n            permission_errors,\n        },\n    );\n}\n\npub(crate) fn emit_index_progress(app: &AppHandle, scanned: u64, indexed: u64, current_path: String) {\n    let _ = app.emit(\n        \"index_progress\",\n        IndexProgressEvent {\n            scanned,\n            indexed,\n            current_path,\n        },\n    );\n}\n\npub(crate) fn set_state(state: &AppState, next: IndexState, message: Option<String>) {\n    let mut status = state.status.lock();\n    status.state = next;\n    status.message = message;\n}\n\npub(crate) fn set_progress(state: &AppState, scanned: u64, indexed: u64, current_path: &str) {\n    let mut status = state.status.lock();\n    status.scanned = scanned;\n    status.indexed = indexed;\n    status.current_path = current_path.to_string();\n}\n\nfn emit_status_counts(app: &AppHandle, state: &AppState) {\n    let status = state.status.lock();\n    emit_index_updated(\n        app,\n        status.entries_count,\n        status.last_updated.unwrap_or_else(now_epoch),\n        status.permission_errors,\n    );\n}\n\npub(crate) fn refresh_and_emit_status_counts(app: &AppHandle, state: &AppState) -> AppResult<()> {\n    let (entries_count, last_updated) = update_status_counts(state)?;\n    // Persist cached counts so next startup can read them instantly\n    if let Ok(conn) = db_connection(&state.db_path) {\n        let _ = set_meta(&conn, \"cached_entries_count\", &entries_count.to_string());\n        if let Some(lu) = last_updated {\n            let _ = set_meta(&conn, \"cached_last_updated\", &lu.to_string());\n        }\n    }\n    emit_status_counts(app, state);\n    Ok(())\n}\n\n/// Load cached entries count from meta table (instant) and emit Ready state + counts.\n/// Used on Windows startup paths where the index is already complete from a prior run.\n#[cfg(target_os = \"windows\")]\npub(crate) fn set_ready_with_cached_counts(app: &AppHandle, state: &AppState) {\n    let (count, last_updated) = db_connection(&state.db_path)\n        .ok()\n        .map(|conn| {\n            let c = get_meta(&conn, \"cached_entries_count\")\n                .and_then(|v| v.parse::<u64>().ok())\n                .unwrap_or(0);\n            let lu = get_meta(&conn, \"cached_last_updated\")\n                .and_then(|v| v.parse::<i64>().ok());\n            (c, lu)\n        })\n        .unwrap_or((0, None));\n\n    {\n        let mut status = state.status.lock();\n        status.state = IndexState::Ready;\n        status.entries_count = count;\n        status.last_updated = last_updated;\n    }\n\n    emit_index_state(app, \"Ready\", None);\n    emit_index_updated(app, count, last_updated.unwrap_or_else(now_epoch), 0);\n}\n\n#[cfg(target_os = \"macos\")]\nfn touch_status_updated(state: &AppState) {\n    state.status.lock().last_updated = Some(now_epoch());\n}\n\n#[cfg(not(target_os = \"windows\"))]\npub(crate) fn start_full_index_worker(app: AppHandle, state: AppState) -> AppResult<()> {\n    start_full_index_worker_inner(app, state, false)\n}\n\n#[cfg(target_os = \"windows\")]\npub(crate) fn start_full_index_worker_silent(app: AppHandle, state: AppState) -> AppResult<()> {\n    start_full_index_worker_inner(app, state, true)\n}\n\nfn start_full_index_worker_inner(app: AppHandle, state: AppState, silent: bool) -> AppResult<()> {\n    if state\n        .indexing_active\n        .compare_exchange(false, true, AtomicOrdering::AcqRel, AtomicOrdering::Acquire)\n        .is_err()\n    {\n        perf_log(\"index_start_skipped already_active=true\");\n        return Ok(());\n    }\n\n    // Mark index as incomplete -- cleared when run_incremental_index succeeds\n    if let Ok(c) = db_connection(&state.db_path) {\n        let _ = set_meta(&c, \"index_complete\", \"0\");\n    }\n\n    if !silent {\n        {\n            let mut status = state.status.lock();\n            status.state = IndexState::Indexing;\n            status.message = None;\n            status.scanned = 0;\n            status.indexed = 0;\n            status.current_path.clear();\n        }\n\n        emit_index_state(&app, \"Indexing\", None);\n        perf_log(\"index_state=Indexing\");\n    } else {\n        perf_log(\"index_start silent=true (background reindex)\");\n    }\n\n    std::thread::spawn(move || {\n        let result = run_incremental_index(&app, &state);\n        if let Err(ref err) = result {\n            eprintln!(\"[index] run_incremental_index failed: {err}\");\n            if !silent {\n                set_state(&state, IndexState::Error, Some(err.clone()));\n                emit_index_state(&app, \"Error\", Some(err.clone()));\n            }\n            // Silent mode: keep Ready state, just log the error\n        }\n        state.indexing_active.store(false, AtomicOrdering::Release);\n    });\n\n    Ok(())\n}\n\nfn is_deferred_dir(path: &Path, home_dir: &Path) -> bool {\n    path.parent() == Some(home_dir)\n        && path\n            .file_name()\n            .and_then(|n| n.to_str())\n            .map(|name| DEFERRED_DIR_NAMES.contains(&name))\n            .unwrap_or(false)\n}\n\nfn preload_existing_entries(\n    conn: &Connection,\n    dir_prefix: &str,\n) -> HashMap<String, (Option<i64>, Option<i64>)> {\n    let like_pattern = format!(\"{}/%\", escape_like(dir_prefix));\n    let mut stmt = match conn.prepare(\n        \"SELECT path, mtime, size FROM entries WHERE path LIKE ?1 ESCAPE '\\\\' OR path = ?2\",\n    ) {\n        Ok(s) => s,\n        Err(_) => return HashMap::new(),\n    };\n\n    let mut map = HashMap::new();\n    let rows = match stmt.query_map(params![like_pattern, dir_prefix], |row| {\n        Ok((\n            row.get::<_, String>(0)?,\n            row.get::<_, Option<i64>>(1)?,\n            row.get::<_, Option<i64>>(2)?,\n        ))\n    }) {\n        Ok(r) => r,\n        Err(_) => return map,\n    };\n\n    for row in rows.flatten() {\n        map.insert(row.0, (row.1, row.2));\n    }\n    map\n}\n\nfn stamp_run_id_batch(conn: &mut Connection, paths: &[String], run_id: i64) -> AppResult<()> {\n    if paths.is_empty() {\n        return Ok(());\n    }\n\n    let tx = conn.transaction().map_err(|e| e.to_string())?;\n    {\n        let mut stmt = tx\n            .prepare(\"UPDATE entries SET run_id = ?1 WHERE path = ?2\")\n            .map_err(|e| e.to_string())?;\n        for path in paths {\n            stmt.execute(params![run_id, path])\n                .map_err(|e| e.to_string())?;\n        }\n    }\n    tx.commit().map_err(|e| e.to_string())?;\n    Ok(())\n}\n\nfn run_incremental_index(app: &AppHandle, state: &AppState) -> AppResult<()> {\n    let started = Instant::now();\n    perf_log(format!(\n        \"index_run_start home={} db={}\",\n        state.home_dir.to_string_lossy(),\n        state.db_path.to_string_lossy(),\n    ));\n\n    let mut conn = db_connection(&state.db_path)?;\n    set_indexing_pragmas(&conn)?;\n\n    let result = run_incremental_index_inner(app, state, &mut conn);\n\n    let _ = conn.execute_batch(\"ANALYZE\");\n    let _ = restore_normal_pragmas(&conn);\n\n    match &result {\n        Ok(_) => {\n            let _ = set_meta(&conn, \"index_complete\", \"1\");\n            let snapshot = state.status.lock().clone();\n            perf_log(format!(\n                \"index_run_done elapsed_ms={} scanned={} indexed={} entries={} permission_errors={} message={:?}\",\n                started.elapsed().as_millis(),\n                snapshot.scanned,\n                snapshot.indexed,\n                snapshot.entries_count,\n                snapshot.permission_errors,\n                snapshot.message,\n            ));\n        }\n        Err(err) => {\n            perf_log(format!(\n                \"index_run_error elapsed_ms={} err={}\",\n                started.elapsed().as_millis(),\n                err,\n            ));\n        }\n    }\n\n    result\n}\n\nfn run_incremental_index_inner(\n    app: &AppHandle,\n    state: &AppState,\n    conn: &mut Connection,\n) -> AppResult<()> {\n\n    let (runtime_ignored_roots, runtime_ignored_patterns) = effective_ignore_rules(\n        &state.home_dir,\n        &state.cwd,\n        state.path_ignores.as_ref(),\n        state.path_ignore_patterns.as_ref(),\n    );\n    let gi_filter = state.gitignore.get();\n\n    let last_run_id: i64 = get_meta(conn, \"last_run_id\")\n        .and_then(|v| v.parse().ok())\n        .unwrap_or(0);\n    let current_run_id = last_run_id + 1;\n    // Fresh index: DB was empty, skip preload/stamp, single unlimited-depth pass\n    let is_fresh = last_run_id == 0;\n\n    let mut scanned: u64 = 0;\n    let mut indexed: u64 = 0;\n    let mut permission_errors: u64 = 0;\n    let mut current_path = String::new();\n    let mut batch: Vec<IndexRow> = Vec::with_capacity(BATCH_SIZE);\n    let mut stamp_batch: Vec<String> = Vec::with_capacity(BATCH_SIZE);\n    let mut last_emit = Instant::now();\n    let mut last_perf_emit = Instant::now();\n\n    // Preload scan_root-level entries (direct children only, not recursive)\n    let scan_str = state.scan_root.to_string_lossy().to_string();\n    let root_existing = preload_existing_entries(conn, &scan_str);\n\n    // Index scan_root itself\n    if let Some(mut row) = index_row_from_path(&state.scan_root) {\n        scanned += 1;\n        row.run_id = current_run_id;\n        if let Some((old_mtime, old_size)) = root_existing.get(&row.path) {\n            if *old_mtime == row.mtime && *old_size == row.size {\n                stamp_batch.push(row.path);\n            } else {\n                batch.push(row);\n            }\n        } else {\n            batch.push(row);\n        }\n    }\n\n    // Partition direct children into priority vs deferred\n    let mut priority_roots: Vec<PathBuf> = Vec::new();\n    let mut deferred_roots: Vec<PathBuf> = Vec::new();\n\n    if let Ok(entries) = fs::read_dir(&state.scan_root) {\n        for dir_entry in entries.flatten() {\n            let child_path = dir_entry.path();\n\n            if should_skip_path_ext(\n                &child_path,\n                &runtime_ignored_roots,\n                &runtime_ignored_patterns,\n                Some(&gi_filter),\n                None,\n            ) {\n                continue;\n            }\n\n            scanned += 1;\n            current_path = child_path.to_string_lossy().to_string();\n\n            if let Some(mut row) = index_row_from_path(&child_path) {\n                row.run_id = current_run_id;\n                if let Some((old_mtime, old_size)) = root_existing.get(&row.path) {\n                    if *old_mtime == row.mtime && *old_size == row.size {\n                        stamp_batch.push(row.path);\n                    } else {\n                        batch.push(row);\n                    }\n                } else {\n                    batch.push(row);\n                }\n            }\n\n            if child_path.is_dir() {\n                if is_deferred_dir(&child_path, &state.scan_root) {\n                    deferred_roots.push(child_path);\n                } else {\n                    priority_roots.push(child_path);\n                }\n            }\n        }\n    }\n\n\n    // Flush home-level stamp batch\n    if stamp_batch.len() >= BATCH_SIZE {\n        stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n        stamp_batch.clear();\n    }\n\n    priority_roots.sort();\n    deferred_roots.sort();\n\n    let roots: Vec<PathBuf> = priority_roots.into_iter().chain(deferred_roots).collect();\n    perf_log(format!(\n        \"index_scan_roots total={} priority+deferred\",\n        roots.len()\n    ));\n\n    // 2-pass indexing: shallow first (depth <= SHALLOW_SCAN_DEPTH), then deep\n    // Both passes use jwalk for parallel scanning\n    let arc_ignored_roots = Arc::new(runtime_ignored_roots.clone());\n    let arc_ignored_patterns = Arc::new(runtime_ignored_patterns.clone());\n\n\n    for pass in 0..2u8 {\n        // Fresh index: single unlimited-depth pass -- avoids double filesystem traversal\n        if pass == 1 && is_fresh {\n            break;\n        }\n        let pass_label = if pass == 0 { \"shallow\" } else { \"deep\" };\n        let pass_started = Instant::now();\n        let mut pass_scanned = 0u64;\n        let mut pass_indexed = 0u64;\n\n        for root in &roots {\n            let root_started = Instant::now();\n            let mut root_scanned = 0u64;\n            let mut root_indexed = 0u64;\n            let mut root_permission_errors = 0u64;\n            let root_str = root.to_string_lossy().to_string();\n\n            // Fresh index: DB is empty, preload is unnecessary\n            let existing = if is_fresh {\n                HashMap::new()\n            } else {\n                let e = preload_existing_entries(conn, &root_str);\n                e\n            };\n\n            let gi_ref = gi_filter.clone();\n            let skip_roots = arc_ignored_roots.clone();\n            let skip_patterns = arc_ignored_patterns.clone();\n\n            let mut builder = jwalk::WalkDir::new(root)\n                .follow_links(false)\n                .skip_hidden(false)\n                .parallelism(jwalk::Parallelism::RayonNewPool(jwalk_num_threads()));\n            // Fresh index: no depth limit -- walk everything in one pass\n            if pass == 0 && !is_fresh {\n                builder = builder.max_depth(SHALLOW_SCAN_DEPTH);\n            }\n            let walker = builder.process_read_dir(move |_depth, path, _state, children| {\n                children.retain(|entry_result| {\n                    entry_result\n                        .as_ref()\n                        .map(|entry| {\n                            let full_path = path.join(&entry.file_name);\n                            let is_dir = Some(entry.file_type.is_dir());\n                            !should_skip_path_ext(\n                                &full_path,\n                                &skip_roots,\n                                &skip_patterns,\n                                Some(&gi_ref),\n                                is_dir,\n                            )\n                        })\n                        .unwrap_or(false)\n                });\n            });\n\n            for result in walker {\n                match result {\n                    Ok(entry) => {\n                        let path = entry.path();\n                        if path == root.as_path() {\n                            continue;\n                        }\n\n                        // Pass 1 (incremental only): skip shallow entries already indexed in pass 0\n                        if pass == 1 && entry.depth <= SHALLOW_SCAN_DEPTH {\n                            continue;\n                        }\n\n                        scanned += 1;\n                        root_scanned += 1;\n                        current_path = path.to_string_lossy().to_string();\n\n                        if let Some(mut row) = index_row_from_jwalk_entry(&entry) {\n                            row.run_id = current_run_id;\n                            if is_fresh {\n                                // Fresh index: all entries are new, skip existing check\n                                indexed += 1;\n                                root_indexed += 1;\n                                batch.push(row);\n                            } else if let Some((old_mtime, old_size)) = existing.get(&row.path) {\n                                if *old_mtime == row.mtime && *old_size == row.size {\n                                    stamp_batch.push(row.path);\n                                } else {\n                                    indexed += 1;\n                                    root_indexed += 1;\n                                    batch.push(row);\n                                }\n                            } else {\n                                indexed += 1;\n                                root_indexed += 1;\n                                batch.push(row);\n                            }\n                        }\n\n                        if batch.len() >= BATCH_SIZE {\n                            upsert_rows(conn, &batch)?;\n                            batch.clear();\n                        }\n\n                        if stamp_batch.len() >= BATCH_SIZE {\n                            stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n                            stamp_batch.clear();\n                        }\n\n                        if last_emit.elapsed() >= Duration::from_millis(200) {\n                            set_progress(state, scanned, indexed, &current_path);\n                            emit_index_progress(app, scanned, indexed, current_path.clone());\n                            last_emit = Instant::now();\n                        }\n                        if perf_log_enabled() && last_perf_emit.elapsed() >= Duration::from_secs(1)\n                        {\n                            perf_log(format!(\n                                \"index_progress pass={} scanned={} indexed={} current_path={}\",\n                                pass_label, scanned, indexed, current_path\n                            ));\n                            last_perf_emit = Instant::now();\n                        }\n                    }\n                    Err(err) => {\n                        scanned += 1;\n                        root_scanned += 1;\n                        permission_errors += 1;\n                        root_permission_errors += 1;\n                        if permission_errors <= 20 || perf_log_enabled() {\n                            eprintln!(\"[index] permission error: {}\", err);\n                        }\n                    }\n                }\n            }\n\n            pass_scanned += root_scanned;\n            pass_indexed += root_indexed;\n\n            eprintln!(\"[timing]   walk_{} {} {}ms scanned={} indexed={} err={}\",\n                pass_label, root_str, root_started.elapsed().as_millis(),\n                root_scanned, root_indexed, root_permission_errors);\n            perf_log(format!(\n                \"index_root_done pass={} root={} elapsed_ms={} scanned={} indexed={} permission_errors={}\",\n                pass_label,\n                root.to_string_lossy(),\n                root_started.elapsed().as_millis(),\n                root_scanned,\n                root_indexed,\n                root_permission_errors,\n            ));\n        }\n\n        // Flush between passes\n        if !batch.is_empty() {\n            upsert_rows(conn, &batch)?;\n            batch.clear();\n        }\n        if !stamp_batch.is_empty() {\n            stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n            stamp_batch.clear();\n        }\n\n        perf_log(format!(\n            \"index_pass_done pass={} elapsed_ms={} scanned={} indexed={}\",\n            pass_label,\n            pass_started.elapsed().as_millis(),\n            pass_scanned,\n            pass_indexed,\n        ));\n\n        // After shallow pass (incremental only), emit progress so UI shows searchable state early\n        // Fresh index uses per-root emit above instead.\n        if pass == 0 && !is_fresh {\n            let _ = refresh_and_emit_status_counts(app, state);\n            let _ = app.emit(\n                \"index_updated\",\n                IndexUpdatedEvent {\n                    entries_count: state.status.lock().entries_count,\n                    last_updated: now_epoch(),\n                    permission_errors,\n                },\n            );\n        }\n    }\n\n    if !batch.is_empty() {\n        upsert_rows(conn, &batch)?;\n    }\n\n    if !stamp_batch.is_empty() {\n        stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n    }\n\n    set_progress(state, scanned, indexed, &current_path);\n    emit_index_progress(app, scanned, indexed, current_path.clone());\n\n    // Remove entries not seen in this run (deleted files)\n    // Fresh index: DB was empty before this run, no stale entries possible\n    let deleted_count: i64 = if is_fresh {\n        0\n    } else {\n        let count = conn\n            .query_row(\n                \"SELECT COUNT(*) FROM entries WHERE run_id < ?1\",\n                params![current_run_id],\n                |row| row.get(0),\n            )\n            .unwrap_or(0);\n        conn.execute(\n            \"DELETE FROM entries WHERE run_id < ?1\",\n            params![current_run_id],\n        )\n        .map_err(|e| e.to_string())?;\n        count\n    };\n\n    set_meta(conn, \"last_run_id\", &current_run_id.to_string())?;\n\n    if deleted_count > 0 || indexed > 0 {\n        invalidate_search_caches(state);\n    }\n\n    let (entries_count, last_updated) = update_status_counts(state)?;\n    // Persist cached counts for instant startup next time\n    let _ = set_meta(conn, \"cached_entries_count\", &entries_count.to_string());\n    if let Some(lu) = last_updated {\n        let _ = set_meta(conn, \"cached_last_updated\", &lu.to_string());\n    }\n    let updated_at = last_updated.unwrap_or_else(now_epoch);\n\n    {\n        let mut status = state.status.lock();\n        status.state = IndexState::Ready;\n        status.permission_errors = permission_errors;\n        status.scanned = scanned;\n        status.indexed = indexed;\n        status.current_path = current_path.clone();\n        status.message = if permission_errors > 0 {\n            Some(format!(\n                \"{} permission/access error(s) occurred.\",\n                permission_errors\n            ))\n        } else {\n            None\n        };\n    }\n    emit_index_progress(app, scanned, indexed, current_path);\n    emit_index_updated(app, entries_count, updated_at, permission_errors);\n    emit_index_state(\n        app,\n        \"Ready\",\n        if permission_errors > 0 {\n            Some(format!(\"{} permission/access error(s)\", permission_errors))\n        } else {\n            None\n        },\n    );\n    perf_log(format!(\n        \"index_state=Ready scanned={} indexed={} deleted={} entries={} permission_errors={}\",\n        scanned, indexed, deleted_count, entries_count, permission_errors\n    ));\n\n    Ok(())\n}\n\nfn trim_recent_ops(ops: &mut Vec<RecentOp>) {\n    let now = Instant::now();\n    ops.retain(|op| now.duration_since(op.at) <= RECENT_OP_TTL);\n}\n\nfn remember_op(\n    state: &AppState,\n    op_type: &'static str,\n    old_path: Option<String>,\n    new_path: Option<String>,\n) {\n    let mut ops = state.recent_ops.lock();\n    trim_recent_ops(&mut ops);\n    ops.push(RecentOp {\n        old_path,\n        new_path,\n        op_type,\n        at: Instant::now(),\n    });\n}\n\n#[cfg(any(target_os = \"macos\", target_os = \"windows\"))]\npub(crate) fn is_recently_touched(state: &AppState, path: &str) -> bool {\n    let mut ops = state.recent_ops.lock();\n    trim_recent_ops(&mut ops);\n\n    ops.iter().any(|op| match op.op_type {\n        \"rename\" | \"trash\" => {\n            op.old_path\n                .as_deref()\n                .map(|old| old == path)\n                .unwrap_or(false)\n                || op\n                    .new_path\n                    .as_deref()\n                    .map(|new| new == path)\n                    .unwrap_or(false)\n        }\n        _ => false,\n    })\n}\n\n#[cfg(target_os = \"macos\")]\nfn apply_path_changes(state: &AppState, paths: &[PathBuf]) -> AppResult<usize> {\n    let (ignored_roots, ignored_patterns) = cached_effective_ignore_rules(state);\n    let mut to_upsert_map: HashMap<String, IndexRow> = HashMap::new();\n    let mut to_delete = Vec::new();\n\n    for path in paths {\n        if should_skip_path(path, &ignored_roots, &ignored_patterns) {\n            continue;\n        }\n\n        let path_str = path.to_string_lossy().to_string();\n        if path_str.is_empty() {\n            continue;\n        }\n\n        if is_recently_touched(state, &path_str) {\n            continue;\n        }\n\n        match fs::symlink_metadata(path) {\n            Ok(metadata) => {\n                if let Some(row) = index_row_from_path_and_metadata(path, &metadata) {\n                    to_upsert_map.insert(row.path.clone(), row);\n                }\n            }\n            Err(_) => {\n                to_delete.push(path_str);\n            }\n        }\n    }\n\n    let to_upsert = to_upsert_map.into_values().collect::<Vec<_>>();\n\n    if to_upsert.is_empty() && to_delete.is_empty() {\n        return Ok(0);\n    }\n\n    let op_start = std::time::Instant::now();\n    let mut conn = db_connection(&state.db_path).map_err(|e| {\n        eprintln!(\n            \"[watcher] db_connection FAILED after {}ms: {} (upsert={} delete={} indexing_active={})\",\n            op_start.elapsed().as_millis(),\n            e,\n            to_upsert.len(),\n            to_delete.len(),\n            state.indexing_active.load(AtomicOrdering::Acquire)\n        );\n        e\n    })?;\n    let mut changed = 0;\n\n    changed += upsert_rows(&mut conn, &to_upsert)?;\n    changed += delete_paths(&mut conn, &to_delete)?;\n\n    Ok(changed)\n}\n\n#[cfg(target_os = \"macos\")]\nconst STATUS_EMIT_MIN_INTERVAL: Duration = Duration::from_secs(2);\n\n#[cfg(target_os = \"macos\")]\nconst DB_BUSY_RETRY_DELAY: Duration = Duration::from_secs(3);\n\n#[cfg(target_os = \"macos\")]\nfn process_watcher_paths(\n    app: &AppHandle,\n    state: &AppState,\n    pending: &mut HashSet<PathBuf>,\n    deadline: &mut Option<Instant>,\n    last_status_emit: &mut Instant,\n    pending_status_emit: &mut bool,\n) {\n    if pending.is_empty() {\n        return;\n    }\n\n    if state.indexing_active.load(AtomicOrdering::Acquire) {\n        return;\n    }\n\n    let mut batch: Vec<PathBuf> = pending.drain().collect();\n    batch.sort();\n\n    match apply_path_changes(state, &batch) {\n        Ok(changed) => {\n            *deadline = None;\n            if changed > 0 {\n                invalidate_search_caches(state);\n                touch_status_updated(state);\n                if last_status_emit.elapsed() >= STATUS_EMIT_MIN_INTERVAL {\n                    let _ = refresh_and_emit_status_counts(app, state);\n                    *last_status_emit = Instant::now();\n                    *pending_status_emit = false;\n                } else {\n                    *pending_status_emit = true;\n                }\n            }\n        }\n        Err(err) => {\n            let is_busy = err.contains(\"locked\") || err.contains(\"busy\");\n            if is_busy {\n                eprintln!(\n                    \"[watcher] DB busy, will retry in {}s: {} | batch_size={}\",\n                    DB_BUSY_RETRY_DELAY.as_secs(),\n                    err,\n                    batch.len()\n                );\n                for path in batch {\n                    pending.insert(path);\n                }\n                *deadline = Some(Instant::now() + DB_BUSY_RETRY_DELAY);\n                return;\n            }\n            eprintln!(\n                \"[watcher] process_watcher_paths ERROR: {} | batch_size={} indexing_active={}\",\n                err,\n                batch.len(),\n                state.indexing_active.load(AtomicOrdering::Acquire)\n            );\n            *deadline = None;\n            if state.indexing_active.load(AtomicOrdering::Acquire) {\n                return;\n            }\n            let mut status = state.status.lock();\n            if !matches!(status.state, IndexState::Indexing) {\n                status.state = IndexState::Error;\n            }\n            status.message = Some(format!(\"Watcher update failed: {err}\"));\n            drop(status);\n            emit_index_state(app, \"Error\", Some(format!(\"Watcher update failed: {err}\")));\n        }\n    }\n}\n\n#[cfg(target_os = \"macos\")]\nconst EVENT_ID_FLUSH_INTERVAL: Duration = Duration::from_secs(30);\n\n#[cfg(target_os = \"macos\")]\nfn persist_event_id(db_path: &Path, event_id: u64) -> AppResult<()> {\n    let conn = db_connection(db_path)?;\n    set_meta(&conn, \"last_event_id\", &event_id.to_string())\n}\n\n#[cfg(target_os = \"macos\")]\nconst MUST_SCAN_THRESHOLD: usize = 10;\n\n#[cfg(target_os = \"macos\")]\nfn start_fsevent_watcher_worker(\n    app: AppHandle,\n    state: AppState,\n    since_event_id: Option<u64>,\n    conditional: bool,\n) {\n    use std::sync::mpsc::{self, RecvTimeoutError};\n    std::thread::spawn(move || {\n        let (tx, rx) = mpsc::channel();\n\n        let mut watcher =\n            match mac::fsevent_watcher::FsEventWatcher::new(&state.home_dir, since_event_id, tx) {\n                Ok(w) => w,\n                Err(err) => {\n                    set_state(\n                        &state,\n                        IndexState::Error,\n                        Some(format!(\"FSEvents watcher initialization failed: {err}\")),\n                    );\n                    emit_index_state(\n                        &app,\n                        \"Error\",\n                        Some(format!(\"FSEvents watcher initialization failed: {err}\")),\n                    );\n                    return;\n                }\n            };\n\n        if conditional {\n            perf_log(\"conditional_startup: watcher started, awaiting history replay\");\n            set_state(&state, IndexState::Ready, None);\n            emit_index_state(&app, \"Ready\", None);\n        }\n\n        let mut pending_paths: HashSet<PathBuf> = HashSet::new();\n        let mut deadline: Option<Instant> = None;\n        let mut last_flush = Instant::now();\n        let mut last_status_emit = Instant::now();\n        let mut pending_status_emit = false;\n        let mut last_count_refresh = Instant::now();\n        let mut must_scan_count: usize = 0;\n        let mut replay_phase = conditional;\n        let mut full_scan_triggered = false;\n\n        loop {\n            let wait = match deadline {\n                Some(due) => {\n                    let now = Instant::now();\n                    if now >= due {\n                        Duration::from_millis(0)\n                    } else {\n                        due - now\n                    }\n                }\n                None => Duration::from_secs(1),\n            };\n            match rx.recv_timeout(wait) {\n                Ok(mac::fsevent_watcher::FsEvent::Paths(paths)) => {\n                    let (ignored_roots, ignored_patterns) = cached_effective_ignore_rules(&state);\n                    let prev_len = pending_paths.len();\n                    for path in paths {\n                        if !should_skip_path(&path, &ignored_roots, &ignored_patterns) {\n                            pending_paths.insert(path);\n                        }\n                    }\n                    if pending_paths.len() > prev_len {\n                        deadline = Some(Instant::now() + WATCH_DEBOUNCE);\n                    }\n                }\n                Ok(mac::fsevent_watcher::FsEvent::MustScanSubDirs(path)) => {\n                    must_scan_count += 1;\n                    if replay_phase\n                        && must_scan_count >= MUST_SCAN_THRESHOLD\n                        && !full_scan_triggered\n                    {\n                        perf_log(format!(\n                            \"conditional_startup: MustScanSubDirs={} >= threshold, triggering full scan\",\n                            must_scan_count\n                        ));\n                        full_scan_triggered = true;\n                        let _ = start_full_index_worker(app.clone(), state.clone());\n                    }\n                    if !state.indexing_active.load(AtomicOrdering::Acquire) {\n                        let (ignored_roots, ignored_patterns) =\n                            cached_effective_ignore_rules(&state);\n                        let rows = collect_rows_recursive(&path, &ignored_roots, &ignored_patterns);\n                        if !rows.is_empty() {\n                            eprintln!(\n                                \"[watcher] MustScanSubDirs DB write: rows={} path={}\",\n                                rows.len(),\n                                path.display()\n                            );\n                            if let Ok(mut conn) = db_connection(&state.db_path) {\n                                if upsert_rows(&mut conn, &rows).is_ok() {\n                                    invalidate_search_caches(&state);\n                                    touch_status_updated(&state);\n                                    if last_status_emit.elapsed() >= STATUS_EMIT_MIN_INTERVAL {\n                                        let _ = refresh_and_emit_status_counts(&app, &state);\n                                        last_status_emit = Instant::now();\n                                        pending_status_emit = false;\n                                    } else {\n                                        pending_status_emit = true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                Ok(mac::fsevent_watcher::FsEvent::HistoryDone) => {\n                    eprintln!(\n                        \"[watcher] HistoryDone: pending_paths={} indexing_active={}\",\n                        pending_paths.len(),\n                        state.indexing_active.load(AtomicOrdering::Acquire)\n                    );\n                    process_watcher_paths(\n                        &app,\n                        &state,\n                        &mut pending_paths,\n                        &mut deadline,\n                        &mut last_status_emit,\n                        &mut pending_status_emit,\n                    );\n                    if replay_phase {\n                        replay_phase = false;\n                        if !full_scan_triggered {\n                            perf_log(format!(\n                                \"conditional_startup: HistoryDone, MustScanSubDirs={}, skipping full scan\",\n                                must_scan_count\n                            ));\n                            let _ = refresh_and_emit_status_counts(&app, &state);\n                            last_status_emit = Instant::now();\n                            pending_status_emit = false;\n                        }\n                    }\n                }\n                Err(RecvTimeoutError::Timeout) => {}\n                Err(RecvTimeoutError::Disconnected) => break,\n            }\n\n            if let Some(due) = deadline {\n                if Instant::now() >= due {\n                    process_watcher_paths(\n                        &app,\n                        &state,\n                        &mut pending_paths,\n                        &mut deadline,\n                        &mut last_status_emit,\n                        &mut pending_status_emit,\n                    );\n                }\n            }\n\n            if pending_status_emit && last_status_emit.elapsed() >= STATUS_EMIT_MIN_INTERVAL {\n                let _ = refresh_and_emit_status_counts(&app, &state);\n                last_status_emit = Instant::now();\n                pending_status_emit = false;\n            }\n\n            // Periodic event_id flush\n            if last_flush.elapsed() >= EVENT_ID_FLUSH_INTERVAL {\n                let eid = watcher.last_event_id();\n                let _ = persist_event_id(&state.db_path, eid);\n                last_flush = Instant::now();\n            }\n\n            // Periodic count refresh to keep in-memory counts accurate\n            if last_count_refresh.elapsed() >= EVENT_ID_FLUSH_INTERVAL {\n                let _ = update_status_counts(&state);\n                last_count_refresh = Instant::now();\n            }\n        }\n\n        // Final flush on shutdown\n        let eid = watcher.last_event_id();\n        let _ = persist_event_id(&state.db_path, eid);\n        watcher.stop();\n    });\n}\n\nfn validate_new_name(new_name: &str) -> AppResult<String> {\n    let trimmed = new_name.trim();\n\n    if trimmed.is_empty() {\n        return Err(\"New name cannot be empty.\".to_string());\n    }\n    if trimmed.contains('/') {\n        return Err(\"New name cannot contain '/'.\".to_string());\n    }\n    if trimmed == \".\" || trimmed == \"..\" {\n        return Err(\"Invalid name.\".to_string());\n    }\n\n    Ok(trimmed.to_string())\n}\n\nfn row_to_entry(row: &rusqlite::Row<'_>) -> rusqlite::Result<EntryDto> {\n    Ok(EntryDto {\n        path: row.get(0)?,\n        name: row.get(1)?,\n        dir: row.get(2)?,\n        is_dir: row.get::<_, i64>(3)? == 1,\n        ext: row.get(4)?,\n        size: row.get(5)?,\n        mtime: row.get(6)?,\n    })\n}\n\n#[cfg(target_os = \"macos\")]\nfn safe_file_type(ext: &str) -> String {\n    if ext.eq_ignore_ascii_case(\"folder\") {\n        return \"public.folder\".to_string();\n    }\n\n    let filtered: String = ext\n        .chars()\n        .filter(|c| c.is_ascii_alphanumeric())\n        .collect::<String>()\n        .to_lowercase();\n\n    if filtered.is_empty() {\n        \"public.data\".to_string()\n    } else {\n        filtered\n    }\n}\n\n#[cfg(target_os = \"macos\")]\nfn load_system_icon_png(ext: &str) -> Option<Vec<u8>> {\n    let file_type = safe_file_type(ext);\n    let script = format!(\n        r#\"import AppKit\nimport Foundation\nlet image = NSWorkspace.shared.icon(forFileType: \"{file_type}\")\nimage.size = NSSize(width: 16, height: 16)\nif let tiff = image.tiffRepresentation,\n   let rep = NSBitmapImageRep(data: tiff),\n   let png = rep.representation(using: .png, properties: [:]) {{\n  FileHandle.standardOutput.write(png)\n}} else {{\n  exit(1)\n}}\n\"#\n    );\n\n    let output = Command::new(\"swift\").arg(\"-e\").arg(script).output().ok()?;\n    if output.status.success() && !output.stdout.is_empty() {\n        Some(output.stdout)\n    } else {\n        None\n    }\n}\n\n#[cfg(target_os = \"windows\")]\nfn load_system_icon_png(ext: &str) -> Option<Vec<u8>> {\n    win::icon::load_icon_png_by_ext(ext)\n}\n\n#[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\nfn load_system_icon_png(_ext: &str) -> Option<Vec<u8>> {\n    None\n}\n\n#[cfg(target_os = \"windows\")]\nfn is_per_file_icon_ext(ext: &str) -> bool {\n    matches!(ext, \"exe\" | \"lnk\" | \"ico\" | \"url\" | \"scr\" | \"appx\")\n}\n\n#[tauri::command]\nfn get_index_status(state: State<'_, AppState>) -> IndexStatusDto {\n    let started = Instant::now();\n    let snapshot = state.status.lock().clone();\n    let snapshot_state = snapshot.state.as_str().to_string();\n    let db_ready = state.db_ready.load(AtomicOrdering::Acquire);\n    let indexing_active = state.indexing_active.load(AtomicOrdering::Acquire);\n    let state_label = if matches!(snapshot.state, IndexState::Error) {\n        snapshot.state.as_str().to_string()\n    } else if matches!(snapshot.state, IndexState::Ready) {\n        \"Ready\".to_string()\n    } else if indexing_active || !db_ready {\n        \"Indexing\".to_string()\n    } else {\n        snapshot.state.as_str().to_string()\n    };\n    let dto = IndexStatusDto {\n        state: state_label,\n        entries_count: snapshot.entries_count,\n        last_updated: snapshot.last_updated,\n        permission_errors: snapshot.permission_errors,\n        message: snapshot.message,\n        scanned: snapshot.scanned,\n        indexed: snapshot.indexed,\n        current_path: snapshot.current_path,\n    };\n    if cfg!(debug_assertions) {\n        eprintln!(\n            \"[rpc/get_index_status] elapsed={}ms state={} snapshot_state={} db_ready={} indexing_active={} entries={} scanned={} indexed={}\",\n            started.elapsed().as_millis(),\n            dto.state,\n            snapshot_state,\n            db_ready,\n            indexing_active,\n            dto.entries_count,\n            dto.scanned,\n            dto.indexed,\n        );\n    }\n    dto\n}\n\n#[tauri::command]\nfn get_home_dir(state: State<'_, AppState>) -> String {\n    state.home_dir.to_string_lossy().to_string()\n}\n\n#[tauri::command]\nfn start_full_index(app: AppHandle, state: State<'_, AppState>) -> AppResult<()> {\n    #[cfg(target_os = \"windows\")]\n    {\n        win::start_windows_indexing(app, state.inner().clone());\n        Ok(())\n    }\n    #[cfg(not(target_os = \"windows\"))]\n    {\n        start_full_index_worker(app, state.inner().clone())\n    }\n}\n\n#[tauri::command]\nasync fn reset_index(app: AppHandle, state: State<'_, AppState>) -> AppResult<()> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        if state.indexing_active.load(AtomicOrdering::Acquire) {\n            return Err(\"Cannot reset while indexing is in progress.\".to_string());\n        }\n\n        // Stop existing file watcher and wait for it to fully exit\n        state.watcher_stop.store(true, AtomicOrdering::Release);\n        let deadline = std::time::Instant::now() + std::time::Duration::from_secs(5);\n        while state.watcher_active.load(AtomicOrdering::Acquire) {\n            if std::time::Instant::now() >= deadline {\n                eprintln!(\"[reset] watcher did not stop within 5s, proceeding anyway\");\n                break;\n            }\n            std::thread::sleep(std::time::Duration::from_millis(50));\n        }\n\n        let conn = db_connection(&state.db_path)?;\n        conn.execute(\"DELETE FROM entries\", [])\n            .map_err(|e| e.to_string())?;\n        conn.execute(\"DELETE FROM meta\", [])\n            .map_err(|e| e.to_string())?;\n\n        {\n            let mut status = state.status.lock();\n            status.state = IndexState::Indexing;\n            status.entries_count = 0;\n            status.last_updated = None;\n            status.permission_errors = 0;\n            status.message = None;\n            status.scanned = 0;\n            status.indexed = 0;\n            status.current_path.clear();\n        }\n\n        invalidate_search_caches(&state);\n\n        emit_index_state(&app, \"Indexing\", None);\n        emit_index_updated(&app, 0, now_epoch(), 0);\n\n        // Allow new watcher to start\n        state.watcher_stop.store(false, AtomicOrdering::Release);\n\n        #[cfg(target_os = \"windows\")]\n        {\n            win::start_windows_indexing(app, state);\n            Ok(())\n        }\n        #[cfg(not(target_os = \"windows\"))]\n        {\n            start_full_index_worker(app, state)\n        }\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\nfn log_search(db_path: &Path, query: &str, mode: &str, results: &[EntryDto]) {\n    if !search_log_enabled() {\n        return;\n    }\n\n    let log_path = db_path.with_file_name(\"search.log\");\n    let Ok(mut f) = fs::OpenOptions::new()\n        .create(true)\n        .append(true)\n        .open(&log_path)\n    else {\n        return;\n    };\n    let top: Vec<&str> = results.iter().take(10).map(|e| e.name.as_str()).collect();\n    let _ = writeln!(\n        f,\n        \"[{}] Q={:?} MODE={} COUNT={} TOP={:?}\",\n        now_epoch(),\n        query,\n        mode,\n        results.len(),\n        top,\n    );\n}\n\nfn search_log_enabled() -> bool {\n    *SEARCH_LOG_ENABLED.get_or_init(|| env_truthy(\"FASTFIND_SEARCH_LOG\"))\n}\n\n/// Returns the total number of entries matching `query` without LIMIT/OFFSET.\n/// Returns `None` when the total is unknown or intentionally skipped.\nfn compute_total_count(\n    db_path: &Path,\n    home_dir: &Path,\n    execution: &SearchExecution,\n) -> Option<u32> {\n    // When fewer results than the limit were returned the total is exact.\n    if (execution.results.len() as u32) < execution.effective_limit {\n        return Some(\n            execution\n                .offset\n                .saturating_add(execution.results.len() as u32),\n        );\n    }\n    // For paginated pages after the first we leave total tracking to the frontend.\n    if execution.offset > 0 {\n        return None;\n    }\n    // Non-SQL fast paths already return all matching entries.\n    if execution.mode_label.starts_with(\"mem_\")\n        || execution.mode_label == \"spotlight\"\n        || execution.mode_label == \"spotlight_timeout\"\n        || execution.mode_label == \"find_fallback\"\n        || execution.mode_label == \"name_neg_cache\"\n    {\n        return Some(execution.results.len() as u32);\n    }\n    let Ok(conn) = db_connection_for_search(db_path) else {\n        return None;\n    };\n    let mode = parse_query(&execution.query);\n    let total = match mode {\n        SearchMode::Empty => conn\n            .query_row(\"SELECT COUNT(*) FROM entries\", [], |r| r.get(0))\n            .unwrap_or(0),\n        SearchMode::NameSearch { name_like } => {\n            let escaped = escape_like(&execution.query);\n            let prefix_like = format!(\"{}%\", escaped);\n            let prefix_count: u32 = conn\n                .query_row(\n                    \"SELECT COUNT(*) FROM entries WHERE name LIKE ?1 ESCAPE '\\\\'\",\n                    params![prefix_like],\n                    |r| r.get(0),\n                )\n                .unwrap_or(0);\n            if prefix_count > 0 {\n                prefix_count\n            } else {\n                // Phase-2 contains fallback was used.\n                conn.query_row(\n                    \"SELECT COUNT(*) FROM entries WHERE name LIKE ?1 ESCAPE '\\\\'\",\n                    params![name_like],\n                    |r| r.get(0),\n                )\n                .unwrap_or(0)\n            }\n        }\n        SearchMode::GlobName { name_like } => conn\n            .query_row(\n                \"SELECT COUNT(*) FROM entries WHERE name LIKE ?1 ESCAPE '\\\\'\",\n                params![name_like],\n                |r| r.get(0),\n            )\n            .unwrap_or(0),\n        SearchMode::ExtSearch { ext, .. } => conn\n            .query_row(\n                \"SELECT COUNT(*) FROM entries WHERE ext = ?1\",\n                params![ext],\n                |r| r.get(0),\n            )\n            .unwrap_or(0),\n        SearchMode::PathSearch {\n            name_like,\n            dir_hint,\n            ..\n        } => {\n            let resolved_dirs = resolve_dir_hint(home_dir, &dir_hint)\n                .map(|p| vec![p.to_string_lossy().to_string()])\n                .unwrap_or_default();\n            let resolved_dirs = if resolved_dirs.is_empty() {\n                resolve_dirs_from_db(&conn, &dir_hint)\n            } else {\n                resolved_dirs\n            };\n\n            if !resolved_dirs.is_empty() {\n                let mut sql_params: Vec<SqlValue> = Vec::new();\n                let mut dir_conditions = Vec::new();\n                let sep = std::path::MAIN_SEPARATOR;\n                for d in &resolved_dirs {\n                    let i = sql_params.len();\n                    let pfx = format!(\"{d}{sep}\");\n                    let pfx_end = format!(\"{d}\\x7F\");\n                    sql_params.push(SqlValue::Text(d.clone()));\n                    sql_params.push(SqlValue::Text(pfx));\n                    sql_params.push(SqlValue::Text(pfx_end));\n                    dir_conditions.push(format!(\n                        \"(e.dir = ?{} OR (e.dir >= ?{} AND e.dir < ?{}))\",\n                        i + 1,\n                        i + 2,\n                        i + 3\n                    ));\n                }\n                let dir_where = dir_conditions.join(\" OR \");\n                let name_filter = if name_like == \"%\" {\n                    String::new()\n                } else {\n                    let ext_shortcut = extract_ext_from_like(&name_like);\n                    if let Some(ext_val) = ext_shortcut {\n                        let i = sql_params.len();\n                        sql_params.push(SqlValue::Text(ext_val));\n                        format!(\" AND e.ext = ?{}\", i + 1)\n                    } else {\n                        let i = sql_params.len();\n                        sql_params.push(SqlValue::Text(name_like.clone()));\n                        format!(\" AND e.name LIKE ?{} ESCAPE '\\\\'\", i + 1)\n                    }\n                };\n                let sql =\n                    format!(\"SELECT COUNT(*) FROM entries e WHERE ({dir_where}){name_filter}\");\n                conn.query_row(&sql, params_from_iter(sql_params.iter()), |r| r.get(0))\n                    .unwrap_or(0)\n            } else {\n                let sep = std::path::MAIN_SEPARATOR;\n                let native_hint = dir_hint.replace('/', &sep.to_string());\n                let escaped_sep = escape_like(&sep.to_string());\n                let dir_suffix = escape_like(&native_hint);\n                let dir_like_exact = format!(\"%{escaped_sep}{dir_suffix}\");\n                let dir_like_sub = format!(\"%{escaped_sep}{dir_suffix}{escaped_sep}%\");\n                let ext_shortcut = extract_ext_from_like(&name_like);\n                if let Some(ext_val) = ext_shortcut {\n                    conn.query_row(\n                        \"SELECT COUNT(*) FROM entries e WHERE e.ext = ?1 AND (e.dir LIKE ?2 ESCAPE '\\\\' OR e.dir LIKE ?3 ESCAPE '\\\\')\",\n                        params![ext_val, dir_like_exact, dir_like_sub],\n                        |r| r.get(0),\n                    )\n                    .unwrap_or(0)\n                } else if name_like == \"%\" {\n                    conn.query_row(\n                        \"SELECT COUNT(*) FROM entries e WHERE e.dir LIKE ?1 ESCAPE '\\\\' OR e.dir LIKE ?2 ESCAPE '\\\\'\",\n                        params![dir_like_exact, dir_like_sub],\n                        |r| r.get(0),\n                    )\n                    .unwrap_or(0)\n                } else {\n                    conn.query_row(\n                        \"SELECT COUNT(*) FROM entries e WHERE (e.dir LIKE ?1 ESCAPE '\\\\' OR e.dir LIKE ?2 ESCAPE '\\\\') AND e.name LIKE ?3 ESCAPE '\\\\'\",\n                        params![dir_like_exact, dir_like_sub, name_like],\n                        |r| r.get(0),\n                    )\n                    .unwrap_or(0)\n                }\n            }\n        }\n    };\n\n    Some(total)\n}\n\nfn execute_search(\n    state: &AppState,\n    query: String,\n    limit: Option<u32>,\n    offset: Option<u32>,\n    sort_by: Option<String>,\n    sort_dir: Option<String>,\n) -> AppResult<SearchExecution> {\n    let query = query.trim().to_string();\n    let base_limit = limit.unwrap_or(DEFAULT_LIMIT).clamp(1, MAX_LIMIT);\n    let effective_limit = if !query.is_empty() && query.chars().count() <= 1 {\n        base_limit.min(SHORT_QUERY_LIMIT)\n    } else {\n        base_limit\n    };\n    let offset = offset.unwrap_or(0);\n\n    let sort_by = sort_by.unwrap_or_else(|| \"name\".to_string());\n    let sort_dir = sort_dir.unwrap_or_else(|| \"asc\".to_string());\n    let (runtime_ignored_roots, runtime_ignored_patterns) = cached_effective_ignore_rules(state);\n\n    #[cfg(target_os = \"macos\")]\n    if !state.db_ready.load(AtomicOrdering::Acquire) {\n        let spotlight = mac::spotlight_search::search_spotlight(&state.home_dir, &query);\n        let mode_label = if spotlight.entries.is_empty() {\n            \"db_not_ready\".to_string()\n        } else if spotlight.timed_out {\n            \"spotlight_timeout\".to_string()\n        } else {\n            \"spotlight\".to_string()\n        };\n        perf_log(format!(\n            \"spotlight_fallback db_not_ready query={:?} results={} timed_out={}\",\n            query,\n            spotlight.entries.len(),\n            spotlight.timed_out\n        ));\n        return Ok(SearchExecution {\n            query,\n            sort_by,\n            sort_dir,\n            effective_limit,\n            offset,\n            mode_label,\n            results: spotlight.entries,\n        });\n    }\n\n    let is_indexing = matches!(state.status.lock().state, IndexState::Indexing);\n    let order_by = sort_clause(&sort_by, &sort_dir, \"e.\");\n\n    let mut results = Vec::with_capacity(effective_limit as usize);\n    let mode = parse_query(&query);\n    let is_name_mode = matches!(&mode, SearchMode::NameSearch { .. });\n    let allow_find_fallback = !is_indexing\n        && matches!(\n            &mode,\n            SearchMode::GlobName { .. } | SearchMode::ExtSearch { .. }\n        );\n    let mut mode_label = match &mode {\n        SearchMode::Empty => \"empty\",\n        SearchMode::NameSearch { .. } => \"name\",\n        SearchMode::GlobName { .. } => \"glob\",\n        SearchMode::ExtSearch { .. } => \"ext\",\n        SearchMode::PathSearch { .. } => \"path\",\n    }\n    .to_string();\n\n    // Fast path: search in-memory index if available (DB upsert still in progress)\n    {\n        let guard = state.mem_index.read();\n        if let Some(ref mi) = *guard {\n            let mem_results = mem_search::search_mem_index(\n                mi, &query, &mode, effective_limit, offset, &sort_by, &sort_dir,\n            );\n            mode_label = format!(\"mem_{mode_label}\");\n            return Ok(SearchExecution {\n                query,\n                sort_by,\n                sort_dir,\n                effective_limit,\n                offset,\n                mode_label,\n                results: mem_results,\n            });\n        }\n    }\n\n    if is_name_mode && !is_indexing && offset == 0 {\n        if let Some(cache_hit) = negative_name_cache_lookup(state, &query) {\n            if cache_hit.age >= WATCH_DEBOUNCE\n                && cache_hit.age <= NEGATIVE_CACHE_FALLBACK_WINDOW\n                && !cache_hit.fallback_checked\n            {\n                let fallback_results = find_search(\n                    &state.home_dir,\n                    &runtime_ignored_roots,\n                    &runtime_ignored_patterns,\n                    &query,\n                    effective_limit as usize,\n                    &sort_by,\n                    &sort_dir,\n                );\n                if !fallback_results.is_empty() {\n                    remove_negative_name_query(state, &cache_hit.query_lower);\n                    perf_log(format!(\n                        \"search_negative_cache_fallback_hit query={:?} age_ms={} results={}\",\n                        query,\n                        cache_hit.age.as_millis(),\n                        fallback_results.len()\n                    ));\n                    return Ok(SearchExecution {\n                        query,\n                        sort_by,\n                        sort_dir,\n                        effective_limit,\n                        offset,\n                        mode_label: \"find_fallback\".to_string(),\n                        results: fallback_results,\n                    });\n                }\n                mark_negative_name_fallback_checked(state, &cache_hit.query_lower);\n            }\n\n            perf_log(format!(\n                \"search_negative_cache_hit query={:?} age_ms={}\",\n                query,\n                cache_hit.age.as_millis()\n            ));\n            return Ok(SearchExecution {\n                query,\n                sort_by,\n                sort_dir,\n                effective_limit,\n                offset,\n                mode_label: \"name_neg_cache\".to_string(),\n                results: Vec::new(),\n            });\n        }\n    }\n\n    #[cfg(target_os = \"macos\")]\n    let db_unavailable;\n    match db_connection_for_search(&state.db_path) {\n        Ok(conn) => {\n            #[cfg(target_os = \"macos\")]\n            { db_unavailable = false; }\n            match &mode {\n                SearchMode::Empty => {\n                    let sql = format!(\n                        r#\"\n                        SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                        FROM entries e\n                        ORDER BY {order_by}\n                        LIMIT ?1 OFFSET ?2\n                        \"#,\n                    );\n                    let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                    let rows = stmt\n                        .query_map(params![effective_limit, offset], row_to_entry)\n                        .map_err(|e| e.to_string())?;\n                    for row in rows {\n                        results.push(row.map_err(|e| e.to_string())?);\n                    }\n                }\n\n                SearchMode::NameSearch { name_like } => {\n                    let escaped_query = escape_like(&query);\n                    let exact_query = query.clone();\n                    let prefix_like = format!(\"{}%\", escaped_query);\n                    let bare_order = sort_clause(&sort_by, &sort_dir, \"\");\n\n                    if offset == 0 {\n                        let exact_sql = format!(\n                            r#\"\n                            SELECT path, name, dir, is_dir, ext, size, mtime\n                            FROM entries\n                            WHERE name COLLATE NOCASE = ?1\n                            ORDER BY {bare_order}\n                            LIMIT ?2\n                            \"#,\n                        );\n                        let mut stmt = conn.prepare(&exact_sql).map_err(|e| e.to_string())?;\n                        let rows = stmt\n                            .query_map(params![exact_query, effective_limit], row_to_entry)\n                            .map_err(|e| e.to_string())?;\n                        for row in rows {\n                            results.push(row.map_err(|e| e.to_string())?);\n                        }\n                    }\n\n                    if (results.len() as u32) < effective_limit {\n                        let remaining = effective_limit - results.len() as u32;\n                        let adj_offset = if offset > 0 {\n                            offset.saturating_sub(results.len() as u32)\n                        } else {\n                            0\n                        };\n\n                        // Try indexed prefix search first; fall back to unindexed if\n                        // the index is temporarily unavailable (during background DB\n                        // rebuild the index may be dropped then recreated).\n                        let prefix_sql_indexed = format!(\n                            r#\"\n                            SELECT path, name, dir, is_dir, ext, size, mtime\n                            FROM entries INDEXED BY idx_entries_name_nocase\n                            WHERE name LIKE ?1 ESCAPE '\\'\n                              AND name COLLATE NOCASE != ?2\n                            ORDER BY {bare_order}\n                            LIMIT ?3 OFFSET ?4\n                            \"#,\n                        );\n                        let prefix_sql_fallback = format!(\n                            r#\"\n                            SELECT path, name, dir, is_dir, ext, size, mtime\n                            FROM entries\n                            WHERE name LIKE ?1 ESCAPE '\\'\n                              AND name COLLATE NOCASE != ?2\n                            ORDER BY {bare_order}\n                            LIMIT ?3 OFFSET ?4\n                            \"#,\n                        );\n                        let mut stmt = match conn.prepare(&prefix_sql_indexed) {\n                            Ok(s) => s,\n                            Err(_) => {\n                                eprintln!(\"[search] idx_entries_name_nocase unavailable, using fallback\");\n                                conn.prepare(&prefix_sql_fallback).map_err(|e| e.to_string())?\n                            }\n                        };\n                        let rows = stmt\n                            .query_map(\n                                params![prefix_like, exact_query, remaining, adj_offset],\n                                row_to_entry,\n                            )\n                            .map_err(|e| e.to_string())?;\n                        for row in rows {\n                            results.push(row.map_err(|e| e.to_string())?);\n                        }\n                    }\n\n                    if results.is_empty() && offset == 0 {\n                        // Phase 2: contains-match (LIKE '%q%') with tight time budget.\n                        // Combines probe + fetch in one pass to avoid double scan overhead.\n                        let phase2_start = Instant::now();\n                        conn.progress_handler(\n                            2_000,\n                            Some(move || phase2_start.elapsed().as_millis() > 5),\n                        );\n\n                        {\n\n                            let phase2_sql = format!(\n                                r#\"\n                                SELECT path, name, dir, is_dir, ext, size, mtime\n                                FROM entries\n                                WHERE name LIKE ?1 ESCAPE '\\'\n                                  AND name COLLATE NOCASE != ?2\n                                  AND name NOT LIKE ?3 ESCAPE '\\'\n                                ORDER BY {bare_order}\n                                LIMIT ?4\n                                \"#,\n                            );\n                            if let Ok(mut stmt2) = conn.prepare(&phase2_sql) {\n                                if let Ok(rows2) = stmt2.query_map(\n                                    params![name_like, exact_query, prefix_like, effective_limit],\n                                    row_to_entry,\n                                ) {\n                                    for row in rows2 {\n                                        match row {\n                                            Ok(entry) => results.push(entry),\n                                            Err(_) => break,\n                                        }\n                                    }\n                                }\n                            }\n                        }\n\n                        conn.progress_handler(0, None::<fn() -> bool>);\n                    }\n                }\n\n                SearchMode::GlobName { name_like } => {\n                    let sql = format!(\n                        r#\"\n                        SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                        FROM entries e\n                        WHERE e.name LIKE ?1 ESCAPE '\\'\n                        ORDER BY {order_by}\n                        LIMIT ?2 OFFSET ?3\n                        \"#,\n                    );\n                    let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                    let rows = stmt\n                        .query_map(params![name_like, effective_limit, offset], row_to_entry)\n                        .map_err(|e| e.to_string())?;\n                    for row in rows {\n                        results.push(row.map_err(|e| e.to_string())?);\n                    }\n                }\n\n                SearchMode::ExtSearch { ext, name_like: _ } => {\n                    let sql = format!(\n                        r#\"\n                        SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                        FROM entries e\n                        WHERE e.ext = ?1\n                        ORDER BY {order_by}\n                        LIMIT ?2 OFFSET ?3\n                        \"#,\n                    );\n                    let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                    let rows = stmt\n                        .query_map(params![ext, effective_limit, offset], row_to_entry)\n                        .map_err(|e| e.to_string())?;\n                    for row in rows {\n                        results.push(row.map_err(|e| e.to_string())?);\n                    }\n                }\n\n                SearchMode::PathSearch {\n                    path_like: _,\n                    name_like,\n                    dir_hint,\n                } => {\n                    let resolved_dirs: Vec<String> = resolve_dir_hint(&state.home_dir, dir_hint)\n                        .map(|p| vec![p.to_string_lossy().to_string()])\n                        .unwrap_or_default();\n                    let resolved_dirs = if resolved_dirs.is_empty() {\n                        resolve_dirs_from_db(&conn, dir_hint)\n                    } else {\n                        resolved_dirs\n                    };\n\n                    if !resolved_dirs.is_empty() {\n                        let ext_shortcut = extract_ext_from_like(name_like);\n                        let mut sql_params: Vec<SqlValue> = Vec::new();\n                        let mut dir_conditions = Vec::new();\n                        let sep = std::path::MAIN_SEPARATOR;\n\n                        for d in &resolved_dirs {\n                            let i = sql_params.len();\n                            let pfx = format!(\"{d}{sep}\");\n                            let pfx_end = format!(\"{d}\\x7F\");\n                            sql_params.push(SqlValue::Text(d.clone()));\n                            sql_params.push(SqlValue::Text(pfx));\n                            sql_params.push(SqlValue::Text(pfx_end));\n                            dir_conditions.push(format!(\n                                \"(e.dir = ?{} OR (e.dir >= ?{} AND e.dir < ?{}))\",\n                                i + 1,\n                                i + 2,\n                                i + 3\n                            ));\n                        }\n                        let dir_where = dir_conditions.join(\" OR \");\n\n                        let name_filter = if name_like == \"%\" {\n                            String::new()\n                        } else if let Some(ref ext_val) = ext_shortcut {\n                            let i = sql_params.len();\n                            sql_params.push(SqlValue::Text(ext_val.clone()));\n                            format!(\" AND e.ext = ?{}\", i + 1)\n                        } else {\n                            let i = sql_params.len();\n                            sql_params.push(SqlValue::Text(name_like.clone()));\n                            format!(\" AND e.name LIKE ?{} ESCAPE '\\\\'\", i + 1)\n                        };\n\n                        let limit_idx = sql_params.len() + 1;\n                        let offset_idx = sql_params.len() + 2;\n                        sql_params.push(SqlValue::Integer(effective_limit as i64));\n                        sql_params.push(SqlValue::Integer(offset as i64));\n\n                        let sql = format!(\n                            r#\"\n                            SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                            FROM entries e\n                            WHERE ({dir_where}){name_filter}\n                            ORDER BY {order_by}\n                            LIMIT ?{limit_idx} OFFSET ?{offset_idx}\n                            \"#,\n                        );\n                        let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                        let rows = stmt\n                            .query_map(params_from_iter(sql_params.iter()), row_to_entry)\n                            .map_err(|e| e.to_string())?;\n                        for row in rows {\n                            results.push(row.map_err(|e| e.to_string())?);\n                        }\n                    } else {\n                        let sep = std::path::MAIN_SEPARATOR;\n                        let sep_str = sep.to_string();\n                        let escaped_sep = escape_like(&sep_str);\n                        let (native_hint, is_absolute) = normalize_hint_to_native(dir_hint);\n                        let dir_suffix = escape_like(&native_hint);\n                        let dir_prefix = if is_absolute {\n                            String::new()\n                        } else {\n                            escaped_sep.clone()\n                        };\n                        let dir_like_exact = format!(\"%{dir_prefix}{dir_suffix}\");\n                        let dir_like_sub = format!(\"%{dir_prefix}{dir_suffix}{escaped_sep}%\");\n                        let ext_shortcut = extract_ext_from_like(name_like);\n\n                        if let Some(ext_val) = ext_shortcut {\n                            let sql = format!(\n                                r#\"\n                                SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                                FROM entries e\n                                WHERE e.ext = ?1\n                                  AND (e.dir LIKE ?2 ESCAPE '\\' OR e.dir LIKE ?3 ESCAPE '\\')\n                                ORDER BY {order_by}\n                                LIMIT ?4 OFFSET ?5\n                                \"#,\n                            );\n                            let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                            let rows = stmt\n                                .query_map(\n                                    params![\n                                        ext_val,\n                                        dir_like_exact,\n                                        dir_like_sub,\n                                        effective_limit,\n                                        offset\n                                    ],\n                                    row_to_entry,\n                                )\n                                .map_err(|e| e.to_string())?;\n                            for row in rows {\n                                results.push(row.map_err(|e| e.to_string())?);\n                            }\n                        } else if name_like == \"%\" {\n                            // Directory listing: no name filter needed, no time budget\n                            let sql = format!(\n                                r#\"\n                                SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                                FROM entries e\n                                WHERE e.dir LIKE ?1 ESCAPE '\\' OR e.dir LIKE ?2 ESCAPE '\\'\n                                ORDER BY {order_by}\n                                LIMIT ?3 OFFSET ?4\n                                \"#,\n                            );\n                            let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                            let rows = stmt\n                                .query_map(\n                                    params![dir_like_exact, dir_like_sub, effective_limit, offset],\n                                    row_to_entry,\n                                )\n                                .map_err(|e| e.to_string())?;\n                            for row in rows {\n                                results.push(row.map_err(|e| e.to_string())?);\n                            }\n                        } else {\n                            // Phase A: fast prefix search via name index\n                            // \"%main%\" -> strip leading '%' -> \"main%\" can use idx_entries_name_nocase\n                            let prefix_like = if name_like.starts_with('%') {\n                                let rest = &name_like[1..];\n                                if !rest.is_empty() && !rest.starts_with('%') {\n                                    Some(rest.to_string())\n                                } else {\n                                    None\n                                }\n                            } else {\n                                // Already a prefix pattern (e.g. \"test%\"), use as-is\n                                Some(name_like.clone())\n                            };\n\n                            if offset == 0 {\n                                if let Some(ref pfx) = prefix_like {\n                                    let sql = format!(\n                                        r#\"\n                                        SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                                        FROM entries e INDEXED BY idx_entries_name_nocase\n                                        WHERE e.name LIKE ?1 ESCAPE '\\'\n                                          AND (e.dir LIKE ?2 ESCAPE '\\' OR e.dir LIKE ?3 ESCAPE '\\')\n                                        ORDER BY {order_by}\n                                        LIMIT ?4\n                                        \"#,\n                                    );\n                                    if let Ok(mut stmt) = conn.prepare(&sql) {\n                                        if let Ok(rows) = stmt.query_map(\n                                            params![\n                                                pfx,\n                                                dir_like_exact,\n                                                dir_like_sub,\n                                                effective_limit\n                                            ],\n                                            row_to_entry,\n                                        ) {\n                                            for row in rows {\n                                                match row {\n                                                    Ok(entry) => results.push(entry),\n                                                    Err(_) => break,\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n\n                            // Phase B: time-budgeted contains fallback if prefix found too few\n                            if results.len() < effective_limit as usize {\n                                let path_start = Instant::now();\n                                conn.progress_handler(\n                                    2_000,\n                                    Some(move || path_start.elapsed().as_millis() > 5),\n                                );\n\n                                let sql = format!(\n                                    r#\"\n                                    SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                                    FROM entries e\n                                    WHERE (e.dir LIKE ?1 ESCAPE '\\' OR e.dir LIKE ?2 ESCAPE '\\')\n                                      AND e.name LIKE ?3 ESCAPE '\\'\n                                    ORDER BY {order_by}\n                                    LIMIT ?4 OFFSET ?5\n                                    \"#,\n                                );\n                                if let Ok(mut stmt) = conn.prepare(&sql) {\n                                    if let Ok(rows) = stmt.query_map(\n                                        params![\n                                            dir_like_exact,\n                                            dir_like_sub,\n                                            name_like,\n                                            effective_limit,\n                                            offset\n                                        ],\n                                        row_to_entry,\n                                    ) {\n                                        for row in rows {\n                                            match row {\n                                                Ok(entry) => results.push(entry),\n                                                Err(_) => break,\n                                            }\n                                        }\n                                    }\n                                }\n\n                                conn.progress_handler(0, None::<fn() -> bool>);\n\n                                // Deduplicate (Phase A prefix results overlap with Phase B contains)\n                                let mut seen = std::collections::HashSet::new();\n                                results.retain(|e| seen.insert(e.path.clone()));\n                                results.truncate(effective_limit as usize);\n                            }\n                        }\n                    }\n                }\n            }\n\n            if results.is_empty() && !query.is_empty() && offset == 0 && allow_find_fallback {\n                results = find_search(\n                    &state.home_dir,\n                    &runtime_ignored_roots,\n                    &runtime_ignored_patterns,\n                    &query,\n                    effective_limit as usize,\n                    &sort_by,\n                    &sort_dir,\n                );\n                mode_label = \"find_fallback\".to_string();\n            }\n        }\n        Err(_) => {\n            #[cfg(target_os = \"macos\")]\n            { db_unavailable = true; }\n            perf_log(format!(\"search_db_unavailable query={:?}\", query));\n        }\n    }\n\n    #[cfg(target_os = \"macos\")]\n    if !query.is_empty() && offset == 0 {\n        let should_spotlight = if results.is_empty() {\n            true\n        } else if results.len() >= effective_limit as usize {\n            false\n        } else {\n            is_indexing || db_unavailable\n        };\n        if should_spotlight {\n            let spotlight = mac::spotlight_search::search_spotlight(&state.home_dir, &query);\n            if !spotlight.entries.is_empty() {\n                if results.is_empty() {\n                    perf_log(format!(\n                        \"spotlight_fallback empty_results query={:?} results={} timed_out={}\",\n                        query,\n                        spotlight.entries.len(),\n                        spotlight.timed_out\n                    ));\n                    results = spotlight.entries;\n                    mode_label = if spotlight.timed_out {\n                        \"spotlight_timeout\".to_string()\n                    } else {\n                        \"spotlight\".to_string()\n                    };\n                } else {\n                    let existing_paths: std::collections::HashSet<String> =\n                        results.iter().map(|e| e.path.clone()).collect();\n                    let mut merged_count = 0usize;\n                    for entry in spotlight.entries {\n                        if !existing_paths.contains(&entry.path) {\n                            results.push(entry);\n                            merged_count += 1;\n                        }\n                    }\n                    if merged_count > 0 {\n                        perf_log(format!(\n                            \"spotlight_merge indexing query={:?} merged={} timed_out={}\",\n                            query, merged_count, spotlight.timed_out\n                        ));\n                        mode_label = format!(\"{}_+spotlight\", mode_label);\n                    }\n                }\n            }\n        }\n    }\n\n    results = filter_ignored_entries(results, &runtime_ignored_roots, &runtime_ignored_patterns);\n    results.truncate(effective_limit as usize);\n    if offset == 0 {\n        if sort_by == \"name\" {\n            sort_entries_with_relevance(&mut results, &query, &sort_by, &sort_dir);\n        } else {\n            sort_entries(&mut results, &sort_by, &sort_dir);\n        }\n    }\n    if is_name_mode && !is_indexing && offset == 0 && results.is_empty() && !query.is_empty() {\n        remember_negative_name_query(state, &query);\n    }\n\n    Ok(SearchExecution {\n        query,\n        sort_by,\n        sort_dir,\n        effective_limit,\n        offset,\n        mode_label,\n        results,\n    })\n}\n\n#[tauri::command]\nasync fn search(\n    _app: AppHandle,\n    query: String,\n    limit: Option<u32>,\n    offset: Option<u32>,\n    sort_by: Option<String>,\n    sort_dir: Option<String>,\n    include_total: Option<bool>,\n    state: State<'_, AppState>,\n) -> AppResult<SearchResultDto> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        let rpc_started = Instant::now();\n        let execute_started = Instant::now();\n        let execution = execute_search(&state, query, limit, offset, sort_by, sort_dir)?;\n        let execute_elapsed_ms = execute_started.elapsed().as_secs_f64() * 1000.0;\n\n        log_search(\n            &state.db_path,\n            &execution.query,\n            &execution.mode_label,\n            &execution.results,\n        );\n\n        if perf_log_enabled() {\n            let top: Vec<&str> = execution\n                .results\n                .iter()\n                .take(5)\n                .map(|entry| entry.name.as_str())\n                .collect();\n            perf_log(format!(\n                \"search query={:?} mode={} sort={}/{} limit={} offset={} results={} elapsed_ms={:.3} top={:?}\",\n                execution.query,\n                execution.mode_label,\n                execution.sort_by,\n                execution.sort_dir,\n                execution.effective_limit,\n                execution.offset,\n                execution.results.len(),\n                execute_elapsed_ms,\n                top,\n            ));\n        }\n\n        let include_total = include_total.unwrap_or(true);\n        let count_started = Instant::now();\n        let (total_count, total_known) = if include_total {\n            match compute_total_count(&state.db_path, &state.home_dir, &execution) {\n                Some(v) => (v, true),\n                None => (0, false),\n            }\n        } else {\n            (0, false)\n        };\n        let count_elapsed_ms = if include_total {\n            count_started.elapsed().as_secs_f64() * 1000.0\n        } else {\n            0.0\n        };\n\n        let rpc_elapsed_ms = rpc_started.elapsed().as_secs_f64() * 1000.0;\n        if cfg!(debug_assertions) {\n            let db_ready = state.db_ready.load(AtomicOrdering::Acquire);\n            let indexing_active = state.indexing_active.load(AtomicOrdering::Acquire);\n            eprintln!(\n                \"[rpc/search] total={:.3}ms execute={:.3}ms total_count={:.3}ms include_total={} query={:?} mode={} sort={}/{} limit={} offset={} results={} total_count={} total_known={} db_ready={} indexing_active={}\",\n                rpc_elapsed_ms,\n                execute_elapsed_ms,\n                count_elapsed_ms,\n                include_total,\n                execution.query,\n                execution.mode_label,\n                execution.sort_by,\n                execution.sort_dir,\n                execution.effective_limit,\n                execution.offset,\n                execution.results.len(),\n                total_count,\n                total_known,\n                db_ready,\n                indexing_active,\n            );\n        }\n        Ok(SearchResultDto {\n            entries: execution.results,\n            mode_label: execution.mode_label,\n            total_count,\n            total_known,\n        })\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nasync fn quick_look(path: String) -> AppResult<()> {\n    tauri::async_runtime::spawn_blocking(move || {\n        #[cfg(target_os = \"macos\")]\n        {\n            Command::new(\"qlmanage\")\n                .args([\"-p\", &path])\n                .stdout(std::process::Stdio::null())\n                .stderr(std::process::Stdio::null())\n                .spawn()\n                .map_err(|e| e.to_string())?;\n        }\n        #[cfg(target_os = \"windows\")]\n        {\n            Command::new(\"explorer\")\n                .arg(&path)\n                .spawn()\n                .map_err(|e| e.to_string())?;\n        }\n        #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n        {\n            Command::new(\"xdg-open\")\n                .arg(&path)\n                .spawn()\n                .map_err(|e| e.to_string())?;\n        }\n        Ok(())\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nasync fn open(paths: Vec<String>) -> AppResult<()> {\n    tauri::async_runtime::spawn_blocking(move || {\n        for path in &paths {\n            #[cfg(target_os = \"macos\")]\n            {\n                let output = Command::new(\"open\")\n                    .arg(path)\n                    .output()\n                    .map_err(|e| e.to_string())?;\n\n                if !output.status.success() && Path::new(path).is_dir() {\n                    let fallback = Command::new(\"open\")\n                        .args([\"-R\", path])\n                        .status()\n                        .map_err(|e| e.to_string())?;\n\n                    if !fallback.success() {\n                        return Err(format!(\"Failed to open: {path}\"));\n                    }\n                } else if !output.status.success() {\n                    let stderr = String::from_utf8_lossy(&output.stderr);\n                    return Err(format!(\"Failed to open: {path} ({stderr})\",));\n                }\n            }\n            #[cfg(target_os = \"windows\")]\n            {\n                let mut cmd = Command::new(\"cmd\");\n                cmd.raw_arg(format!(\"/C start \\\"\\\" \\\"{}\\\"\", path.replace('\"', \"\")));\n                let status = cmd.status().map_err(|e| e.to_string())?;\n                if !status.success() {\n                    return Err(format!(\"Failed to open: {path}\"));\n                }\n            }\n            #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n            {\n                let status = Command::new(\"xdg-open\")\n                    .arg(path)\n                    .status()\n                    .map_err(|e| e.to_string())?;\n                if !status.success() {\n                    return Err(format!(\"Failed to open: {path}\"));\n                }\n            }\n        }\n\n        Ok(())\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\nfn reveal_in_finder_impl(paths: Vec<String>) -> AppResult<()> {\n    if paths.is_empty() {\n        return Ok(());\n    }\n\n    #[cfg(target_os = \"macos\")]\n    {\n        if paths.len() == 1 {\n            let status = Command::new(\"open\")\n                .arg(\"-R\")\n                .arg(&paths[0])\n                .status()\n                .map_err(|e| e.to_string())?;\n\n            if !status.success() {\n                return Err(format!(\"Failed to reveal in Finder: {}\", paths[0]));\n            }\n\n            return Ok(());\n        }\n\n        let mut unique_parents: HashSet<PathBuf> = HashSet::new();\n        for path in &paths {\n            let p = PathBuf::from(path);\n            if let Some(parent) = p.parent() {\n                unique_parents.insert(parent.to_path_buf());\n            }\n        }\n\n        for parent in unique_parents {\n            let status = Command::new(\"open\")\n                .arg(&parent)\n                .status()\n                .map_err(|e| e.to_string())?;\n\n            if !status.success() {\n                return Err(format!(\n                    \"Failed to open in Finder: {}\",\n                    parent.to_string_lossy()\n                ));\n            }\n        }\n    }\n\n    #[cfg(target_os = \"windows\")]\n    {\n        for path in &paths {\n            let mut cmd = Command::new(\"explorer\");\n            cmd.raw_arg(format!(\"/select,\\\"{}\\\"\", path.replace('\"', \"\")));\n            let _ = cmd.status();\n        }\n    }\n\n    #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n    {\n        for path in &paths {\n            let target = Path::new(path);\n            let dir = if target.is_dir() {\n                path.as_str()\n            } else {\n                target\n                    .parent()\n                    .map(|p| p.to_str().unwrap_or(\"/\"))\n                    .unwrap_or(\"/\")\n            };\n            let _ = Command::new(\"xdg-open\").arg(dir).status();\n        }\n    }\n\n    Ok(())\n}\n\nfn copy_with_command(program: &str, args: &[&str], text: &str) -> AppResult<()> {\n    let mut child = Command::new(program)\n        .args(args)\n        .stdin(Stdio::piped())\n        .spawn()\n        .map_err(|e| format!(\"Failed to run {program}: {e}\"))?;\n\n    if let Some(mut stdin) = child.stdin.take() {\n        stdin\n            .write_all(text.as_bytes())\n            .map_err(|e| format!(\"Failed to write to clipboard: {e}\"))?;\n    } else {\n        return Err(\"Cannot open clipboard input stream.\".to_string());\n    }\n\n    let status = child\n        .wait()\n        .map_err(|e| format!(\"Failed to wait for {program}: {e}\"))?;\n\n    if status.success() {\n        Ok(())\n    } else {\n        Err(format!(\"{program} execution failed.\"))\n    }\n}\n\n#[cfg(target_os = \"macos\")]\nfn copy_text_to_clipboard(text: &str) -> AppResult<()> {\n    copy_with_command(\"pbcopy\", &[], text)\n}\n\n#[cfg(target_os = \"windows\")]\nfn copy_text_to_clipboard(text: &str) -> AppResult<()> {\n    copy_with_command(\"cmd\", &[\"/C\", \"clip\"], text)\n}\n\n#[cfg(all(unix, not(target_os = \"macos\")))]\nfn copy_text_to_clipboard(text: &str) -> AppResult<()> {\n    let mut last_error = None;\n\n    match copy_with_command(\"wl-copy\", &[], text) {\n        Ok(()) => return Ok(()),\n        Err(err) => last_error = Some(err),\n    }\n    match copy_with_command(\"xclip\", &[\"-selection\", \"clipboard\"], text) {\n        Ok(()) => return Ok(()),\n        Err(err) => last_error = Some(err),\n    }\n    match copy_with_command(\"xsel\", &[\"--clipboard\", \"--input\"], text) {\n        Ok(()) => return Ok(()),\n        Err(err) => last_error = Some(err),\n    }\n\n    Err(last_error.unwrap_or_else(|| {\n        \"No supported clipboard tool found. Please install wl-copy, xclip, or xsel.\".to_string()\n    }))\n}\n\n#[tauri::command]\nasync fn open_with(path: String) -> AppResult<()> {\n    tauri::async_runtime::spawn_blocking(move || reveal_in_finder_impl(vec![path]))\n        .await\n        .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nasync fn reveal_in_finder(paths: Vec<String>) -> AppResult<()> {\n    tauri::async_runtime::spawn_blocking(move || reveal_in_finder_impl(paths))\n        .await\n        .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nfn copy_paths(paths: Vec<String>) -> AppResult<()> {\n    copy_text_to_clipboard(&paths.join(\"\\n\"))\n}\n\n#[cfg(target_os = \"macos\")]\nfn copy_files_to_clipboard(paths: &[String]) -> AppResult<()> {\n    if paths.is_empty() {\n        return Ok(());\n    }\n    let file_exprs: Vec<String> = paths\n        .iter()\n        .map(|p| {\n            let escaped = p.replace('\\\\', \"\\\\\\\\\").replace('\"', \"\\\\\\\"\");\n            format!(\"POSIX file \\\"{}\\\"\", escaped)\n        })\n        .collect();\n    let script = if file_exprs.len() == 1 {\n        format!(\"set the clipboard to {}\", file_exprs[0])\n    } else {\n        format!(\"set the clipboard to {{{}}}\", file_exprs.join(\", \"))\n    };\n    let status = Command::new(\"osascript\")\n        .arg(\"-e\")\n        .arg(&script)\n        .status()\n        .map_err(|e| e.to_string())?;\n    if !status.success() {\n        return Err(\"Failed to copy files to clipboard\".to_string());\n    }\n    Ok(())\n}\n\n#[cfg(target_os = \"macos\")]\n#[tauri::command]\nfn copy_files(paths: Vec<String>) -> AppResult<()> {\n    copy_files_to_clipboard(&paths)\n}\n\n#[cfg(not(target_os = \"macos\"))]\n#[tauri::command]\nfn copy_files(_paths: Vec<String>) -> AppResult<()> {\n    Err(\"copy_files is only supported on macOS\".to_string())\n}\n\n#[tauri::command]\nasync fn move_to_trash(\n    paths: Vec<String>,\n    app: AppHandle,\n    state: State<'_, AppState>,\n) -> AppResult<()> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        let mut deleted_targets = Vec::new();\n\n        for path in &paths {\n            trash::delete(path).map_err(|e| e.to_string())?;\n            remember_op(&state, \"trash\", Some(path.clone()), None);\n            deleted_targets.push(path.clone());\n        }\n\n        let mut conn = db_connection(&state.db_path)?;\n        let _ = delete_paths(&mut conn, &deleted_targets)?;\n        invalidate_search_caches(&state);\n\n        refresh_and_emit_status_counts(&app, &state)?;\n        Ok(())\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nasync fn rename(\n    path: String,\n    new_name: String,\n    app: AppHandle,\n    state: State<'_, AppState>,\n) -> AppResult<EntryDto> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        let validated_name = validate_new_name(&new_name)?;\n        let old_path = PathBuf::from(&path);\n\n        if !old_path.exists() {\n            return Err(\"Source file does not exist.\".to_string());\n        }\n\n        let parent = old_path\n            .parent()\n            .ok_or_else(|| \"Parent directory not found.\".to_string())?;\n\n        let new_path = parent.join(&validated_name);\n        if new_path == old_path {\n            let meta = fs::symlink_metadata(&old_path).ok();\n            return Ok(EntryDto {\n                path: path.clone(),\n                name: old_path\n                    .file_name()\n                    .map(|v| v.to_string_lossy().to_string())\n                    .unwrap_or_else(|| validated_name.clone()),\n                dir: parent.to_string_lossy().to_string(),\n                is_dir: old_path.is_dir(),\n                ext: extension_for(&old_path, old_path.is_dir()),\n                size: meta\n                    .as_ref()\n                    .filter(|m| m.is_file())\n                    .map(|m| m.len() as i64),\n                mtime: meta\n                    .and_then(|m| m.modified().ok())\n                    .and_then(|m| m.duration_since(UNIX_EPOCH).ok())\n                    .map(|d| d.as_secs() as i64),\n            });\n        }\n\n        if new_path.exists() {\n            return Err(\"A file/folder with the same name already exists.\".to_string());\n        }\n\n        let original_is_dir = old_path.is_dir();\n        fs::rename(&old_path, &new_path).map_err(|e| e.to_string())?;\n\n        let mut conn = db_connection(&state.db_path)?;\n        let _ = delete_paths(&mut conn, &[path.clone()])?;\n\n        if original_is_dir {\n            let rows =\n                collect_rows_recursive(&new_path, &state.path_ignores, &state.path_ignore_patterns);\n            for chunk in rows.chunks(BATCH_SIZE) {\n                let _ = upsert_rows(&mut conn, chunk)?;\n            }\n        } else {\n            let row = index_row_from_path(&new_path)\n                .ok_or_else(|| \"Cannot read renamed file info.\".to_string())?;\n            let _ = upsert_rows(&mut conn, &[row])?;\n        }\n\n        invalidate_search_caches(&state);\n\n        remember_op(\n            &state,\n            \"rename\",\n            Some(old_path.to_string_lossy().to_string()),\n            Some(new_path.to_string_lossy().to_string()),\n        );\n\n        refresh_and_emit_status_counts(&app, &state)?;\n\n        let new_meta = fs::symlink_metadata(&new_path).ok();\n        Ok(EntryDto {\n            path: new_path.to_string_lossy().to_string(),\n            name: validated_name,\n            dir: parent.to_string_lossy().to_string(),\n            is_dir: original_is_dir,\n            ext: extension_for(&new_path, original_is_dir),\n            size: new_meta\n                .as_ref()\n                .filter(|m| m.is_file())\n                .map(|m| m.len() as i64),\n            mtime: new_meta\n                .and_then(|m| m.modified().ok())\n                .and_then(|m| m.duration_since(UNIX_EPOCH).ok())\n                .map(|d| d.as_secs() as i64),\n        })\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nasync fn fd_search(\n    query: String,\n    limit: Option<u32>,\n    offset: Option<u32>,\n    sort_by: Option<String>,\n    sort_dir: Option<String>,\n    state: State<'_, AppState>,\n) -> AppResult<FdSearchResultDto> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        let query = query.trim().to_string();\n        let limit = limit.unwrap_or(500).clamp(1, 5000) as usize;\n        let offset = offset.unwrap_or(0) as usize;\n        let sort_by = sort_by.unwrap_or_else(|| \"name\".to_string());\n        let sort_dir = sort_dir.unwrap_or_else(|| \"asc\".to_string());\n        let (runtime_ignored_roots, runtime_ignored_patterns) =\n            cached_effective_ignore_rules(&state);\n        let ignore_fingerprint =\n            ignore_rules_fingerprint(&runtime_ignored_roots, &runtime_ignored_patterns);\n\n        if query.is_empty() {\n            return Ok(FdSearchResultDto {\n                entries: Vec::new(),\n                total: 0,\n                timed_out: false,\n            });\n        }\n\n        {\n            let cache = state.fd_search_cache.lock();\n            if let Some(cached) = cache.as_ref() {\n                let cache_hit = cached.query == query\n                    && cached.sort_by == sort_by\n                    && cached.sort_dir == sort_dir\n                    && cached.ignore_fingerprint == ignore_fingerprint;\n                if cache_hit {\n                    let total = cached.entries.len() as u64;\n                    let end = (offset + limit).min(cached.entries.len());\n                    let page = if offset < cached.entries.len() {\n                        cached.entries[offset..end].to_vec()\n                    } else {\n                        Vec::new()\n                    };\n                    return Ok(FdSearchResultDto {\n                        entries: page,\n                        total,\n                        timed_out: false,\n                    });\n                }\n            }\n        }\n\n        let result = fd_search::run_fd_search(\n            &state.scan_root,\n            &runtime_ignored_roots,\n            &runtime_ignored_patterns,\n            &query,\n            &sort_by,\n            &sort_dir,\n        );\n        let total = result.entries.len() as u64;\n        let end = (offset + limit).min(result.entries.len());\n        let page = if offset < result.entries.len() {\n            result.entries[offset..end].to_vec()\n        } else {\n            Vec::new()\n        };\n\n        {\n            let mut cache = state.fd_search_cache.lock();\n            *cache = Some(FdSearchCache {\n                query: query.clone(),\n                sort_by: sort_by.clone(),\n                sort_dir: sort_dir.clone(),\n                ignore_fingerprint,\n                entries: result.entries,\n            });\n        }\n\n        Ok(FdSearchResultDto {\n            entries: page,\n            total,\n            timed_out: result.timed_out,\n        })\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nfn frontend_log(msg: String) {\n    eprintln!(\"{msg}\");\n}\n\n#[tauri::command]\nfn mark_frontend_ready(state: State<'_, AppState>) {\n    state.frontend_ready.store(true, AtomicOrdering::Release);\n    if cfg!(debug_assertions) {\n        eprintln!(\"[startup] frontend_ready=true\");\n    }\n}\n\n#[tauri::command]\nfn get_platform() -> String {\n    if cfg!(target_os = \"windows\") {\n        \"windows\".to_string()\n    } else if cfg!(target_os = \"macos\") {\n        \"macos\".to_string()\n    } else {\n        \"linux\".to_string()\n    }\n}\n\n#[cfg(target_os = \"windows\")]\n#[tauri::command]\nasync fn show_context_menu(\n    paths: Vec<String>,\n    x: f64,\n    y: f64,\n    _single_selection: bool,\n    app: AppHandle,\n) -> AppResult<()> {\n    let window = app\n        .get_webview_window(\"main\")\n        .ok_or_else(|| \"Main window not found\".to_string())?;\n\n    let scale = window.scale_factor().map_err(|e| e.to_string())?;\n    let win_pos = window.inner_position().map_err(|e| e.to_string())?;\n    let screen_x = win_pos.x + (x * scale) as i32;\n    let screen_y = win_pos.y + (y * scale) as i32;\n\n    let hwnd_raw = window.hwnd().map_err(|e| e.to_string())?.0 as isize;\n\n    // TrackPopupMenu must run on the thread that owns the HWND (main UI thread).\n    // Use a channel to relay the result back to the async context.\n    let (tx, rx) = std::sync::mpsc::sync_channel::<Result<(), String>>(1);\n\n    app.run_on_main_thread(move || {\n        let result = win::context_menu::show(hwnd_raw, &paths, screen_x, screen_y);\n        let _ = tx.send(result);\n    })\n    .map_err(|e| e.to_string())?;\n\n    tauri::async_runtime::spawn_blocking(move || {\n        rx.recv().map_err(|e| format!(\"context menu channel: {e}\"))?\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[cfg(target_os = \"macos\")]\n#[tauri::command]\nasync fn show_context_menu(\n    _paths: Vec<String>,\n    x: f64,\n    y: f64,\n    single_selection: bool,\n    app: AppHandle,\n) -> AppResult<()> {\n    use tauri::menu::{IsMenuItem, Menu, MenuItem, PredefinedMenuItem};\n\n    let window = app\n        .get_webview_window(\"main\")\n        .ok_or_else(|| \"Main window not found\".to_string())?;\n\n    let (tx, rx) = std::sync::mpsc::sync_channel::<Result<(), String>>(1);\n\n    let app_clone = app.clone();\n    app.run_on_main_thread(move || {\n        let app = app_clone;\n        let result = (|| -> Result<(), tauri::Error> {\n            let open = MenuItem::with_id(&app, \"ctx_open\", \"Open\", true, None::<&str>)?;\n            let quick_look =\n                MenuItem::with_id(&app, \"ctx_quick_look\", \"Quick Look\", true, None::<&str>)?;\n            let open_with =\n                MenuItem::with_id(&app, \"ctx_open_with\", \"Open With...\", true, None::<&str>)?;\n            let sep1 = PredefinedMenuItem::separator(&app)?;\n            let reveal = MenuItem::with_id(\n                &app,\n                \"ctx_reveal\",\n                \"Reveal in Finder\",\n                true,\n                None::<&str>,\n            )?;\n            let sep2 = PredefinedMenuItem::separator(&app)?;\n            let copy_files =\n                MenuItem::with_id(&app, \"ctx_copy_files\", \"Copy\", true, None::<&str>)?;\n            let copy_path =\n                MenuItem::with_id(&app, \"ctx_copy_path\", \"Copy Path\", true, None::<&str>)?;\n            let sep3 = PredefinedMenuItem::separator(&app)?;\n            let trash = MenuItem::with_id(\n                &app,\n                \"ctx_trash\",\n                \"Move to Trash\",\n                true,\n                None::<&str>,\n            )?;\n            let rename =\n                MenuItem::with_id(&app, \"ctx_rename\", \"Rename\", true, None::<&str>)?;\n\n            let mut items: Vec<&dyn IsMenuItem<tauri::Wry>> = vec![\n                &open, &quick_look, &open_with, &sep1, &reveal, &sep2, &copy_files, &copy_path, &sep3, &trash,\n            ];\n            if single_selection {\n                items.push(&rename);\n            }\n\n            let menu = Menu::with_items(&app, &items)?;\n            // Position is window-relative logical pixels, matching clientX/clientY.\n            window.popup_menu_at(&menu, tauri::LogicalPosition::new(x, y))?;\n            Ok(())\n        })();\n        let _ = tx.send(result.map_err(|e| e.to_string()));\n    })\n    .map_err(|e| e.to_string())?;\n\n    tauri::async_runtime::spawn_blocking(move || {\n        rx.recv().map_err(|e| format!(\"context menu channel: {e}\"))?\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[cfg(not(any(target_os = \"windows\", target_os = \"macos\")))]\n#[tauri::command]\nasync fn show_context_menu(\n    _paths: Vec<String>,\n    _x: f64,\n    _y: f64,\n    _single_selection: bool,\n    _app: AppHandle,\n) -> AppResult<()> {\n    Err(\"Native context menu is only supported on Windows and macOS\".to_string())\n}\n\n#[tauri::command]\nasync fn set_native_theme(theme: String, app: AppHandle) -> AppResult<()> {\n    let window = app\n        .get_webview_window(\"main\")\n        .ok_or_else(|| \"Main window not found\".to_string())?;\n    let t = if theme == \"light\" {\n        tauri::Theme::Light\n    } else {\n        tauri::Theme::Dark\n    };\n    window.set_theme(Some(t)).map_err(|e| e.to_string())\n}\n\n#[tauri::command]\nasync fn get_file_icon(\n    path: Option<String>,\n    ext: String,\n    state: State<'_, AppState>,\n) -> AppResult<Vec<u8>> {\n    let state = state.inner().clone();\n    Ok(tauri::async_runtime::spawn_blocking(move || {\n        let ext_lower = if ext.trim().is_empty() {\n            \"__default__\".to_string()\n        } else {\n            ext.to_lowercase()\n        };\n\n        #[cfg(target_os = \"windows\")]\n        let cache_key = {\n            if is_per_file_icon_ext(&ext_lower) {\n                path.as_deref().unwrap_or(&ext_lower).to_string()\n            } else {\n                ext_lower.clone()\n            }\n        };\n        #[cfg(not(target_os = \"windows\"))]\n        let cache_key = ext_lower.clone();\n\n        if let Some(cached) = state.icon_cache.lock().get(&cache_key).cloned() {\n            return cached;\n        }\n\n        #[cfg(target_os = \"windows\")]\n        let icon = {\n            let from_path = path\n                .as_deref()\n                .filter(|p| !p.is_empty())\n                .and_then(win::icon::load_icon_png);\n            from_path.or_else(|| load_system_icon_png(&ext_lower))\n        };\n        #[cfg(not(target_os = \"windows\"))]\n        let icon = {\n            let _ = path;\n            load_system_icon_png(&ext_lower)\n        };\n\n        let icon = icon.unwrap_or_default();\n        state.icon_cache.lock().insert(cache_key, icon.clone());\n        icon\n    })\n    .await\n    .unwrap_or_default())\n}\n\nfn default_bench_cases() -> Vec<BenchCase> {\n    vec![\n        BenchCase {\n            id: \"TC01_exact_name\",\n            query: \"report_00042\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC02_prefix_name\",\n            query: \"report_00\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 10,\n        },\n        BenchCase {\n            id: \"TC03_contains_name\",\n            query: \"invoice\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC04_ext_md\",\n            query: \"*.md\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC05_path_glob_png\",\n            query: \"Desktop/ *.png\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC06_path_term\",\n            query: \"Projects/rust\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC07_path_ext_rs\",\n            query: \"Projects/ *.rs\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC08_no_match\",\n            query: \"zzzz_not_exists_12345\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 0,\n        },\n    ]\n}\n\nfn bench_iterations() -> u32 {\n    std::env::var(\"EVERYTHING_BENCH_ITERATIONS\")\n        .ok()\n        .and_then(|v| v.parse::<u32>().ok())\n        .map(|v| v.clamp(1, 50))\n        .unwrap_or(5)\n}\n\nfn bench_wait_timeout() -> Duration {\n    let seconds = std::env::var(\"EVERYTHING_BENCH_WAIT_SEC\")\n        .ok()\n        .and_then(|v| v.parse::<u64>().ok())\n        .map(|v| v.clamp(10, 7200))\n        .unwrap_or(1800);\n    Duration::from_secs(seconds)\n}\n\nfn bench_run_label() -> String {\n    std::env::var(\"EVERYTHING_BENCH_RUN_LABEL\")\n        .ok()\n        .filter(|v| !v.trim().is_empty())\n        .unwrap_or_else(|| format!(\"run-{}\", now_epoch()))\n}\n\nfn bench_output_path(db_path: &Path, run_label: &str) -> PathBuf {\n    std::env::var(\"EVERYTHING_BENCH_OUTPUT\")\n        .ok()\n        .filter(|v| !v.trim().is_empty())\n        .map(PathBuf::from)\n        .unwrap_or_else(|| db_path.with_file_name(format!(\"bench-report-{run_label}.json\")))\n}\n\nfn write_bench_report(path: &Path, report: &BenchReport) -> AppResult<()> {\n    let json = serde_json::to_string_pretty(report).map_err(|e| e.to_string())?;\n    fs::write(path, json).map_err(|e| e.to_string())\n}\n\nfn start_bench_runner(app_handle: AppHandle, state: AppState) {\n    std::thread::spawn(move || {\n        let run_label = bench_run_label();\n        let output_path = bench_output_path(&state.db_path, &run_label);\n        let iterations = bench_iterations();\n        let wait_timeout = bench_wait_timeout();\n        let started_at = now_epoch();\n\n        perf_log(format!(\n            \"bench_start run_label={} output={} iterations={} wait_timeout_s={}\",\n            run_label,\n            output_path.to_string_lossy(),\n            iterations,\n            wait_timeout.as_secs(),\n        ));\n\n        let wait_started = Instant::now();\n        let mut saw_indexing = false;\n        let index_snapshot: IndexStatus;\n        loop {\n            let snapshot = state.status.lock().clone();\n            let active = state.indexing_active.load(AtomicOrdering::Acquire)\n                || matches!(snapshot.state, IndexState::Indexing);\n\n            if active {\n                saw_indexing = true;\n            }\n\n            if state.db_ready.load(AtomicOrdering::Acquire) && saw_indexing && !active {\n                index_snapshot = snapshot;\n                break;\n            }\n\n            if wait_started.elapsed() >= wait_timeout {\n                let report = BenchReport {\n                    run_label: run_label.clone(),\n                    started_at,\n                    completed_at: now_epoch(),\n                    home_dir: state.home_dir.to_string_lossy().to_string(),\n                    db_path: state.db_path.to_string_lossy().to_string(),\n                    index_wait_ms: wait_started.elapsed().as_millis(),\n                    index_scanned: snapshot.scanned,\n                    index_indexed: snapshot.indexed,\n                    index_entries_count: snapshot.entries_count,\n                    index_permission_errors: snapshot.permission_errors,\n                    index_message: Some(\"Timed out waiting for index ready\".to_string()),\n                    search_iterations: iterations,\n                    search_results: Vec::new(),\n                };\n                let _ = write_bench_report(&output_path, &report);\n                perf_log(format!(\n                    \"bench_timeout run_label={} waited_ms={}\",\n                    run_label,\n                    wait_started.elapsed().as_millis()\n                ));\n                if env_truthy(\"EVERYTHING_BENCH_EXIT\") {\n                    app_handle.exit(2);\n                }\n                return;\n            }\n\n            std::thread::sleep(Duration::from_millis(200));\n        }\n\n        let index_wait_ms = wait_started.elapsed().as_millis();\n        perf_log(format!(\n            \"bench_index_ready run_label={} waited_ms={} scanned={} indexed={} entries={} permission_errors={}\",\n            run_label,\n            index_wait_ms,\n            index_snapshot.scanned,\n            index_snapshot.indexed,\n            index_snapshot.entries_count,\n            index_snapshot.permission_errors,\n        ));\n\n        let mut search_results = Vec::new();\n        for case in default_bench_cases() {\n            let mut elapsed_sum = 0.0f64;\n            let mut success_count = 0u32;\n            let mut result_count = 0usize;\n            let mut mode = String::new();\n            let mut top_results = Vec::new();\n            let mut case_error = None;\n\n            for iter in 1..=iterations {\n                let started = Instant::now();\n                match execute_search(\n                    &state,\n                    case.query.to_string(),\n                    Some(case.limit),\n                    Some(case.offset),\n                    Some(case.sort_by.to_string()),\n                    Some(case.sort_dir.to_string()),\n                ) {\n                    Ok(execution) => {\n                        let elapsed_ms = started.elapsed().as_secs_f64() * 1000.0;\n                        elapsed_sum += elapsed_ms;\n                        success_count += 1;\n                        result_count = execution.results.len();\n                        mode = execution.mode_label;\n                        top_results = execution\n                            .results\n                            .iter()\n                            .take(5)\n                            .map(|entry| entry.path.clone())\n                            .collect();\n\n                        perf_log(format!(\n                            \"bench_query run_label={} case={} iter={}/{} query={:?} mode={} results={} elapsed_ms={:.3}\",\n                            run_label,\n                            case.id,\n                            iter,\n                            iterations,\n                            case.query,\n                            mode,\n                            result_count,\n                            elapsed_ms\n                        ));\n                    }\n                    Err(err) => {\n                        case_error = Some(err);\n                        break;\n                    }\n                }\n            }\n\n            let elapsed_ms = if success_count > 0 {\n                elapsed_sum / success_count as f64\n            } else {\n                0.0\n            };\n            let passed = case_error.is_none() && result_count >= case.expected_min_results;\n\n            search_results.push(BenchCaseResult {\n                id: case.id.to_string(),\n                query: case.query.to_string(),\n                mode,\n                sort_by: case.sort_by.to_string(),\n                sort_dir: case.sort_dir.to_string(),\n                limit: case.limit,\n                offset: case.offset,\n                elapsed_ms,\n                result_count,\n                expected_min_results: case.expected_min_results,\n                passed,\n                top_results,\n                error: case_error,\n            });\n        }\n\n        let report = BenchReport {\n            run_label: run_label.clone(),\n            started_at,\n            completed_at: now_epoch(),\n            home_dir: state.home_dir.to_string_lossy().to_string(),\n            db_path: state.db_path.to_string_lossy().to_string(),\n            index_wait_ms,\n            index_scanned: index_snapshot.scanned,\n            index_indexed: index_snapshot.indexed,\n            index_entries_count: index_snapshot.entries_count,\n            index_permission_errors: index_snapshot.permission_errors,\n            index_message: index_snapshot.message.clone(),\n            search_iterations: iterations,\n            search_results,\n        };\n\n        match write_bench_report(&output_path, &report) {\n            Ok(()) => perf_log(format!(\n                \"bench_report_written run_label={} path={}\",\n                run_label,\n                output_path.to_string_lossy()\n            )),\n            Err(err) => perf_log(format!(\n                \"bench_report_write_error run_label={} path={} err={}\",\n                run_label,\n                output_path.to_string_lossy(),\n                err\n            )),\n        }\n\n        if env_truthy(\"EVERYTHING_BENCH_EXIT\") {\n            app_handle.exit(0);\n        }\n    });\n}\n\n#[cfg(target_os = \"macos\")]\nfn register_global_shortcut(app: &AppHandle) -> AppResult<()> {\n    let shortcut = Shortcut::new(Some(Modifiers::SUPER | Modifiers::SHIFT), Code::Space);\n\n    app.global_shortcut()\n        .on_shortcut(shortcut, move |app_handle, _, _| {\n            if let Some(window) = app_handle.get_webview_window(\"main\") {\n                let _ = window.show();\n                let _ = window.unminimize();\n                let _ = window.set_focus();\n            }\n            let _ = app_handle.emit(\"focus_search\", ());\n        })\n        .map_err(|e| format!(\"Failed to register global shortcut: {e}\"))\n}\n\n#[cfg(not(target_os = \"macos\"))]\nfn register_global_shortcut(_app: &AppHandle) -> AppResult<()> {\n    Ok(())\n}\n\nfn setup_app(app: &mut tauri::App) -> AppResult<()> {\n    let setup_started = std::time::Instant::now();\n    eprintln!(\"[startup] setup_app() entered\");\n    let bench_mode = bench_mode_enabled();\n\n    #[cfg(target_os = \"macos\")]\n    if let Some(window) = app.get_webview_window(\"main\") {\n        use tauri::window::Color;\n        let is_dark = window\n            .theme()\n            .map(|t| t == tauri::Theme::Dark)\n            .unwrap_or(false);\n        let bg = if is_dark {\n            Color(0x1f, 0x1f, 0x1f, 0xff)\n        } else {\n            Color(0xf4, 0xf5, 0xf7, 0xff)\n        };\n        let _ = window.set_background_color(Some(bg));\n        let _ = window.show();\n    }\n\n    #[cfg(target_os = \"windows\")]\n    if let Some(window) = app.get_webview_window(\"main\") {\n        eprintln!(\"[startup +{}ms] windows setup: before window.show()\", startup_elapsed_ms());\n        use tauri::window::Color;\n        let is_dark = window.theme().map(|t| t == tauri::Theme::Dark).unwrap_or(false);\n        let bg = if is_dark {\n            Color(0x1f, 0x1f, 0x1f, 0xff)\n        } else {\n            Color(0xf4, 0xf5, 0xf7, 0xff)\n        };\n        let _ = window.set_background_color(Some(bg));\n        if let Err(e) = window.set_decorations(false) {\n            eprintln!(\n                \"[startup +{}ms] windows setup: set_decorations(false) failed: {}\",\n                startup_elapsed_ms(),\n                e\n            );\n        }\n        let _ = window.show();\n        eprintln!(\"[startup +{}ms] windows setup: window.show() returned\", startup_elapsed_ms());\n    }\n\n    let app_data_dir = app\n        .path()\n        .app_data_dir()\n        .map_err(|e| format!(\"Failed to get app data dir: {e}\"))?;\n    fs::create_dir_all(&app_data_dir).map_err(|e| e.to_string())?;\n\n    let db_path = app_data_dir.join(\"index.db\");\n    let home_dir = PathBuf::from(\n        std::env::var(\"HOME\")\n            .or_else(|_| std::env::var(\"USERPROFILE\"))\n            .unwrap_or_else(|_| if cfg!(windows) { \"C:\\\\\".to_string() } else { \"/\".to_string() }),\n    );\n    let scan_root = if cfg!(windows) {\n        PathBuf::from(\"C:\\\\\")\n    } else {\n        home_dir.clone()\n    };\n    let cwd = std::env::current_dir().unwrap_or_else(|_| home_dir.clone());\n    eprintln!(\"[startup] +{}ms loading pathignore rules...\", setup_started.elapsed().as_millis());\n    let (mut path_ignores, path_ignore_patterns) = load_pathignore_rules(&home_dir, &cwd);\n    if !path_ignores.iter().any(|r| r == &app_data_dir) {\n        path_ignores.push(app_data_dir.clone());\n    }\n    for root in load_gitignore_roots(&home_dir, &cwd) {\n        if !path_ignores.iter().any(|r| r == &root) {\n            path_ignores.push(root);\n        }\n    }\n    eprintln!(\"[startup] +{}ms pathignore done\", setup_started.elapsed().as_millis());\n\n    let gitignore = Arc::new(gitignore_filter::LazyGitignoreFilter::new(home_dir.clone()));\n\n    let state = AppState {\n        db_path,\n        home_dir,\n        scan_root,\n        cwd,\n        path_ignores: Arc::new(path_ignores),\n        path_ignore_patterns: Arc::new(path_ignore_patterns),\n        db_ready: Arc::new(AtomicBool::new(false)),\n        indexing_active: Arc::new(AtomicBool::new(false)),\n        status: Arc::new(Mutex::new(IndexStatus::default())),\n        recent_ops: Arc::new(Mutex::new(Vec::new())),\n        icon_cache: Arc::new(Mutex::new(HashMap::new())),\n        fd_search_cache: Arc::new(Mutex::new(None)),\n        negative_name_cache: Arc::new(Mutex::new(HashMap::new())),\n        ignore_cache: Arc::new(Mutex::new(None)),\n        gitignore,\n        mem_index: Arc::new(RwLock::new(None)),\n        watcher_stop: Arc::new(AtomicBool::new(false)),\n        watcher_active: Arc::new(AtomicBool::new(false)),\n        frontend_ready: Arc::new(AtomicBool::new(false)),\n    };\n\n    eprintln!(\"[startup] +{}ms AppState created\", setup_started.elapsed().as_millis());\n    app.manage(state.clone());\n    if !bench_mode {\n        register_global_shortcut(&app.handle())?;\n    }\n    // Context menu item IDs use the \"ctx_\" prefix by convention.\n    // All matching IDs are forwarded as \"context_menu_action\" events to the frontend.\n    #[cfg(target_os = \"macos\")]\n    {\n        app.handle().on_menu_event(|app, event| {\n            let action = match event.id().as_ref() {\n                \"ctx_open\" => \"open\",\n                \"ctx_quick_look\" => \"quick_look\",\n                \"ctx_open_with\" => \"open_with\",\n                \"ctx_reveal\" => \"reveal\",\n                \"ctx_copy_files\" => \"copy_files\",\n                \"ctx_copy_path\" => \"copy_path\",\n                \"ctx_trash\" => \"trash\",\n                \"ctx_rename\" => \"rename\",\n                _ => return,\n            };\n            let _ = app.emit(\"context_menu_action\", action);\n        });\n    }\n    eprintln!(\"[startup] +{}ms global shortcut registered\", setup_started.elapsed().as_millis());\n    if bench_mode {\n        if let Some(window) = app.get_webview_window(\"main\") {\n            let _ = window.hide();\n        }\n    }\n\n    eprintln!(\"[startup] +{}ms setup_app() done, spawning init thread\", setup_started.elapsed().as_millis());\n\n    let app_handle = app.handle().clone();\n    std::thread::spawn(move || {\n        let thread_started = std::time::Instant::now();\n        eprintln!(\"[startup/thread] init thread started\");\n\n        eprintln!(\"[startup/thread] +{}ms calling init_db...\", thread_started.elapsed().as_millis());\n        if let Err(err) = init_db(&state.db_path) {\n            set_state(&state, IndexState::Error, Some(err.clone()));\n            emit_index_state(&app_handle, \"Error\", Some(err));\n            return;\n        }\n        eprintln!(\"[startup/thread] +{}ms init_db done\", thread_started.elapsed().as_millis());\n\n        state.db_ready.store(true, AtomicOrdering::Release);\n        eprintln!(\"[startup/thread] +{}ms db_ready=true -- launching indexing immediately\", thread_started.elapsed().as_millis());\n\n        // Deferred housekeeping -- purge + status counts run in background\n        {\n            let hk_app = app_handle.clone();\n            let hk_state = state.clone();\n            std::thread::spawn(move || {\n                // Brief pause so indexing thread can start first\n                std::thread::sleep(std::time::Duration::from_millis(500));\n                let hk_started = std::time::Instant::now();\n                let _ = refresh_and_emit_status_counts(&hk_app, &hk_state);\n                eprintln!(\"[startup/housekeeping] refresh_and_emit_status_counts done in {}ms\", hk_started.elapsed().as_millis());\n                // Wait for frontend readiness so initial paint and first input are not contended by purge I/O.\n                const FRONTEND_READY_TIMEOUT: Duration = Duration::from_secs(180);\n                const POST_READY_GRACE: Duration = Duration::from_secs(2);\n                let wait_started = std::time::Instant::now();\n                while !hk_state.frontend_ready.load(AtomicOrdering::Acquire)\n                    && wait_started.elapsed() < FRONTEND_READY_TIMEOUT\n                {\n                    std::thread::sleep(Duration::from_millis(50));\n                }\n                if hk_state.frontend_ready.load(AtomicOrdering::Acquire) {\n                    eprintln!(\n                        \"[startup/housekeeping] frontend_ready observed after {}ms; purging in {}ms\",\n                        wait_started.elapsed().as_millis(),\n                        POST_READY_GRACE.as_millis()\n                    );\n                } else {\n                    eprintln!(\n                        \"[startup/housekeeping] frontend_ready wait timed out after {}ms; proceeding with purge\",\n                        FRONTEND_READY_TIMEOUT.as_millis()\n                    );\n                }\n                std::thread::sleep(POST_READY_GRACE);\n                let purge_started = std::time::Instant::now();\n                if let Err(err) = purge_ignored_entries(&hk_state.db_path, &hk_state.path_ignores) {\n                    eprintln!(\"[startup/housekeeping] purge_ignored_entries failed: {err}\");\n                } else {\n                    eprintln!(\n                        \"[startup/housekeeping] purge_ignored_entries done in {}ms\",\n                        purge_started.elapsed().as_millis()\n                    );\n                }\n                eprintln!(\"[startup/housekeeping] all done in {}ms\", hk_started.elapsed().as_millis());\n            });\n        }\n\n        #[cfg(target_os = \"macos\")]\n        {\n            if bench_mode {\n                let _ = start_full_index_worker(app_handle.clone(), state.clone());\n            } else {\n                let (stored_event_id, index_complete) = db_connection(&state.db_path)\n                    .ok()\n                    .map(|c| {\n                        let eid = get_meta(&c, \"last_event_id\")\n                            .and_then(|v| v.parse::<u64>().ok());\n                        let complete = get_meta(&c, \"index_complete\")\n                            .map(|v| v == \"1\")\n                            .unwrap_or(false);\n                        (eid, complete)\n                    })\n                    .unwrap_or((None, false));\n\n                if stored_event_id.is_some() && index_complete {\n                    // Conditional startup: try watcher replay first, skip full scan if OK\n                    start_fsevent_watcher_worker(\n                        app_handle.clone(),\n                        state.clone(),\n                        stored_event_id,\n                        true,\n                    );\n                } else {\n                    if !index_complete {\n                        eprintln!(\"[mac] index incomplete; starting full index\");\n                    }\n                    let _ = start_full_index_worker(app_handle.clone(), state.clone());\n                    start_fsevent_watcher_worker(app_handle.clone(), state.clone(), None, false);\n                }\n            }\n        }\n\n        #[cfg(target_os = \"windows\")]\n        {\n            win::start_windows_indexing(app_handle.clone(), state.clone());\n        }\n\n        #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n        {\n            let _ = start_full_index_worker(app_handle.clone(), state.clone());\n        }\n\n        if bench_mode {\n            start_bench_runner(app_handle.clone(), state.clone());\n        }\n\n        #[cfg(not(target_os = \"windows\"))]\n        if !bench_mode {\n            let icon_cache = state.icon_cache.clone();\n            std::thread::spawn(move || {\n                let exts = [\n                    \"txt\", \"pdf\", \"png\", \"jpg\", \"md\", \"json\", \"swift\", \"rs\", \"js\", \"ts\", \"html\",\n                    \"css\", \"py\", \"zip\", \"dmg\", \"app\", \"doc\", \"xls\", \"ppt\", \"mov\",\n                ];\n                for ext in &exts {\n                    let key = ext.to_string();\n                    if icon_cache.lock().contains_key(&key) {\n                        continue;\n                    }\n                    if let Some(icon) = load_system_icon_png(ext) {\n                        icon_cache.lock().insert(key, icon);\n                    }\n                }\n            });\n        }\n    });\n\n    Ok(())\n}\n\n#[cfg_attr(mobile, tauri::mobile_entry_point)]\npub fn run() {\n    let _ = STARTUP_T0.set(Instant::now());\n    eprintln!(\"[startup +{}ms] run() entered\", startup_elapsed_ms());\n    #[cfg(target_os = \"windows\")]\n    if cfg!(debug_assertions) {\n        // Safety: called at program start before any threads are spawned.\n        // Will require `unsafe` block when migrating to Rust edition 2024.\n        std::env::set_var(\n            \"WEBVIEW2_ADDITIONAL_BROWSER_ARGUMENTS\",\n            \"--no-proxy-server --disable-http-cache --disk-cache-size=1 --media-cache-size=1\",\n        );\n        eprintln!(\n            \"[startup +{}ms] set REDACTED --disable-http-cache --disk-cache-size=1 --media-cache-size=1\",\n            startup_elapsed_ms()\n        );\n    }\n    let mut builder = tauri::Builder::default()\n        .plugin(tauri_plugin_decorum::init())\n        .plugin(tauri_plugin_drag::init())\n        .plugin(tauri_plugin_global_shortcut::Builder::new().build());\n\n    if !cfg!(debug_assertions) {\n        builder = builder.plugin(tauri_plugin_window_state::Builder::default().build());\n    } else {\n        eprintln!(\n            \"[startup +{}ms] debug mode: window-state plugin disabled for startup A/B test\",\n            startup_elapsed_ms()\n        );\n    }\n\n    builder\n        .on_page_load(|window, payload| {\n            eprintln!(\n                \"[startup/page +{}ms] on_page_load label={} event={:?} url={}\",\n                startup_elapsed_ms(),\n                window.label(),\n                payload.event(),\n                payload.url()\n            );\n        })\n        .setup(|app| {\n            setup_app(app).map_err(|e| {\n                Box::<dyn std::error::Error>::from(io::Error::new(io::ErrorKind::Other, e))\n            })\n        })\n        .invoke_handler(tauri::generate_handler![\n            get_index_status,\n            get_home_dir,\n            start_full_index,\n            reset_index,\n            search,\n            fd_search,\n            quick_look,\n            open,\n            open_with,\n            reveal_in_finder,\n            copy_paths,\n            copy_files,\n            move_to_trash,\n            rename,\n            get_file_icon,\n            get_platform,\n            show_context_menu,\n            set_native_theme,\n            frontend_log,\n            mark_frontend_ready\n        ])\n        .run(tauri::generate_context!())\n        .expect(\"error while running tauri application\");\n}\n\nfn main() {\n    run();\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::time::{SystemTime, UNIX_EPOCH};\n\n    fn mk_entry(path: &str, name: &str) -> EntryDto {\n        let parent = Path::new(path)\n            .parent()\n            .map(|p| p.to_string_lossy().to_string())\n            .unwrap_or_else(|| \"/\".to_string());\n        EntryDto {\n            path: path.to_string(),\n            name: name.to_string(),\n            dir: parent,\n            is_dir: false,\n            ext: None,\n            size: None,\n            mtime: None,\n        }\n    }\n\n    fn temp_case_dir(case: &str) -> PathBuf {\n        let stamp = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .map(|d| d.as_nanos())\n            .unwrap_or(0);\n        let base = if cfg!(target_os = \"windows\") {\n            std::env::current_dir()\n                .map(|dir| dir.join(\"tmp-test-dirs\"))\n                .unwrap_or_else(|_| std::env::temp_dir())\n        } else {\n            std::env::temp_dir()\n        };\n        base.join(format!(\n            \"everything_{case}_{}_{}\",\n            std::process::id(),\n            stamp\n        ))\n    }\n\n    fn test_state_for(db_path: PathBuf, home_dir: PathBuf, cwd: PathBuf) -> AppState {\n        AppState {\n            db_path,\n            home_dir: home_dir.clone(),\n            scan_root: home_dir.clone(),\n            cwd,\n            path_ignores: Arc::new(Vec::new()),\n            path_ignore_patterns: Arc::new(Vec::new()),\n            db_ready: Arc::new(AtomicBool::new(true)),\n            indexing_active: Arc::new(AtomicBool::new(false)),\n            status: Arc::new(Mutex::new(IndexStatus::default())),\n            recent_ops: Arc::new(Mutex::new(Vec::new())),\n            icon_cache: Arc::new(Mutex::new(HashMap::new())),\n            fd_search_cache: Arc::new(Mutex::new(None)),\n            negative_name_cache: Arc::new(Mutex::new(HashMap::new())),\n            ignore_cache: Arc::new(Mutex::new(None)),\n            gitignore: Arc::new(gitignore_filter::LazyGitignoreFilter::new(home_dir.clone())),\n            mem_index: Arc::new(RwLock::new(None)),\n            watcher_stop: Arc::new(AtomicBool::new(false)),\n            watcher_active: Arc::new(AtomicBool::new(false)),\n            frontend_ready: Arc::new(AtomicBool::new(true)),\n        }\n    }\n\n    #[test]\n    fn should_skip_path_for_ignored_descendant() {\n        let ignored = vec![PathBuf::from(\n            \"/Users/al02402336/Library/Developer/Xcode/DerivedData\",\n        )];\n        let target = Path::new(\n            \"REDACTED\",\n        );\n\n        assert!(should_skip_path(target, &ignored, &[]));\n    }\n\n    #[test]\n    fn filter_ignored_entries_removes_pathignore_matches() {\n        let ignored = vec![PathBuf::from(\n            \"/Users/al02402336/Library/Developer/Xcode/DerivedData\",\n        )];\n        let entries = vec![\n            mk_entry(\n                \"REDACTED\",\n                \"-Users-al02402336-a_desktop\",\n            ),\n            mk_entry(\"/Users/al02402336/a_desktop\", \"a_desktop\"),\n        ];\n\n        let filtered = filter_ignored_entries(entries, &ignored, &[]);\n\n        assert_eq!(filtered.len(), 1);\n        assert_eq!(filtered[0].path, \"/Users/al02402336/a_desktop\");\n    }\n\n    #[test]\n    fn should_skip_path_for_glob_any_segment_target() {\n        let patterns = vec![IgnorePattern::AnySegment(\"target\".to_string())];\n\n        assert!(should_skip_path(\n            Path::new(\"/Users/al02402336/work/rust/target\"),\n            &[],\n            &patterns\n        ));\n        assert!(should_skip_path(\n            Path::new(\"/Users/al02402336/work/rust/target/debug/deps/foo.o\"),\n            &[],\n            &patterns\n        ));\n        assert!(!should_skip_path(\n            Path::new(\"/Users/al02402336/work/rust/targets/debug/deps/foo.o\"),\n            &[],\n            &patterns\n        ));\n    }\n\n    #[test]\n    fn relevance_sort_prefers_shallow_exact_match() {\n        let mut entries = vec![\n            mk_entry(\"/Users/al02402336/work/a_desktop\", \"a_desktop\"),\n            mk_entry(\"/Users/al02402336/a_desktop\", \"a_desktop\"),\n            mk_entry(\n                \"/Users/al02402336/Library/Developer/Xcode/DerivedData/-Users-al02402336-a_desktop\",\n                \"-Users-al02402336-a_desktop\",\n            ),\n        ];\n\n        sort_entries_with_relevance(&mut entries, \"a_desktop\", \"name\", \"asc\");\n\n        assert_eq!(entries[0].path, \"/Users/al02402336/a_desktop\");\n    }\n\n    #[test]\n    fn resolved_dir_range_excludes_sibling_with_same_prefix() {\n        let dir_exact = \"/Users/user/Projects\";\n        let dir_prefix = format!(\"{}/\", dir_exact);\n        let dir_prefix_end = format!(\"{}0\", dir_exact);\n\n        let in_scope = |dir: &str| {\n            dir == dir_exact || (dir >= dir_prefix.as_str() && dir < dir_prefix_end.as_str())\n        };\n\n        assert!(in_scope(\"/Users/user/Projects\"));\n        assert!(in_scope(\"/Users/user/Projects/src\"));\n        assert!(in_scope(\"/Users/user/Projects/src/deeper\"));\n\n        assert!(!in_scope(\"/Users/user/Projects-archived\"));\n        assert!(!in_scope(\"/Users/user/Projects.archived\"));\n        assert!(!in_scope(\"/Users/user/Projects_archived\"));\n        assert!(!in_scope(\"/Users/user/Projectz\"));\n    }\n\n    #[test]\n    fn delete_paths_root_clears_all_entries() {\n        let root = temp_case_dir(\"delete_paths_root\");\n        let dir_a = root.join(\"alpha\");\n        let dir_b = root.join(\"beta\").join(\"nested\");\n        fs::create_dir_all(&dir_a).unwrap();\n        fs::create_dir_all(&dir_b).unwrap();\n\n        let db_path = root.join(\"index.db\");\n        init_db(&db_path).unwrap();\n        let mut conn = db_connection(&db_path).unwrap();\n        let now = now_epoch();\n\n        for (path, name, dir, ext) in [\n            (dir_a.join(\"a.txt\"), \"a.txt\", dir_a.clone(), \"txt\"),\n            (dir_b.join(\"b.rs\"), \"b.rs\", dir_b.clone(), \"rs\"),\n        ] {\n            conn.execute(\n                \"INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n                 VALUES(?1, ?2, ?3, 0, ?4, NULL, NULL, ?5, 1)\",\n                params![\n                    path.to_string_lossy().to_string(),\n                    name,\n                    dir.to_string_lossy().to_string(),\n                    ext,\n                    now\n                ],\n            )\n            .unwrap();\n        }\n\n        let deleted = delete_paths(&mut conn, &[\"/\".to_string()]).unwrap();\n        assert!(deleted >= 2);\n\n        let remaining: i64 = conn\n            .query_row(\"SELECT COUNT(*) FROM entries\", [], |row| row.get(0))\n            .unwrap();\n        assert_eq!(remaining, 0);\n\n        let _ = fs::remove_dir_all(root);\n    }\n\n    #[test]\n    fn execute_search_resolved_path_does_not_include_prefixed_sibling_dirs() {\n        let root = temp_case_dir(\"resolved_path_scope_execute\");\n        let projects_src = root.join(\"Projects\").join(\"src\");\n        let archived_src = root.join(\"Projects-archived\").join(\"src\");\n        fs::create_dir_all(&projects_src).unwrap();\n        fs::create_dir_all(&archived_src).unwrap();\n\n        let db_path = root.join(\"index.db\");\n        init_db(&db_path).unwrap();\n        let conn = db_connection(&db_path).unwrap();\n        let now = now_epoch();\n\n        let project_path = projects_src.join(\"main.rs\");\n        let archived_path = archived_src.join(\"legacy.rs\");\n\n        conn.execute(\n            \"INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n             VALUES(?1, ?2, ?3, 0, ?4, NULL, NULL, ?5, 1)\",\n            params![\n                project_path.to_string_lossy().to_string(),\n                \"main.rs\",\n                projects_src.to_string_lossy().to_string(),\n                \"rs\",\n                now\n            ],\n        )\n        .unwrap();\n\n        conn.execute(\n            \"INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n             VALUES(?1, ?2, ?3, 0, ?4, NULL, NULL, ?5, 1)\",\n            params![\n                archived_path.to_string_lossy().to_string(),\n                \"legacy.rs\",\n                archived_src.to_string_lossy().to_string(),\n                \"rs\",\n                now\n            ],\n        )\n        .unwrap();\n\n        let state = test_state_for(db_path.clone(), root.clone(), root.clone());\n        let result = execute_search(\n            &state,\n            \"Projects/ *.rs\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        assert!(result\n            .results\n            .iter()\n            .any(|entry| entry.path == project_path.to_string_lossy()));\n        assert!(result\n            .results\n            .iter()\n            .all(|entry| !entry.path.contains(\"Projects-archived\")));\n\n        let _ = fs::remove_dir_all(root);\n    }\n\n    #[test]\n    fn find_file_upward_locates_repo_level_pathignore() {\n        let root = temp_case_dir(\"pathignore_upward\");\n        let nested = root.join(\"src-tauri\").join(\"target\");\n        fs::create_dir_all(&nested).unwrap();\n        fs::write(root.join(\".pathignore\"), \"node_modules\\n\").unwrap();\n\n        let found = find_file_upward(&nested, \".pathignore\");\n        assert_eq!(found, Some(root.join(\".pathignore\")));\n\n        let _ = fs::remove_dir_all(root);\n    }\n\n    #[test]\n    fn find_git_root_works_from_nested_directory() {\n        let root = temp_case_dir(\"git_root\");\n        let nested = root.join(\"src-tauri\").join(\"target\");\n        fs::create_dir_all(&nested).unwrap();\n        fs::create_dir_all(root.join(\".git\")).unwrap();\n\n        let found = find_git_root(&nested);\n        assert_eq!(found, Some(root.clone()));\n\n        let _ = fs::remove_dir_all(root);\n    }\n\n    #[test]\n    fn extract_ext_from_like_rejects_multi_dot() {\n        assert_eq!(extract_ext_from_like(\"%.tar.gz\"), None);\n        assert_eq!(extract_ext_from_like(\"%.d.ts\"), None);\n        assert_eq!(extract_ext_from_like(\"%.rs\"), Some(\"rs\".to_string()));\n        assert_eq!(extract_ext_from_like(\"%.png\"), Some(\"png\".to_string()));\n    }\n\n    #[test]\n    fn negative_cache_fallback_removes_matched_key_not_query() {\n        let state = test_state_for(\n            PathBuf::from(\"/tmp/neg_cache_test.db\"),\n            PathBuf::from(\"/tmp\"),\n            PathBuf::from(\"/tmp\"),\n        );\n\n        remember_negative_name_query(&state, \"abc\");\n\n        let hit = negative_name_cache_lookup(&state, \"xabc\");\n        assert!(hit.is_some());\n        assert_eq!(hit.unwrap().query_lower, \"abc\");\n\n        remove_negative_name_query(&state, \"abc\");\n\n        let hit_after = negative_name_cache_lookup(&state, \"xabc\");\n        assert!(hit_after.is_none());\n    }\n\n    #[test]\n    fn dir_listing_deep_nested_path_without_time_budget() {\n        let root = temp_case_dir(\"dir_listing_deep\");\n        // Simulate: ~/Library/Containers/jp.naver.line.mac/Data/Library/Containers/jp.naver.line/log/\n        let deep_dir = root\n            .join(\"Library\")\n            .join(\"Containers\")\n            .join(\"jp.naver.line.mac\")\n            .join(\"Data\")\n            .join(\"Library\")\n            .join(\"Containers\")\n            .join(\"jp.naver.line\")\n            .join(\"log\");\n        let sub_dir = deep_dir.join(\"archive\");\n        fs::create_dir_all(&deep_dir).unwrap();\n        fs::create_dir_all(&sub_dir).unwrap();\n\n        let db_path = root.join(\"index.db\");\n        init_db(&db_path).unwrap();\n        let conn = db_connection(&db_path).unwrap();\n        let now = now_epoch();\n\n        let file1 = deep_dir.join(\"20260211_14.txt\");\n        let file2 = sub_dir.join(\"old.log\");\n        for (path, name, dir, ext) in [\n            (&file1, \"20260211_14.txt\", &deep_dir, \"txt\"),\n            (&file2, \"old.log\", &sub_dir, \"log\"),\n        ] {\n            conn.execute(\n                \"INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n                 VALUES(?1, ?2, ?3, 0, ?4, NULL, NULL, ?5, 1)\",\n                params![\n                    path.to_string_lossy().to_string(),\n                    name,\n                    dir.to_string_lossy().to_string(),\n                    ext,\n                    now\n                ],\n            )\n            .unwrap();\n        }\n\n        let state = test_state_for(db_path, root.clone(), root.clone());\n\n        // Query: \"jp.naver.line/log/\" - dir listing, name_like = \"%\"\n        let result = execute_search(\n            &state,\n            \"jp.naver.line/log/\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        assert_eq!(\n            result.results.len(),\n            2,\n            \"should find both files under log/ and log/archive/\"\n        );\n        let names: Vec<&str> = result.results.iter().map(|e| e.name.as_str()).collect();\n        assert!(names.contains(&\"20260211_14.txt\"));\n        assert!(names.contains(&\"old.log\"));\n\n        // Query with glob: \"jp.naver.line/log/ *\"\n        let result2 = execute_search(\n            &state,\n            \"jp.naver.line/log/ *\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        assert_eq!(\n            result2.results.len(),\n            2,\n            \"glob * should also list all files\"\n        );\n\n        // Query with trailing dot: \"jp.naver.line/log/ *.\" - name_like becomes \"%.\"\n        let result3 = execute_search(\n            &state,\n            \"jp.naver.line/log/ *.\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        // \"*.\" matches files ending with \".\" - none of our test files end with \".\"\n        // so this correctly returns 0 (this is expected, NOT a bug)\n        assert_eq!(\n            result3.results.len(),\n            0,\n            \"*. matches only files ending with dot\"\n        );\n\n        // But plain \"/\" at end should list all\n        let result4 = execute_search(\n            &state,\n            \"jp.naver.line/log/\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        assert_eq!(\n            result4.results.len(),\n            2,\n            \"trailing slash should list all files\"\n        );\n\n        let _ = fs::remove_dir_all(root);\n    }\n\n    #[test]\n    fn path_search_multi_dot_ext_uses_like_not_ext_shortcut() {\n        let root = temp_case_dir(\"multi_dot_ext\");\n        let proj_dir = root.join(\"Projects\");\n        fs::create_dir_all(&proj_dir).unwrap();\n\n        let db_path = root.join(\"index.db\");\n        init_db(&db_path).unwrap();\n        let conn = db_connection(&db_path).unwrap();\n        let now = now_epoch();\n\n        let file_path = proj_dir.join(\"archive.tar.gz\");\n        conn.execute(\n            \"INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n             VALUES(?1, ?2, ?3, 0, ?4, NULL, NULL, ?5, 1)\",\n            params![\n                file_path.to_string_lossy().to_string(),\n                \"archive.tar.gz\",\n                proj_dir.to_string_lossy().to_string(),\n                \"gz\",\n                now\n            ],\n        )\n        .unwrap();\n\n        let state = test_state_for(db_path, root.clone(), root.clone());\n        let result = execute_search(\n            &state,\n            \"Projects/ *.tar.gz\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        assert_eq!(result.results.len(), 1);\n        assert!(result.results[0].name == \"archive.tar.gz\");\n\n        let _ = fs::remove_dir_all(root);\n    }\n}\n","structuredPatch":[{"oldStart":411,"oldLines":10,"newStart":411,"newLines":10,"lines":[" pub(crate) fn set_indexing_pragmas(conn: &Connection) -> AppResult<()> {","     conn.execute_batch(","         r#\"","-        PRAGMA synchronous = NORMAL;","-        PRAGMA cache_size = -65536;","-        PRAGMA mmap_size = 268435456;","-        PRAGMA wal_autocheckpoint = 10000;","+        PRAGMA synchronous = OFF;","+        PRAGMA cache_size = -131072;","+        PRAGMA mmap_size = 536870912;","+        PRAGMA wal_autocheckpoint = 0;","         \"#,","     )","     .map_err(|e| e.to_string())"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"1b63c29d-e8c3-40c3-9981-f18a4941a0ab"}
{"parentUuid":"166770d0-3426-421f-bf19-81475cb16506","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_019fCjCvnzHXRgVPufXi8rsW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01K7chE3GBxH5LJPQcDbMDc3","name":"Read","input":{"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","offset":2954,"limit":8},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3133,"cache_read_input_tokens":149826,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3133},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNipSrkEuNaZyX1pN7Q2","type":"assistant","uuid":"d1d789b8-e755-4b73-9ab3-b1e30379c57e","timestamp":"2026-02-22T07:35:05.981Z"}
{"parentUuid":"d1d789b8-e755-4b73-9ab3-b1e30379c57e","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01K7chE3GBxH5LJPQcDbMDc3","toolUseID":"toolu_01K7chE3GBxH5LJPQcDbMDc3","timestamp":"2026-02-22T07:35:05.993Z","uuid":"9ca03e06-5093-47cf-81f1-5b15b9357b74"}
{"parentUuid":"d1d789b8-e755-4b73-9ab3-b1e30379c57e","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01K7chE3GBxH5LJPQcDbMDc3","type":"tool_result","content":"  2954â†’\n  2955â†’        let conn = db_connection(&state.db_path)?;\n  2956â†’        conn.execute(\"DELETE FROM entries\", [])\n  2957â†’            .map_err(|e| e.to_string())?;\n  2958â†’        conn.execute(\"DELETE FROM meta\", [])\n  2959â†’            .map_err(|e| e.to_string())?;\n  2960â†’\n  2961â†’        {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"f4b5024e-0979-4484-8eee-aca620c4f278","timestamp":"2026-02-22T07:35:05.992Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src-tauri/src/main.rs","content":"\n        let conn = db_connection(&state.db_path)?;\n        conn.execute(\"DELETE FROM entries\", [])\n            .map_err(|e| e.to_string())?;\n        conn.execute(\"DELETE FROM meta\", [])\n            .map_err(|e| e.to_string())?;\n\n        {","numLines":8,"startLine":2954,"totalLines":5753}},"sourceToolAssistantUUID":"d1d789b8-e755-4b73-9ab3-b1e30379c57e"}
{"parentUuid":"f4b5024e-0979-4484-8eee-aca620c4f278","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01Y3A5eZWocegBMzUQKqpsyC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01D8wETJ1g1Xf75GKRRDXUYu","name":"Edit","input":{"replace_all":false,"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","old_string":"        let conn = db_connection(&state.db_path)?;\n        conn.execute(\"DELETE FROM entries\", [])\n            .map_err(|e| e.to_string())?;\n        conn.execute(\"DELETE FROM meta\", [])\n            .map_err(|e| e.to_string())?;","new_string":"        let conn = db_connection(&state.db_path)?;\n        // Use synchronous=OFF + large cache to make the bulk DELETE fast\n        let _ = conn.execute_batch(\n            \"PRAGMA synchronous=OFF; PRAGMA cache_size=-131072;\",\n        );\n        conn.execute(\"DELETE FROM entries\", [])\n            .map_err(|e| e.to_string())?;\n        conn.execute(\"DELETE FROM meta\", [])\n            .map_err(|e| e.to_string())?;"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":311,"cache_read_input_tokens":152959,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":311},"output_tokens":18,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNipd1SUhUHCB39gpZfN","type":"assistant","uuid":"e92b0153-4bcc-449d-9ca2-9b5b29d249e7","timestamp":"2026-02-22T07:35:10.656Z"}
{"parentUuid":"e92b0153-4bcc-449d-9ca2-9b5b29d249e7","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01D8wETJ1g1Xf75GKRRDXUYu","toolUseID":"toolu_01D8wETJ1g1Xf75GKRRDXUYu","timestamp":"2026-02-22T07:35:10.667Z","uuid":"e8de19dd-8a87-4da1-b3a3-caeb0de277eb"}
{"parentUuid":"e92b0153-4bcc-449d-9ca2-9b5b29d249e7","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01D8wETJ1g1Xf75GKRRDXUYu","type":"tool_result","content":"The file /Users/al02402336/everything/src-tauri/src/main.rs has been updated successfully."}]},"uuid":"d83acdc3-5bf1-4b76-97c4-75d65f94830b","timestamp":"2026-02-22T07:35:10.666Z","toolUseResult":{"filePath":"/Users/al02402336/everything/src-tauri/src/main.rs","oldString":"        let conn = db_connection(&state.db_path)?;\n        conn.execute(\"DELETE FROM entries\", [])\n            .map_err(|e| e.to_string())?;\n        conn.execute(\"DELETE FROM meta\", [])\n            .map_err(|e| e.to_string())?;","newString":"        let conn = db_connection(&state.db_path)?;\n        // Use synchronous=OFF + large cache to make the bulk DELETE fast\n        let _ = conn.execute_batch(\n            \"PRAGMA synchronous=OFF; PRAGMA cache_size=-131072;\",\n        );\n        conn.execute(\"DELETE FROM entries\", [])\n            .map_err(|e| e.to_string())?;\n        conn.execute(\"DELETE FROM meta\", [])\n            .map_err(|e| e.to_string())?;","originalFile":"#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\n\nuse std::{\n    cmp::Ordering,\n    collections::{HashMap, HashSet},\n    fs,\n    hash::{Hash, Hasher},\n    io::{self, BufRead, BufReader, Write},\n    path::{Path, PathBuf},\n    process::{Command, Stdio},\n    sync::{\n        atomic::{AtomicBool, Ordering as AtomicOrdering},\n        Arc, OnceLock,\n    },\n    time::{Duration, Instant, SystemTime, UNIX_EPOCH},\n};\n\nuse parking_lot::{Mutex, RwLock};\nuse rusqlite::{params, params_from_iter, types::Value as SqlValue, Connection};\nuse serde::Serialize;\nuse tauri::{AppHandle, Emitter, Manager, State};\n#[cfg(target_os = \"macos\")]\nuse tauri_plugin_global_shortcut::{Code, GlobalShortcutExt, Modifiers, Shortcut};\n#[cfg(target_os = \"windows\")]\nuse std::os::windows::process::CommandExt;\nuse walkdir::WalkDir;\n\nmod fd_search;\nmod gitignore_filter;\n#[cfg(target_os = \"macos\")]\nmod mac;\nmod mem_search;\nmod query;\n#[cfg(target_os = \"windows\")]\nmod win;\nuse fd_search::{FdSearchCache, FdSearchResultDto};\nuse query::{escape_like, parse_query, SearchMode};\n\nconst DEFAULT_LIMIT: u32 = 300;\nconst SHORT_QUERY_LIMIT: u32 = 100;\nconst MAX_LIMIT: u32 = 1000;\npub(crate) const BATCH_SIZE: usize = 10_000;\nconst RECENT_OP_TTL: Duration = Duration::from_secs(2);\npub(crate) const WATCH_DEBOUNCE: Duration = Duration::from_millis(300);\nconst NEGATIVE_CACHE_TTL: Duration = Duration::from_secs(60);\nconst NEGATIVE_CACHE_FALLBACK_WINDOW: Duration = Duration::from_millis(550);\nconst DB_VERSION: i32 = 4;\nconst DEFERRED_DIR_NAMES: &[&str] = &[\n    \"Library\", \".Trash\", \".Trashes\",\n    // Windows system directories (deferred when scan_root is C:\\)\n    \"Windows\", \"Program Files\", \"Program Files (x86)\",\n    \"$Recycle.Bin\", \"System Volume Information\", \"Recovery\", \"PerfLogs\",\n];\nconst SHALLOW_SCAN_DEPTH: usize = 6;\nfn jwalk_num_threads() -> usize {\n    std::thread::available_parallelism()\n        .map(|n| (n.get() / 2).max(4).min(16))\n        .unwrap_or(8)\n}\n\npub(crate) const BUILTIN_SKIP_NAMES: &[&str] = &[\n    \".git\",\n    \"node_modules\",\n    \".Trash\",\n    \".Trashes\",\n    \".npm\",\n    \".cache\",\n    \"CMakeFiles\",\n    \".qtc_clangd\",\n    \"__pycache__\",\n    \".gradle\",\n    \"DerivedData\",\n];\n\n/// Path segments whose name ends with one of these suffixes are skipped.\n/// e.g. \"*.build\" skips Xcode intermediate build directories like \"MyApp.build\".\npub(crate) const BUILTIN_SKIP_SUFFIXES: &[&str] = &[\n    \".build\", // Xcode intermediate build dir (MyApp.build, Objects-normal, etc.)\n];\n\npub(crate) const BUILTIN_SKIP_PATHS: &[&str] = &[\n    // macOS\n    \"Library/Caches\",\n    \"Library/Developer/CoreSimulator\",\n    \"Library/Logs\",\n    // Cross-platform\n    \".vscode/extensions\",\n    // Windows: noisy system directories under AppData\n    \"AppData/Local/Temp\",\n    \"AppData/Local/Microsoft\",\n    \"AppData/Local/Google\",\n    \"AppData/Local/Packages\",\n];\n\ntype AppResult<T> = Result<T, String>;\nstatic SEARCH_LOG_ENABLED: OnceLock<bool> = OnceLock::new();\nstatic PERF_LOG_ENABLED: OnceLock<bool> = OnceLock::new();\nstatic BENCH_MODE_ENABLED: OnceLock<bool> = OnceLock::new();\nstatic STARTUP_T0: OnceLock<Instant> = OnceLock::new();\n\nfn startup_elapsed_ms() -> u128 {\n    STARTUP_T0\n        .get()\n        .map(|started| started.elapsed().as_millis())\n        .unwrap_or(0)\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct EntryDto {\n    pub path: String,\n    pub name: String,\n    pub dir: String,\n    pub is_dir: bool,\n    pub ext: Option<String>,\n    pub size: Option<i64>,\n    pub mtime: Option<i64>,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct IndexStatusDto {\n    state: String,\n    entries_count: u64,\n    last_updated: Option<i64>,\n    permission_errors: u64,\n    message: Option<String>,\n    scanned: u64,\n    indexed: u64,\n    current_path: String,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct IndexProgressEvent {\n    scanned: u64,\n    indexed: u64,\n    current_path: String,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct IndexStateEvent {\n    state: String,\n    message: Option<String>,\n    is_catchup: bool,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct IndexUpdatedEvent {\n    entries_count: u64,\n    last_updated: i64,\n    permission_errors: u64,\n}\n\n#[derive(Debug, Clone)]\nstruct SearchExecution {\n    query: String,\n    sort_by: String,\n    sort_dir: String,\n    effective_limit: u32,\n    offset: u32,\n    mode_label: String,\n    results: Vec<EntryDto>,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct SearchResultDto {\n    entries: Vec<EntryDto>,\n    mode_label: String,\n    /// Total number of results matching the query (ignoring LIMIT/OFFSET).\n    total_count: u32,\n    /// True when total_count is exact. False means frontend should treat it as unknown.\n    total_known: bool,\n}\n\n#[allow(dead_code)]\n#[derive(Debug, Clone)]\nstruct BenchCase {\n    id: &'static str,\n    query: &'static str,\n    sort_by: &'static str,\n    sort_dir: &'static str,\n    limit: u32,\n    offset: u32,\n    expected_min_results: usize,\n}\n\n#[allow(dead_code)]\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct BenchCaseResult {\n    id: String,\n    query: String,\n    mode: String,\n    sort_by: String,\n    sort_dir: String,\n    limit: u32,\n    offset: u32,\n    elapsed_ms: f64,\n    result_count: usize,\n    expected_min_results: usize,\n    passed: bool,\n    top_results: Vec<String>,\n    error: Option<String>,\n}\n\n#[allow(dead_code)]\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct BenchReport {\n    run_label: String,\n    started_at: i64,\n    completed_at: i64,\n    home_dir: String,\n    db_path: String,\n    index_wait_ms: u128,\n    index_scanned: u64,\n    index_indexed: u64,\n    index_entries_count: u64,\n    index_permission_errors: u64,\n    index_message: Option<String>,\n    search_iterations: u32,\n    search_results: Vec<BenchCaseResult>,\n}\n\n#[derive(Debug, Clone)]\npub(crate) enum IndexState {\n    Ready,\n    Indexing,\n    Error,\n}\n\nimpl IndexState {\n    fn as_str(&self) -> &'static str {\n        match self {\n            Self::Ready => \"Ready\",\n            Self::Indexing => \"Indexing\",\n            Self::Error => \"Error\",\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct IndexStatus {\n    pub(crate) state: IndexState,\n    pub(crate) entries_count: u64,\n    pub(crate) last_updated: Option<i64>,\n    pub(crate) permission_errors: u64,\n    pub(crate) message: Option<String>,\n    pub(crate) scanned: u64,\n    pub(crate) indexed: u64,\n    pub(crate) current_path: String,\n}\n\nimpl Default for IndexStatus {\n    fn default() -> Self {\n        Self {\n            state: IndexState::Indexing,\n            entries_count: 0,\n            last_updated: None,\n            permission_errors: 0,\n            message: None,\n            scanned: 0,\n            indexed: 0,\n            current_path: String::new(),\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\n#[allow(dead_code)]\npub(crate) struct RecentOp {\n    old_path: Option<String>,\n    new_path: Option<String>,\n    op_type: &'static str,\n    at: Instant,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub(crate) enum IgnorePattern {\n    AnySegment(String),\n    Glob(String),\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct IgnoreRulesCache {\n    roots: Vec<PathBuf>,\n    patterns: Vec<IgnorePattern>,\n    pathignore_mtime: Option<SystemTime>,\n    gitignore_mtime: Option<SystemTime>,\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct AppState {\n    pub(crate) db_path: PathBuf,\n    pub(crate) home_dir: PathBuf,\n    pub(crate) scan_root: PathBuf,\n    pub(crate) cwd: PathBuf,\n    pub(crate) path_ignores: Arc<Vec<PathBuf>>,\n    pub(crate) path_ignore_patterns: Arc<Vec<IgnorePattern>>,\n    pub(crate) db_ready: Arc<AtomicBool>,\n    pub(crate) indexing_active: Arc<AtomicBool>,\n    pub(crate) status: Arc<Mutex<IndexStatus>>,\n    pub(crate) recent_ops: Arc<Mutex<Vec<RecentOp>>>,\n    pub(crate) icon_cache: Arc<Mutex<HashMap<String, Vec<u8>>>>,\n    pub(crate) fd_search_cache: Arc<Mutex<Option<FdSearchCache>>>,\n    pub(crate) negative_name_cache: Arc<Mutex<HashMap<String, NegativeNameEntry>>>,\n    pub(crate) ignore_cache: Arc<Mutex<Option<IgnoreRulesCache>>>,\n    pub(crate) gitignore: Arc<gitignore_filter::LazyGitignoreFilter>,\n    /// In-memory index for instant search while DB upsert runs in background.\n    /// Set by MFT scan, cleared after background DB upsert completes.\n    pub(crate) mem_index: Arc<RwLock<Option<Arc<mem_search::MemIndex>>>>,\n    /// Signal to stop the file watcher (RDCW / USN). Set to true on reset_index.\n    pub(crate) watcher_stop: Arc<AtomicBool>,\n    /// Set to true while a file watcher event loop is running.\n    pub(crate) watcher_active: Arc<AtomicBool>,\n    /// Set to true once frontend onMount has completed enough to accept user input.\n    pub(crate) frontend_ready: Arc<AtomicBool>,\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct NegativeNameEntry {\n    created_at: Instant,\n    fallback_checked: bool,\n}\n\n#[derive(Debug, Clone)]\nstruct NegativeCacheHit {\n    query_lower: String,\n    age: Duration,\n    fallback_checked: bool,\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct IndexRow {\n    pub(crate) path: String,\n    pub(crate) name: String,\n    pub(crate) dir: String,\n    pub(crate) is_dir: i64,\n    pub(crate) ext: Option<String>,\n    pub(crate) mtime: Option<i64>,\n    pub(crate) size: Option<i64>,\n    pub(crate) indexed_at: i64,\n    pub(crate) run_id: i64,\n}\n\npub(crate) fn now_epoch() -> i64 {\n    SystemTime::now()\n        .duration_since(UNIX_EPOCH)\n        .map(|d| d.as_secs() as i64)\n        .unwrap_or_default()\n}\n\nfn env_truthy(key: &str) -> bool {\n    std::env::var(key)\n        .ok()\n        .map(|value| {\n            matches!(\n                value.trim().to_ascii_lowercase().as_str(),\n                \"1\" | \"true\" | \"yes\" | \"on\"\n            )\n        })\n        .unwrap_or(false)\n}\n\nfn bench_mode_enabled() -> bool {\n    *BENCH_MODE_ENABLED.get_or_init(|| env_truthy(\"EVERYTHING_BENCH\"))\n}\n\nfn perf_log_enabled() -> bool {\n    *PERF_LOG_ENABLED.get_or_init(|| env_truthy(\"FASTFIND_PERF_LOG\") || bench_mode_enabled())\n}\n\npub(crate) fn perf_log(message: impl AsRef<str>) {\n    if perf_log_enabled() {\n        eprintln!(\"[perf] {}\", message.as_ref());\n    }\n}\n\nfn db_connection_with_timeout(db_path: &Path, busy_timeout_ms: u32) -> AppResult<Connection> {\n    let conn = Connection::open(db_path).map_err(|e| e.to_string())?;\n    conn.execute_batch(&format!(\n        r#\"\n        PRAGMA journal_mode=WAL;\n        PRAGMA synchronous=NORMAL;\n        PRAGMA temp_store=MEMORY;\n        PRAGMA busy_timeout={busy_timeout_ms};\n        \"#,\n    ))\n    .map_err(|e| e.to_string())?;\n    Ok(conn)\n}\n\npub(crate) fn db_connection(db_path: &Path) -> AppResult<Connection> {\n    db_connection_with_timeout(db_path, 3000)\n}\n\nfn db_connection_for_search(db_path: &Path) -> AppResult<Connection> {\n    let conn = db_connection_with_timeout(db_path, 500)?;\n    conn.execute_batch(\n        \"PRAGMA cache_size = -32768;\n         PRAGMA mmap_size = 268435456;\",\n    )\n    .map_err(|e| e.to_string())?;\n    Ok(conn)\n}\n\npub(crate) fn set_indexing_pragmas(conn: &Connection) -> AppResult<()> {\n    conn.execute_batch(\n        r#\"\n        PRAGMA synchronous = OFF;\n        PRAGMA cache_size = -131072;\n        PRAGMA mmap_size = 536870912;\n        PRAGMA wal_autocheckpoint = 0;\n        \"#,\n    )\n    .map_err(|e| e.to_string())\n}\n\npub(crate) fn restore_normal_pragmas(conn: &Connection) -> AppResult<()> {\n    conn.execute_batch(\n        r#\"\n        PRAGMA synchronous = NORMAL;\n        PRAGMA cache_size = -16384;\n        PRAGMA mmap_size = 268435456;\n        PRAGMA wal_autocheckpoint = 1000;\n        \"#,\n    )\n    .map_err(|e| e.to_string())?;\n    conn.execute_batch(\"PRAGMA wal_checkpoint(TRUNCATE);\")\n        .map_err(|e| e.to_string())?;\n    Ok(())\n}\n\nfn init_db(db_path: &Path) -> AppResult<()> {\n    let t = Instant::now();\n    let conn = db_connection(db_path)?;\n    eprintln!(\"[init_db] +{}ms db_connection opened\", t.elapsed().as_millis());\n\n    let current_version: i32 = conn\n        .query_row(\"PRAGMA user_version\", [], |row| row.get(0))\n        .unwrap_or(0);\n    if current_version != DB_VERSION {\n        conn.execute_batch(\n            r#\"\n            DROP TRIGGER IF EXISTS entries_ai;\n            DROP TRIGGER IF EXISTS entries_ad;\n            DROP TRIGGER IF EXISTS entries_au;\n            DROP TABLE IF EXISTS entries_fts;\n            DROP TABLE IF EXISTS entries;\n            \"#,\n        )\n        .map_err(|e| e.to_string())?;\n        conn.execute_batch(&format!(\"PRAGMA user_version = {};\", DB_VERSION))\n            .map_err(|e| e.to_string())?;\n    }\n    eprintln!(\"[init_db] +{}ms version check done (v={})\", t.elapsed().as_millis(), current_version);\n\n    conn.execute_batch(\n        r#\"\n        CREATE TABLE IF NOT EXISTS entries (\n          id INTEGER PRIMARY KEY,\n          path TEXT NOT NULL UNIQUE,\n          name TEXT NOT NULL,\n          dir TEXT NOT NULL,\n          is_dir INTEGER NOT NULL,\n          ext TEXT,\n          mtime INTEGER,\n          size INTEGER,\n          indexed_at INTEGER NOT NULL,\n          run_id INTEGER NOT NULL DEFAULT 0\n        );\n\n        CREATE INDEX IF NOT EXISTS idx_entries_dir_ext_name_nocase ON entries(dir, ext, name COLLATE NOCASE);\n        CREATE INDEX IF NOT EXISTS idx_entries_mtime ON entries(mtime);\n        CREATE INDEX IF NOT EXISTS idx_entries_name_nocase ON entries(name COLLATE NOCASE);\n        CREATE INDEX IF NOT EXISTS idx_entries_ext_name ON entries(ext, name COLLATE NOCASE);\n\n        CREATE TABLE IF NOT EXISTS meta (\n          key TEXT PRIMARY KEY,\n          value TEXT NOT NULL\n        );\n        \"#,\n    )\n    .map_err(|e| e.to_string())?;\n    eprintln!(\"[init_db] +{}ms schema ensured\", t.elapsed().as_millis());\n\n    let legacy_index_migration_key = \"migration_drop_idx_entries_dir_name_nocase_v1\";\n    let migrated = get_meta(&conn, legacy_index_migration_key)\n        .map(|v| v == \"1\")\n        .unwrap_or(false);\n    if !migrated {\n        conn.execute_batch(\"DROP INDEX IF EXISTS idx_entries_dir_name_nocase;\")\n            .map_err(|e| e.to_string())?;\n        set_meta(&conn, legacy_index_migration_key, \"1\")?;\n    }\n    eprintln!(\"[init_db] +{}ms total\", t.elapsed().as_millis());\n\n    Ok(())\n}\n\npub(crate) fn get_meta(conn: &Connection, key: &str) -> Option<String> {\n    conn.query_row(\n        \"SELECT value FROM meta WHERE key = ?1\",\n        params![key],\n        |row| row.get(0),\n    )\n    .ok()\n}\n\npub(crate) fn set_meta(conn: &Connection, key: &str, value: &str) -> AppResult<()> {\n    conn.execute(\n        \"INSERT OR REPLACE INTO meta(key, value) VALUES(?1, ?2)\",\n        params![key, value],\n    )\n    .map_err(|e| e.to_string())?;\n    Ok(())\n}\n\nfn update_counts(state: &AppState) -> AppResult<(u64, Option<i64>)> {\n    let conn = db_connection(&state.db_path)?;\n\n    let entries_count = conn\n        .query_row(\"SELECT COUNT(*) FROM entries\", [], |row| {\n            row.get::<_, i64>(0)\n        })\n        .map_err(|e| e.to_string())?\n        .max(0) as u64;\n\n    let last_updated = conn\n        .query_row(\"SELECT MAX(indexed_at) FROM entries\", [], |row| {\n            row.get::<_, Option<i64>>(0)\n        })\n        .map_err(|e| e.to_string())?;\n\n    Ok((entries_count, last_updated))\n}\n\npub(crate) fn update_status_counts(state: &AppState) -> AppResult<(u64, Option<i64>)> {\n    let (entries_count, last_updated) = update_counts(state)?;\n    let mut status = state.status.lock();\n    status.entries_count = entries_count;\n    status.last_updated = last_updated;\n    Ok((entries_count, last_updated))\n}\n\npub(crate) fn invalidate_search_caches(state: &AppState) {\n    state.fd_search_cache.lock().take();\n    state.negative_name_cache.lock().clear();\n}\n\nfn prune_negative_name_cache(cache: &mut HashMap<String, NegativeNameEntry>) {\n    let now = Instant::now();\n    cache.retain(|_, entry| now.duration_since(entry.created_at) <= NEGATIVE_CACHE_TTL);\n}\n\nfn negative_name_cache_lookup(state: &AppState, query: &str) -> Option<NegativeCacheHit> {\n    if query.is_empty() {\n        return None;\n    }\n    let q = query.to_lowercase();\n    let now = Instant::now();\n    let mut cache = state.negative_name_cache.lock();\n    prune_negative_name_cache(&mut cache);\n    cache\n        .iter()\n        .filter(|(key, _)| q.contains(key.as_str()))\n        .max_by_key(|(key, _)| key.len())\n        .map(|(key, entry)| NegativeCacheHit {\n            query_lower: key.clone(),\n            age: now.duration_since(entry.created_at),\n            fallback_checked: entry.fallback_checked,\n        })\n}\n\nfn remember_negative_name_query(state: &AppState, query: &str) {\n    if query.is_empty() {\n        return;\n    }\n    let normalized = query.to_lowercase();\n    let mut cache = state.negative_name_cache.lock();\n    prune_negative_name_cache(&mut cache);\n\n    if cache.contains_key(&normalized) {\n        return;\n    }\n\n    cache.insert(\n        normalized,\n        NegativeNameEntry {\n            created_at: Instant::now(),\n            fallback_checked: false,\n        },\n    );\n    const MAX_NEGATIVE_CACHE: usize = 512;\n    if cache.len() > MAX_NEGATIVE_CACHE {\n        let mut entries: Vec<_> =\n            cache.iter().map(|(k, v)| (k.clone(), v.created_at)).collect();\n        entries.sort_by_key(|(_, t)| *t);\n        let drop_count = cache.len() - MAX_NEGATIVE_CACHE;\n        for (key, _) in entries.into_iter().take(drop_count) {\n            cache.remove(&key);\n        }\n    }\n}\n\nfn remove_negative_name_query(state: &AppState, query: &str) {\n    if query.is_empty() {\n        return;\n    }\n    let normalized = query.to_lowercase();\n    state.negative_name_cache.lock().remove(&normalized);\n}\n\nfn mark_negative_name_fallback_checked(state: &AppState, query_lower: &str) {\n    let mut cache = state.negative_name_cache.lock();\n    if let Some(entry) = cache.get_mut(query_lower) {\n        entry.fallback_checked = true;\n    }\n}\n\nfn sort_clause(sort_by: &str, sort_dir: &str, prefix: &str) -> String {\n    match (sort_by, sort_dir) {\n        (\"name\", \"desc\") => {\n            format!(\"{prefix}name COLLATE NOCASE DESC, {prefix}path COLLATE NOCASE DESC\")\n        }\n        (\"mtime\", \"asc\") => {\n            format!(\"COALESCE({prefix}mtime, 0) ASC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        (\"mtime\", \"desc\") => {\n            format!(\"COALESCE({prefix}mtime, 0) DESC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        (\"dir\", \"asc\") => {\n            format!(\"{prefix}dir COLLATE NOCASE ASC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        (\"dir\", \"desc\") => {\n            format!(\"{prefix}dir COLLATE NOCASE DESC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        (\"size\", \"asc\") => {\n            format!(\"{prefix}size IS NULL ASC, {prefix}size ASC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        (\"size\", \"desc\") => {\n            format!(\"{prefix}size IS NULL ASC, {prefix}size DESC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        _ => format!(\"{prefix}name COLLATE NOCASE ASC, {prefix}path COLLATE NOCASE ASC\"),\n    }\n}\n\nfn contains_glob_meta(s: &str) -> bool {\n    s.contains('*') || s.contains('?')\n}\n\n/// Detect if a LIKE pattern is a pure extension filter (e.g. `%.rs`).\n/// Returns the lowercase extension if matched, None otherwise.\nfn extract_ext_from_like(like_pattern: &str) -> Option<String> {\n    let rest = like_pattern.strip_prefix('%')?;\n    let ext = rest.strip_prefix('.')?;\n    if ext.is_empty()\n        || ext.contains('%')\n        || ext.contains('_')\n        || ext.contains('\\\\')\n        || ext.contains('/')\n        || ext.contains('.')\n    {\n        return None;\n    }\n    Some(ext.to_lowercase())\n}\n\nfn normalize_hint_to_native(dir_hint: &str) -> (String, bool) {\n    let native = dir_hint.replace('/', &std::path::MAIN_SEPARATOR.to_string());\n    let is_abs = Path::new(&native).is_absolute();\n    (native, is_abs)\n}\n\nfn last_segment(dir_hint: &str) -> &str {\n    dir_hint\n        .rsplit(|c| c == '/' || c == '\\\\')\n        .find(|seg| !seg.is_empty())\n        .unwrap_or(dir_hint)\n}\n\nfn resolve_dir_hint(home_dir: &Path, dir_hint: &str) -> Option<PathBuf> {\n    if dir_hint.is_empty() || contains_glob_meta(dir_hint) {\n        return None;\n    }\n\n    let candidate = if dir_hint == \"~\" {\n        home_dir.to_path_buf()\n    } else if let Some(rest) = dir_hint.strip_prefix(\"~/\") {\n        home_dir.join(rest)\n    } else {\n        let (native_hint, is_absolute) = normalize_hint_to_native(dir_hint);\n        if is_absolute {\n            PathBuf::from(native_hint)\n        } else {\n            home_dir.join(native_hint)\n        }\n    };\n\n    if candidate.is_dir() {\n        Some(candidate)\n    } else {\n        None\n    }\n}\n\nconst RESOLVE_DIRS_MAX: usize = 20;\n\nfn resolve_dirs_from_db(conn: &Connection, dir_hint: &str) -> Vec<String> {\n    if dir_hint.is_empty() || contains_glob_meta(dir_hint) {\n        return Vec::new();\n    }\n    let last_seg = last_segment(dir_hint);\n    let sep = std::path::MAIN_SEPARATOR;\n    let (native_hint, is_absolute) = normalize_hint_to_native(dir_hint);\n    let sep_str = sep.to_string();\n    let escaped_sep = escape_like(&sep_str);\n    let path_pattern = if is_absolute {\n        format!(\"%{}\", escape_like(&native_hint))\n    } else {\n        format!(\"%{escaped_sep}{}\", escape_like(&native_hint))\n    };\n    let fetch_limit = (RESOLVE_DIRS_MAX + 1) as i64;\n    let mut stmt = match conn.prepare(\n        \"SELECT path FROM entries WHERE name = ?1 COLLATE NOCASE AND is_dir = 1 AND path LIKE ?2 ESCAPE '\\\\' LIMIT ?3\",\n    ) {\n        Ok(s) => s,\n        Err(_) => return Vec::new(),\n    };\n    let rows = match stmt.query_map(params![last_seg, path_pattern, fetch_limit], |row| {\n        row.get::<_, String>(0)\n    }) {\n        Ok(r) => r,\n        Err(_) => return Vec::new(),\n    };\n    let dirs: Vec<String> = rows.filter_map(|r| r.ok()).collect();\n    if dirs.len() > RESOLVE_DIRS_MAX {\n        return Vec::new();\n    }\n    dirs\n}\n\nfn normalize_slashes(s: String) -> String {\n    s.replace('\\\\', \"/\")\n}\n\nfn resolve_ignore_path(raw: &str, base_dir: &Path, home_dir: &Path) -> Option<PathBuf> {\n    let trimmed = raw.trim();\n    if trimmed.is_empty() || trimmed.starts_with('#') || trimmed.starts_with('!') {\n        return None;\n    }\n\n    let mut path = if trimmed == \"~\" {\n        home_dir.to_path_buf()\n    } else if let Some(rest) = trimmed.strip_prefix(\"~/\") {\n        home_dir.join(rest)\n    } else {\n        PathBuf::from(trimmed)\n    };\n\n    if !path.is_absolute() {\n        path = base_dir.join(path);\n    }\n\n    Some(fs::canonicalize(&path).unwrap_or(path))\n}\n\nfn normalize_ignore_pattern(raw: &str, base_dir: &Path, home_dir: &Path) -> String {\n    let trimmed = raw.trim().trim_end_matches('/').to_string();\n    if trimmed == \"~\" {\n        return normalize_slashes(home_dir.to_string_lossy().to_string());\n    }\n    if let Some(rest) = trimmed.strip_prefix(\"~/\") {\n        return normalize_slashes(home_dir.join(rest).to_string_lossy().to_string());\n    }\n    if trimmed.starts_with('/') || trimmed.starts_with(\"**/\") {\n        return trimmed;\n    }\n    normalize_slashes(base_dir.join(&trimmed).to_string_lossy().to_string())\n}\n\nfn parse_ignore_pattern(raw: &str, base_dir: &Path, home_dir: &Path) -> Option<IgnorePattern> {\n    let trimmed = raw.trim().trim_end_matches('/');\n    if trimmed.is_empty() {\n        return None;\n    }\n\n    if let Some(segment) = trimmed.strip_prefix(\"**/\") {\n        if !segment.is_empty() && !segment.contains('/') && !contains_glob_meta(segment) {\n            return Some(IgnorePattern::AnySegment(segment.to_string()));\n        }\n    }\n\n    Some(IgnorePattern::Glob(normalize_ignore_pattern(\n        trimmed, base_dir, home_dir,\n    )))\n}\n\nfn ignore_pattern_key(pattern: &IgnorePattern) -> String {\n    match pattern {\n        IgnorePattern::AnySegment(segment) => format!(\"seg:{segment}\"),\n        IgnorePattern::Glob(glob) => format!(\"glob:{glob}\"),\n    }\n}\n\nfn find_file_upward(start: &Path, file_name: &str) -> Option<PathBuf> {\n    let mut current = Some(start);\n    while let Some(dir) = current {\n        let candidate = dir.join(file_name);\n        if candidate.is_file() {\n            return Some(candidate);\n        }\n        current = dir.parent();\n    }\n    None\n}\n\nfn find_git_root(start: &Path) -> Option<PathBuf> {\n    let mut current = Some(start);\n    while let Some(dir) = current {\n        let marker = dir.join(\".git\");\n        if marker.is_dir() || marker.is_file() {\n            return Some(dir.to_path_buf());\n        }\n        current = dir.parent();\n    }\n    None\n}\n\nfn load_pathignore_rules(home_dir: &Path, cwd: &Path) -> (Vec<PathBuf>, Vec<IgnorePattern>) {\n    let mut files = Vec::new();\n    if let Some(file) = find_file_upward(cwd, \".pathignore\") {\n        files.push(file);\n    } else {\n        files.push(cwd.join(\".pathignore\"));\n    }\n    let home_file = home_dir.join(\".pathignore\");\n    if !files.iter().any(|p| p == &home_file) {\n        files.push(home_file);\n    }\n\n    let mut roots = Vec::new();\n    let mut patterns = Vec::new();\n    let mut seen_roots = HashSet::new();\n    let mut seen_patterns = HashSet::new();\n\n    for file in files {\n        let Ok(contents) = fs::read_to_string(&file) else {\n            continue;\n        };\n        let base_dir = file.parent().unwrap_or_else(|| Path::new(\"/\"));\n        for line in contents.lines() {\n            let trimmed = line.trim();\n            if trimmed.is_empty() || trimmed.starts_with('#') || trimmed.starts_with('!') {\n                continue;\n            }\n\n            if contains_glob_meta(trimmed) {\n                let Some(pattern) = parse_ignore_pattern(trimmed, base_dir, home_dir) else {\n                    continue;\n                };\n                let key = ignore_pattern_key(&pattern);\n                if seen_patterns.insert(key) {\n                    patterns.push(pattern);\n                }\n                continue;\n            }\n\n            let Some(path) = resolve_ignore_path(trimmed, base_dir, home_dir) else {\n                continue;\n            };\n\n            let key = path.to_string_lossy().to_string();\n            if seen_roots.insert(key) {\n                roots.push(path);\n            }\n        }\n    }\n\n    (roots, patterns)\n}\n\nfn load_gitignore_roots(home_dir: &Path, cwd: &Path) -> Vec<PathBuf> {\n    let gitignore = if let Some(root) = find_git_root(cwd) {\n        root.join(\".gitignore\")\n    } else if let Some(file) = find_file_upward(&cwd, \".gitignore\") {\n        file\n    } else {\n        return Vec::new();\n    };\n    let contents = match fs::read_to_string(&gitignore) {\n        Ok(contents) => contents,\n        Err(_) => return Vec::new(),\n    };\n\n    let mut roots = Vec::new();\n    let mut seen = HashSet::new();\n\n    for line in contents.lines() {\n        let trimmed = line.trim();\n        if trimmed.is_empty() || trimmed.starts_with('#') || trimmed.starts_with('!') {\n            continue;\n        }\n        if contains_glob_meta(trimmed) || trimmed.contains('[') {\n            continue;\n        }\n\n        let normalized = trimmed.trim_start_matches('/').trim_end_matches('/');\n        if normalized.is_empty() {\n            continue;\n        }\n\n        let Some(path) = resolve_ignore_path(normalized, &cwd, home_dir) else {\n            continue;\n        };\n\n        let key = path.to_string_lossy().to_string();\n        if seen.insert(key) {\n            roots.push(path);\n        }\n    }\n\n    roots\n}\n\n#[cfg(target_os = \"macos\")]\nfn macos_tcc_ignore_roots(home_dir: &Path) -> Vec<PathBuf> {\n    let library = home_dir.join(\"Library\");\n    let app_support = library.join(\"Application Support\");\n    let caches = library.join(\"Caches\");\n\n    let dirs: Vec<PathBuf> = vec![\n        home_dir.join(\".Trash\"),\n        library.join(\"Accounts\"),\n        library.join(\"AppleMediaServices\"),\n        library.join(\"Assistant\").join(\"SiriVocabulary\"),\n        library.join(\"Autosave Information\"),\n        library.join(\"Biome\"),\n        library.join(\"Calendars\"),\n        library.join(\"com.apple.aiml.instrumentation\"),\n        library.join(\"ContainerManager\"),\n        library.join(\"Cookies\"),\n        library.join(\"CoreFollowUp\"),\n        library.join(\"Daemon Containers\"),\n        library.join(\"DoNotDisturb\"),\n        library.join(\"DuetExpertCenter\"),\n        library.join(\"Group Containers\"),\n        library.join(\"HomeKit\"),\n        library.join(\"Developer\").join(\"Xcode\").join(\"DerivedData\"),\n        library.join(\"IdentityServices\"),\n        library.join(\"IntelligencePlatform\"),\n        library.join(\"Mail\"),\n        library.join(\"Messages\"),\n        library.join(\"Metadata\").join(\"CoreSpotlight\"),\n        library.join(\"PersonalizationPortrait\"),\n        library.join(\"Reminders\"),\n        library.join(\"Safari\"),\n        library.join(\"Sharing\"),\n        library.join(\"Shortcuts\"),\n        library.join(\"StatusKit\"),\n        library.join(\"Suggestions\"),\n        library.join(\"Trial\"),\n        library.join(\"Weather\"),\n        app_support.join(\"AddressBook\"),\n        app_support.join(\"CallHistoryDB\"),\n        app_support.join(\"CallHistoryTransactions\"),\n        app_support.join(\"CloudDocs\"),\n        app_support.join(\"com.apple.avfoundation\"),\n        app_support.join(\"com.apple.sharedfilelist\"),\n        app_support.join(\"com.apple.TCC\"),\n        app_support.join(\"DifferentialPrivacy\"),\n        app_support.join(\"FaceTime\"),\n        app_support.join(\"FileProvider\"),\n        app_support.join(\"Knowledge\"),\n        caches.join(\"CloudKit\"),\n        caches.join(\"com.apple.ap.adprivacyd\"),\n        caches.join(\"com.apple.containermanagerd\"),\n        caches.join(\"com.apple.findmy.fmfcore\"),\n        caches.join(\"com.apple.findmy.fmipcore\"),\n        caches.join(\"com.apple.homed\"),\n        caches.join(\"com.apple.HomeKit\"),\n        caches.join(\"com.apple.Safari\"),\n        caches.join(\"FamilyCircle\"),\n    ];\n\n    dirs.into_iter().filter(|p| p.exists()).collect()\n}\n\n#[cfg(not(target_os = \"macos\"))]\nfn macos_tcc_ignore_roots(_home_dir: &Path) -> Vec<PathBuf> {\n    Vec::new()\n}\n\n/// Directories under home that generate heavy background I/O on Windows\n/// (browser caches, Windows Update temp files, UWP package state, etc.).\n/// Pruning these from the MFT subtree eliminates noisy USN records.\n#[cfg(target_os = \"windows\")]\nfn windows_noisy_roots(home_dir: &Path) -> Vec<PathBuf> {\n    let local = home_dir.join(\"AppData\").join(\"Local\");\n    let dirs = vec![\n        local.join(\"Temp\"),\n        local.join(\"Microsoft\"),\n        local.join(\"Google\"),\n        local.join(\"Packages\"),\n        // C:\\ system directories (Windows is deferred, not excluded)\n        PathBuf::from(\"C:\\\\$Recycle.Bin\"),\n        PathBuf::from(\"C:\\\\System Volume Information\"),\n        PathBuf::from(\"C:\\\\Recovery\"),\n        PathBuf::from(\"C:\\\\PerfLogs\"),\n    ];\n    dirs.into_iter().filter(|p| p.exists()).collect()\n}\n\n#[cfg(not(target_os = \"windows\"))]\nfn windows_noisy_roots(_home_dir: &Path) -> Vec<PathBuf> {\n    Vec::new()\n}\n\npub(crate) fn effective_ignore_rules(\n    home_dir: &Path,\n    cwd: &Path,\n    base_roots: &[PathBuf],\n    base_patterns: &[IgnorePattern],\n) -> (Vec<PathBuf>, Vec<IgnorePattern>) {\n    let mut roots = base_roots.to_vec();\n    let mut patterns = base_patterns.to_vec();\n    let mut seen: HashSet<String> = roots\n        .iter()\n        .map(|p| p.to_string_lossy().to_string())\n        .collect();\n    let mut seen_patterns: HashSet<String> = patterns.iter().map(ignore_pattern_key).collect();\n\n    let (pathignore_roots, pathignore_patterns) = load_pathignore_rules(home_dir, cwd);\n    for root in pathignore_roots\n        .into_iter()\n        .chain(load_gitignore_roots(home_dir, cwd).into_iter())\n        .chain(macos_tcc_ignore_roots(home_dir).into_iter())\n        .chain(windows_noisy_roots(home_dir).into_iter())\n    {\n        let key = root.to_string_lossy().to_string();\n        if seen.insert(key) {\n            roots.push(root);\n        }\n    }\n\n    for pattern in pathignore_patterns\n        .into_iter()\n        .chain(builtin_ignore_patterns(home_dir))\n    {\n        let key = ignore_pattern_key(&pattern);\n        if seen_patterns.insert(key) {\n            patterns.push(pattern);\n        }\n    }\n\n    (roots, patterns)\n}\n\nfn builtin_ignore_patterns(home_dir: &Path) -> Vec<IgnorePattern> {\n    let home = normalize_slashes(home_dir.to_string_lossy().to_string());\n    vec![\n        // ~/Library/Application Support/*/Cache*\n        IgnorePattern::Glob(format!(\"{home}/Library/Application Support/*/Cache*\")),\n        // ~/Library/Application Support/*/Code Cache\n        IgnorePattern::Glob(format!(\"{home}/Library/Application Support/*/Code Cache\")),\n        // ~/.rustup/toolchains/*/share/doc\n        IgnorePattern::Glob(format!(\"{home}/.rustup/toolchains/*/share/doc\")),\n        // ~/.pyenv/versions/*/lib\n        IgnorePattern::Glob(format!(\"{home}/.pyenv/versions/*/lib\")),\n    ]\n}\n\npub(crate) fn cached_effective_ignore_rules(state: &AppState) -> (Vec<PathBuf>, Vec<IgnorePattern>) {\n    let home_dir = &state.home_dir;\n    let cwd = &state.cwd;\n\n    let pathignore_mtime = find_file_upward(cwd, \".pathignore\")\n        .or_else(|| Some(home_dir.join(\".pathignore\")))\n        .and_then(|p| fs::metadata(&p).ok())\n        .and_then(|m| m.modified().ok());\n\n    let gitignore_mtime = find_git_root(cwd)\n        .map(|root| root.join(\".gitignore\"))\n        .or_else(|| find_file_upward(cwd, \".gitignore\"))\n        .and_then(|p| fs::metadata(&p).ok())\n        .and_then(|m| m.modified().ok());\n\n    let mut cache = state.ignore_cache.lock();\n    if let Some(ref cached) = *cache {\n        if cached.pathignore_mtime == pathignore_mtime && cached.gitignore_mtime == gitignore_mtime\n        {\n            return (cached.roots.clone(), cached.patterns.clone());\n        }\n    }\n\n    let (roots, patterns) = effective_ignore_rules(\n        home_dir,\n        cwd,\n        state.path_ignores.as_ref(),\n        state.path_ignore_patterns.as_ref(),\n    );\n\n    *cache = Some(IgnoreRulesCache {\n        roots: roots.clone(),\n        patterns: patterns.clone(),\n        pathignore_mtime,\n        gitignore_mtime,\n    });\n\n    (roots, patterns)\n}\n\nfn ignore_rules_fingerprint(roots: &[PathBuf], patterns: &[IgnorePattern]) -> u64 {\n    let mut hasher = std::collections::hash_map::DefaultHasher::new();\n    for root in roots {\n        normalize_slashes(root.to_string_lossy().to_string()).hash(&mut hasher);\n    }\n    for pattern in patterns {\n        ignore_pattern_key(pattern).hash(&mut hasher);\n    }\n    hasher.finish()\n}\n\nfn purge_ignored_entries(db_path: &Path, ignored_roots: &[PathBuf]) -> AppResult<()> {\n    if ignored_roots.is_empty() {\n        return Ok(());\n    }\n\n    let conn = db_connection(db_path)?;\n    for root in ignored_roots {\n        let root_str = root.to_string_lossy().to_string();\n        if root_str.is_empty() {\n            continue;\n        }\n\n        if root_str == \"/\" {\n            conn.execute(\"DELETE FROM entries\", [])\n                .map_err(|e| e.to_string())?;\n            break;\n        }\n\n        let prefix = root_str.trim_end_matches('/');\n        let descendant_like = format!(\"{}%\", escape_like(&format!(\"{prefix}/\")));\n        conn.execute(\n            \"DELETE FROM entries WHERE path = ?1 OR path LIKE ?2 ESCAPE '\\\\'\",\n            params![prefix, descendant_like],\n        )\n        .map_err(|e| e.to_string())?;\n    }\n\n    Ok(())\n}\n\nfn glob_match_path(pattern: &str, text: &str) -> bool {\n    let pat = pattern.as_bytes();\n    let txt = text.as_bytes();\n    let (pn, tn) = (pat.len(), txt.len());\n\n    let mut px = 0usize;\n    let mut tx = 0usize;\n    let mut star_px = usize::MAX;\n    let mut star_tx = 0usize;\n    let mut star_is_double = false;\n\n    while tx < tn {\n        if px < pn && px + 1 < pn && pat[px] == b'*' && pat[px + 1] == b'*' {\n            star_px = px;\n            star_tx = tx;\n            star_is_double = true;\n            px += 2;\n        } else if px < pn && pat[px] == b'*' {\n            star_px = px;\n            star_tx = tx;\n            star_is_double = false;\n            px += 1;\n        } else if px < pn && (pat[px] == b'?' && txt[tx] != b'/') {\n            px += 1;\n            tx += 1;\n        } else if px < pn && pat[px] == txt[tx] {\n            px += 1;\n            tx += 1;\n        } else if star_px != usize::MAX {\n            star_tx += 1;\n            if !star_is_double && txt[star_tx - 1] == b'/' {\n                return false;\n            }\n            px = if star_is_double {\n                star_px + 2\n            } else {\n                star_px + 1\n            };\n            tx = star_tx;\n        } else {\n            return false;\n        }\n    }\n\n    while px < pn && pat[px] == b'*' {\n        px += 1;\n    }\n\n    px == pn\n}\n\npub(crate) fn matches_ignore_pattern(path: &str, pattern: &IgnorePattern) -> bool {\n    match pattern {\n        IgnorePattern::AnySegment(segment) => {\n            let suffix = format!(\"/{segment}\");\n            let infix = format!(\"/{segment}/\");\n            path.ends_with(&suffix) || path.contains(&infix)\n        }\n        IgnorePattern::Glob(glob) => {\n            let mut cur = path;\n            loop {\n                if glob_match_path(glob, cur) {\n                    return true;\n                }\n\n                if cur == \"/\" {\n                    break;\n                }\n\n                let Some(pos) = cur.rfind('/') else {\n                    break;\n                };\n\n                cur = if pos == 0 { \"/\" } else { &cur[..pos] };\n            }\n            false\n        }\n    }\n}\n\npub(crate) fn should_skip_path(\n    path: &Path,\n    ignored_roots: &[PathBuf],\n    ignored_patterns: &[IgnorePattern],\n) -> bool {\n    should_skip_path_ext(path, ignored_roots, ignored_patterns, None, None)\n}\n\npub(crate) fn should_skip_path_ext(\n    path: &Path,\n    ignored_roots: &[PathBuf],\n    ignored_patterns: &[IgnorePattern],\n    gitignore: Option<&gitignore_filter::GitignoreFilter>,\n    is_dir_hint: Option<bool>,\n) -> bool {\n    let s = normalize_slashes(path.to_string_lossy().to_string());\n\n    // Single-component builtin names: check path segments\n    if s.split('/').any(|seg| {\n        BUILTIN_SKIP_NAMES.contains(&seg)\n            || BUILTIN_SKIP_SUFFIXES.iter().any(|suf| seg.ends_with(suf))\n    }) {\n        return true;\n    }\n\n    // Multi-component builtin paths\n    if BUILTIN_SKIP_PATHS.iter().any(|pat| {\n        let infix = format!(\"/{pat}/\");\n        let suffix = format!(\"/{pat}\");\n        s.contains(&infix) || s.ends_with(&suffix)\n    }) {\n        return true;\n    }\n\n    if ignored_roots\n        .iter()\n        .any(|root| path == root || path.starts_with(root))\n    {\n        return true;\n    }\n    if ignored_patterns\n        .iter()\n        .any(|pattern| matches_ignore_pattern(&s, pattern))\n    {\n        return true;\n    }\n    if let Some(gi) = gitignore {\n        let is_dir = is_dir_hint.unwrap_or_else(|| path.is_dir());\n        if gi.is_ignored(path, is_dir) {\n            return true;\n        }\n    }\n    false\n}\n\nfn extension_for(path: &Path, is_dir: bool) -> Option<String> {\n    if is_dir {\n        return None;\n    }\n\n    path.extension()\n        .and_then(|ext| ext.to_str())\n        .map(|ext| ext.to_lowercase())\n}\n\npub(crate) fn index_row_from_path_and_metadata(path: &Path, metadata: &fs::Metadata) -> Option<IndexRow> {\n    let is_dir = metadata.is_dir();\n\n    let name = path\n        .file_name()\n        .map(|v| v.to_string_lossy().to_string())\n        .or_else(|| {\n            if path == Path::new(\"/\") {\n                Some(\"/\".to_string())\n            } else {\n                None\n            }\n        })?;\n\n    let dir = path\n        .parent()\n        .map(|p| p.to_string_lossy().to_string())\n        .unwrap_or_else(|| \"/\".to_string());\n\n    let mtime = metadata\n        .modified()\n        .ok()\n        .and_then(|m| m.duration_since(UNIX_EPOCH).ok())\n        .map(|d| d.as_secs() as i64);\n\n    let size = if metadata.is_file() {\n        Some(metadata.len() as i64)\n    } else {\n        None\n    };\n\n    Some(IndexRow {\n        path: path.to_string_lossy().to_string(),\n        name,\n        dir,\n        is_dir: if is_dir { 1 } else { 0 },\n        ext: extension_for(path, is_dir),\n        mtime,\n        size,\n        indexed_at: now_epoch(),\n        run_id: 0,\n    })\n}\n\nfn index_row_from_path(path: &Path) -> Option<IndexRow> {\n    let metadata = fs::symlink_metadata(path).ok()?;\n    index_row_from_path_and_metadata(path, &metadata)\n}\n\nfn index_row_from_walkdir_entry(entry: &walkdir::DirEntry) -> Option<IndexRow> {\n    let metadata = entry.metadata().ok()?;\n    index_row_from_path_and_metadata(entry.path(), &metadata)\n}\n\nfn index_row_from_jwalk_entry(entry: &jwalk::DirEntry<((), ())>) -> Option<IndexRow> {\n    let metadata = entry.metadata().ok()?;\n    index_row_from_path_and_metadata(&entry.path(), &metadata)\n}\n\nfn collect_rows_recursive(\n    root: &Path,\n    ignored_roots: &[PathBuf],\n    ignored_patterns: &[IgnorePattern],\n) -> Vec<IndexRow> {\n    let mut rows = Vec::new();\n\n    let iter = WalkDir::new(root)\n        .follow_links(false)\n        .into_iter()\n        .filter_entry(|entry| !should_skip_path(entry.path(), ignored_roots, ignored_patterns));\n\n    for entry in iter.flatten() {\n        if let Some(row) = index_row_from_walkdir_entry(&entry) {\n            rows.push(row);\n        }\n    }\n\n    rows\n}\n\nfn entry_from_index_row(row: IndexRow) -> EntryDto {\n    EntryDto {\n        path: row.path,\n        name: row.name,\n        dir: row.dir,\n        is_dir: row.is_dir == 1,\n        ext: row.ext,\n        size: row.size,\n        mtime: row.mtime,\n    }\n}\n\npub fn entry_from_path(path: &Path) -> Option<EntryDto> {\n    index_row_from_path(path).map(entry_from_index_row)\n}\n\nfn entry_cmp(a: &EntryDto, b: &EntryDto, sort_by: &str, sort_dir: &str) -> Ordering {\n    match sort_by {\n        \"mtime\" => {\n            let lhs = a.mtime.unwrap_or(0);\n            let rhs = b.mtime.unwrap_or(0);\n            let primary = if sort_dir == \"desc\" {\n                rhs.cmp(&lhs)\n            } else {\n                lhs.cmp(&rhs)\n            };\n\n            if primary != Ordering::Equal {\n                return primary;\n            }\n\n            a.name\n                .to_lowercase()\n                .cmp(&b.name.to_lowercase())\n                .then(a.path.to_lowercase().cmp(&b.path.to_lowercase()))\n        }\n        \"dir\" => {\n            let lhs = a.dir.to_lowercase();\n            let rhs = b.dir.to_lowercase();\n            let primary = if sort_dir == \"desc\" {\n                rhs.cmp(&lhs)\n            } else {\n                lhs.cmp(&rhs)\n            };\n            if primary != Ordering::Equal {\n                return primary;\n            }\n            a.name.to_lowercase().cmp(&b.name.to_lowercase())\n        }\n        \"size\" => {\n            let lhs = a.size.unwrap_or(0);\n            let rhs = b.size.unwrap_or(0);\n            let primary = if sort_dir == \"desc\" {\n                rhs.cmp(&lhs)\n            } else {\n                lhs.cmp(&rhs)\n            };\n            if primary != Ordering::Equal {\n                return primary;\n            }\n            a.name\n                .to_lowercase()\n                .cmp(&b.name.to_lowercase())\n                .then(a.path.to_lowercase().cmp(&b.path.to_lowercase()))\n        }\n        _ => {\n            let lhs_name = a.name.to_lowercase();\n            let rhs_name = b.name.to_lowercase();\n            let primary = if sort_dir == \"desc\" {\n                rhs_name.cmp(&lhs_name)\n            } else {\n                lhs_name.cmp(&rhs_name)\n            };\n\n            if primary != Ordering::Equal {\n                return primary;\n            }\n\n            let lhs_path = a.path.to_lowercase();\n            let rhs_path = b.path.to_lowercase();\n            if sort_dir == \"desc\" {\n                rhs_path.cmp(&lhs_path)\n            } else {\n                lhs_path.cmp(&rhs_path)\n            }\n        }\n    }\n}\n\nfn relevance_rank(entry: &EntryDto, query_lower: &str, path_suffix: &str) -> u8 {\n    if query_lower.is_empty() {\n        return 255;\n    }\n\n    let name = entry.name.to_lowercase();\n    let path = entry.path.to_lowercase();\n\n    if name == query_lower {\n        return 0;\n    }\n    if name.starts_with(query_lower) {\n        return 1;\n    }\n    if name.contains(query_lower) {\n        return 2;\n    }\n    if path.ends_with(path_suffix) {\n        return 3;\n    }\n    if path.contains(query_lower) {\n        return 4;\n    }\n\n    5\n}\n\nfn path_depth(path: &str) -> usize {\n    Path::new(path).components().count()\n}\n\npub fn sort_entries(entries: &mut Vec<EntryDto>, sort_by: &str, sort_dir: &str) {\n    entries.sort_by(|a, b| entry_cmp(a, b, sort_by, sort_dir));\n}\n\nfn sort_entries_with_relevance(\n    entries: &mut Vec<EntryDto>,\n    query: &str,\n    sort_by: &str,\n    sort_dir: &str,\n) {\n    let query_lower = query.trim().to_lowercase();\n    if query_lower.is_empty() {\n        sort_entries(entries, sort_by, sort_dir);\n        return;\n    }\n    let path_suffix = format!(\"/{query_lower}\");\n\n    entries.sort_by(|a, b| {\n        let ra = relevance_rank(a, &query_lower, &path_suffix);\n        let rb = relevance_rank(b, &query_lower, &path_suffix);\n        if ra != rb {\n            return ra.cmp(&rb);\n        }\n\n        // For highly-relevant matches, prefer shallower paths first\n        // so `~/name` ranks above deep descendants with the same name.\n        if ra <= 3 {\n            let da = path_depth(&a.path);\n            let db = path_depth(&b.path);\n            if da != db {\n                return da.cmp(&db);\n            }\n        }\n\n        entry_cmp(a, b, sort_by, sort_dir)\n    });\n}\n\nfn filter_ignored_entries(\n    entries: Vec<EntryDto>,\n    ignored_roots: &[PathBuf],\n    ignored_patterns: &[IgnorePattern],\n) -> Vec<EntryDto> {\n    entries\n        .into_iter()\n        .filter(|entry| !should_skip_path(Path::new(&entry.path), ignored_roots, ignored_patterns))\n        .collect()\n}\n\nfn find_search(\n    home_dir: &Path,\n    ignored_roots: &[PathBuf],\n    ignored_patterns: &[IgnorePattern],\n    query: &str,\n    limit: usize,\n    sort_by: &str,\n    sort_dir: &str,\n) -> Vec<EntryDto> {\n    let trimmed = query.trim();\n    if trimmed.is_empty() || limit == 0 {\n        return Vec::new();\n    }\n\n    let mut search_root = home_dir.to_path_buf();\n    let mut dir_filter_pattern: Option<String> = None;\n    let mut name_filter_pattern: Option<String> = None;\n    let mut name_filter_glob = false;\n\n    if trimmed.contains('/') {\n        let last_slash = trimmed.rfind('/').unwrap();\n        let dir_part = trimmed[..last_slash].trim();\n        let name_part = trimmed[last_slash + 1..].trim();\n\n        if !dir_part.is_empty() {\n            let mut hinted = if dir_part == \"~\" {\n                Some(home_dir.to_path_buf())\n            } else if let Some(rest) = dir_part.strip_prefix(\"~/\") {\n                Some(home_dir.join(rest))\n            } else {\n                let p = PathBuf::from(dir_part);\n                if p.is_absolute() {\n                    Some(p)\n                } else if !dir_part.contains('*')\n                    && !dir_part.contains('?')\n                    && !dir_part.contains('[')\n                {\n                    Some(home_dir.join(dir_part))\n                } else {\n                    None\n                }\n            };\n\n            if let Some(path) = hinted.take() {\n                if path.exists() && path.is_dir() {\n                    search_root = path;\n                } else {\n                    dir_filter_pattern = Some(format!(\"*{}/*\", dir_part));\n                }\n            } else {\n                dir_filter_pattern = Some(format!(\"*{}/*\", dir_part));\n            }\n        }\n\n        if !name_part.is_empty() {\n            if name_part.contains('*') || name_part.contains('?') {\n                name_filter_pattern = Some(name_part.to_string());\n                name_filter_glob = true;\n            } else {\n                name_filter_pattern = Some(format!(\"*{}*\", name_part));\n            }\n        }\n    } else if trimmed.contains('*') || trimmed.contains('?') {\n        name_filter_pattern = Some(trimmed.to_string());\n        name_filter_glob = true;\n    } else {\n        name_filter_pattern = Some(format!(\"*{}*\", trimmed));\n    }\n\n    let mut cmd = Command::new(\"find\");\n    cmd.arg(&search_root);\n\n    if search_root == home_dir {\n        cmd.args([\"-maxdepth\", \"8\"]);\n    }\n\n    if let Some(dir_pattern) = dir_filter_pattern.as_deref() {\n        cmd.args([\"-ipath\", dir_pattern]);\n    }\n    if let Some(name_pattern) = name_filter_pattern.as_deref() {\n        cmd.args([\"-iname\", name_pattern]);\n    }\n    if name_filter_glob {\n        cmd.args([\"-type\", \"f\"]);\n    }\n\n    cmd.args([\"!\", \"-path\", \"*/.git/*\"])\n        .args([\"!\", \"-path\", \"*/node_modules/*\"])\n        .args([\"!\", \"-path\", \"*/.Trash/*\"])\n        .args([\"!\", \"-path\", \"*/.Trashes/*\"])\n        .args([\"!\", \"-path\", \"*/Library/Caches/*\"])\n        .stdout(Stdio::piped())\n        .stderr(Stdio::null());\n\n    let mut child = match cmd.spawn() {\n        Ok(c) => c,\n        Err(_) => return Vec::new(),\n    };\n\n    let stdout = match child.stdout.take() {\n        Some(s) => s,\n        None => return Vec::new(),\n    };\n\n    let reader = BufReader::new(stdout);\n    let mut entries = Vec::with_capacity(limit);\n\n    for line in reader.lines() {\n        let Ok(line) = line else { continue };\n        let path = PathBuf::from(&line);\n        if should_skip_path(&path, ignored_roots, ignored_patterns) {\n            continue;\n        }\n\n        if let Some(entry) = entry_from_path(&path) {\n            entries.push(entry);\n            if entries.len() >= limit {\n                break;\n            }\n        }\n    }\n\n    let _ = child.kill();\n    let _ = child.wait();\n\n    sort_entries_with_relevance(&mut entries, trimmed, sort_by, sort_dir);\n    entries\n}\n\npub(crate) fn upsert_rows(conn: &mut Connection, rows: &[IndexRow]) -> AppResult<usize> {\n    if rows.is_empty() {\n        return Ok(0);\n    }\n\n    let tx = conn.transaction().map_err(|e| e.to_string())?;\n    {\n        let mut stmt = tx\n            .prepare(\n                r#\"\n                INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n                VALUES(?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)\n                ON CONFLICT(path) DO UPDATE SET\n                  name = excluded.name,\n                  dir = excluded.dir,\n                  is_dir = excluded.is_dir,\n                  ext = excluded.ext,\n                  mtime = excluded.mtime,\n                  size = excluded.size,\n                  indexed_at = excluded.indexed_at,\n                  run_id = excluded.run_id\n                \"#,\n            )\n            .map_err(|e| e.to_string())?;\n\n        for row in rows {\n            stmt.execute(params![\n                row.path,\n                row.name,\n                row.dir,\n                row.is_dir,\n                row.ext,\n                row.mtime,\n                row.size,\n                row.indexed_at,\n                row.run_id\n            ])\n            .map_err(|e| e.to_string())?;\n        }\n    }\n    tx.commit().map_err(|e| e.to_string())?;\n    Ok(rows.len())\n}\n\npub(crate) fn delete_paths(conn: &mut Connection, raw_paths: &[String]) -> AppResult<usize> {\n    if raw_paths.is_empty() {\n        return Ok(0);\n    }\n\n    let tx = conn.transaction().map_err(|e| e.to_string())?;\n    let mut deleted = 0;\n\n    {\n        let mut stmt_exact = tx\n            .prepare(\"DELETE FROM entries WHERE path = ?1\")\n            .map_err(|e| e.to_string())?;\n        let mut stmt_children = tx\n            .prepare(\"DELETE FROM entries WHERE path >= ?1 AND path < ?2\")\n            .map_err(|e| e.to_string())?;\n\n        for path in raw_paths {\n            let is_root = path == \"/\" || path == \"\\\\\";\n            let normalized = if is_root {\n                path.clone()\n            } else {\n                path.trim_end_matches(&['/', '\\\\'][..]).to_string()\n            };\n\n            if normalized.is_empty() {\n                continue;\n            }\n\n            if is_root {\n                deleted += tx\n                    .execute(\"DELETE FROM entries\", [])\n                    .map_err(|e| e.to_string())?;\n                continue;\n            }\n\n            deleted += stmt_exact\n                .execute(params![&normalized])\n                .map_err(|e| e.to_string())?;\n\n            // Delete children using B-tree range scan: path >= \"{normalized}{sep}\" AND path < \"{normalized}\\x7F\"\n            // \\x7F (127) is higher than both '/' (47) and '\\' (92), so this captures all children.\n            let sep = std::path::MAIN_SEPARATOR;\n            let range_start = format!(\"{normalized}{sep}\");\n            let range_end = format!(\"{normalized}\\x7F\");\n            deleted += stmt_children\n                .execute(params![&range_start, &range_end])\n                .map_err(|e| e.to_string())?;\n        }\n    }\n\n    tx.commit().map_err(|e| e.to_string())?;\n    Ok(deleted)\n}\n\npub(crate) fn emit_index_state(app: &AppHandle, state: &str, message: Option<String>) {\n    let is_catchup = message.as_ref().map_or(false, |m| m.starts_with(\"Catchup:\"));\n    let _ = app.emit(\n        \"index_state\",\n        IndexStateEvent {\n            state: state.to_string(),\n            message,\n            is_catchup,\n        },\n    );\n}\n\npub(crate) fn emit_index_updated(\n    app: &AppHandle,\n    entries_count: u64,\n    last_updated: i64,\n    permission_errors: u64,\n) {\n    let _ = app.emit(\n        \"index_updated\",\n        IndexUpdatedEvent {\n            entries_count,\n            last_updated,\n            permission_errors,\n        },\n    );\n}\n\npub(crate) fn emit_index_progress(app: &AppHandle, scanned: u64, indexed: u64, current_path: String) {\n    let _ = app.emit(\n        \"index_progress\",\n        IndexProgressEvent {\n            scanned,\n            indexed,\n            current_path,\n        },\n    );\n}\n\npub(crate) fn set_state(state: &AppState, next: IndexState, message: Option<String>) {\n    let mut status = state.status.lock();\n    status.state = next;\n    status.message = message;\n}\n\npub(crate) fn set_progress(state: &AppState, scanned: u64, indexed: u64, current_path: &str) {\n    let mut status = state.status.lock();\n    status.scanned = scanned;\n    status.indexed = indexed;\n    status.current_path = current_path.to_string();\n}\n\nfn emit_status_counts(app: &AppHandle, state: &AppState) {\n    let status = state.status.lock();\n    emit_index_updated(\n        app,\n        status.entries_count,\n        status.last_updated.unwrap_or_else(now_epoch),\n        status.permission_errors,\n    );\n}\n\npub(crate) fn refresh_and_emit_status_counts(app: &AppHandle, state: &AppState) -> AppResult<()> {\n    let (entries_count, last_updated) = update_status_counts(state)?;\n    // Persist cached counts so next startup can read them instantly\n    if let Ok(conn) = db_connection(&state.db_path) {\n        let _ = set_meta(&conn, \"cached_entries_count\", &entries_count.to_string());\n        if let Some(lu) = last_updated {\n            let _ = set_meta(&conn, \"cached_last_updated\", &lu.to_string());\n        }\n    }\n    emit_status_counts(app, state);\n    Ok(())\n}\n\n/// Load cached entries count from meta table (instant) and emit Ready state + counts.\n/// Used on Windows startup paths where the index is already complete from a prior run.\n#[cfg(target_os = \"windows\")]\npub(crate) fn set_ready_with_cached_counts(app: &AppHandle, state: &AppState) {\n    let (count, last_updated) = db_connection(&state.db_path)\n        .ok()\n        .map(|conn| {\n            let c = get_meta(&conn, \"cached_entries_count\")\n                .and_then(|v| v.parse::<u64>().ok())\n                .unwrap_or(0);\n            let lu = get_meta(&conn, \"cached_last_updated\")\n                .and_then(|v| v.parse::<i64>().ok());\n            (c, lu)\n        })\n        .unwrap_or((0, None));\n\n    {\n        let mut status = state.status.lock();\n        status.state = IndexState::Ready;\n        status.entries_count = count;\n        status.last_updated = last_updated;\n    }\n\n    emit_index_state(app, \"Ready\", None);\n    emit_index_updated(app, count, last_updated.unwrap_or_else(now_epoch), 0);\n}\n\n#[cfg(target_os = \"macos\")]\nfn touch_status_updated(state: &AppState) {\n    state.status.lock().last_updated = Some(now_epoch());\n}\n\n#[cfg(not(target_os = \"windows\"))]\npub(crate) fn start_full_index_worker(app: AppHandle, state: AppState) -> AppResult<()> {\n    start_full_index_worker_inner(app, state, false)\n}\n\n#[cfg(target_os = \"windows\")]\npub(crate) fn start_full_index_worker_silent(app: AppHandle, state: AppState) -> AppResult<()> {\n    start_full_index_worker_inner(app, state, true)\n}\n\nfn start_full_index_worker_inner(app: AppHandle, state: AppState, silent: bool) -> AppResult<()> {\n    if state\n        .indexing_active\n        .compare_exchange(false, true, AtomicOrdering::AcqRel, AtomicOrdering::Acquire)\n        .is_err()\n    {\n        perf_log(\"index_start_skipped already_active=true\");\n        return Ok(());\n    }\n\n    // Mark index as incomplete -- cleared when run_incremental_index succeeds\n    if let Ok(c) = db_connection(&state.db_path) {\n        let _ = set_meta(&c, \"index_complete\", \"0\");\n    }\n\n    if !silent {\n        {\n            let mut status = state.status.lock();\n            status.state = IndexState::Indexing;\n            status.message = None;\n            status.scanned = 0;\n            status.indexed = 0;\n            status.current_path.clear();\n        }\n\n        emit_index_state(&app, \"Indexing\", None);\n        perf_log(\"index_state=Indexing\");\n    } else {\n        perf_log(\"index_start silent=true (background reindex)\");\n    }\n\n    std::thread::spawn(move || {\n        let result = run_incremental_index(&app, &state);\n        if let Err(ref err) = result {\n            eprintln!(\"[index] run_incremental_index failed: {err}\");\n            if !silent {\n                set_state(&state, IndexState::Error, Some(err.clone()));\n                emit_index_state(&app, \"Error\", Some(err.clone()));\n            }\n            // Silent mode: keep Ready state, just log the error\n        }\n        state.indexing_active.store(false, AtomicOrdering::Release);\n    });\n\n    Ok(())\n}\n\nfn is_deferred_dir(path: &Path, home_dir: &Path) -> bool {\n    path.parent() == Some(home_dir)\n        && path\n            .file_name()\n            .and_then(|n| n.to_str())\n            .map(|name| DEFERRED_DIR_NAMES.contains(&name))\n            .unwrap_or(false)\n}\n\nfn preload_existing_entries(\n    conn: &Connection,\n    dir_prefix: &str,\n) -> HashMap<String, (Option<i64>, Option<i64>)> {\n    let like_pattern = format!(\"{}/%\", escape_like(dir_prefix));\n    let mut stmt = match conn.prepare(\n        \"SELECT path, mtime, size FROM entries WHERE path LIKE ?1 ESCAPE '\\\\' OR path = ?2\",\n    ) {\n        Ok(s) => s,\n        Err(_) => return HashMap::new(),\n    };\n\n    let mut map = HashMap::new();\n    let rows = match stmt.query_map(params![like_pattern, dir_prefix], |row| {\n        Ok((\n            row.get::<_, String>(0)?,\n            row.get::<_, Option<i64>>(1)?,\n            row.get::<_, Option<i64>>(2)?,\n        ))\n    }) {\n        Ok(r) => r,\n        Err(_) => return map,\n    };\n\n    for row in rows.flatten() {\n        map.insert(row.0, (row.1, row.2));\n    }\n    map\n}\n\nfn stamp_run_id_batch(conn: &mut Connection, paths: &[String], run_id: i64) -> AppResult<()> {\n    if paths.is_empty() {\n        return Ok(());\n    }\n\n    let tx = conn.transaction().map_err(|e| e.to_string())?;\n    {\n        let mut stmt = tx\n            .prepare(\"UPDATE entries SET run_id = ?1 WHERE path = ?2\")\n            .map_err(|e| e.to_string())?;\n        for path in paths {\n            stmt.execute(params![run_id, path])\n                .map_err(|e| e.to_string())?;\n        }\n    }\n    tx.commit().map_err(|e| e.to_string())?;\n    Ok(())\n}\n\nfn run_incremental_index(app: &AppHandle, state: &AppState) -> AppResult<()> {\n    let started = Instant::now();\n    perf_log(format!(\n        \"index_run_start home={} db={}\",\n        state.home_dir.to_string_lossy(),\n        state.db_path.to_string_lossy(),\n    ));\n\n    let mut conn = db_connection(&state.db_path)?;\n    set_indexing_pragmas(&conn)?;\n\n    let result = run_incremental_index_inner(app, state, &mut conn);\n\n    let _ = conn.execute_batch(\"ANALYZE\");\n    let _ = restore_normal_pragmas(&conn);\n\n    match &result {\n        Ok(_) => {\n            let _ = set_meta(&conn, \"index_complete\", \"1\");\n            let snapshot = state.status.lock().clone();\n            perf_log(format!(\n                \"index_run_done elapsed_ms={} scanned={} indexed={} entries={} permission_errors={} message={:?}\",\n                started.elapsed().as_millis(),\n                snapshot.scanned,\n                snapshot.indexed,\n                snapshot.entries_count,\n                snapshot.permission_errors,\n                snapshot.message,\n            ));\n        }\n        Err(err) => {\n            perf_log(format!(\n                \"index_run_error elapsed_ms={} err={}\",\n                started.elapsed().as_millis(),\n                err,\n            ));\n        }\n    }\n\n    result\n}\n\nfn run_incremental_index_inner(\n    app: &AppHandle,\n    state: &AppState,\n    conn: &mut Connection,\n) -> AppResult<()> {\n\n    let (runtime_ignored_roots, runtime_ignored_patterns) = effective_ignore_rules(\n        &state.home_dir,\n        &state.cwd,\n        state.path_ignores.as_ref(),\n        state.path_ignore_patterns.as_ref(),\n    );\n    let gi_filter = state.gitignore.get();\n\n    let last_run_id: i64 = get_meta(conn, \"last_run_id\")\n        .and_then(|v| v.parse().ok())\n        .unwrap_or(0);\n    let current_run_id = last_run_id + 1;\n    // Fresh index: DB was empty, skip preload/stamp, single unlimited-depth pass\n    let is_fresh = last_run_id == 0;\n\n    let mut scanned: u64 = 0;\n    let mut indexed: u64 = 0;\n    let mut permission_errors: u64 = 0;\n    let mut current_path = String::new();\n    let mut batch: Vec<IndexRow> = Vec::with_capacity(BATCH_SIZE);\n    let mut stamp_batch: Vec<String> = Vec::with_capacity(BATCH_SIZE);\n    let mut last_emit = Instant::now();\n    let mut last_perf_emit = Instant::now();\n\n    // Preload scan_root-level entries (direct children only, not recursive)\n    let scan_str = state.scan_root.to_string_lossy().to_string();\n    let root_existing = preload_existing_entries(conn, &scan_str);\n\n    // Index scan_root itself\n    if let Some(mut row) = index_row_from_path(&state.scan_root) {\n        scanned += 1;\n        row.run_id = current_run_id;\n        if let Some((old_mtime, old_size)) = root_existing.get(&row.path) {\n            if *old_mtime == row.mtime && *old_size == row.size {\n                stamp_batch.push(row.path);\n            } else {\n                batch.push(row);\n            }\n        } else {\n            batch.push(row);\n        }\n    }\n\n    // Partition direct children into priority vs deferred\n    let mut priority_roots: Vec<PathBuf> = Vec::new();\n    let mut deferred_roots: Vec<PathBuf> = Vec::new();\n\n    if let Ok(entries) = fs::read_dir(&state.scan_root) {\n        for dir_entry in entries.flatten() {\n            let child_path = dir_entry.path();\n\n            if should_skip_path_ext(\n                &child_path,\n                &runtime_ignored_roots,\n                &runtime_ignored_patterns,\n                Some(&gi_filter),\n                None,\n            ) {\n                continue;\n            }\n\n            scanned += 1;\n            current_path = child_path.to_string_lossy().to_string();\n\n            if let Some(mut row) = index_row_from_path(&child_path) {\n                row.run_id = current_run_id;\n                if let Some((old_mtime, old_size)) = root_existing.get(&row.path) {\n                    if *old_mtime == row.mtime && *old_size == row.size {\n                        stamp_batch.push(row.path);\n                    } else {\n                        batch.push(row);\n                    }\n                } else {\n                    batch.push(row);\n                }\n            }\n\n            if child_path.is_dir() {\n                if is_deferred_dir(&child_path, &state.scan_root) {\n                    deferred_roots.push(child_path);\n                } else {\n                    priority_roots.push(child_path);\n                }\n            }\n        }\n    }\n\n\n    // Flush home-level stamp batch\n    if stamp_batch.len() >= BATCH_SIZE {\n        stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n        stamp_batch.clear();\n    }\n\n    priority_roots.sort();\n    deferred_roots.sort();\n\n    let roots: Vec<PathBuf> = priority_roots.into_iter().chain(deferred_roots).collect();\n    perf_log(format!(\n        \"index_scan_roots total={} priority+deferred\",\n        roots.len()\n    ));\n\n    // 2-pass indexing: shallow first (depth <= SHALLOW_SCAN_DEPTH), then deep\n    // Both passes use jwalk for parallel scanning\n    let arc_ignored_roots = Arc::new(runtime_ignored_roots.clone());\n    let arc_ignored_patterns = Arc::new(runtime_ignored_patterns.clone());\n\n\n    for pass in 0..2u8 {\n        // Fresh index: single unlimited-depth pass -- avoids double filesystem traversal\n        if pass == 1 && is_fresh {\n            break;\n        }\n        let pass_label = if pass == 0 { \"shallow\" } else { \"deep\" };\n        let pass_started = Instant::now();\n        let mut pass_scanned = 0u64;\n        let mut pass_indexed = 0u64;\n\n        for root in &roots {\n            let root_started = Instant::now();\n            let mut root_scanned = 0u64;\n            let mut root_indexed = 0u64;\n            let mut root_permission_errors = 0u64;\n            let root_str = root.to_string_lossy().to_string();\n\n            // Fresh index: DB is empty, preload is unnecessary\n            let existing = if is_fresh {\n                HashMap::new()\n            } else {\n                let e = preload_existing_entries(conn, &root_str);\n                e\n            };\n\n            let gi_ref = gi_filter.clone();\n            let skip_roots = arc_ignored_roots.clone();\n            let skip_patterns = arc_ignored_patterns.clone();\n\n            let mut builder = jwalk::WalkDir::new(root)\n                .follow_links(false)\n                .skip_hidden(false)\n                .parallelism(jwalk::Parallelism::RayonNewPool(jwalk_num_threads()));\n            // Fresh index: no depth limit -- walk everything in one pass\n            if pass == 0 && !is_fresh {\n                builder = builder.max_depth(SHALLOW_SCAN_DEPTH);\n            }\n            let walker = builder.process_read_dir(move |_depth, path, _state, children| {\n                children.retain(|entry_result| {\n                    entry_result\n                        .as_ref()\n                        .map(|entry| {\n                            let full_path = path.join(&entry.file_name);\n                            let is_dir = Some(entry.file_type.is_dir());\n                            !should_skip_path_ext(\n                                &full_path,\n                                &skip_roots,\n                                &skip_patterns,\n                                Some(&gi_ref),\n                                is_dir,\n                            )\n                        })\n                        .unwrap_or(false)\n                });\n            });\n\n            for result in walker {\n                match result {\n                    Ok(entry) => {\n                        let path = entry.path();\n                        if path == root.as_path() {\n                            continue;\n                        }\n\n                        // Pass 1 (incremental only): skip shallow entries already indexed in pass 0\n                        if pass == 1 && entry.depth <= SHALLOW_SCAN_DEPTH {\n                            continue;\n                        }\n\n                        scanned += 1;\n                        root_scanned += 1;\n                        current_path = path.to_string_lossy().to_string();\n\n                        if let Some(mut row) = index_row_from_jwalk_entry(&entry) {\n                            row.run_id = current_run_id;\n                            if is_fresh {\n                                // Fresh index: all entries are new, skip existing check\n                                indexed += 1;\n                                root_indexed += 1;\n                                batch.push(row);\n                            } else if let Some((old_mtime, old_size)) = existing.get(&row.path) {\n                                if *old_mtime == row.mtime && *old_size == row.size {\n                                    stamp_batch.push(row.path);\n                                } else {\n                                    indexed += 1;\n                                    root_indexed += 1;\n                                    batch.push(row);\n                                }\n                            } else {\n                                indexed += 1;\n                                root_indexed += 1;\n                                batch.push(row);\n                            }\n                        }\n\n                        if batch.len() >= BATCH_SIZE {\n                            upsert_rows(conn, &batch)?;\n                            batch.clear();\n                        }\n\n                        if stamp_batch.len() >= BATCH_SIZE {\n                            stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n                            stamp_batch.clear();\n                        }\n\n                        if last_emit.elapsed() >= Duration::from_millis(200) {\n                            set_progress(state, scanned, indexed, &current_path);\n                            emit_index_progress(app, scanned, indexed, current_path.clone());\n                            last_emit = Instant::now();\n                        }\n                        if perf_log_enabled() && last_perf_emit.elapsed() >= Duration::from_secs(1)\n                        {\n                            perf_log(format!(\n                                \"index_progress pass={} scanned={} indexed={} current_path={}\",\n                                pass_label, scanned, indexed, current_path\n                            ));\n                            last_perf_emit = Instant::now();\n                        }\n                    }\n                    Err(err) => {\n                        scanned += 1;\n                        root_scanned += 1;\n                        permission_errors += 1;\n                        root_permission_errors += 1;\n                        if permission_errors <= 20 || perf_log_enabled() {\n                            eprintln!(\"[index] permission error: {}\", err);\n                        }\n                    }\n                }\n            }\n\n            pass_scanned += root_scanned;\n            pass_indexed += root_indexed;\n\n            eprintln!(\"[timing]   walk_{} {} {}ms scanned={} indexed={} err={}\",\n                pass_label, root_str, root_started.elapsed().as_millis(),\n                root_scanned, root_indexed, root_permission_errors);\n            perf_log(format!(\n                \"index_root_done pass={} root={} elapsed_ms={} scanned={} indexed={} permission_errors={}\",\n                pass_label,\n                root.to_string_lossy(),\n                root_started.elapsed().as_millis(),\n                root_scanned,\n                root_indexed,\n                root_permission_errors,\n            ));\n        }\n\n        // Flush between passes\n        if !batch.is_empty() {\n            upsert_rows(conn, &batch)?;\n            batch.clear();\n        }\n        if !stamp_batch.is_empty() {\n            stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n            stamp_batch.clear();\n        }\n\n        perf_log(format!(\n            \"index_pass_done pass={} elapsed_ms={} scanned={} indexed={}\",\n            pass_label,\n            pass_started.elapsed().as_millis(),\n            pass_scanned,\n            pass_indexed,\n        ));\n\n        // After shallow pass (incremental only), emit progress so UI shows searchable state early\n        // Fresh index uses per-root emit above instead.\n        if pass == 0 && !is_fresh {\n            let _ = refresh_and_emit_status_counts(app, state);\n            let _ = app.emit(\n                \"index_updated\",\n                IndexUpdatedEvent {\n                    entries_count: state.status.lock().entries_count,\n                    last_updated: now_epoch(),\n                    permission_errors,\n                },\n            );\n        }\n    }\n\n    if !batch.is_empty() {\n        upsert_rows(conn, &batch)?;\n    }\n\n    if !stamp_batch.is_empty() {\n        stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n    }\n\n    set_progress(state, scanned, indexed, &current_path);\n    emit_index_progress(app, scanned, indexed, current_path.clone());\n\n    // Remove entries not seen in this run (deleted files)\n    // Fresh index: DB was empty before this run, no stale entries possible\n    let deleted_count: i64 = if is_fresh {\n        0\n    } else {\n        let count = conn\n            .query_row(\n                \"SELECT COUNT(*) FROM entries WHERE run_id < ?1\",\n                params![current_run_id],\n                |row| row.get(0),\n            )\n            .unwrap_or(0);\n        conn.execute(\n            \"DELETE FROM entries WHERE run_id < ?1\",\n            params![current_run_id],\n        )\n        .map_err(|e| e.to_string())?;\n        count\n    };\n\n    set_meta(conn, \"last_run_id\", &current_run_id.to_string())?;\n\n    if deleted_count > 0 || indexed > 0 {\n        invalidate_search_caches(state);\n    }\n\n    let (entries_count, last_updated) = update_status_counts(state)?;\n    // Persist cached counts for instant startup next time\n    let _ = set_meta(conn, \"cached_entries_count\", &entries_count.to_string());\n    if let Some(lu) = last_updated {\n        let _ = set_meta(conn, \"cached_last_updated\", &lu.to_string());\n    }\n    let updated_at = last_updated.unwrap_or_else(now_epoch);\n\n    {\n        let mut status = state.status.lock();\n        status.state = IndexState::Ready;\n        status.permission_errors = permission_errors;\n        status.scanned = scanned;\n        status.indexed = indexed;\n        status.current_path = current_path.clone();\n        status.message = if permission_errors > 0 {\n            Some(format!(\n                \"{} permission/access error(s) occurred.\",\n                permission_errors\n            ))\n        } else {\n            None\n        };\n    }\n    emit_index_progress(app, scanned, indexed, current_path);\n    emit_index_updated(app, entries_count, updated_at, permission_errors);\n    emit_index_state(\n        app,\n        \"Ready\",\n        if permission_errors > 0 {\n            Some(format!(\"{} permission/access error(s)\", permission_errors))\n        } else {\n            None\n        },\n    );\n    perf_log(format!(\n        \"index_state=Ready scanned={} indexed={} deleted={} entries={} permission_errors={}\",\n        scanned, indexed, deleted_count, entries_count, permission_errors\n    ));\n\n    Ok(())\n}\n\nfn trim_recent_ops(ops: &mut Vec<RecentOp>) {\n    let now = Instant::now();\n    ops.retain(|op| now.duration_since(op.at) <= RECENT_OP_TTL);\n}\n\nfn remember_op(\n    state: &AppState,\n    op_type: &'static str,\n    old_path: Option<String>,\n    new_path: Option<String>,\n) {\n    let mut ops = state.recent_ops.lock();\n    trim_recent_ops(&mut ops);\n    ops.push(RecentOp {\n        old_path,\n        new_path,\n        op_type,\n        at: Instant::now(),\n    });\n}\n\n#[cfg(any(target_os = \"macos\", target_os = \"windows\"))]\npub(crate) fn is_recently_touched(state: &AppState, path: &str) -> bool {\n    let mut ops = state.recent_ops.lock();\n    trim_recent_ops(&mut ops);\n\n    ops.iter().any(|op| match op.op_type {\n        \"rename\" | \"trash\" => {\n            op.old_path\n                .as_deref()\n                .map(|old| old == path)\n                .unwrap_or(false)\n                || op\n                    .new_path\n                    .as_deref()\n                    .map(|new| new == path)\n                    .unwrap_or(false)\n        }\n        _ => false,\n    })\n}\n\n#[cfg(target_os = \"macos\")]\nfn apply_path_changes(state: &AppState, paths: &[PathBuf]) -> AppResult<usize> {\n    let (ignored_roots, ignored_patterns) = cached_effective_ignore_rules(state);\n    let mut to_upsert_map: HashMap<String, IndexRow> = HashMap::new();\n    let mut to_delete = Vec::new();\n\n    for path in paths {\n        if should_skip_path(path, &ignored_roots, &ignored_patterns) {\n            continue;\n        }\n\n        let path_str = path.to_string_lossy().to_string();\n        if path_str.is_empty() {\n            continue;\n        }\n\n        if is_recently_touched(state, &path_str) {\n            continue;\n        }\n\n        match fs::symlink_metadata(path) {\n            Ok(metadata) => {\n                if let Some(row) = index_row_from_path_and_metadata(path, &metadata) {\n                    to_upsert_map.insert(row.path.clone(), row);\n                }\n            }\n            Err(_) => {\n                to_delete.push(path_str);\n            }\n        }\n    }\n\n    let to_upsert = to_upsert_map.into_values().collect::<Vec<_>>();\n\n    if to_upsert.is_empty() && to_delete.is_empty() {\n        return Ok(0);\n    }\n\n    let op_start = std::time::Instant::now();\n    let mut conn = db_connection(&state.db_path).map_err(|e| {\n        eprintln!(\n            \"[watcher] db_connection FAILED after {}ms: {} (upsert={} delete={} indexing_active={})\",\n            op_start.elapsed().as_millis(),\n            e,\n            to_upsert.len(),\n            to_delete.len(),\n            state.indexing_active.load(AtomicOrdering::Acquire)\n        );\n        e\n    })?;\n    let mut changed = 0;\n\n    changed += upsert_rows(&mut conn, &to_upsert)?;\n    changed += delete_paths(&mut conn, &to_delete)?;\n\n    Ok(changed)\n}\n\n#[cfg(target_os = \"macos\")]\nconst STATUS_EMIT_MIN_INTERVAL: Duration = Duration::from_secs(2);\n\n#[cfg(target_os = \"macos\")]\nconst DB_BUSY_RETRY_DELAY: Duration = Duration::from_secs(3);\n\n#[cfg(target_os = \"macos\")]\nfn process_watcher_paths(\n    app: &AppHandle,\n    state: &AppState,\n    pending: &mut HashSet<PathBuf>,\n    deadline: &mut Option<Instant>,\n    last_status_emit: &mut Instant,\n    pending_status_emit: &mut bool,\n) {\n    if pending.is_empty() {\n        return;\n    }\n\n    if state.indexing_active.load(AtomicOrdering::Acquire) {\n        return;\n    }\n\n    let mut batch: Vec<PathBuf> = pending.drain().collect();\n    batch.sort();\n\n    match apply_path_changes(state, &batch) {\n        Ok(changed) => {\n            *deadline = None;\n            if changed > 0 {\n                invalidate_search_caches(state);\n                touch_status_updated(state);\n                if last_status_emit.elapsed() >= STATUS_EMIT_MIN_INTERVAL {\n                    let _ = refresh_and_emit_status_counts(app, state);\n                    *last_status_emit = Instant::now();\n                    *pending_status_emit = false;\n                } else {\n                    *pending_status_emit = true;\n                }\n            }\n        }\n        Err(err) => {\n            let is_busy = err.contains(\"locked\") || err.contains(\"busy\");\n            if is_busy {\n                eprintln!(\n                    \"[watcher] DB busy, will retry in {}s: {} | batch_size={}\",\n                    DB_BUSY_RETRY_DELAY.as_secs(),\n                    err,\n                    batch.len()\n                );\n                for path in batch {\n                    pending.insert(path);\n                }\n                *deadline = Some(Instant::now() + DB_BUSY_RETRY_DELAY);\n                return;\n            }\n            eprintln!(\n                \"[watcher] process_watcher_paths ERROR: {} | batch_size={} indexing_active={}\",\n                err,\n                batch.len(),\n                state.indexing_active.load(AtomicOrdering::Acquire)\n            );\n            *deadline = None;\n            if state.indexing_active.load(AtomicOrdering::Acquire) {\n                return;\n            }\n            let mut status = state.status.lock();\n            if !matches!(status.state, IndexState::Indexing) {\n                status.state = IndexState::Error;\n            }\n            status.message = Some(format!(\"Watcher update failed: {err}\"));\n            drop(status);\n            emit_index_state(app, \"Error\", Some(format!(\"Watcher update failed: {err}\")));\n        }\n    }\n}\n\n#[cfg(target_os = \"macos\")]\nconst EVENT_ID_FLUSH_INTERVAL: Duration = Duration::from_secs(30);\n\n#[cfg(target_os = \"macos\")]\nfn persist_event_id(db_path: &Path, event_id: u64) -> AppResult<()> {\n    let conn = db_connection(db_path)?;\n    set_meta(&conn, \"last_event_id\", &event_id.to_string())\n}\n\n#[cfg(target_os = \"macos\")]\nconst MUST_SCAN_THRESHOLD: usize = 10;\n\n#[cfg(target_os = \"macos\")]\nfn start_fsevent_watcher_worker(\n    app: AppHandle,\n    state: AppState,\n    since_event_id: Option<u64>,\n    conditional: bool,\n) {\n    use std::sync::mpsc::{self, RecvTimeoutError};\n    std::thread::spawn(move || {\n        let (tx, rx) = mpsc::channel();\n\n        let mut watcher =\n            match mac::fsevent_watcher::FsEventWatcher::new(&state.home_dir, since_event_id, tx) {\n                Ok(w) => w,\n                Err(err) => {\n                    set_state(\n                        &state,\n                        IndexState::Error,\n                        Some(format!(\"FSEvents watcher initialization failed: {err}\")),\n                    );\n                    emit_index_state(\n                        &app,\n                        \"Error\",\n                        Some(format!(\"FSEvents watcher initialization failed: {err}\")),\n                    );\n                    return;\n                }\n            };\n\n        if conditional {\n            perf_log(\"conditional_startup: watcher started, awaiting history replay\");\n            set_state(&state, IndexState::Ready, None);\n            emit_index_state(&app, \"Ready\", None);\n        }\n\n        let mut pending_paths: HashSet<PathBuf> = HashSet::new();\n        let mut deadline: Option<Instant> = None;\n        let mut last_flush = Instant::now();\n        let mut last_status_emit = Instant::now();\n        let mut pending_status_emit = false;\n        let mut last_count_refresh = Instant::now();\n        let mut must_scan_count: usize = 0;\n        let mut replay_phase = conditional;\n        let mut full_scan_triggered = false;\n\n        loop {\n            let wait = match deadline {\n                Some(due) => {\n                    let now = Instant::now();\n                    if now >= due {\n                        Duration::from_millis(0)\n                    } else {\n                        due - now\n                    }\n                }\n                None => Duration::from_secs(1),\n            };\n            match rx.recv_timeout(wait) {\n                Ok(mac::fsevent_watcher::FsEvent::Paths(paths)) => {\n                    let (ignored_roots, ignored_patterns) = cached_effective_ignore_rules(&state);\n                    let prev_len = pending_paths.len();\n                    for path in paths {\n                        if !should_skip_path(&path, &ignored_roots, &ignored_patterns) {\n                            pending_paths.insert(path);\n                        }\n                    }\n                    if pending_paths.len() > prev_len {\n                        deadline = Some(Instant::now() + WATCH_DEBOUNCE);\n                    }\n                }\n                Ok(mac::fsevent_watcher::FsEvent::MustScanSubDirs(path)) => {\n                    must_scan_count += 1;\n                    if replay_phase\n                        && must_scan_count >= MUST_SCAN_THRESHOLD\n                        && !full_scan_triggered\n                    {\n                        perf_log(format!(\n                            \"conditional_startup: MustScanSubDirs={} >= threshold, triggering full scan\",\n                            must_scan_count\n                        ));\n                        full_scan_triggered = true;\n                        let _ = start_full_index_worker(app.clone(), state.clone());\n                    }\n                    if !state.indexing_active.load(AtomicOrdering::Acquire) {\n                        let (ignored_roots, ignored_patterns) =\n                            cached_effective_ignore_rules(&state);\n                        let rows = collect_rows_recursive(&path, &ignored_roots, &ignored_patterns);\n                        if !rows.is_empty() {\n                            eprintln!(\n                                \"[watcher] MustScanSubDirs DB write: rows={} path={}\",\n                                rows.len(),\n                                path.display()\n                            );\n                            if let Ok(mut conn) = db_connection(&state.db_path) {\n                                if upsert_rows(&mut conn, &rows).is_ok() {\n                                    invalidate_search_caches(&state);\n                                    touch_status_updated(&state);\n                                    if last_status_emit.elapsed() >= STATUS_EMIT_MIN_INTERVAL {\n                                        let _ = refresh_and_emit_status_counts(&app, &state);\n                                        last_status_emit = Instant::now();\n                                        pending_status_emit = false;\n                                    } else {\n                                        pending_status_emit = true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                Ok(mac::fsevent_watcher::FsEvent::HistoryDone) => {\n                    eprintln!(\n                        \"[watcher] HistoryDone: pending_paths={} indexing_active={}\",\n                        pending_paths.len(),\n                        state.indexing_active.load(AtomicOrdering::Acquire)\n                    );\n                    process_watcher_paths(\n                        &app,\n                        &state,\n                        &mut pending_paths,\n                        &mut deadline,\n                        &mut last_status_emit,\n                        &mut pending_status_emit,\n                    );\n                    if replay_phase {\n                        replay_phase = false;\n                        if !full_scan_triggered {\n                            perf_log(format!(\n                                \"conditional_startup: HistoryDone, MustScanSubDirs={}, skipping full scan\",\n                                must_scan_count\n                            ));\n                            let _ = refresh_and_emit_status_counts(&app, &state);\n                            last_status_emit = Instant::now();\n                            pending_status_emit = false;\n                        }\n                    }\n                }\n                Err(RecvTimeoutError::Timeout) => {}\n                Err(RecvTimeoutError::Disconnected) => break,\n            }\n\n            if let Some(due) = deadline {\n                if Instant::now() >= due {\n                    process_watcher_paths(\n                        &app,\n                        &state,\n                        &mut pending_paths,\n                        &mut deadline,\n                        &mut last_status_emit,\n                        &mut pending_status_emit,\n                    );\n                }\n            }\n\n            if pending_status_emit && last_status_emit.elapsed() >= STATUS_EMIT_MIN_INTERVAL {\n                let _ = refresh_and_emit_status_counts(&app, &state);\n                last_status_emit = Instant::now();\n                pending_status_emit = false;\n            }\n\n            // Periodic event_id flush\n            if last_flush.elapsed() >= EVENT_ID_FLUSH_INTERVAL {\n                let eid = watcher.last_event_id();\n                let _ = persist_event_id(&state.db_path, eid);\n                last_flush = Instant::now();\n            }\n\n            // Periodic count refresh to keep in-memory counts accurate\n            if last_count_refresh.elapsed() >= EVENT_ID_FLUSH_INTERVAL {\n                let _ = update_status_counts(&state);\n                last_count_refresh = Instant::now();\n            }\n        }\n\n        // Final flush on shutdown\n        let eid = watcher.last_event_id();\n        let _ = persist_event_id(&state.db_path, eid);\n        watcher.stop();\n    });\n}\n\nfn validate_new_name(new_name: &str) -> AppResult<String> {\n    let trimmed = new_name.trim();\n\n    if trimmed.is_empty() {\n        return Err(\"New name cannot be empty.\".to_string());\n    }\n    if trimmed.contains('/') {\n        return Err(\"New name cannot contain '/'.\".to_string());\n    }\n    if trimmed == \".\" || trimmed == \"..\" {\n        return Err(\"Invalid name.\".to_string());\n    }\n\n    Ok(trimmed.to_string())\n}\n\nfn row_to_entry(row: &rusqlite::Row<'_>) -> rusqlite::Result<EntryDto> {\n    Ok(EntryDto {\n        path: row.get(0)?,\n        name: row.get(1)?,\n        dir: row.get(2)?,\n        is_dir: row.get::<_, i64>(3)? == 1,\n        ext: row.get(4)?,\n        size: row.get(5)?,\n        mtime: row.get(6)?,\n    })\n}\n\n#[cfg(target_os = \"macos\")]\nfn safe_file_type(ext: &str) -> String {\n    if ext.eq_ignore_ascii_case(\"folder\") {\n        return \"public.folder\".to_string();\n    }\n\n    let filtered: String = ext\n        .chars()\n        .filter(|c| c.is_ascii_alphanumeric())\n        .collect::<String>()\n        .to_lowercase();\n\n    if filtered.is_empty() {\n        \"public.data\".to_string()\n    } else {\n        filtered\n    }\n}\n\n#[cfg(target_os = \"macos\")]\nfn load_system_icon_png(ext: &str) -> Option<Vec<u8>> {\n    let file_type = safe_file_type(ext);\n    let script = format!(\n        r#\"import AppKit\nimport Foundation\nlet image = NSWorkspace.shared.icon(forFileType: \"{file_type}\")\nimage.size = NSSize(width: 16, height: 16)\nif let tiff = image.tiffRepresentation,\n   let rep = NSBitmapImageRep(data: tiff),\n   let png = rep.representation(using: .png, properties: [:]) {{\n  FileHandle.standardOutput.write(png)\n}} else {{\n  exit(1)\n}}\n\"#\n    );\n\n    let output = Command::new(\"swift\").arg(\"-e\").arg(script).output().ok()?;\n    if output.status.success() && !output.stdout.is_empty() {\n        Some(output.stdout)\n    } else {\n        None\n    }\n}\n\n#[cfg(target_os = \"windows\")]\nfn load_system_icon_png(ext: &str) -> Option<Vec<u8>> {\n    win::icon::load_icon_png_by_ext(ext)\n}\n\n#[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\nfn load_system_icon_png(_ext: &str) -> Option<Vec<u8>> {\n    None\n}\n\n#[cfg(target_os = \"windows\")]\nfn is_per_file_icon_ext(ext: &str) -> bool {\n    matches!(ext, \"exe\" | \"lnk\" | \"ico\" | \"url\" | \"scr\" | \"appx\")\n}\n\n#[tauri::command]\nfn get_index_status(state: State<'_, AppState>) -> IndexStatusDto {\n    let started = Instant::now();\n    let snapshot = state.status.lock().clone();\n    let snapshot_state = snapshot.state.as_str().to_string();\n    let db_ready = state.db_ready.load(AtomicOrdering::Acquire);\n    let indexing_active = state.indexing_active.load(AtomicOrdering::Acquire);\n    let state_label = if matches!(snapshot.state, IndexState::Error) {\n        snapshot.state.as_str().to_string()\n    } else if matches!(snapshot.state, IndexState::Ready) {\n        \"Ready\".to_string()\n    } else if indexing_active || !db_ready {\n        \"Indexing\".to_string()\n    } else {\n        snapshot.state.as_str().to_string()\n    };\n    let dto = IndexStatusDto {\n        state: state_label,\n        entries_count: snapshot.entries_count,\n        last_updated: snapshot.last_updated,\n        permission_errors: snapshot.permission_errors,\n        message: snapshot.message,\n        scanned: snapshot.scanned,\n        indexed: snapshot.indexed,\n        current_path: snapshot.current_path,\n    };\n    if cfg!(debug_assertions) {\n        eprintln!(\n            \"[rpc/get_index_status] elapsed={}ms state={} snapshot_state={} db_ready={} indexing_active={} entries={} scanned={} indexed={}\",\n            started.elapsed().as_millis(),\n            dto.state,\n            snapshot_state,\n            db_ready,\n            indexing_active,\n            dto.entries_count,\n            dto.scanned,\n            dto.indexed,\n        );\n    }\n    dto\n}\n\n#[tauri::command]\nfn get_home_dir(state: State<'_, AppState>) -> String {\n    state.home_dir.to_string_lossy().to_string()\n}\n\n#[tauri::command]\nfn start_full_index(app: AppHandle, state: State<'_, AppState>) -> AppResult<()> {\n    #[cfg(target_os = \"windows\")]\n    {\n        win::start_windows_indexing(app, state.inner().clone());\n        Ok(())\n    }\n    #[cfg(not(target_os = \"windows\"))]\n    {\n        start_full_index_worker(app, state.inner().clone())\n    }\n}\n\n#[tauri::command]\nasync fn reset_index(app: AppHandle, state: State<'_, AppState>) -> AppResult<()> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        if state.indexing_active.load(AtomicOrdering::Acquire) {\n            return Err(\"Cannot reset while indexing is in progress.\".to_string());\n        }\n\n        // Stop existing file watcher and wait for it to fully exit\n        state.watcher_stop.store(true, AtomicOrdering::Release);\n        let deadline = std::time::Instant::now() + std::time::Duration::from_secs(5);\n        while state.watcher_active.load(AtomicOrdering::Acquire) {\n            if std::time::Instant::now() >= deadline {\n                eprintln!(\"[reset] watcher did not stop within 5s, proceeding anyway\");\n                break;\n            }\n            std::thread::sleep(std::time::Duration::from_millis(50));\n        }\n\n        let conn = db_connection(&state.db_path)?;\n        conn.execute(\"DELETE FROM entries\", [])\n            .map_err(|e| e.to_string())?;\n        conn.execute(\"DELETE FROM meta\", [])\n            .map_err(|e| e.to_string())?;\n\n        {\n            let mut status = state.status.lock();\n            status.state = IndexState::Indexing;\n            status.entries_count = 0;\n            status.last_updated = None;\n            status.permission_errors = 0;\n            status.message = None;\n            status.scanned = 0;\n            status.indexed = 0;\n            status.current_path.clear();\n        }\n\n        invalidate_search_caches(&state);\n\n        emit_index_state(&app, \"Indexing\", None);\n        emit_index_updated(&app, 0, now_epoch(), 0);\n\n        // Allow new watcher to start\n        state.watcher_stop.store(false, AtomicOrdering::Release);\n\n        #[cfg(target_os = \"windows\")]\n        {\n            win::start_windows_indexing(app, state);\n            Ok(())\n        }\n        #[cfg(not(target_os = \"windows\"))]\n        {\n            start_full_index_worker(app, state)\n        }\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\nfn log_search(db_path: &Path, query: &str, mode: &str, results: &[EntryDto]) {\n    if !search_log_enabled() {\n        return;\n    }\n\n    let log_path = db_path.with_file_name(\"search.log\");\n    let Ok(mut f) = fs::OpenOptions::new()\n        .create(true)\n        .append(true)\n        .open(&log_path)\n    else {\n        return;\n    };\n    let top: Vec<&str> = results.iter().take(10).map(|e| e.name.as_str()).collect();\n    let _ = writeln!(\n        f,\n        \"[{}] Q={:?} MODE={} COUNT={} TOP={:?}\",\n        now_epoch(),\n        query,\n        mode,\n        results.len(),\n        top,\n    );\n}\n\nfn search_log_enabled() -> bool {\n    *SEARCH_LOG_ENABLED.get_or_init(|| env_truthy(\"FASTFIND_SEARCH_LOG\"))\n}\n\n/// Returns the total number of entries matching `query` without LIMIT/OFFSET.\n/// Returns `None` when the total is unknown or intentionally skipped.\nfn compute_total_count(\n    db_path: &Path,\n    home_dir: &Path,\n    execution: &SearchExecution,\n) -> Option<u32> {\n    // When fewer results than the limit were returned the total is exact.\n    if (execution.results.len() as u32) < execution.effective_limit {\n        return Some(\n            execution\n                .offset\n                .saturating_add(execution.results.len() as u32),\n        );\n    }\n    // For paginated pages after the first we leave total tracking to the frontend.\n    if execution.offset > 0 {\n        return None;\n    }\n    // Non-SQL fast paths already return all matching entries.\n    if execution.mode_label.starts_with(\"mem_\")\n        || execution.mode_label == \"spotlight\"\n        || execution.mode_label == \"spotlight_timeout\"\n        || execution.mode_label == \"find_fallback\"\n        || execution.mode_label == \"name_neg_cache\"\n    {\n        return Some(execution.results.len() as u32);\n    }\n    let Ok(conn) = db_connection_for_search(db_path) else {\n        return None;\n    };\n    let mode = parse_query(&execution.query);\n    let total = match mode {\n        SearchMode::Empty => conn\n            .query_row(\"SELECT COUNT(*) FROM entries\", [], |r| r.get(0))\n            .unwrap_or(0),\n        SearchMode::NameSearch { name_like } => {\n            let escaped = escape_like(&execution.query);\n            let prefix_like = format!(\"{}%\", escaped);\n            let prefix_count: u32 = conn\n                .query_row(\n                    \"SELECT COUNT(*) FROM entries WHERE name LIKE ?1 ESCAPE '\\\\'\",\n                    params![prefix_like],\n                    |r| r.get(0),\n                )\n                .unwrap_or(0);\n            if prefix_count > 0 {\n                prefix_count\n            } else {\n                // Phase-2 contains fallback was used.\n                conn.query_row(\n                    \"SELECT COUNT(*) FROM entries WHERE name LIKE ?1 ESCAPE '\\\\'\",\n                    params![name_like],\n                    |r| r.get(0),\n                )\n                .unwrap_or(0)\n            }\n        }\n        SearchMode::GlobName { name_like } => conn\n            .query_row(\n                \"SELECT COUNT(*) FROM entries WHERE name LIKE ?1 ESCAPE '\\\\'\",\n                params![name_like],\n                |r| r.get(0),\n            )\n            .unwrap_or(0),\n        SearchMode::ExtSearch { ext, .. } => conn\n            .query_row(\n                \"SELECT COUNT(*) FROM entries WHERE ext = ?1\",\n                params![ext],\n                |r| r.get(0),\n            )\n            .unwrap_or(0),\n        SearchMode::PathSearch {\n            name_like,\n            dir_hint,\n            ..\n        } => {\n            let resolved_dirs = resolve_dir_hint(home_dir, &dir_hint)\n                .map(|p| vec![p.to_string_lossy().to_string()])\n                .unwrap_or_default();\n            let resolved_dirs = if resolved_dirs.is_empty() {\n                resolve_dirs_from_db(&conn, &dir_hint)\n            } else {\n                resolved_dirs\n            };\n\n            if !resolved_dirs.is_empty() {\n                let mut sql_params: Vec<SqlValue> = Vec::new();\n                let mut dir_conditions = Vec::new();\n                let sep = std::path::MAIN_SEPARATOR;\n                for d in &resolved_dirs {\n                    let i = sql_params.len();\n                    let pfx = format!(\"{d}{sep}\");\n                    let pfx_end = format!(\"{d}\\x7F\");\n                    sql_params.push(SqlValue::Text(d.clone()));\n                    sql_params.push(SqlValue::Text(pfx));\n                    sql_params.push(SqlValue::Text(pfx_end));\n                    dir_conditions.push(format!(\n                        \"(e.dir = ?{} OR (e.dir >= ?{} AND e.dir < ?{}))\",\n                        i + 1,\n                        i + 2,\n                        i + 3\n                    ));\n                }\n                let dir_where = dir_conditions.join(\" OR \");\n                let name_filter = if name_like == \"%\" {\n                    String::new()\n                } else {\n                    let ext_shortcut = extract_ext_from_like(&name_like);\n                    if let Some(ext_val) = ext_shortcut {\n                        let i = sql_params.len();\n                        sql_params.push(SqlValue::Text(ext_val));\n                        format!(\" AND e.ext = ?{}\", i + 1)\n                    } else {\n                        let i = sql_params.len();\n                        sql_params.push(SqlValue::Text(name_like.clone()));\n                        format!(\" AND e.name LIKE ?{} ESCAPE '\\\\'\", i + 1)\n                    }\n                };\n                let sql =\n                    format!(\"SELECT COUNT(*) FROM entries e WHERE ({dir_where}){name_filter}\");\n                conn.query_row(&sql, params_from_iter(sql_params.iter()), |r| r.get(0))\n                    .unwrap_or(0)\n            } else {\n                let sep = std::path::MAIN_SEPARATOR;\n                let native_hint = dir_hint.replace('/', &sep.to_string());\n                let escaped_sep = escape_like(&sep.to_string());\n                let dir_suffix = escape_like(&native_hint);\n                let dir_like_exact = format!(\"%{escaped_sep}{dir_suffix}\");\n                let dir_like_sub = format!(\"%{escaped_sep}{dir_suffix}{escaped_sep}%\");\n                let ext_shortcut = extract_ext_from_like(&name_like);\n                if let Some(ext_val) = ext_shortcut {\n                    conn.query_row(\n                        \"SELECT COUNT(*) FROM entries e WHERE e.ext = ?1 AND (e.dir LIKE ?2 ESCAPE '\\\\' OR e.dir LIKE ?3 ESCAPE '\\\\')\",\n                        params![ext_val, dir_like_exact, dir_like_sub],\n                        |r| r.get(0),\n                    )\n                    .unwrap_or(0)\n                } else if name_like == \"%\" {\n                    conn.query_row(\n                        \"SELECT COUNT(*) FROM entries e WHERE e.dir LIKE ?1 ESCAPE '\\\\' OR e.dir LIKE ?2 ESCAPE '\\\\'\",\n                        params![dir_like_exact, dir_like_sub],\n                        |r| r.get(0),\n                    )\n                    .unwrap_or(0)\n                } else {\n                    conn.query_row(\n                        \"SELECT COUNT(*) FROM entries e WHERE (e.dir LIKE ?1 ESCAPE '\\\\' OR e.dir LIKE ?2 ESCAPE '\\\\') AND e.name LIKE ?3 ESCAPE '\\\\'\",\n                        params![dir_like_exact, dir_like_sub, name_like],\n                        |r| r.get(0),\n                    )\n                    .unwrap_or(0)\n                }\n            }\n        }\n    };\n\n    Some(total)\n}\n\nfn execute_search(\n    state: &AppState,\n    query: String,\n    limit: Option<u32>,\n    offset: Option<u32>,\n    sort_by: Option<String>,\n    sort_dir: Option<String>,\n) -> AppResult<SearchExecution> {\n    let query = query.trim().to_string();\n    let base_limit = limit.unwrap_or(DEFAULT_LIMIT).clamp(1, MAX_LIMIT);\n    let effective_limit = if !query.is_empty() && query.chars().count() <= 1 {\n        base_limit.min(SHORT_QUERY_LIMIT)\n    } else {\n        base_limit\n    };\n    let offset = offset.unwrap_or(0);\n\n    let sort_by = sort_by.unwrap_or_else(|| \"name\".to_string());\n    let sort_dir = sort_dir.unwrap_or_else(|| \"asc\".to_string());\n    let (runtime_ignored_roots, runtime_ignored_patterns) = cached_effective_ignore_rules(state);\n\n    #[cfg(target_os = \"macos\")]\n    if !state.db_ready.load(AtomicOrdering::Acquire) {\n        let spotlight = mac::spotlight_search::search_spotlight(&state.home_dir, &query);\n        let mode_label = if spotlight.entries.is_empty() {\n            \"db_not_ready\".to_string()\n        } else if spotlight.timed_out {\n            \"spotlight_timeout\".to_string()\n        } else {\n            \"spotlight\".to_string()\n        };\n        perf_log(format!(\n            \"spotlight_fallback db_not_ready query={:?} results={} timed_out={}\",\n            query,\n            spotlight.entries.len(),\n            spotlight.timed_out\n        ));\n        return Ok(SearchExecution {\n            query,\n            sort_by,\n            sort_dir,\n            effective_limit,\n            offset,\n            mode_label,\n            results: spotlight.entries,\n        });\n    }\n\n    let is_indexing = matches!(state.status.lock().state, IndexState::Indexing);\n    let order_by = sort_clause(&sort_by, &sort_dir, \"e.\");\n\n    let mut results = Vec::with_capacity(effective_limit as usize);\n    let mode = parse_query(&query);\n    let is_name_mode = matches!(&mode, SearchMode::NameSearch { .. });\n    let allow_find_fallback = !is_indexing\n        && matches!(\n            &mode,\n            SearchMode::GlobName { .. } | SearchMode::ExtSearch { .. }\n        );\n    let mut mode_label = match &mode {\n        SearchMode::Empty => \"empty\",\n        SearchMode::NameSearch { .. } => \"name\",\n        SearchMode::GlobName { .. } => \"glob\",\n        SearchMode::ExtSearch { .. } => \"ext\",\n        SearchMode::PathSearch { .. } => \"path\",\n    }\n    .to_string();\n\n    // Fast path: search in-memory index if available (DB upsert still in progress)\n    {\n        let guard = state.mem_index.read();\n        if let Some(ref mi) = *guard {\n            let mem_results = mem_search::search_mem_index(\n                mi, &query, &mode, effective_limit, offset, &sort_by, &sort_dir,\n            );\n            mode_label = format!(\"mem_{mode_label}\");\n            return Ok(SearchExecution {\n                query,\n                sort_by,\n                sort_dir,\n                effective_limit,\n                offset,\n                mode_label,\n                results: mem_results,\n            });\n        }\n    }\n\n    if is_name_mode && !is_indexing && offset == 0 {\n        if let Some(cache_hit) = negative_name_cache_lookup(state, &query) {\n            if cache_hit.age >= WATCH_DEBOUNCE\n                && cache_hit.age <= NEGATIVE_CACHE_FALLBACK_WINDOW\n                && !cache_hit.fallback_checked\n            {\n                let fallback_results = find_search(\n                    &state.home_dir,\n                    &runtime_ignored_roots,\n                    &runtime_ignored_patterns,\n                    &query,\n                    effective_limit as usize,\n                    &sort_by,\n                    &sort_dir,\n                );\n                if !fallback_results.is_empty() {\n                    remove_negative_name_query(state, &cache_hit.query_lower);\n                    perf_log(format!(\n                        \"search_negative_cache_fallback_hit query={:?} age_ms={} results={}\",\n                        query,\n                        cache_hit.age.as_millis(),\n                        fallback_results.len()\n                    ));\n                    return Ok(SearchExecution {\n                        query,\n                        sort_by,\n                        sort_dir,\n                        effective_limit,\n                        offset,\n                        mode_label: \"find_fallback\".to_string(),\n                        results: fallback_results,\n                    });\n                }\n                mark_negative_name_fallback_checked(state, &cache_hit.query_lower);\n            }\n\n            perf_log(format!(\n                \"search_negative_cache_hit query={:?} age_ms={}\",\n                query,\n                cache_hit.age.as_millis()\n            ));\n            return Ok(SearchExecution {\n                query,\n                sort_by,\n                sort_dir,\n                effective_limit,\n                offset,\n                mode_label: \"name_neg_cache\".to_string(),\n                results: Vec::new(),\n            });\n        }\n    }\n\n    #[cfg(target_os = \"macos\")]\n    let db_unavailable;\n    match db_connection_for_search(&state.db_path) {\n        Ok(conn) => {\n            #[cfg(target_os = \"macos\")]\n            { db_unavailable = false; }\n            match &mode {\n                SearchMode::Empty => {\n                    let sql = format!(\n                        r#\"\n                        SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                        FROM entries e\n                        ORDER BY {order_by}\n                        LIMIT ?1 OFFSET ?2\n                        \"#,\n                    );\n                    let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                    let rows = stmt\n                        .query_map(params![effective_limit, offset], row_to_entry)\n                        .map_err(|e| e.to_string())?;\n                    for row in rows {\n                        results.push(row.map_err(|e| e.to_string())?);\n                    }\n                }\n\n                SearchMode::NameSearch { name_like } => {\n                    let escaped_query = escape_like(&query);\n                    let exact_query = query.clone();\n                    let prefix_like = format!(\"{}%\", escaped_query);\n                    let bare_order = sort_clause(&sort_by, &sort_dir, \"\");\n\n                    if offset == 0 {\n                        let exact_sql = format!(\n                            r#\"\n                            SELECT path, name, dir, is_dir, ext, size, mtime\n                            FROM entries\n                            WHERE name COLLATE NOCASE = ?1\n                            ORDER BY {bare_order}\n                            LIMIT ?2\n                            \"#,\n                        );\n                        let mut stmt = conn.prepare(&exact_sql).map_err(|e| e.to_string())?;\n                        let rows = stmt\n                            .query_map(params![exact_query, effective_limit], row_to_entry)\n                            .map_err(|e| e.to_string())?;\n                        for row in rows {\n                            results.push(row.map_err(|e| e.to_string())?);\n                        }\n                    }\n\n                    if (results.len() as u32) < effective_limit {\n                        let remaining = effective_limit - results.len() as u32;\n                        let adj_offset = if offset > 0 {\n                            offset.saturating_sub(results.len() as u32)\n                        } else {\n                            0\n                        };\n\n                        // Try indexed prefix search first; fall back to unindexed if\n                        // the index is temporarily unavailable (during background DB\n                        // rebuild the index may be dropped then recreated).\n                        let prefix_sql_indexed = format!(\n                            r#\"\n                            SELECT path, name, dir, is_dir, ext, size, mtime\n                            FROM entries INDEXED BY idx_entries_name_nocase\n                            WHERE name LIKE ?1 ESCAPE '\\'\n                              AND name COLLATE NOCASE != ?2\n                            ORDER BY {bare_order}\n                            LIMIT ?3 OFFSET ?4\n                            \"#,\n                        );\n                        let prefix_sql_fallback = format!(\n                            r#\"\n                            SELECT path, name, dir, is_dir, ext, size, mtime\n                            FROM entries\n                            WHERE name LIKE ?1 ESCAPE '\\'\n                              AND name COLLATE NOCASE != ?2\n                            ORDER BY {bare_order}\n                            LIMIT ?3 OFFSET ?4\n                            \"#,\n                        );\n                        let mut stmt = match conn.prepare(&prefix_sql_indexed) {\n                            Ok(s) => s,\n                            Err(_) => {\n                                eprintln!(\"[search] idx_entries_name_nocase unavailable, using fallback\");\n                                conn.prepare(&prefix_sql_fallback).map_err(|e| e.to_string())?\n                            }\n                        };\n                        let rows = stmt\n                            .query_map(\n                                params![prefix_like, exact_query, remaining, adj_offset],\n                                row_to_entry,\n                            )\n                            .map_err(|e| e.to_string())?;\n                        for row in rows {\n                            results.push(row.map_err(|e| e.to_string())?);\n                        }\n                    }\n\n                    if results.is_empty() && offset == 0 {\n                        // Phase 2: contains-match (LIKE '%q%') with tight time budget.\n                        // Combines probe + fetch in one pass to avoid double scan overhead.\n                        let phase2_start = Instant::now();\n                        conn.progress_handler(\n                            2_000,\n                            Some(move || phase2_start.elapsed().as_millis() > 5),\n                        );\n\n                        {\n\n                            let phase2_sql = format!(\n                                r#\"\n                                SELECT path, name, dir, is_dir, ext, size, mtime\n                                FROM entries\n                                WHERE name LIKE ?1 ESCAPE '\\'\n                                  AND name COLLATE NOCASE != ?2\n                                  AND name NOT LIKE ?3 ESCAPE '\\'\n                                ORDER BY {bare_order}\n                                LIMIT ?4\n                                \"#,\n                            );\n                            if let Ok(mut stmt2) = conn.prepare(&phase2_sql) {\n                                if let Ok(rows2) = stmt2.query_map(\n                                    params![name_like, exact_query, prefix_like, effective_limit],\n                                    row_to_entry,\n                                ) {\n                                    for row in rows2 {\n                                        match row {\n                                            Ok(entry) => results.push(entry),\n                                            Err(_) => break,\n                                        }\n                                    }\n                                }\n                            }\n                        }\n\n                        conn.progress_handler(0, None::<fn() -> bool>);\n                    }\n                }\n\n                SearchMode::GlobName { name_like } => {\n                    let sql = format!(\n                        r#\"\n                        SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                        FROM entries e\n                        WHERE e.name LIKE ?1 ESCAPE '\\'\n                        ORDER BY {order_by}\n                        LIMIT ?2 OFFSET ?3\n                        \"#,\n                    );\n                    let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                    let rows = stmt\n                        .query_map(params![name_like, effective_limit, offset], row_to_entry)\n                        .map_err(|e| e.to_string())?;\n                    for row in rows {\n                        results.push(row.map_err(|e| e.to_string())?);\n                    }\n                }\n\n                SearchMode::ExtSearch { ext, name_like: _ } => {\n                    let sql = format!(\n                        r#\"\n                        SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                        FROM entries e\n                        WHERE e.ext = ?1\n                        ORDER BY {order_by}\n                        LIMIT ?2 OFFSET ?3\n                        \"#,\n                    );\n                    let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                    let rows = stmt\n                        .query_map(params![ext, effective_limit, offset], row_to_entry)\n                        .map_err(|e| e.to_string())?;\n                    for row in rows {\n                        results.push(row.map_err(|e| e.to_string())?);\n                    }\n                }\n\n                SearchMode::PathSearch {\n                    path_like: _,\n                    name_like,\n                    dir_hint,\n                } => {\n                    let resolved_dirs: Vec<String> = resolve_dir_hint(&state.home_dir, dir_hint)\n                        .map(|p| vec![p.to_string_lossy().to_string()])\n                        .unwrap_or_default();\n                    let resolved_dirs = if resolved_dirs.is_empty() {\n                        resolve_dirs_from_db(&conn, dir_hint)\n                    } else {\n                        resolved_dirs\n                    };\n\n                    if !resolved_dirs.is_empty() {\n                        let ext_shortcut = extract_ext_from_like(name_like);\n                        let mut sql_params: Vec<SqlValue> = Vec::new();\n                        let mut dir_conditions = Vec::new();\n                        let sep = std::path::MAIN_SEPARATOR;\n\n                        for d in &resolved_dirs {\n                            let i = sql_params.len();\n                            let pfx = format!(\"{d}{sep}\");\n                            let pfx_end = format!(\"{d}\\x7F\");\n                            sql_params.push(SqlValue::Text(d.clone()));\n                            sql_params.push(SqlValue::Text(pfx));\n                            sql_params.push(SqlValue::Text(pfx_end));\n                            dir_conditions.push(format!(\n                                \"(e.dir = ?{} OR (e.dir >= ?{} AND e.dir < ?{}))\",\n                                i + 1,\n                                i + 2,\n                                i + 3\n                            ));\n                        }\n                        let dir_where = dir_conditions.join(\" OR \");\n\n                        let name_filter = if name_like == \"%\" {\n                            String::new()\n                        } else if let Some(ref ext_val) = ext_shortcut {\n                            let i = sql_params.len();\n                            sql_params.push(SqlValue::Text(ext_val.clone()));\n                            format!(\" AND e.ext = ?{}\", i + 1)\n                        } else {\n                            let i = sql_params.len();\n                            sql_params.push(SqlValue::Text(name_like.clone()));\n                            format!(\" AND e.name LIKE ?{} ESCAPE '\\\\'\", i + 1)\n                        };\n\n                        let limit_idx = sql_params.len() + 1;\n                        let offset_idx = sql_params.len() + 2;\n                        sql_params.push(SqlValue::Integer(effective_limit as i64));\n                        sql_params.push(SqlValue::Integer(offset as i64));\n\n                        let sql = format!(\n                            r#\"\n                            SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                            FROM entries e\n                            WHERE ({dir_where}){name_filter}\n                            ORDER BY {order_by}\n                            LIMIT ?{limit_idx} OFFSET ?{offset_idx}\n                            \"#,\n                        );\n                        let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                        let rows = stmt\n                            .query_map(params_from_iter(sql_params.iter()), row_to_entry)\n                            .map_err(|e| e.to_string())?;\n                        for row in rows {\n                            results.push(row.map_err(|e| e.to_string())?);\n                        }\n                    } else {\n                        let sep = std::path::MAIN_SEPARATOR;\n                        let sep_str = sep.to_string();\n                        let escaped_sep = escape_like(&sep_str);\n                        let (native_hint, is_absolute) = normalize_hint_to_native(dir_hint);\n                        let dir_suffix = escape_like(&native_hint);\n                        let dir_prefix = if is_absolute {\n                            String::new()\n                        } else {\n                            escaped_sep.clone()\n                        };\n                        let dir_like_exact = format!(\"%{dir_prefix}{dir_suffix}\");\n                        let dir_like_sub = format!(\"%{dir_prefix}{dir_suffix}{escaped_sep}%\");\n                        let ext_shortcut = extract_ext_from_like(name_like);\n\n                        if let Some(ext_val) = ext_shortcut {\n                            let sql = format!(\n                                r#\"\n                                SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                                FROM entries e\n                                WHERE e.ext = ?1\n                                  AND (e.dir LIKE ?2 ESCAPE '\\' OR e.dir LIKE ?3 ESCAPE '\\')\n                                ORDER BY {order_by}\n                                LIMIT ?4 OFFSET ?5\n                                \"#,\n                            );\n                            let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                            let rows = stmt\n                                .query_map(\n                                    params![\n                                        ext_val,\n                                        dir_like_exact,\n                                        dir_like_sub,\n                                        effective_limit,\n                                        offset\n                                    ],\n                                    row_to_entry,\n                                )\n                                .map_err(|e| e.to_string())?;\n                            for row in rows {\n                                results.push(row.map_err(|e| e.to_string())?);\n                            }\n                        } else if name_like == \"%\" {\n                            // Directory listing: no name filter needed, no time budget\n                            let sql = format!(\n                                r#\"\n                                SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                                FROM entries e\n                                WHERE e.dir LIKE ?1 ESCAPE '\\' OR e.dir LIKE ?2 ESCAPE '\\'\n                                ORDER BY {order_by}\n                                LIMIT ?3 OFFSET ?4\n                                \"#,\n                            );\n                            let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                            let rows = stmt\n                                .query_map(\n                                    params![dir_like_exact, dir_like_sub, effective_limit, offset],\n                                    row_to_entry,\n                                )\n                                .map_err(|e| e.to_string())?;\n                            for row in rows {\n                                results.push(row.map_err(|e| e.to_string())?);\n                            }\n                        } else {\n                            // Phase A: fast prefix search via name index\n                            // \"%main%\" -> strip leading '%' -> \"main%\" can use idx_entries_name_nocase\n                            let prefix_like = if name_like.starts_with('%') {\n                                let rest = &name_like[1..];\n                                if !rest.is_empty() && !rest.starts_with('%') {\n                                    Some(rest.to_string())\n                                } else {\n                                    None\n                                }\n                            } else {\n                                // Already a prefix pattern (e.g. \"test%\"), use as-is\n                                Some(name_like.clone())\n                            };\n\n                            if offset == 0 {\n                                if let Some(ref pfx) = prefix_like {\n                                    let sql = format!(\n                                        r#\"\n                                        SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                                        FROM entries e INDEXED BY idx_entries_name_nocase\n                                        WHERE e.name LIKE ?1 ESCAPE '\\'\n                                          AND (e.dir LIKE ?2 ESCAPE '\\' OR e.dir LIKE ?3 ESCAPE '\\')\n                                        ORDER BY {order_by}\n                                        LIMIT ?4\n                                        \"#,\n                                    );\n                                    if let Ok(mut stmt) = conn.prepare(&sql) {\n                                        if let Ok(rows) = stmt.query_map(\n                                            params![\n                                                pfx,\n                                                dir_like_exact,\n                                                dir_like_sub,\n                                                effective_limit\n                                            ],\n                                            row_to_entry,\n                                        ) {\n                                            for row in rows {\n                                                match row {\n                                                    Ok(entry) => results.push(entry),\n                                                    Err(_) => break,\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n\n                            // Phase B: time-budgeted contains fallback if prefix found too few\n                            if results.len() < effective_limit as usize {\n                                let path_start = Instant::now();\n                                conn.progress_handler(\n                                    2_000,\n                                    Some(move || path_start.elapsed().as_millis() > 5),\n                                );\n\n                                let sql = format!(\n                                    r#\"\n                                    SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                                    FROM entries e\n                                    WHERE (e.dir LIKE ?1 ESCAPE '\\' OR e.dir LIKE ?2 ESCAPE '\\')\n                                      AND e.name LIKE ?3 ESCAPE '\\'\n                                    ORDER BY {order_by}\n                                    LIMIT ?4 OFFSET ?5\n                                    \"#,\n                                );\n                                if let Ok(mut stmt) = conn.prepare(&sql) {\n                                    if let Ok(rows) = stmt.query_map(\n                                        params![\n                                            dir_like_exact,\n                                            dir_like_sub,\n                                            name_like,\n                                            effective_limit,\n                                            offset\n                                        ],\n                                        row_to_entry,\n                                    ) {\n                                        for row in rows {\n                                            match row {\n                                                Ok(entry) => results.push(entry),\n                                                Err(_) => break,\n                                            }\n                                        }\n                                    }\n                                }\n\n                                conn.progress_handler(0, None::<fn() -> bool>);\n\n                                // Deduplicate (Phase A prefix results overlap with Phase B contains)\n                                let mut seen = std::collections::HashSet::new();\n                                results.retain(|e| seen.insert(e.path.clone()));\n                                results.truncate(effective_limit as usize);\n                            }\n                        }\n                    }\n                }\n            }\n\n            if results.is_empty() && !query.is_empty() && offset == 0 && allow_find_fallback {\n                results = find_search(\n                    &state.home_dir,\n                    &runtime_ignored_roots,\n                    &runtime_ignored_patterns,\n                    &query,\n                    effective_limit as usize,\n                    &sort_by,\n                    &sort_dir,\n                );\n                mode_label = \"find_fallback\".to_string();\n            }\n        }\n        Err(_) => {\n            #[cfg(target_os = \"macos\")]\n            { db_unavailable = true; }\n            perf_log(format!(\"search_db_unavailable query={:?}\", query));\n        }\n    }\n\n    #[cfg(target_os = \"macos\")]\n    if !query.is_empty() && offset == 0 {\n        let should_spotlight = if results.is_empty() {\n            true\n        } else if results.len() >= effective_limit as usize {\n            false\n        } else {\n            is_indexing || db_unavailable\n        };\n        if should_spotlight {\n            let spotlight = mac::spotlight_search::search_spotlight(&state.home_dir, &query);\n            if !spotlight.entries.is_empty() {\n                if results.is_empty() {\n                    perf_log(format!(\n                        \"spotlight_fallback empty_results query={:?} results={} timed_out={}\",\n                        query,\n                        spotlight.entries.len(),\n                        spotlight.timed_out\n                    ));\n                    results = spotlight.entries;\n                    mode_label = if spotlight.timed_out {\n                        \"spotlight_timeout\".to_string()\n                    } else {\n                        \"spotlight\".to_string()\n                    };\n                } else {\n                    let existing_paths: std::collections::HashSet<String> =\n                        results.iter().map(|e| e.path.clone()).collect();\n                    let mut merged_count = 0usize;\n                    for entry in spotlight.entries {\n                        if !existing_paths.contains(&entry.path) {\n                            results.push(entry);\n                            merged_count += 1;\n                        }\n                    }\n                    if merged_count > 0 {\n                        perf_log(format!(\n                            \"spotlight_merge indexing query={:?} merged={} timed_out={}\",\n                            query, merged_count, spotlight.timed_out\n                        ));\n                        mode_label = format!(\"{}_+spotlight\", mode_label);\n                    }\n                }\n            }\n        }\n    }\n\n    results = filter_ignored_entries(results, &runtime_ignored_roots, &runtime_ignored_patterns);\n    results.truncate(effective_limit as usize);\n    if offset == 0 {\n        if sort_by == \"name\" {\n            sort_entries_with_relevance(&mut results, &query, &sort_by, &sort_dir);\n        } else {\n            sort_entries(&mut results, &sort_by, &sort_dir);\n        }\n    }\n    if is_name_mode && !is_indexing && offset == 0 && results.is_empty() && !query.is_empty() {\n        remember_negative_name_query(state, &query);\n    }\n\n    Ok(SearchExecution {\n        query,\n        sort_by,\n        sort_dir,\n        effective_limit,\n        offset,\n        mode_label,\n        results,\n    })\n}\n\n#[tauri::command]\nasync fn search(\n    _app: AppHandle,\n    query: String,\n    limit: Option<u32>,\n    offset: Option<u32>,\n    sort_by: Option<String>,\n    sort_dir: Option<String>,\n    include_total: Option<bool>,\n    state: State<'_, AppState>,\n) -> AppResult<SearchResultDto> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        let rpc_started = Instant::now();\n        let execute_started = Instant::now();\n        let execution = execute_search(&state, query, limit, offset, sort_by, sort_dir)?;\n        let execute_elapsed_ms = execute_started.elapsed().as_secs_f64() * 1000.0;\n\n        log_search(\n            &state.db_path,\n            &execution.query,\n            &execution.mode_label,\n            &execution.results,\n        );\n\n        if perf_log_enabled() {\n            let top: Vec<&str> = execution\n                .results\n                .iter()\n                .take(5)\n                .map(|entry| entry.name.as_str())\n                .collect();\n            perf_log(format!(\n                \"search query={:?} mode={} sort={}/{} limit={} offset={} results={} elapsed_ms={:.3} top={:?}\",\n                execution.query,\n                execution.mode_label,\n                execution.sort_by,\n                execution.sort_dir,\n                execution.effective_limit,\n                execution.offset,\n                execution.results.len(),\n                execute_elapsed_ms,\n                top,\n            ));\n        }\n\n        let include_total = include_total.unwrap_or(true);\n        let count_started = Instant::now();\n        let (total_count, total_known) = if include_total {\n            match compute_total_count(&state.db_path, &state.home_dir, &execution) {\n                Some(v) => (v, true),\n                None => (0, false),\n            }\n        } else {\n            (0, false)\n        };\n        let count_elapsed_ms = if include_total {\n            count_started.elapsed().as_secs_f64() * 1000.0\n        } else {\n            0.0\n        };\n\n        let rpc_elapsed_ms = rpc_started.elapsed().as_secs_f64() * 1000.0;\n        if cfg!(debug_assertions) {\n            let db_ready = state.db_ready.load(AtomicOrdering::Acquire);\n            let indexing_active = state.indexing_active.load(AtomicOrdering::Acquire);\n            eprintln!(\n                \"[rpc/search] total={:.3}ms execute={:.3}ms total_count={:.3}ms include_total={} query={:?} mode={} sort={}/{} limit={} offset={} results={} total_count={} total_known={} db_ready={} indexing_active={}\",\n                rpc_elapsed_ms,\n                execute_elapsed_ms,\n                count_elapsed_ms,\n                include_total,\n                execution.query,\n                execution.mode_label,\n                execution.sort_by,\n                execution.sort_dir,\n                execution.effective_limit,\n                execution.offset,\n                execution.results.len(),\n                total_count,\n                total_known,\n                db_ready,\n                indexing_active,\n            );\n        }\n        Ok(SearchResultDto {\n            entries: execution.results,\n            mode_label: execution.mode_label,\n            total_count,\n            total_known,\n        })\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nasync fn quick_look(path: String) -> AppResult<()> {\n    tauri::async_runtime::spawn_blocking(move || {\n        #[cfg(target_os = \"macos\")]\n        {\n            Command::new(\"qlmanage\")\n                .args([\"-p\", &path])\n                .stdout(std::process::Stdio::null())\n                .stderr(std::process::Stdio::null())\n                .spawn()\n                .map_err(|e| e.to_string())?;\n        }\n        #[cfg(target_os = \"windows\")]\n        {\n            Command::new(\"explorer\")\n                .arg(&path)\n                .spawn()\n                .map_err(|e| e.to_string())?;\n        }\n        #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n        {\n            Command::new(\"xdg-open\")\n                .arg(&path)\n                .spawn()\n                .map_err(|e| e.to_string())?;\n        }\n        Ok(())\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nasync fn open(paths: Vec<String>) -> AppResult<()> {\n    tauri::async_runtime::spawn_blocking(move || {\n        for path in &paths {\n            #[cfg(target_os = \"macos\")]\n            {\n                let output = Command::new(\"open\")\n                    .arg(path)\n                    .output()\n                    .map_err(|e| e.to_string())?;\n\n                if !output.status.success() && Path::new(path).is_dir() {\n                    let fallback = Command::new(\"open\")\n                        .args([\"-R\", path])\n                        .status()\n                        .map_err(|e| e.to_string())?;\n\n                    if !fallback.success() {\n                        return Err(format!(\"Failed to open: {path}\"));\n                    }\n                } else if !output.status.success() {\n                    let stderr = String::from_utf8_lossy(&output.stderr);\n                    return Err(format!(\"Failed to open: {path} ({stderr})\",));\n                }\n            }\n            #[cfg(target_os = \"windows\")]\n            {\n                let mut cmd = Command::new(\"cmd\");\n                cmd.raw_arg(format!(\"/C start \\\"\\\" \\\"{}\\\"\", path.replace('\"', \"\")));\n                let status = cmd.status().map_err(|e| e.to_string())?;\n                if !status.success() {\n                    return Err(format!(\"Failed to open: {path}\"));\n                }\n            }\n            #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n            {\n                let status = Command::new(\"xdg-open\")\n                    .arg(path)\n                    .status()\n                    .map_err(|e| e.to_string())?;\n                if !status.success() {\n                    return Err(format!(\"Failed to open: {path}\"));\n                }\n            }\n        }\n\n        Ok(())\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\nfn reveal_in_finder_impl(paths: Vec<String>) -> AppResult<()> {\n    if paths.is_empty() {\n        return Ok(());\n    }\n\n    #[cfg(target_os = \"macos\")]\n    {\n        if paths.len() == 1 {\n            let status = Command::new(\"open\")\n                .arg(\"-R\")\n                .arg(&paths[0])\n                .status()\n                .map_err(|e| e.to_string())?;\n\n            if !status.success() {\n                return Err(format!(\"Failed to reveal in Finder: {}\", paths[0]));\n            }\n\n            return Ok(());\n        }\n\n        let mut unique_parents: HashSet<PathBuf> = HashSet::new();\n        for path in &paths {\n            let p = PathBuf::from(path);\n            if let Some(parent) = p.parent() {\n                unique_parents.insert(parent.to_path_buf());\n            }\n        }\n\n        for parent in unique_parents {\n            let status = Command::new(\"open\")\n                .arg(&parent)\n                .status()\n                .map_err(|e| e.to_string())?;\n\n            if !status.success() {\n                return Err(format!(\n                    \"Failed to open in Finder: {}\",\n                    parent.to_string_lossy()\n                ));\n            }\n        }\n    }\n\n    #[cfg(target_os = \"windows\")]\n    {\n        for path in &paths {\n            let mut cmd = Command::new(\"explorer\");\n            cmd.raw_arg(format!(\"/select,\\\"{}\\\"\", path.replace('\"', \"\")));\n            let _ = cmd.status();\n        }\n    }\n\n    #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n    {\n        for path in &paths {\n            let target = Path::new(path);\n            let dir = if target.is_dir() {\n                path.as_str()\n            } else {\n                target\n                    .parent()\n                    .map(|p| p.to_str().unwrap_or(\"/\"))\n                    .unwrap_or(\"/\")\n            };\n            let _ = Command::new(\"xdg-open\").arg(dir).status();\n        }\n    }\n\n    Ok(())\n}\n\nfn copy_with_command(program: &str, args: &[&str], text: &str) -> AppResult<()> {\n    let mut child = Command::new(program)\n        .args(args)\n        .stdin(Stdio::piped())\n        .spawn()\n        .map_err(|e| format!(\"Failed to run {program}: {e}\"))?;\n\n    if let Some(mut stdin) = child.stdin.take() {\n        stdin\n            .write_all(text.as_bytes())\n            .map_err(|e| format!(\"Failed to write to clipboard: {e}\"))?;\n    } else {\n        return Err(\"Cannot open clipboard input stream.\".to_string());\n    }\n\n    let status = child\n        .wait()\n        .map_err(|e| format!(\"Failed to wait for {program}: {e}\"))?;\n\n    if status.success() {\n        Ok(())\n    } else {\n        Err(format!(\"{program} execution failed.\"))\n    }\n}\n\n#[cfg(target_os = \"macos\")]\nfn copy_text_to_clipboard(text: &str) -> AppResult<()> {\n    copy_with_command(\"pbcopy\", &[], text)\n}\n\n#[cfg(target_os = \"windows\")]\nfn copy_text_to_clipboard(text: &str) -> AppResult<()> {\n    copy_with_command(\"cmd\", &[\"/C\", \"clip\"], text)\n}\n\n#[cfg(all(unix, not(target_os = \"macos\")))]\nfn copy_text_to_clipboard(text: &str) -> AppResult<()> {\n    let mut last_error = None;\n\n    match copy_with_command(\"wl-copy\", &[], text) {\n        Ok(()) => return Ok(()),\n        Err(err) => last_error = Some(err),\n    }\n    match copy_with_command(\"xclip\", &[\"-selection\", \"clipboard\"], text) {\n        Ok(()) => return Ok(()),\n        Err(err) => last_error = Some(err),\n    }\n    match copy_with_command(\"xsel\", &[\"--clipboard\", \"--input\"], text) {\n        Ok(()) => return Ok(()),\n        Err(err) => last_error = Some(err),\n    }\n\n    Err(last_error.unwrap_or_else(|| {\n        \"No supported clipboard tool found. Please install wl-copy, xclip, or xsel.\".to_string()\n    }))\n}\n\n#[tauri::command]\nasync fn open_with(path: String) -> AppResult<()> {\n    tauri::async_runtime::spawn_blocking(move || reveal_in_finder_impl(vec![path]))\n        .await\n        .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nasync fn reveal_in_finder(paths: Vec<String>) -> AppResult<()> {\n    tauri::async_runtime::spawn_blocking(move || reveal_in_finder_impl(paths))\n        .await\n        .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nfn copy_paths(paths: Vec<String>) -> AppResult<()> {\n    copy_text_to_clipboard(&paths.join(\"\\n\"))\n}\n\n#[cfg(target_os = \"macos\")]\nfn copy_files_to_clipboard(paths: &[String]) -> AppResult<()> {\n    if paths.is_empty() {\n        return Ok(());\n    }\n    let file_exprs: Vec<String> = paths\n        .iter()\n        .map(|p| {\n            let escaped = p.replace('\\\\', \"\\\\\\\\\").replace('\"', \"\\\\\\\"\");\n            format!(\"POSIX file \\\"{}\\\"\", escaped)\n        })\n        .collect();\n    let script = if file_exprs.len() == 1 {\n        format!(\"set the clipboard to {}\", file_exprs[0])\n    } else {\n        format!(\"set the clipboard to {{{}}}\", file_exprs.join(\", \"))\n    };\n    let status = Command::new(\"osascript\")\n        .arg(\"-e\")\n        .arg(&script)\n        .status()\n        .map_err(|e| e.to_string())?;\n    if !status.success() {\n        return Err(\"Failed to copy files to clipboard\".to_string());\n    }\n    Ok(())\n}\n\n#[cfg(target_os = \"macos\")]\n#[tauri::command]\nfn copy_files(paths: Vec<String>) -> AppResult<()> {\n    copy_files_to_clipboard(&paths)\n}\n\n#[cfg(not(target_os = \"macos\"))]\n#[tauri::command]\nfn copy_files(_paths: Vec<String>) -> AppResult<()> {\n    Err(\"copy_files is only supported on macOS\".to_string())\n}\n\n#[tauri::command]\nasync fn move_to_trash(\n    paths: Vec<String>,\n    app: AppHandle,\n    state: State<'_, AppState>,\n) -> AppResult<()> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        let mut deleted_targets = Vec::new();\n\n        for path in &paths {\n            trash::delete(path).map_err(|e| e.to_string())?;\n            remember_op(&state, \"trash\", Some(path.clone()), None);\n            deleted_targets.push(path.clone());\n        }\n\n        let mut conn = db_connection(&state.db_path)?;\n        let _ = delete_paths(&mut conn, &deleted_targets)?;\n        invalidate_search_caches(&state);\n\n        refresh_and_emit_status_counts(&app, &state)?;\n        Ok(())\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nasync fn rename(\n    path: String,\n    new_name: String,\n    app: AppHandle,\n    state: State<'_, AppState>,\n) -> AppResult<EntryDto> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        let validated_name = validate_new_name(&new_name)?;\n        let old_path = PathBuf::from(&path);\n\n        if !old_path.exists() {\n            return Err(\"Source file does not exist.\".to_string());\n        }\n\n        let parent = old_path\n            .parent()\n            .ok_or_else(|| \"Parent directory not found.\".to_string())?;\n\n        let new_path = parent.join(&validated_name);\n        if new_path == old_path {\n            let meta = fs::symlink_metadata(&old_path).ok();\n            return Ok(EntryDto {\n                path: path.clone(),\n                name: old_path\n                    .file_name()\n                    .map(|v| v.to_string_lossy().to_string())\n                    .unwrap_or_else(|| validated_name.clone()),\n                dir: parent.to_string_lossy().to_string(),\n                is_dir: old_path.is_dir(),\n                ext: extension_for(&old_path, old_path.is_dir()),\n                size: meta\n                    .as_ref()\n                    .filter(|m| m.is_file())\n                    .map(|m| m.len() as i64),\n                mtime: meta\n                    .and_then(|m| m.modified().ok())\n                    .and_then(|m| m.duration_since(UNIX_EPOCH).ok())\n                    .map(|d| d.as_secs() as i64),\n            });\n        }\n\n        if new_path.exists() {\n            return Err(\"A file/folder with the same name already exists.\".to_string());\n        }\n\n        let original_is_dir = old_path.is_dir();\n        fs::rename(&old_path, &new_path).map_err(|e| e.to_string())?;\n\n        let mut conn = db_connection(&state.db_path)?;\n        let _ = delete_paths(&mut conn, &[path.clone()])?;\n\n        if original_is_dir {\n            let rows =\n                collect_rows_recursive(&new_path, &state.path_ignores, &state.path_ignore_patterns);\n            for chunk in rows.chunks(BATCH_SIZE) {\n                let _ = upsert_rows(&mut conn, chunk)?;\n            }\n        } else {\n            let row = index_row_from_path(&new_path)\n                .ok_or_else(|| \"Cannot read renamed file info.\".to_string())?;\n            let _ = upsert_rows(&mut conn, &[row])?;\n        }\n\n        invalidate_search_caches(&state);\n\n        remember_op(\n            &state,\n            \"rename\",\n            Some(old_path.to_string_lossy().to_string()),\n            Some(new_path.to_string_lossy().to_string()),\n        );\n\n        refresh_and_emit_status_counts(&app, &state)?;\n\n        let new_meta = fs::symlink_metadata(&new_path).ok();\n        Ok(EntryDto {\n            path: new_path.to_string_lossy().to_string(),\n            name: validated_name,\n            dir: parent.to_string_lossy().to_string(),\n            is_dir: original_is_dir,\n            ext: extension_for(&new_path, original_is_dir),\n            size: new_meta\n                .as_ref()\n                .filter(|m| m.is_file())\n                .map(|m| m.len() as i64),\n            mtime: new_meta\n                .and_then(|m| m.modified().ok())\n                .and_then(|m| m.duration_since(UNIX_EPOCH).ok())\n                .map(|d| d.as_secs() as i64),\n        })\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nasync fn fd_search(\n    query: String,\n    limit: Option<u32>,\n    offset: Option<u32>,\n    sort_by: Option<String>,\n    sort_dir: Option<String>,\n    state: State<'_, AppState>,\n) -> AppResult<FdSearchResultDto> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        let query = query.trim().to_string();\n        let limit = limit.unwrap_or(500).clamp(1, 5000) as usize;\n        let offset = offset.unwrap_or(0) as usize;\n        let sort_by = sort_by.unwrap_or_else(|| \"name\".to_string());\n        let sort_dir = sort_dir.unwrap_or_else(|| \"asc\".to_string());\n        let (runtime_ignored_roots, runtime_ignored_patterns) =\n            cached_effective_ignore_rules(&state);\n        let ignore_fingerprint =\n            ignore_rules_fingerprint(&runtime_ignored_roots, &runtime_ignored_patterns);\n\n        if query.is_empty() {\n            return Ok(FdSearchResultDto {\n                entries: Vec::new(),\n                total: 0,\n                timed_out: false,\n            });\n        }\n\n        {\n            let cache = state.fd_search_cache.lock();\n            if let Some(cached) = cache.as_ref() {\n                let cache_hit = cached.query == query\n                    && cached.sort_by == sort_by\n                    && cached.sort_dir == sort_dir\n                    && cached.ignore_fingerprint == ignore_fingerprint;\n                if cache_hit {\n                    let total = cached.entries.len() as u64;\n                    let end = (offset + limit).min(cached.entries.len());\n                    let page = if offset < cached.entries.len() {\n                        cached.entries[offset..end].to_vec()\n                    } else {\n                        Vec::new()\n                    };\n                    return Ok(FdSearchResultDto {\n                        entries: page,\n                        total,\n                        timed_out: false,\n                    });\n                }\n            }\n        }\n\n        let result = fd_search::run_fd_search(\n            &state.scan_root,\n            &runtime_ignored_roots,\n            &runtime_ignored_patterns,\n            &query,\n            &sort_by,\n            &sort_dir,\n        );\n        let total = result.entries.len() as u64;\n        let end = (offset + limit).min(result.entries.len());\n        let page = if offset < result.entries.len() {\n            result.entries[offset..end].to_vec()\n        } else {\n            Vec::new()\n        };\n\n        {\n            let mut cache = state.fd_search_cache.lock();\n            *cache = Some(FdSearchCache {\n                query: query.clone(),\n                sort_by: sort_by.clone(),\n                sort_dir: sort_dir.clone(),\n                ignore_fingerprint,\n                entries: result.entries,\n            });\n        }\n\n        Ok(FdSearchResultDto {\n            entries: page,\n            total,\n            timed_out: result.timed_out,\n        })\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nfn frontend_log(msg: String) {\n    eprintln!(\"{msg}\");\n}\n\n#[tauri::command]\nfn mark_frontend_ready(state: State<'_, AppState>) {\n    state.frontend_ready.store(true, AtomicOrdering::Release);\n    if cfg!(debug_assertions) {\n        eprintln!(\"[startup] frontend_ready=true\");\n    }\n}\n\n#[tauri::command]\nfn get_platform() -> String {\n    if cfg!(target_os = \"windows\") {\n        \"windows\".to_string()\n    } else if cfg!(target_os = \"macos\") {\n        \"macos\".to_string()\n    } else {\n        \"linux\".to_string()\n    }\n}\n\n#[cfg(target_os = \"windows\")]\n#[tauri::command]\nasync fn show_context_menu(\n    paths: Vec<String>,\n    x: f64,\n    y: f64,\n    _single_selection: bool,\n    app: AppHandle,\n) -> AppResult<()> {\n    let window = app\n        .get_webview_window(\"main\")\n        .ok_or_else(|| \"Main window not found\".to_string())?;\n\n    let scale = window.scale_factor().map_err(|e| e.to_string())?;\n    let win_pos = window.inner_position().map_err(|e| e.to_string())?;\n    let screen_x = win_pos.x + (x * scale) as i32;\n    let screen_y = win_pos.y + (y * scale) as i32;\n\n    let hwnd_raw = window.hwnd().map_err(|e| e.to_string())?.0 as isize;\n\n    // TrackPopupMenu must run on the thread that owns the HWND (main UI thread).\n    // Use a channel to relay the result back to the async context.\n    let (tx, rx) = std::sync::mpsc::sync_channel::<Result<(), String>>(1);\n\n    app.run_on_main_thread(move || {\n        let result = win::context_menu::show(hwnd_raw, &paths, screen_x, screen_y);\n        let _ = tx.send(result);\n    })\n    .map_err(|e| e.to_string())?;\n\n    tauri::async_runtime::spawn_blocking(move || {\n        rx.recv().map_err(|e| format!(\"context menu channel: {e}\"))?\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[cfg(target_os = \"macos\")]\n#[tauri::command]\nasync fn show_context_menu(\n    _paths: Vec<String>,\n    x: f64,\n    y: f64,\n    single_selection: bool,\n    app: AppHandle,\n) -> AppResult<()> {\n    use tauri::menu::{IsMenuItem, Menu, MenuItem, PredefinedMenuItem};\n\n    let window = app\n        .get_webview_window(\"main\")\n        .ok_or_else(|| \"Main window not found\".to_string())?;\n\n    let (tx, rx) = std::sync::mpsc::sync_channel::<Result<(), String>>(1);\n\n    let app_clone = app.clone();\n    app.run_on_main_thread(move || {\n        let app = app_clone;\n        let result = (|| -> Result<(), tauri::Error> {\n            let open = MenuItem::with_id(&app, \"ctx_open\", \"Open\", true, None::<&str>)?;\n            let quick_look =\n                MenuItem::with_id(&app, \"ctx_quick_look\", \"Quick Look\", true, None::<&str>)?;\n            let open_with =\n                MenuItem::with_id(&app, \"ctx_open_with\", \"Open With...\", true, None::<&str>)?;\n            let sep1 = PredefinedMenuItem::separator(&app)?;\n            let reveal = MenuItem::with_id(\n                &app,\n                \"ctx_reveal\",\n                \"Reveal in Finder\",\n                true,\n                None::<&str>,\n            )?;\n            let sep2 = PredefinedMenuItem::separator(&app)?;\n            let copy_files =\n                MenuItem::with_id(&app, \"ctx_copy_files\", \"Copy\", true, None::<&str>)?;\n            let copy_path =\n                MenuItem::with_id(&app, \"ctx_copy_path\", \"Copy Path\", true, None::<&str>)?;\n            let sep3 = PredefinedMenuItem::separator(&app)?;\n            let trash = MenuItem::with_id(\n                &app,\n                \"ctx_trash\",\n                \"Move to Trash\",\n                true,\n                None::<&str>,\n            )?;\n            let rename =\n                MenuItem::with_id(&app, \"ctx_rename\", \"Rename\", true, None::<&str>)?;\n\n            let mut items: Vec<&dyn IsMenuItem<tauri::Wry>> = vec![\n                &open, &quick_look, &open_with, &sep1, &reveal, &sep2, &copy_files, &copy_path, &sep3, &trash,\n            ];\n            if single_selection {\n                items.push(&rename);\n            }\n\n            let menu = Menu::with_items(&app, &items)?;\n            // Position is window-relative logical pixels, matching clientX/clientY.\n            window.popup_menu_at(&menu, tauri::LogicalPosition::new(x, y))?;\n            Ok(())\n        })();\n        let _ = tx.send(result.map_err(|e| e.to_string()));\n    })\n    .map_err(|e| e.to_string())?;\n\n    tauri::async_runtime::spawn_blocking(move || {\n        rx.recv().map_err(|e| format!(\"context menu channel: {e}\"))?\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[cfg(not(any(target_os = \"windows\", target_os = \"macos\")))]\n#[tauri::command]\nasync fn show_context_menu(\n    _paths: Vec<String>,\n    _x: f64,\n    _y: f64,\n    _single_selection: bool,\n    _app: AppHandle,\n) -> AppResult<()> {\n    Err(\"Native context menu is only supported on Windows and macOS\".to_string())\n}\n\n#[tauri::command]\nasync fn set_native_theme(theme: String, app: AppHandle) -> AppResult<()> {\n    let window = app\n        .get_webview_window(\"main\")\n        .ok_or_else(|| \"Main window not found\".to_string())?;\n    let t = if theme == \"light\" {\n        tauri::Theme::Light\n    } else {\n        tauri::Theme::Dark\n    };\n    window.set_theme(Some(t)).map_err(|e| e.to_string())\n}\n\n#[tauri::command]\nasync fn get_file_icon(\n    path: Option<String>,\n    ext: String,\n    state: State<'_, AppState>,\n) -> AppResult<Vec<u8>> {\n    let state = state.inner().clone();\n    Ok(tauri::async_runtime::spawn_blocking(move || {\n        let ext_lower = if ext.trim().is_empty() {\n            \"__default__\".to_string()\n        } else {\n            ext.to_lowercase()\n        };\n\n        #[cfg(target_os = \"windows\")]\n        let cache_key = {\n            if is_per_file_icon_ext(&ext_lower) {\n                path.as_deref().unwrap_or(&ext_lower).to_string()\n            } else {\n                ext_lower.clone()\n            }\n        };\n        #[cfg(not(target_os = \"windows\"))]\n        let cache_key = ext_lower.clone();\n\n        if let Some(cached) = state.icon_cache.lock().get(&cache_key).cloned() {\n            return cached;\n        }\n\n        #[cfg(target_os = \"windows\")]\n        let icon = {\n            let from_path = path\n                .as_deref()\n                .filter(|p| !p.is_empty())\n                .and_then(win::icon::load_icon_png);\n            from_path.or_else(|| load_system_icon_png(&ext_lower))\n        };\n        #[cfg(not(target_os = \"windows\"))]\n        let icon = {\n            let _ = path;\n            load_system_icon_png(&ext_lower)\n        };\n\n        let icon = icon.unwrap_or_default();\n        state.icon_cache.lock().insert(cache_key, icon.clone());\n        icon\n    })\n    .await\n    .unwrap_or_default())\n}\n\nfn default_bench_cases() -> Vec<BenchCase> {\n    vec![\n        BenchCase {\n            id: \"TC01_exact_name\",\n            query: \"report_00042\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC02_prefix_name\",\n            query: \"report_00\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 10,\n        },\n        BenchCase {\n            id: \"TC03_contains_name\",\n            query: \"invoice\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC04_ext_md\",\n            query: \"*.md\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC05_path_glob_png\",\n            query: \"Desktop/ *.png\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC06_path_term\",\n            query: \"Projects/rust\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC07_path_ext_rs\",\n            query: \"Projects/ *.rs\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC08_no_match\",\n            query: \"zzzz_not_exists_12345\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 0,\n        },\n    ]\n}\n\nfn bench_iterations() -> u32 {\n    std::env::var(\"EVERYTHING_BENCH_ITERATIONS\")\n        .ok()\n        .and_then(|v| v.parse::<u32>().ok())\n        .map(|v| v.clamp(1, 50))\n        .unwrap_or(5)\n}\n\nfn bench_wait_timeout() -> Duration {\n    let seconds = std::env::var(\"EVERYTHING_BENCH_WAIT_SEC\")\n        .ok()\n        .and_then(|v| v.parse::<u64>().ok())\n        .map(|v| v.clamp(10, 7200))\n        .unwrap_or(1800);\n    Duration::from_secs(seconds)\n}\n\nfn bench_run_label() -> String {\n    std::env::var(\"EVERYTHING_BENCH_RUN_LABEL\")\n        .ok()\n        .filter(|v| !v.trim().is_empty())\n        .unwrap_or_else(|| format!(\"run-{}\", now_epoch()))\n}\n\nfn bench_output_path(db_path: &Path, run_label: &str) -> PathBuf {\n    std::env::var(\"EVERYTHING_BENCH_OUTPUT\")\n        .ok()\n        .filter(|v| !v.trim().is_empty())\n        .map(PathBuf::from)\n        .unwrap_or_else(|| db_path.with_file_name(format!(\"bench-report-{run_label}.json\")))\n}\n\nfn write_bench_report(path: &Path, report: &BenchReport) -> AppResult<()> {\n    let json = serde_json::to_string_pretty(report).map_err(|e| e.to_string())?;\n    fs::write(path, json).map_err(|e| e.to_string())\n}\n\nfn start_bench_runner(app_handle: AppHandle, state: AppState) {\n    std::thread::spawn(move || {\n        let run_label = bench_run_label();\n        let output_path = bench_output_path(&state.db_path, &run_label);\n        let iterations = bench_iterations();\n        let wait_timeout = bench_wait_timeout();\n        let started_at = now_epoch();\n\n        perf_log(format!(\n            \"bench_start run_label={} output={} iterations={} wait_timeout_s={}\",\n            run_label,\n            output_path.to_string_lossy(),\n            iterations,\n            wait_timeout.as_secs(),\n        ));\n\n        let wait_started = Instant::now();\n        let mut saw_indexing = false;\n        let index_snapshot: IndexStatus;\n        loop {\n            let snapshot = state.status.lock().clone();\n            let active = state.indexing_active.load(AtomicOrdering::Acquire)\n                || matches!(snapshot.state, IndexState::Indexing);\n\n            if active {\n                saw_indexing = true;\n            }\n\n            if state.db_ready.load(AtomicOrdering::Acquire) && saw_indexing && !active {\n                index_snapshot = snapshot;\n                break;\n            }\n\n            if wait_started.elapsed() >= wait_timeout {\n                let report = BenchReport {\n                    run_label: run_label.clone(),\n                    started_at,\n                    completed_at: now_epoch(),\n                    home_dir: state.home_dir.to_string_lossy().to_string(),\n                    db_path: state.db_path.to_string_lossy().to_string(),\n                    index_wait_ms: wait_started.elapsed().as_millis(),\n                    index_scanned: snapshot.scanned,\n                    index_indexed: snapshot.indexed,\n                    index_entries_count: snapshot.entries_count,\n                    index_permission_errors: snapshot.permission_errors,\n                    index_message: Some(\"Timed out waiting for index ready\".to_string()),\n                    search_iterations: iterations,\n                    search_results: Vec::new(),\n                };\n                let _ = write_bench_report(&output_path, &report);\n                perf_log(format!(\n                    \"bench_timeout run_label={} waited_ms={}\",\n                    run_label,\n                    wait_started.elapsed().as_millis()\n                ));\n                if env_truthy(\"EVERYTHING_BENCH_EXIT\") {\n                    app_handle.exit(2);\n                }\n                return;\n            }\n\n            std::thread::sleep(Duration::from_millis(200));\n        }\n\n        let index_wait_ms = wait_started.elapsed().as_millis();\n        perf_log(format!(\n            \"bench_index_ready run_label={} waited_ms={} scanned={} indexed={} entries={} permission_errors={}\",\n            run_label,\n            index_wait_ms,\n            index_snapshot.scanned,\n            index_snapshot.indexed,\n            index_snapshot.entries_count,\n            index_snapshot.permission_errors,\n        ));\n\n        let mut search_results = Vec::new();\n        for case in default_bench_cases() {\n            let mut elapsed_sum = 0.0f64;\n            let mut success_count = 0u32;\n            let mut result_count = 0usize;\n            let mut mode = String::new();\n            let mut top_results = Vec::new();\n            let mut case_error = None;\n\n            for iter in 1..=iterations {\n                let started = Instant::now();\n                match execute_search(\n                    &state,\n                    case.query.to_string(),\n                    Some(case.limit),\n                    Some(case.offset),\n                    Some(case.sort_by.to_string()),\n                    Some(case.sort_dir.to_string()),\n                ) {\n                    Ok(execution) => {\n                        let elapsed_ms = started.elapsed().as_secs_f64() * 1000.0;\n                        elapsed_sum += elapsed_ms;\n                        success_count += 1;\n                        result_count = execution.results.len();\n                        mode = execution.mode_label;\n                        top_results = execution\n                            .results\n                            .iter()\n                            .take(5)\n                            .map(|entry| entry.path.clone())\n                            .collect();\n\n                        perf_log(format!(\n                            \"bench_query run_label={} case={} iter={}/{} query={:?} mode={} results={} elapsed_ms={:.3}\",\n                            run_label,\n                            case.id,\n                            iter,\n                            iterations,\n                            case.query,\n                            mode,\n                            result_count,\n                            elapsed_ms\n                        ));\n                    }\n                    Err(err) => {\n                        case_error = Some(err);\n                        break;\n                    }\n                }\n            }\n\n            let elapsed_ms = if success_count > 0 {\n                elapsed_sum / success_count as f64\n            } else {\n                0.0\n            };\n            let passed = case_error.is_none() && result_count >= case.expected_min_results;\n\n            search_results.push(BenchCaseResult {\n                id: case.id.to_string(),\n                query: case.query.to_string(),\n                mode,\n                sort_by: case.sort_by.to_string(),\n                sort_dir: case.sort_dir.to_string(),\n                limit: case.limit,\n                offset: case.offset,\n                elapsed_ms,\n                result_count,\n                expected_min_results: case.expected_min_results,\n                passed,\n                top_results,\n                error: case_error,\n            });\n        }\n\n        let report = BenchReport {\n            run_label: run_label.clone(),\n            started_at,\n            completed_at: now_epoch(),\n            home_dir: state.home_dir.to_string_lossy().to_string(),\n            db_path: state.db_path.to_string_lossy().to_string(),\n            index_wait_ms,\n            index_scanned: index_snapshot.scanned,\n            index_indexed: index_snapshot.indexed,\n            index_entries_count: index_snapshot.entries_count,\n            index_permission_errors: index_snapshot.permission_errors,\n            index_message: index_snapshot.message.clone(),\n            search_iterations: iterations,\n            search_results,\n        };\n\n        match write_bench_report(&output_path, &report) {\n            Ok(()) => perf_log(format!(\n                \"bench_report_written run_label={} path={}\",\n                run_label,\n                output_path.to_string_lossy()\n            )),\n            Err(err) => perf_log(format!(\n                \"bench_report_write_error run_label={} path={} err={}\",\n                run_label,\n                output_path.to_string_lossy(),\n                err\n            )),\n        }\n\n        if env_truthy(\"EVERYTHING_BENCH_EXIT\") {\n            app_handle.exit(0);\n        }\n    });\n}\n\n#[cfg(target_os = \"macos\")]\nfn register_global_shortcut(app: &AppHandle) -> AppResult<()> {\n    let shortcut = Shortcut::new(Some(Modifiers::SUPER | Modifiers::SHIFT), Code::Space);\n\n    app.global_shortcut()\n        .on_shortcut(shortcut, move |app_handle, _, _| {\n            if let Some(window) = app_handle.get_webview_window(\"main\") {\n                let _ = window.show();\n                let _ = window.unminimize();\n                let _ = window.set_focus();\n            }\n            let _ = app_handle.emit(\"focus_search\", ());\n        })\n        .map_err(|e| format!(\"Failed to register global shortcut: {e}\"))\n}\n\n#[cfg(not(target_os = \"macos\"))]\nfn register_global_shortcut(_app: &AppHandle) -> AppResult<()> {\n    Ok(())\n}\n\nfn setup_app(app: &mut tauri::App) -> AppResult<()> {\n    let setup_started = std::time::Instant::now();\n    eprintln!(\"[startup] setup_app() entered\");\n    let bench_mode = bench_mode_enabled();\n\n    #[cfg(target_os = \"macos\")]\n    if let Some(window) = app.get_webview_window(\"main\") {\n        use tauri::window::Color;\n        let is_dark = window\n            .theme()\n            .map(|t| t == tauri::Theme::Dark)\n            .unwrap_or(false);\n        let bg = if is_dark {\n            Color(0x1f, 0x1f, 0x1f, 0xff)\n        } else {\n            Color(0xf4, 0xf5, 0xf7, 0xff)\n        };\n        let _ = window.set_background_color(Some(bg));\n        let _ = window.show();\n    }\n\n    #[cfg(target_os = \"windows\")]\n    if let Some(window) = app.get_webview_window(\"main\") {\n        eprintln!(\"[startup +{}ms] windows setup: before window.show()\", startup_elapsed_ms());\n        use tauri::window::Color;\n        let is_dark = window.theme().map(|t| t == tauri::Theme::Dark).unwrap_or(false);\n        let bg = if is_dark {\n            Color(0x1f, 0x1f, 0x1f, 0xff)\n        } else {\n            Color(0xf4, 0xf5, 0xf7, 0xff)\n        };\n        let _ = window.set_background_color(Some(bg));\n        if let Err(e) = window.set_decorations(false) {\n            eprintln!(\n                \"[startup +{}ms] windows setup: set_decorations(false) failed: {}\",\n                startup_elapsed_ms(),\n                e\n            );\n        }\n        let _ = window.show();\n        eprintln!(\"[startup +{}ms] windows setup: window.show() returned\", startup_elapsed_ms());\n    }\n\n    let app_data_dir = app\n        .path()\n        .app_data_dir()\n        .map_err(|e| format!(\"Failed to get app data dir: {e}\"))?;\n    fs::create_dir_all(&app_data_dir).map_err(|e| e.to_string())?;\n\n    let db_path = app_data_dir.join(\"index.db\");\n    let home_dir = PathBuf::from(\n        std::env::var(\"HOME\")\n            .or_else(|_| std::env::var(\"USERPROFILE\"))\n            .unwrap_or_else(|_| if cfg!(windows) { \"C:\\\\\".to_string() } else { \"/\".to_string() }),\n    );\n    let scan_root = if cfg!(windows) {\n        PathBuf::from(\"C:\\\\\")\n    } else {\n        home_dir.clone()\n    };\n    let cwd = std::env::current_dir().unwrap_or_else(|_| home_dir.clone());\n    eprintln!(\"[startup] +{}ms loading pathignore rules...\", setup_started.elapsed().as_millis());\n    let (mut path_ignores, path_ignore_patterns) = load_pathignore_rules(&home_dir, &cwd);\n    if !path_ignores.iter().any(|r| r == &app_data_dir) {\n        path_ignores.push(app_data_dir.clone());\n    }\n    for root in load_gitignore_roots(&home_dir, &cwd) {\n        if !path_ignores.iter().any(|r| r == &root) {\n            path_ignores.push(root);\n        }\n    }\n    eprintln!(\"[startup] +{}ms pathignore done\", setup_started.elapsed().as_millis());\n\n    let gitignore = Arc::new(gitignore_filter::LazyGitignoreFilter::new(home_dir.clone()));\n\n    let state = AppState {\n        db_path,\n        home_dir,\n        scan_root,\n        cwd,\n        path_ignores: Arc::new(path_ignores),\n        path_ignore_patterns: Arc::new(path_ignore_patterns),\n        db_ready: Arc::new(AtomicBool::new(false)),\n        indexing_active: Arc::new(AtomicBool::new(false)),\n        status: Arc::new(Mutex::new(IndexStatus::default())),\n        recent_ops: Arc::new(Mutex::new(Vec::new())),\n        icon_cache: Arc::new(Mutex::new(HashMap::new())),\n        fd_search_cache: Arc::new(Mutex::new(None)),\n        negative_name_cache: Arc::new(Mutex::new(HashMap::new())),\n        ignore_cache: Arc::new(Mutex::new(None)),\n        gitignore,\n        mem_index: Arc::new(RwLock::new(None)),\n        watcher_stop: Arc::new(AtomicBool::new(false)),\n        watcher_active: Arc::new(AtomicBool::new(false)),\n        frontend_ready: Arc::new(AtomicBool::new(false)),\n    };\n\n    eprintln!(\"[startup] +{}ms AppState created\", setup_started.elapsed().as_millis());\n    app.manage(state.clone());\n    if !bench_mode {\n        register_global_shortcut(&app.handle())?;\n    }\n    // Context menu item IDs use the \"ctx_\" prefix by convention.\n    // All matching IDs are forwarded as \"context_menu_action\" events to the frontend.\n    #[cfg(target_os = \"macos\")]\n    {\n        app.handle().on_menu_event(|app, event| {\n            let action = match event.id().as_ref() {\n                \"ctx_open\" => \"open\",\n                \"ctx_quick_look\" => \"quick_look\",\n                \"ctx_open_with\" => \"open_with\",\n                \"ctx_reveal\" => \"reveal\",\n                \"ctx_copy_files\" => \"copy_files\",\n                \"ctx_copy_path\" => \"copy_path\",\n                \"ctx_trash\" => \"trash\",\n                \"ctx_rename\" => \"rename\",\n                _ => return,\n            };\n            let _ = app.emit(\"context_menu_action\", action);\n        });\n    }\n    eprintln!(\"[startup] +{}ms global shortcut registered\", setup_started.elapsed().as_millis());\n    if bench_mode {\n        if let Some(window) = app.get_webview_window(\"main\") {\n            let _ = window.hide();\n        }\n    }\n\n    eprintln!(\"[startup] +{}ms setup_app() done, spawning init thread\", setup_started.elapsed().as_millis());\n\n    let app_handle = app.handle().clone();\n    std::thread::spawn(move || {\n        let thread_started = std::time::Instant::now();\n        eprintln!(\"[startup/thread] init thread started\");\n\n        eprintln!(\"[startup/thread] +{}ms calling init_db...\", thread_started.elapsed().as_millis());\n        if let Err(err) = init_db(&state.db_path) {\n            set_state(&state, IndexState::Error, Some(err.clone()));\n            emit_index_state(&app_handle, \"Error\", Some(err));\n            return;\n        }\n        eprintln!(\"[startup/thread] +{}ms init_db done\", thread_started.elapsed().as_millis());\n\n        state.db_ready.store(true, AtomicOrdering::Release);\n        eprintln!(\"[startup/thread] +{}ms db_ready=true -- launching indexing immediately\", thread_started.elapsed().as_millis());\n\n        // Deferred housekeeping -- purge + status counts run in background\n        {\n            let hk_app = app_handle.clone();\n            let hk_state = state.clone();\n            std::thread::spawn(move || {\n                // Brief pause so indexing thread can start first\n                std::thread::sleep(std::time::Duration::from_millis(500));\n                let hk_started = std::time::Instant::now();\n                let _ = refresh_and_emit_status_counts(&hk_app, &hk_state);\n                eprintln!(\"[startup/housekeeping] refresh_and_emit_status_counts done in {}ms\", hk_started.elapsed().as_millis());\n                // Wait for frontend readiness so initial paint and first input are not contended by purge I/O.\n                const FRONTEND_READY_TIMEOUT: Duration = Duration::from_secs(180);\n                const POST_READY_GRACE: Duration = Duration::from_secs(2);\n                let wait_started = std::time::Instant::now();\n                while !hk_state.frontend_ready.load(AtomicOrdering::Acquire)\n                    && wait_started.elapsed() < FRONTEND_READY_TIMEOUT\n                {\n                    std::thread::sleep(Duration::from_millis(50));\n                }\n                if hk_state.frontend_ready.load(AtomicOrdering::Acquire) {\n                    eprintln!(\n                        \"[startup/housekeeping] frontend_ready observed after {}ms; purging in {}ms\",\n                        wait_started.elapsed().as_millis(),\n                        POST_READY_GRACE.as_millis()\n                    );\n                } else {\n                    eprintln!(\n                        \"[startup/housekeeping] frontend_ready wait timed out after {}ms; proceeding with purge\",\n                        FRONTEND_READY_TIMEOUT.as_millis()\n                    );\n                }\n                std::thread::sleep(POST_READY_GRACE);\n                let purge_started = std::time::Instant::now();\n                if let Err(err) = purge_ignored_entries(&hk_state.db_path, &hk_state.path_ignores) {\n                    eprintln!(\"[startup/housekeeping] purge_ignored_entries failed: {err}\");\n                } else {\n                    eprintln!(\n                        \"[startup/housekeeping] purge_ignored_entries done in {}ms\",\n                        purge_started.elapsed().as_millis()\n                    );\n                }\n                eprintln!(\"[startup/housekeeping] all done in {}ms\", hk_started.elapsed().as_millis());\n            });\n        }\n\n        #[cfg(target_os = \"macos\")]\n        {\n            if bench_mode {\n                let _ = start_full_index_worker(app_handle.clone(), state.clone());\n            } else {\n                let (stored_event_id, index_complete) = db_connection(&state.db_path)\n                    .ok()\n                    .map(|c| {\n                        let eid = get_meta(&c, \"last_event_id\")\n                            .and_then(|v| v.parse::<u64>().ok());\n                        let complete = get_meta(&c, \"index_complete\")\n                            .map(|v| v == \"1\")\n                            .unwrap_or(false);\n                        (eid, complete)\n                    })\n                    .unwrap_or((None, false));\n\n                if stored_event_id.is_some() && index_complete {\n                    // Conditional startup: try watcher replay first, skip full scan if OK\n                    start_fsevent_watcher_worker(\n                        app_handle.clone(),\n                        state.clone(),\n                        stored_event_id,\n                        true,\n                    );\n                } else {\n                    if !index_complete {\n                        eprintln!(\"[mac] index incomplete; starting full index\");\n                    }\n                    let _ = start_full_index_worker(app_handle.clone(), state.clone());\n                    start_fsevent_watcher_worker(app_handle.clone(), state.clone(), None, false);\n                }\n            }\n        }\n\n        #[cfg(target_os = \"windows\")]\n        {\n            win::start_windows_indexing(app_handle.clone(), state.clone());\n        }\n\n        #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n        {\n            let _ = start_full_index_worker(app_handle.clone(), state.clone());\n        }\n\n        if bench_mode {\n            start_bench_runner(app_handle.clone(), state.clone());\n        }\n\n        #[cfg(not(target_os = \"windows\"))]\n        if !bench_mode {\n            let icon_cache = state.icon_cache.clone();\n            std::thread::spawn(move || {\n                let exts = [\n                    \"txt\", \"pdf\", \"png\", \"jpg\", \"md\", \"json\", \"swift\", \"rs\", \"js\", \"ts\", \"html\",\n                    \"css\", \"py\", \"zip\", \"dmg\", \"app\", \"doc\", \"xls\", \"ppt\", \"mov\",\n                ];\n                for ext in &exts {\n                    let key = ext.to_string();\n                    if icon_cache.lock().contains_key(&key) {\n                        continue;\n                    }\n                    if let Some(icon) = load_system_icon_png(ext) {\n                        icon_cache.lock().insert(key, icon);\n                    }\n                }\n            });\n        }\n    });\n\n    Ok(())\n}\n\n#[cfg_attr(mobile, tauri::mobile_entry_point)]\npub fn run() {\n    let _ = STARTUP_T0.set(Instant::now());\n    eprintln!(\"[startup +{}ms] run() entered\", startup_elapsed_ms());\n    #[cfg(target_os = \"windows\")]\n    if cfg!(debug_assertions) {\n        // Safety: called at program start before any threads are spawned.\n        // Will require `unsafe` block when migrating to Rust edition 2024.\n        std::env::set_var(\n            \"WEBVIEW2_ADDITIONAL_BROWSER_ARGUMENTS\",\n            \"--no-proxy-server --disable-http-cache --disk-cache-size=1 --media-cache-size=1\",\n        );\n        eprintln!(\n            \"[startup +{}ms] set REDACTED --disable-http-cache --disk-cache-size=1 --media-cache-size=1\",\n            startup_elapsed_ms()\n        );\n    }\n    let mut builder = tauri::Builder::default()\n        .plugin(tauri_plugin_decorum::init())\n        .plugin(tauri_plugin_drag::init())\n        .plugin(tauri_plugin_global_shortcut::Builder::new().build());\n\n    if !cfg!(debug_assertions) {\n        builder = builder.plugin(tauri_plugin_window_state::Builder::default().build());\n    } else {\n        eprintln!(\n            \"[startup +{}ms] debug mode: window-state plugin disabled for startup A/B test\",\n            startup_elapsed_ms()\n        );\n    }\n\n    builder\n        .on_page_load(|window, payload| {\n            eprintln!(\n                \"[startup/page +{}ms] on_page_load label={} event={:?} url={}\",\n                startup_elapsed_ms(),\n                window.label(),\n                payload.event(),\n                payload.url()\n            );\n        })\n        .setup(|app| {\n            setup_app(app).map_err(|e| {\n                Box::<dyn std::error::Error>::from(io::Error::new(io::ErrorKind::Other, e))\n            })\n        })\n        .invoke_handler(tauri::generate_handler![\n            get_index_status,\n            get_home_dir,\n            start_full_index,\n            reset_index,\n            search,\n            fd_search,\n            quick_look,\n            open,\n            open_with,\n            reveal_in_finder,\n            copy_paths,\n            copy_files,\n            move_to_trash,\n            rename,\n            get_file_icon,\n            get_platform,\n            show_context_menu,\n            set_native_theme,\n            frontend_log,\n            mark_frontend_ready\n        ])\n        .run(tauri::generate_context!())\n        .expect(\"error while running tauri application\");\n}\n\nfn main() {\n    run();\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::time::{SystemTime, UNIX_EPOCH};\n\n    fn mk_entry(path: &str, name: &str) -> EntryDto {\n        let parent = Path::new(path)\n            .parent()\n            .map(|p| p.to_string_lossy().to_string())\n            .unwrap_or_else(|| \"/\".to_string());\n        EntryDto {\n            path: path.to_string(),\n            name: name.to_string(),\n            dir: parent,\n            is_dir: false,\n            ext: None,\n            size: None,\n            mtime: None,\n        }\n    }\n\n    fn temp_case_dir(case: &str) -> PathBuf {\n        let stamp = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .map(|d| d.as_nanos())\n            .unwrap_or(0);\n        let base = if cfg!(target_os = \"windows\") {\n            std::env::current_dir()\n                .map(|dir| dir.join(\"tmp-test-dirs\"))\n                .unwrap_or_else(|_| std::env::temp_dir())\n        } else {\n            std::env::temp_dir()\n        };\n        base.join(format!(\n            \"everything_{case}_{}_{}\",\n            std::process::id(),\n            stamp\n        ))\n    }\n\n    fn test_state_for(db_path: PathBuf, home_dir: PathBuf, cwd: PathBuf) -> AppState {\n        AppState {\n            db_path,\n            home_dir: home_dir.clone(),\n            scan_root: home_dir.clone(),\n            cwd,\n            path_ignores: Arc::new(Vec::new()),\n            path_ignore_patterns: Arc::new(Vec::new()),\n            db_ready: Arc::new(AtomicBool::new(true)),\n            indexing_active: Arc::new(AtomicBool::new(false)),\n            status: Arc::new(Mutex::new(IndexStatus::default())),\n            recent_ops: Arc::new(Mutex::new(Vec::new())),\n            icon_cache: Arc::new(Mutex::new(HashMap::new())),\n            fd_search_cache: Arc::new(Mutex::new(None)),\n            negative_name_cache: Arc::new(Mutex::new(HashMap::new())),\n            ignore_cache: Arc::new(Mutex::new(None)),\n            gitignore: Arc::new(gitignore_filter::LazyGitignoreFilter::new(home_dir.clone())),\n            mem_index: Arc::new(RwLock::new(None)),\n            watcher_stop: Arc::new(AtomicBool::new(false)),\n            watcher_active: Arc::new(AtomicBool::new(false)),\n            frontend_ready: Arc::new(AtomicBool::new(true)),\n        }\n    }\n\n    #[test]\n    fn should_skip_path_for_ignored_descendant() {\n        let ignored = vec![PathBuf::from(\n            \"/Users/al02402336/Library/Developer/Xcode/DerivedData\",\n        )];\n        let target = Path::new(\n            \"REDACTED\",\n        );\n\n        assert!(should_skip_path(target, &ignored, &[]));\n    }\n\n    #[test]\n    fn filter_ignored_entries_removes_pathignore_matches() {\n        let ignored = vec![PathBuf::from(\n            \"/Users/al02402336/Library/Developer/Xcode/DerivedData\",\n        )];\n        let entries = vec![\n            mk_entry(\n                \"REDACTED\",\n                \"-Users-al02402336-a_desktop\",\n            ),\n            mk_entry(\"/Users/al02402336/a_desktop\", \"a_desktop\"),\n        ];\n\n        let filtered = filter_ignored_entries(entries, &ignored, &[]);\n\n        assert_eq!(filtered.len(), 1);\n        assert_eq!(filtered[0].path, \"/Users/al02402336/a_desktop\");\n    }\n\n    #[test]\n    fn should_skip_path_for_glob_any_segment_target() {\n        let patterns = vec![IgnorePattern::AnySegment(\"target\".to_string())];\n\n        assert!(should_skip_path(\n            Path::new(\"/Users/al02402336/work/rust/target\"),\n            &[],\n            &patterns\n        ));\n        assert!(should_skip_path(\n            Path::new(\"/Users/al02402336/work/rust/target/debug/deps/foo.o\"),\n            &[],\n            &patterns\n        ));\n        assert!(!should_skip_path(\n            Path::new(\"/Users/al02402336/work/rust/targets/debug/deps/foo.o\"),\n            &[],\n            &patterns\n        ));\n    }\n\n    #[test]\n    fn relevance_sort_prefers_shallow_exact_match() {\n        let mut entries = vec![\n            mk_entry(\"/Users/al02402336/work/a_desktop\", \"a_desktop\"),\n            mk_entry(\"/Users/al02402336/a_desktop\", \"a_desktop\"),\n            mk_entry(\n                \"/Users/al02402336/Library/Developer/Xcode/DerivedData/-Users-al02402336-a_desktop\",\n                \"-Users-al02402336-a_desktop\",\n            ),\n        ];\n\n        sort_entries_with_relevance(&mut entries, \"a_desktop\", \"name\", \"asc\");\n\n        assert_eq!(entries[0].path, \"/Users/al02402336/a_desktop\");\n    }\n\n    #[test]\n    fn resolved_dir_range_excludes_sibling_with_same_prefix() {\n        let dir_exact = \"/Users/user/Projects\";\n        let dir_prefix = format!(\"{}/\", dir_exact);\n        let dir_prefix_end = format!(\"{}0\", dir_exact);\n\n        let in_scope = |dir: &str| {\n            dir == dir_exact || (dir >= dir_prefix.as_str() && dir < dir_prefix_end.as_str())\n        };\n\n        assert!(in_scope(\"/Users/user/Projects\"));\n        assert!(in_scope(\"/Users/user/Projects/src\"));\n        assert!(in_scope(\"/Users/user/Projects/src/deeper\"));\n\n        assert!(!in_scope(\"/Users/user/Projects-archived\"));\n        assert!(!in_scope(\"/Users/user/Projects.archived\"));\n        assert!(!in_scope(\"/Users/user/Projects_archived\"));\n        assert!(!in_scope(\"/Users/user/Projectz\"));\n    }\n\n    #[test]\n    fn delete_paths_root_clears_all_entries() {\n        let root = temp_case_dir(\"delete_paths_root\");\n        let dir_a = root.join(\"alpha\");\n        let dir_b = root.join(\"beta\").join(\"nested\");\n        fs::create_dir_all(&dir_a).unwrap();\n        fs::create_dir_all(&dir_b).unwrap();\n\n        let db_path = root.join(\"index.db\");\n        init_db(&db_path).unwrap();\n        let mut conn = db_connection(&db_path).unwrap();\n        let now = now_epoch();\n\n        for (path, name, dir, ext) in [\n            (dir_a.join(\"a.txt\"), \"a.txt\", dir_a.clone(), \"txt\"),\n            (dir_b.join(\"b.rs\"), \"b.rs\", dir_b.clone(), \"rs\"),\n        ] {\n            conn.execute(\n                \"INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n                 VALUES(?1, ?2, ?3, 0, ?4, NULL, NULL, ?5, 1)\",\n                params![\n                    path.to_string_lossy().to_string(),\n                    name,\n                    dir.to_string_lossy().to_string(),\n                    ext,\n                    now\n                ],\n            )\n            .unwrap();\n        }\n\n        let deleted = delete_paths(&mut conn, &[\"/\".to_string()]).unwrap();\n        assert!(deleted >= 2);\n\n        let remaining: i64 = conn\n            .query_row(\"SELECT COUNT(*) FROM entries\", [], |row| row.get(0))\n            .unwrap();\n        assert_eq!(remaining, 0);\n\n        let _ = fs::remove_dir_all(root);\n    }\n\n    #[test]\n    fn execute_search_resolved_path_does_not_include_prefixed_sibling_dirs() {\n        let root = temp_case_dir(\"resolved_path_scope_execute\");\n        let projects_src = root.join(\"Projects\").join(\"src\");\n        let archived_src = root.join(\"Projects-archived\").join(\"src\");\n        fs::create_dir_all(&projects_src).unwrap();\n        fs::create_dir_all(&archived_src).unwrap();\n\n        let db_path = root.join(\"index.db\");\n        init_db(&db_path).unwrap();\n        let conn = db_connection(&db_path).unwrap();\n        let now = now_epoch();\n\n        let project_path = projects_src.join(\"main.rs\");\n        let archived_path = archived_src.join(\"legacy.rs\");\n\n        conn.execute(\n            \"INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n             VALUES(?1, ?2, ?3, 0, ?4, NULL, NULL, ?5, 1)\",\n            params![\n                project_path.to_string_lossy().to_string(),\n                \"main.rs\",\n                projects_src.to_string_lossy().to_string(),\n                \"rs\",\n                now\n            ],\n        )\n        .unwrap();\n\n        conn.execute(\n            \"INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n             VALUES(?1, ?2, ?3, 0, ?4, NULL, NULL, ?5, 1)\",\n            params![\n                archived_path.to_string_lossy().to_string(),\n                \"legacy.rs\",\n                archived_src.to_string_lossy().to_string(),\n                \"rs\",\n                now\n            ],\n        )\n        .unwrap();\n\n        let state = test_state_for(db_path.clone(), root.clone(), root.clone());\n        let result = execute_search(\n            &state,\n            \"Projects/ *.rs\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        assert!(result\n            .results\n            .iter()\n            .any(|entry| entry.path == project_path.to_string_lossy()));\n        assert!(result\n            .results\n            .iter()\n            .all(|entry| !entry.path.contains(\"Projects-archived\")));\n\n        let _ = fs::remove_dir_all(root);\n    }\n\n    #[test]\n    fn find_file_upward_locates_repo_level_pathignore() {\n        let root = temp_case_dir(\"pathignore_upward\");\n        let nested = root.join(\"src-tauri\").join(\"target\");\n        fs::create_dir_all(&nested).unwrap();\n        fs::write(root.join(\".pathignore\"), \"node_modules\\n\").unwrap();\n\n        let found = find_file_upward(&nested, \".pathignore\");\n        assert_eq!(found, Some(root.join(\".pathignore\")));\n\n        let _ = fs::remove_dir_all(root);\n    }\n\n    #[test]\n    fn find_git_root_works_from_nested_directory() {\n        let root = temp_case_dir(\"git_root\");\n        let nested = root.join(\"src-tauri\").join(\"target\");\n        fs::create_dir_all(&nested).unwrap();\n        fs::create_dir_all(root.join(\".git\")).unwrap();\n\n        let found = find_git_root(&nested);\n        assert_eq!(found, Some(root.clone()));\n\n        let _ = fs::remove_dir_all(root);\n    }\n\n    #[test]\n    fn extract_ext_from_like_rejects_multi_dot() {\n        assert_eq!(extract_ext_from_like(\"%.tar.gz\"), None);\n        assert_eq!(extract_ext_from_like(\"%.d.ts\"), None);\n        assert_eq!(extract_ext_from_like(\"%.rs\"), Some(\"rs\".to_string()));\n        assert_eq!(extract_ext_from_like(\"%.png\"), Some(\"png\".to_string()));\n    }\n\n    #[test]\n    fn negative_cache_fallback_removes_matched_key_not_query() {\n        let state = test_state_for(\n            PathBuf::from(\"/tmp/neg_cache_test.db\"),\n            PathBuf::from(\"/tmp\"),\n            PathBuf::from(\"/tmp\"),\n        );\n\n        remember_negative_name_query(&state, \"abc\");\n\n        let hit = negative_name_cache_lookup(&state, \"xabc\");\n        assert!(hit.is_some());\n        assert_eq!(hit.unwrap().query_lower, \"abc\");\n\n        remove_negative_name_query(&state, \"abc\");\n\n        let hit_after = negative_name_cache_lookup(&state, \"xabc\");\n        assert!(hit_after.is_none());\n    }\n\n    #[test]\n    fn dir_listing_deep_nested_path_without_time_budget() {\n        let root = temp_case_dir(\"dir_listing_deep\");\n        // Simulate: ~/Library/Containers/jp.naver.line.mac/Data/Library/Containers/jp.naver.line/log/\n        let deep_dir = root\n            .join(\"Library\")\n            .join(\"Containers\")\n            .join(\"jp.naver.line.mac\")\n            .join(\"Data\")\n            .join(\"Library\")\n            .join(\"Containers\")\n            .join(\"jp.naver.line\")\n            .join(\"log\");\n        let sub_dir = deep_dir.join(\"archive\");\n        fs::create_dir_all(&deep_dir).unwrap();\n        fs::create_dir_all(&sub_dir).unwrap();\n\n        let db_path = root.join(\"index.db\");\n        init_db(&db_path).unwrap();\n        let conn = db_connection(&db_path).unwrap();\n        let now = now_epoch();\n\n        let file1 = deep_dir.join(\"20260211_14.txt\");\n        let file2 = sub_dir.join(\"old.log\");\n        for (path, name, dir, ext) in [\n            (&file1, \"20260211_14.txt\", &deep_dir, \"txt\"),\n            (&file2, \"old.log\", &sub_dir, \"log\"),\n        ] {\n            conn.execute(\n                \"INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n                 VALUES(?1, ?2, ?3, 0, ?4, NULL, NULL, ?5, 1)\",\n                params![\n                    path.to_string_lossy().to_string(),\n                    name,\n                    dir.to_string_lossy().to_string(),\n                    ext,\n                    now\n                ],\n            )\n            .unwrap();\n        }\n\n        let state = test_state_for(db_path, root.clone(), root.clone());\n\n        // Query: \"jp.naver.line/log/\" - dir listing, name_like = \"%\"\n        let result = execute_search(\n            &state,\n            \"jp.naver.line/log/\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        assert_eq!(\n            result.results.len(),\n            2,\n            \"should find both files under log/ and log/archive/\"\n        );\n        let names: Vec<&str> = result.results.iter().map(|e| e.name.as_str()).collect();\n        assert!(names.contains(&\"20260211_14.txt\"));\n        assert!(names.contains(&\"old.log\"));\n\n        // Query with glob: \"jp.naver.line/log/ *\"\n        let result2 = execute_search(\n            &state,\n            \"jp.naver.line/log/ *\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        assert_eq!(\n            result2.results.len(),\n            2,\n            \"glob * should also list all files\"\n        );\n\n        // Query with trailing dot: \"jp.naver.line/log/ *.\" - name_like becomes \"%.\"\n        let result3 = execute_search(\n            &state,\n            \"jp.naver.line/log/ *.\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        // \"*.\" matches files ending with \".\" - none of our test files end with \".\"\n        // so this correctly returns 0 (this is expected, NOT a bug)\n        assert_eq!(\n            result3.results.len(),\n            0,\n            \"*. matches only files ending with dot\"\n        );\n\n        // But plain \"/\" at end should list all\n        let result4 = execute_search(\n            &state,\n            \"jp.naver.line/log/\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        assert_eq!(\n            result4.results.len(),\n            2,\n            \"trailing slash should list all files\"\n        );\n\n        let _ = fs::remove_dir_all(root);\n    }\n\n    #[test]\n    fn path_search_multi_dot_ext_uses_like_not_ext_shortcut() {\n        let root = temp_case_dir(\"multi_dot_ext\");\n        let proj_dir = root.join(\"Projects\");\n        fs::create_dir_all(&proj_dir).unwrap();\n\n        let db_path = root.join(\"index.db\");\n        init_db(&db_path).unwrap();\n        let conn = db_connection(&db_path).unwrap();\n        let now = now_epoch();\n\n        let file_path = proj_dir.join(\"archive.tar.gz\");\n        conn.execute(\n            \"INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n             VALUES(?1, ?2, ?3, 0, ?4, NULL, NULL, ?5, 1)\",\n            params![\n                file_path.to_string_lossy().to_string(),\n                \"archive.tar.gz\",\n                proj_dir.to_string_lossy().to_string(),\n                \"gz\",\n                now\n            ],\n        )\n        .unwrap();\n\n        let state = test_state_for(db_path, root.clone(), root.clone());\n        let result = execute_search(\n            &state,\n            \"Projects/ *.tar.gz\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        assert_eq!(result.results.len(), 1);\n        assert!(result.results[0].name == \"archive.tar.gz\");\n\n        let _ = fs::remove_dir_all(root);\n    }\n}\n","structuredPatch":[{"oldStart":2953,"oldLines":6,"newStart":2953,"newLines":10,"lines":["         }"," ","         let conn = db_connection(&state.db_path)?;","+        // Use synchronous=OFF + large cache to make the bulk DELETE fast","+        let _ = conn.execute_batch(","+            \"PRAGMA synchronous=OFF; PRAGMA cache_size=-131072;\",","+        );","         conn.execute(\"DELETE FROM entries\", [])","             .map_err(|e| e.to_string())?;","         conn.execute(\"DELETE FROM meta\", [])"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"e92b0153-4bcc-449d-9ca2-9b5b29d249e7"}
{"parentUuid":"d83acdc3-5bf1-4b76-97c4-75d65f94830b","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01TLFrCRdw8cavLfUNModDTR","type":"message","role":"assistant","content":[{"type":"text","text":"ì´ì œ fresh index ì‹œ secondary indexë¥¼ ë¨¼ì € dropí•˜ê³  ì‚½ìž… í›„ ìž¬ìƒì„±í•˜ëŠ” ë¡œì§ì„ ì¶”ê°€í•©ë‹ˆë‹¤."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":364,"cache_read_input_tokens":153270,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":364},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNipy2TGdMVbFdSXxp6n","type":"assistant","uuid":"2e908fcf-4a56-4030-99f8-16f79eaad136","timestamp":"2026-02-22T07:35:13.155Z"}
{"parentUuid":"2e908fcf-4a56-4030-99f8-16f79eaad136","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01TLFrCRdw8cavLfUNModDTR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012A7nJAdMSJr2ngUy1nCbSw","name":"Read","input":{"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","offset":2001,"limit":25},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":364,"cache_read_input_tokens":153270,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":364},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNipy2TGdMVbFdSXxp6n","type":"assistant","uuid":"cf5d4e14-897f-41e4-a61d-bde5c1ff6aaa","timestamp":"2026-02-22T07:35:13.744Z"}
{"parentUuid":"cf5d4e14-897f-41e4-a61d-bde5c1ff6aaa","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_012A7nJAdMSJr2ngUy1nCbSw","toolUseID":"toolu_012A7nJAdMSJr2ngUy1nCbSw","timestamp":"2026-02-22T07:35:13.760Z","uuid":"39462d13-e70f-4d6e-9f8d-d0db28285980"}
{"parentUuid":"cf5d4e14-897f-41e4-a61d-bde5c1ff6aaa","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012A7nJAdMSJr2ngUy1nCbSw","type":"tool_result","content":"  2001â†’fn run_incremental_index(app: &AppHandle, state: &AppState) -> AppResult<()> {\n  2002â†’    let started = Instant::now();\n  2003â†’    perf_log(format!(\n  2004â†’        \"index_run_start home={} db={}\",\n  2005â†’        state.home_dir.to_string_lossy(),\n  2006â†’        state.db_path.to_string_lossy(),\n  2007â†’    ));\n  2008â†’\n  2009â†’    let mut conn = db_connection(&state.db_path)?;\n  2010â†’    set_indexing_pragmas(&conn)?;\n  2011â†’\n  2012â†’    let result = run_incremental_index_inner(app, state, &mut conn);\n  2013â†’\n  2014â†’    let _ = conn.execute_batch(\"ANALYZE\");\n  2015â†’    let _ = restore_normal_pragmas(&conn);\n  2016â†’\n  2017â†’    match &result {\n  2018â†’        Ok(_) => {\n  2019â†’            let _ = set_meta(&conn, \"index_complete\", \"1\");\n  2020â†’            let snapshot = state.status.lock().clone();\n  2021â†’            perf_log(format!(\n  2022â†’                \"index_run_done elapsed_ms={} scanned={} indexed={} entries={} permission_errors={} message={:?}\",\n  2023â†’                started.elapsed().as_millis(),\n  2024â†’                snapshot.scanned,\n  2025â†’                snapshot.indexed,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"9bde03dc-3c95-46f0-8908-62db09bde0b0","timestamp":"2026-02-22T07:35:13.759Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src-tauri/src/main.rs","content":"fn run_incremental_index(app: &AppHandle, state: &AppState) -> AppResult<()> {\n    let started = Instant::now();\n    perf_log(format!(\n        \"index_run_start home={} db={}\",\n        state.home_dir.to_string_lossy(),\n        state.db_path.to_string_lossy(),\n    ));\n\n    let mut conn = db_connection(&state.db_path)?;\n    set_indexing_pragmas(&conn)?;\n\n    let result = run_incremental_index_inner(app, state, &mut conn);\n\n    let _ = conn.execute_batch(\"ANALYZE\");\n    let _ = restore_normal_pragmas(&conn);\n\n    match &result {\n        Ok(_) => {\n            let _ = set_meta(&conn, \"index_complete\", \"1\");\n            let snapshot = state.status.lock().clone();\n            perf_log(format!(\n                \"index_run_done elapsed_ms={} scanned={} indexed={} entries={} permission_errors={} message={:?}\",\n                started.elapsed().as_millis(),\n                snapshot.scanned,\n                snapshot.indexed,","numLines":25,"startLine":2001,"totalLines":5757}},"sourceToolAssistantUUID":"cf5d4e14-897f-41e4-a61d-bde5c1ff6aaa"}
{"parentUuid":"9bde03dc-3c95-46f0-8908-62db09bde0b0","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01ECUBk1jpP8EpLGJEuzERz9","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KAGLjWWVe61hAmp2sgC8oX","name":"Edit","input":{"replace_all":false,"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","old_string":"    let mut conn = db_connection(&state.db_path)?;\n    set_indexing_pragmas(&conn)?;\n\n    let result = run_incremental_index_inner(app, state, &mut conn);\n\n    let _ = conn.execute_batch(\"ANALYZE\");","new_string":"    let mut conn = db_connection(&state.db_path)?;\n    set_indexing_pragmas(&conn)?;\n\n    // For fresh index (empty DB), drop secondary indexes before bulk insert and\n    // recreate them after. This avoids per-row BTREE maintenance on every insert,\n    // which can be 3-5x faster when loading hundreds of thousands of rows.\n    let is_fresh_run: bool = get_meta(&conn, \"last_run_id\")\n        .and_then(|v| v.parse::<i64>().ok())\n        .unwrap_or(0)\n        == 0;\n    if is_fresh_run {\n        let _ = conn.execute_batch(\n            \"DROP INDEX IF EXISTS idx_entries_dir_ext_name_nocase;\n             DROP INDEX IF EXISTS idx_entries_mtime;\n             DROP INDEX IF EXISTS idx_entries_name_nocase;\n             DROP INDEX IF EXISTS idx_entries_ext_name;\",\n        );\n    }\n\n    let result = run_incremental_index_inner(app, state, &mut conn);\n\n    if is_fresh_run {\n        let _ = conn.execute_batch(\n            \"CREATE INDEX IF NOT EXISTS idx_entries_dir_ext_name_nocase ON entries(dir, ext, name COLLATE NOCASE);\n             CREATE INDEX IF NOT EXISTS idx_entries_mtime ON entries(mtime);\n             CREATE INDEX IF NOT EXISTS idx_entries_name_nocase ON entries(name COLLATE NOCASE);\n             CREATE INDEX IF NOT EXISTS idx_entries_ext_name ON entries(ext, name COLLATE NOCASE);\",\n        );\n    }\n\n    let _ = conn.execute_batch(\"ANALYZE\");"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":633,"cache_read_input_tokens":153634,"output_tokens":600,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":633,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYNiqD3a53ifGJjQAsS4X","type":"assistant","uuid":"9d100d43-acec-414b-b8cc-dea453c86a77","timestamp":"2026-02-22T07:35:21.627Z"}
{"parentUuid":"9d100d43-acec-414b-b8cc-dea453c86a77","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01KAGLjWWVe61hAmp2sgC8oX","toolUseID":"toolu_01KAGLjWWVe61hAmp2sgC8oX","timestamp":"2026-02-22T07:35:21.637Z","uuid":"53d451b1-223a-4dae-b498-fc7fbc53fe6d"}
{"parentUuid":"9d100d43-acec-414b-b8cc-dea453c86a77","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KAGLjWWVe61hAmp2sgC8oX","type":"tool_result","content":"The file /Users/al02402336/everything/src-tauri/src/main.rs has been updated successfully."}]},"uuid":"306a5af0-0801-4ae6-b3e0-902e6bbf05d3","timestamp":"2026-02-22T07:35:21.637Z","toolUseResult":{"filePath":"/Users/al02402336/everything/src-tauri/src/main.rs","oldString":"    let mut conn = db_connection(&state.db_path)?;\n    set_indexing_pragmas(&conn)?;\n\n    let result = run_incremental_index_inner(app, state, &mut conn);\n\n    let _ = conn.execute_batch(\"ANALYZE\");","newString":"    let mut conn = db_connection(&state.db_path)?;\n    set_indexing_pragmas(&conn)?;\n\n    // For fresh index (empty DB), drop secondary indexes before bulk insert and\n    // recreate them after. This avoids per-row BTREE maintenance on every insert,\n    // which can be 3-5x faster when loading hundreds of thousands of rows.\n    let is_fresh_run: bool = get_meta(&conn, \"last_run_id\")\n        .and_then(|v| v.parse::<i64>().ok())\n        .unwrap_or(0)\n        == 0;\n    if is_fresh_run {\n        let _ = conn.execute_batch(\n            \"DROP INDEX IF EXISTS idx_entries_dir_ext_name_nocase;\n             DROP INDEX IF EXISTS idx_entries_mtime;\n             DROP INDEX IF EXISTS idx_entries_name_nocase;\n             DROP INDEX IF EXISTS idx_entries_ext_name;\",\n        );\n    }\n\n    let result = run_incremental_index_inner(app, state, &mut conn);\n\n    if is_fresh_run {\n        let _ = conn.execute_batch(\n            \"CREATE INDEX IF NOT EXISTS idx_entries_dir_ext_name_nocase ON entries(dir, ext, name COLLATE NOCASE);\n             CREATE INDEX IF NOT EXISTS idx_entries_mtime ON entries(mtime);\n             CREATE INDEX IF NOT EXISTS idx_entries_name_nocase ON entries(name COLLATE NOCASE);\n             CREATE INDEX IF NOT EXISTS idx_entries_ext_name ON entries(ext, name COLLATE NOCASE);\",\n        );\n    }\n\n    let _ = conn.execute_batch(\"ANALYZE\");","originalFile":"#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\n\nuse std::{\n    cmp::Ordering,\n    collections::{HashMap, HashSet},\n    fs,\n    hash::{Hash, Hasher},\n    io::{self, BufRead, BufReader, Write},\n    path::{Path, PathBuf},\n    process::{Command, Stdio},\n    sync::{\n        atomic::{AtomicBool, Ordering as AtomicOrdering},\n        Arc, OnceLock,\n    },\n    time::{Duration, Instant, SystemTime, UNIX_EPOCH},\n};\n\nuse parking_lot::{Mutex, RwLock};\nuse rusqlite::{params, params_from_iter, types::Value as SqlValue, Connection};\nuse serde::Serialize;\nuse tauri::{AppHandle, Emitter, Manager, State};\n#[cfg(target_os = \"macos\")]\nuse tauri_plugin_global_shortcut::{Code, GlobalShortcutExt, Modifiers, Shortcut};\n#[cfg(target_os = \"windows\")]\nuse std::os::windows::process::CommandExt;\nuse walkdir::WalkDir;\n\nmod fd_search;\nmod gitignore_filter;\n#[cfg(target_os = \"macos\")]\nmod mac;\nmod mem_search;\nmod query;\n#[cfg(target_os = \"windows\")]\nmod win;\nuse fd_search::{FdSearchCache, FdSearchResultDto};\nuse query::{escape_like, parse_query, SearchMode};\n\nconst DEFAULT_LIMIT: u32 = 300;\nconst SHORT_QUERY_LIMIT: u32 = 100;\nconst MAX_LIMIT: u32 = 1000;\npub(crate) const BATCH_SIZE: usize = 10_000;\nconst RECENT_OP_TTL: Duration = Duration::from_secs(2);\npub(crate) const WATCH_DEBOUNCE: Duration = Duration::from_millis(300);\nconst NEGATIVE_CACHE_TTL: Duration = Duration::from_secs(60);\nconst NEGATIVE_CACHE_FALLBACK_WINDOW: Duration = Duration::from_millis(550);\nconst DB_VERSION: i32 = 4;\nconst DEFERRED_DIR_NAMES: &[&str] = &[\n    \"Library\", \".Trash\", \".Trashes\",\n    // Windows system directories (deferred when scan_root is C:\\)\n    \"Windows\", \"Program Files\", \"Program Files (x86)\",\n    \"$Recycle.Bin\", \"System Volume Information\", \"Recovery\", \"PerfLogs\",\n];\nconst SHALLOW_SCAN_DEPTH: usize = 6;\nfn jwalk_num_threads() -> usize {\n    std::thread::available_parallelism()\n        .map(|n| (n.get() / 2).max(4).min(16))\n        .unwrap_or(8)\n}\n\npub(crate) const BUILTIN_SKIP_NAMES: &[&str] = &[\n    \".git\",\n    \"node_modules\",\n    \".Trash\",\n    \".Trashes\",\n    \".npm\",\n    \".cache\",\n    \"CMakeFiles\",\n    \".qtc_clangd\",\n    \"__pycache__\",\n    \".gradle\",\n    \"DerivedData\",\n];\n\n/// Path segments whose name ends with one of these suffixes are skipped.\n/// e.g. \"*.build\" skips Xcode intermediate build directories like \"MyApp.build\".\npub(crate) const BUILTIN_SKIP_SUFFIXES: &[&str] = &[\n    \".build\", // Xcode intermediate build dir (MyApp.build, Objects-normal, etc.)\n];\n\npub(crate) const BUILTIN_SKIP_PATHS: &[&str] = &[\n    // macOS\n    \"Library/Caches\",\n    \"Library/Developer/CoreSimulator\",\n    \"Library/Logs\",\n    // Cross-platform\n    \".vscode/extensions\",\n    // Windows: noisy system directories under AppData\n    \"AppData/Local/Temp\",\n    \"AppData/Local/Microsoft\",\n    \"AppData/Local/Google\",\n    \"AppData/Local/Packages\",\n];\n\ntype AppResult<T> = Result<T, String>;\nstatic SEARCH_LOG_ENABLED: OnceLock<bool> = OnceLock::new();\nstatic PERF_LOG_ENABLED: OnceLock<bool> = OnceLock::new();\nstatic BENCH_MODE_ENABLED: OnceLock<bool> = OnceLock::new();\nstatic STARTUP_T0: OnceLock<Instant> = OnceLock::new();\n\nfn startup_elapsed_ms() -> u128 {\n    STARTUP_T0\n        .get()\n        .map(|started| started.elapsed().as_millis())\n        .unwrap_or(0)\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct EntryDto {\n    pub path: String,\n    pub name: String,\n    pub dir: String,\n    pub is_dir: bool,\n    pub ext: Option<String>,\n    pub size: Option<i64>,\n    pub mtime: Option<i64>,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct IndexStatusDto {\n    state: String,\n    entries_count: u64,\n    last_updated: Option<i64>,\n    permission_errors: u64,\n    message: Option<String>,\n    scanned: u64,\n    indexed: u64,\n    current_path: String,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct IndexProgressEvent {\n    scanned: u64,\n    indexed: u64,\n    current_path: String,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct IndexStateEvent {\n    state: String,\n    message: Option<String>,\n    is_catchup: bool,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct IndexUpdatedEvent {\n    entries_count: u64,\n    last_updated: i64,\n    permission_errors: u64,\n}\n\n#[derive(Debug, Clone)]\nstruct SearchExecution {\n    query: String,\n    sort_by: String,\n    sort_dir: String,\n    effective_limit: u32,\n    offset: u32,\n    mode_label: String,\n    results: Vec<EntryDto>,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct SearchResultDto {\n    entries: Vec<EntryDto>,\n    mode_label: String,\n    /// Total number of results matching the query (ignoring LIMIT/OFFSET).\n    total_count: u32,\n    /// True when total_count is exact. False means frontend should treat it as unknown.\n    total_known: bool,\n}\n\n#[allow(dead_code)]\n#[derive(Debug, Clone)]\nstruct BenchCase {\n    id: &'static str,\n    query: &'static str,\n    sort_by: &'static str,\n    sort_dir: &'static str,\n    limit: u32,\n    offset: u32,\n    expected_min_results: usize,\n}\n\n#[allow(dead_code)]\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct BenchCaseResult {\n    id: String,\n    query: String,\n    mode: String,\n    sort_by: String,\n    sort_dir: String,\n    limit: u32,\n    offset: u32,\n    elapsed_ms: f64,\n    result_count: usize,\n    expected_min_results: usize,\n    passed: bool,\n    top_results: Vec<String>,\n    error: Option<String>,\n}\n\n#[allow(dead_code)]\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct BenchReport {\n    run_label: String,\n    started_at: i64,\n    completed_at: i64,\n    home_dir: String,\n    db_path: String,\n    index_wait_ms: u128,\n    index_scanned: u64,\n    index_indexed: u64,\n    index_entries_count: u64,\n    index_permission_errors: u64,\n    index_message: Option<String>,\n    search_iterations: u32,\n    search_results: Vec<BenchCaseResult>,\n}\n\n#[derive(Debug, Clone)]\npub(crate) enum IndexState {\n    Ready,\n    Indexing,\n    Error,\n}\n\nimpl IndexState {\n    fn as_str(&self) -> &'static str {\n        match self {\n            Self::Ready => \"Ready\",\n            Self::Indexing => \"Indexing\",\n            Self::Error => \"Error\",\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct IndexStatus {\n    pub(crate) state: IndexState,\n    pub(crate) entries_count: u64,\n    pub(crate) last_updated: Option<i64>,\n    pub(crate) permission_errors: u64,\n    pub(crate) message: Option<String>,\n    pub(crate) scanned: u64,\n    pub(crate) indexed: u64,\n    pub(crate) current_path: String,\n}\n\nimpl Default for IndexStatus {\n    fn default() -> Self {\n        Self {\n            state: IndexState::Indexing,\n            entries_count: 0,\n            last_updated: None,\n            permission_errors: 0,\n            message: None,\n            scanned: 0,\n            indexed: 0,\n            current_path: String::new(),\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\n#[allow(dead_code)]\npub(crate) struct RecentOp {\n    old_path: Option<String>,\n    new_path: Option<String>,\n    op_type: &'static str,\n    at: Instant,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub(crate) enum IgnorePattern {\n    AnySegment(String),\n    Glob(String),\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct IgnoreRulesCache {\n    roots: Vec<PathBuf>,\n    patterns: Vec<IgnorePattern>,\n    pathignore_mtime: Option<SystemTime>,\n    gitignore_mtime: Option<SystemTime>,\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct AppState {\n    pub(crate) db_path: PathBuf,\n    pub(crate) home_dir: PathBuf,\n    pub(crate) scan_root: PathBuf,\n    pub(crate) cwd: PathBuf,\n    pub(crate) path_ignores: Arc<Vec<PathBuf>>,\n    pub(crate) path_ignore_patterns: Arc<Vec<IgnorePattern>>,\n    pub(crate) db_ready: Arc<AtomicBool>,\n    pub(crate) indexing_active: Arc<AtomicBool>,\n    pub(crate) status: Arc<Mutex<IndexStatus>>,\n    pub(crate) recent_ops: Arc<Mutex<Vec<RecentOp>>>,\n    pub(crate) icon_cache: Arc<Mutex<HashMap<String, Vec<u8>>>>,\n    pub(crate) fd_search_cache: Arc<Mutex<Option<FdSearchCache>>>,\n    pub(crate) negative_name_cache: Arc<Mutex<HashMap<String, NegativeNameEntry>>>,\n    pub(crate) ignore_cache: Arc<Mutex<Option<IgnoreRulesCache>>>,\n    pub(crate) gitignore: Arc<gitignore_filter::LazyGitignoreFilter>,\n    /// In-memory index for instant search while DB upsert runs in background.\n    /// Set by MFT scan, cleared after background DB upsert completes.\n    pub(crate) mem_index: Arc<RwLock<Option<Arc<mem_search::MemIndex>>>>,\n    /// Signal to stop the file watcher (RDCW / USN). Set to true on reset_index.\n    pub(crate) watcher_stop: Arc<AtomicBool>,\n    /// Set to true while a file watcher event loop is running.\n    pub(crate) watcher_active: Arc<AtomicBool>,\n    /// Set to true once frontend onMount has completed enough to accept user input.\n    pub(crate) frontend_ready: Arc<AtomicBool>,\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct NegativeNameEntry {\n    created_at: Instant,\n    fallback_checked: bool,\n}\n\n#[derive(Debug, Clone)]\nstruct NegativeCacheHit {\n    query_lower: String,\n    age: Duration,\n    fallback_checked: bool,\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct IndexRow {\n    pub(crate) path: String,\n    pub(crate) name: String,\n    pub(crate) dir: String,\n    pub(crate) is_dir: i64,\n    pub(crate) ext: Option<String>,\n    pub(crate) mtime: Option<i64>,\n    pub(crate) size: Option<i64>,\n    pub(crate) indexed_at: i64,\n    pub(crate) run_id: i64,\n}\n\npub(crate) fn now_epoch() -> i64 {\n    SystemTime::now()\n        .duration_since(UNIX_EPOCH)\n        .map(|d| d.as_secs() as i64)\n        .unwrap_or_default()\n}\n\nfn env_truthy(key: &str) -> bool {\n    std::env::var(key)\n        .ok()\n        .map(|value| {\n            matches!(\n                value.trim().to_ascii_lowercase().as_str(),\n                \"1\" | \"true\" | \"yes\" | \"on\"\n            )\n        })\n        .unwrap_or(false)\n}\n\nfn bench_mode_enabled() -> bool {\n    *BENCH_MODE_ENABLED.get_or_init(|| env_truthy(\"EVERYTHING_BENCH\"))\n}\n\nfn perf_log_enabled() -> bool {\n    *PERF_LOG_ENABLED.get_or_init(|| env_truthy(\"FASTFIND_PERF_LOG\") || bench_mode_enabled())\n}\n\npub(crate) fn perf_log(message: impl AsRef<str>) {\n    if perf_log_enabled() {\n        eprintln!(\"[perf] {}\", message.as_ref());\n    }\n}\n\nfn db_connection_with_timeout(db_path: &Path, busy_timeout_ms: u32) -> AppResult<Connection> {\n    let conn = Connection::open(db_path).map_err(|e| e.to_string())?;\n    conn.execute_batch(&format!(\n        r#\"\n        PRAGMA journal_mode=WAL;\n        PRAGMA synchronous=NORMAL;\n        PRAGMA temp_store=MEMORY;\n        PRAGMA busy_timeout={busy_timeout_ms};\n        \"#,\n    ))\n    .map_err(|e| e.to_string())?;\n    Ok(conn)\n}\n\npub(crate) fn db_connection(db_path: &Path) -> AppResult<Connection> {\n    db_connection_with_timeout(db_path, 3000)\n}\n\nfn db_connection_for_search(db_path: &Path) -> AppResult<Connection> {\n    let conn = db_connection_with_timeout(db_path, 500)?;\n    conn.execute_batch(\n        \"PRAGMA cache_size = -32768;\n         PRAGMA mmap_size = 268435456;\",\n    )\n    .map_err(|e| e.to_string())?;\n    Ok(conn)\n}\n\npub(crate) fn set_indexing_pragmas(conn: &Connection) -> AppResult<()> {\n    conn.execute_batch(\n        r#\"\n        PRAGMA synchronous = OFF;\n        PRAGMA cache_size = -131072;\n        PRAGMA mmap_size = 536870912;\n        PRAGMA wal_autocheckpoint = 0;\n        \"#,\n    )\n    .map_err(|e| e.to_string())\n}\n\npub(crate) fn restore_normal_pragmas(conn: &Connection) -> AppResult<()> {\n    conn.execute_batch(\n        r#\"\n        PRAGMA synchronous = NORMAL;\n        PRAGMA cache_size = -16384;\n        PRAGMA mmap_size = 268435456;\n        PRAGMA wal_autocheckpoint = 1000;\n        \"#,\n    )\n    .map_err(|e| e.to_string())?;\n    conn.execute_batch(\"PRAGMA wal_checkpoint(TRUNCATE);\")\n        .map_err(|e| e.to_string())?;\n    Ok(())\n}\n\nfn init_db(db_path: &Path) -> AppResult<()> {\n    let t = Instant::now();\n    let conn = db_connection(db_path)?;\n    eprintln!(\"[init_db] +{}ms db_connection opened\", t.elapsed().as_millis());\n\n    let current_version: i32 = conn\n        .query_row(\"PRAGMA user_version\", [], |row| row.get(0))\n        .unwrap_or(0);\n    if current_version != DB_VERSION {\n        conn.execute_batch(\n            r#\"\n            DROP TRIGGER IF EXISTS entries_ai;\n            DROP TRIGGER IF EXISTS entries_ad;\n            DROP TRIGGER IF EXISTS entries_au;\n            DROP TABLE IF EXISTS entries_fts;\n            DROP TABLE IF EXISTS entries;\n            \"#,\n        )\n        .map_err(|e| e.to_string())?;\n        conn.execute_batch(&format!(\"PRAGMA user_version = {};\", DB_VERSION))\n            .map_err(|e| e.to_string())?;\n    }\n    eprintln!(\"[init_db] +{}ms version check done (v={})\", t.elapsed().as_millis(), current_version);\n\n    conn.execute_batch(\n        r#\"\n        CREATE TABLE IF NOT EXISTS entries (\n          id INTEGER PRIMARY KEY,\n          path TEXT NOT NULL UNIQUE,\n          name TEXT NOT NULL,\n          dir TEXT NOT NULL,\n          is_dir INTEGER NOT NULL,\n          ext TEXT,\n          mtime INTEGER,\n          size INTEGER,\n          indexed_at INTEGER NOT NULL,\n          run_id INTEGER NOT NULL DEFAULT 0\n        );\n\n        CREATE INDEX IF NOT EXISTS idx_entries_dir_ext_name_nocase ON entries(dir, ext, name COLLATE NOCASE);\n        CREATE INDEX IF NOT EXISTS idx_entries_mtime ON entries(mtime);\n        CREATE INDEX IF NOT EXISTS idx_entries_name_nocase ON entries(name COLLATE NOCASE);\n        CREATE INDEX IF NOT EXISTS idx_entries_ext_name ON entries(ext, name COLLATE NOCASE);\n\n        CREATE TABLE IF NOT EXISTS meta (\n          key TEXT PRIMARY KEY,\n          value TEXT NOT NULL\n        );\n        \"#,\n    )\n    .map_err(|e| e.to_string())?;\n    eprintln!(\"[init_db] +{}ms schema ensured\", t.elapsed().as_millis());\n\n    let legacy_index_migration_key = \"migration_drop_idx_entries_dir_name_nocase_v1\";\n    let migrated = get_meta(&conn, legacy_index_migration_key)\n        .map(|v| v == \"1\")\n        .unwrap_or(false);\n    if !migrated {\n        conn.execute_batch(\"DROP INDEX IF EXISTS idx_entries_dir_name_nocase;\")\n            .map_err(|e| e.to_string())?;\n        set_meta(&conn, legacy_index_migration_key, \"1\")?;\n    }\n    eprintln!(\"[init_db] +{}ms total\", t.elapsed().as_millis());\n\n    Ok(())\n}\n\npub(crate) fn get_meta(conn: &Connection, key: &str) -> Option<String> {\n    conn.query_row(\n        \"SELECT value FROM meta WHERE key = ?1\",\n        params![key],\n        |row| row.get(0),\n    )\n    .ok()\n}\n\npub(crate) fn set_meta(conn: &Connection, key: &str, value: &str) -> AppResult<()> {\n    conn.execute(\n        \"INSERT OR REPLACE INTO meta(key, value) VALUES(?1, ?2)\",\n        params![key, value],\n    )\n    .map_err(|e| e.to_string())?;\n    Ok(())\n}\n\nfn update_counts(state: &AppState) -> AppResult<(u64, Option<i64>)> {\n    let conn = db_connection(&state.db_path)?;\n\n    let entries_count = conn\n        .query_row(\"SELECT COUNT(*) FROM entries\", [], |row| {\n            row.get::<_, i64>(0)\n        })\n        .map_err(|e| e.to_string())?\n        .max(0) as u64;\n\n    let last_updated = conn\n        .query_row(\"SELECT MAX(indexed_at) FROM entries\", [], |row| {\n            row.get::<_, Option<i64>>(0)\n        })\n        .map_err(|e| e.to_string())?;\n\n    Ok((entries_count, last_updated))\n}\n\npub(crate) fn update_status_counts(state: &AppState) -> AppResult<(u64, Option<i64>)> {\n    let (entries_count, last_updated) = update_counts(state)?;\n    let mut status = state.status.lock();\n    status.entries_count = entries_count;\n    status.last_updated = last_updated;\n    Ok((entries_count, last_updated))\n}\n\npub(crate) fn invalidate_search_caches(state: &AppState) {\n    state.fd_search_cache.lock().take();\n    state.negative_name_cache.lock().clear();\n}\n\nfn prune_negative_name_cache(cache: &mut HashMap<String, NegativeNameEntry>) {\n    let now = Instant::now();\n    cache.retain(|_, entry| now.duration_since(entry.created_at) <= NEGATIVE_CACHE_TTL);\n}\n\nfn negative_name_cache_lookup(state: &AppState, query: &str) -> Option<NegativeCacheHit> {\n    if query.is_empty() {\n        return None;\n    }\n    let q = query.to_lowercase();\n    let now = Instant::now();\n    let mut cache = state.negative_name_cache.lock();\n    prune_negative_name_cache(&mut cache);\n    cache\n        .iter()\n        .filter(|(key, _)| q.contains(key.as_str()))\n        .max_by_key(|(key, _)| key.len())\n        .map(|(key, entry)| NegativeCacheHit {\n            query_lower: key.clone(),\n            age: now.duration_since(entry.created_at),\n            fallback_checked: entry.fallback_checked,\n        })\n}\n\nfn remember_negative_name_query(state: &AppState, query: &str) {\n    if query.is_empty() {\n        return;\n    }\n    let normalized = query.to_lowercase();\n    let mut cache = state.negative_name_cache.lock();\n    prune_negative_name_cache(&mut cache);\n\n    if cache.contains_key(&normalized) {\n        return;\n    }\n\n    cache.insert(\n        normalized,\n        NegativeNameEntry {\n            created_at: Instant::now(),\n            fallback_checked: false,\n        },\n    );\n    const MAX_NEGATIVE_CACHE: usize = 512;\n    if cache.len() > MAX_NEGATIVE_CACHE {\n        let mut entries: Vec<_> =\n            cache.iter().map(|(k, v)| (k.clone(), v.created_at)).collect();\n        entries.sort_by_key(|(_, t)| *t);\n        let drop_count = cache.len() - MAX_NEGATIVE_CACHE;\n        for (key, _) in entries.into_iter().take(drop_count) {\n            cache.remove(&key);\n        }\n    }\n}\n\nfn remove_negative_name_query(state: &AppState, query: &str) {\n    if query.is_empty() {\n        return;\n    }\n    let normalized = query.to_lowercase();\n    state.negative_name_cache.lock().remove(&normalized);\n}\n\nfn mark_negative_name_fallback_checked(state: &AppState, query_lower: &str) {\n    let mut cache = state.negative_name_cache.lock();\n    if let Some(entry) = cache.get_mut(query_lower) {\n        entry.fallback_checked = true;\n    }\n}\n\nfn sort_clause(sort_by: &str, sort_dir: &str, prefix: &str) -> String {\n    match (sort_by, sort_dir) {\n        (\"name\", \"desc\") => {\n            format!(\"{prefix}name COLLATE NOCASE DESC, {prefix}path COLLATE NOCASE DESC\")\n        }\n        (\"mtime\", \"asc\") => {\n            format!(\"COALESCE({prefix}mtime, 0) ASC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        (\"mtime\", \"desc\") => {\n            format!(\"COALESCE({prefix}mtime, 0) DESC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        (\"dir\", \"asc\") => {\n            format!(\"{prefix}dir COLLATE NOCASE ASC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        (\"dir\", \"desc\") => {\n            format!(\"{prefix}dir COLLATE NOCASE DESC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        (\"size\", \"asc\") => {\n            format!(\"{prefix}size IS NULL ASC, {prefix}size ASC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        (\"size\", \"desc\") => {\n            format!(\"{prefix}size IS NULL ASC, {prefix}size DESC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        _ => format!(\"{prefix}name COLLATE NOCASE ASC, {prefix}path COLLATE NOCASE ASC\"),\n    }\n}\n\nfn contains_glob_meta(s: &str) -> bool {\n    s.contains('*') || s.contains('?')\n}\n\n/// Detect if a LIKE pattern is a pure extension filter (e.g. `%.rs`).\n/// Returns the lowercase extension if matched, None otherwise.\nfn extract_ext_from_like(like_pattern: &str) -> Option<String> {\n    let rest = like_pattern.strip_prefix('%')?;\n    let ext = rest.strip_prefix('.')?;\n    if ext.is_empty()\n        || ext.contains('%')\n        || ext.contains('_')\n        || ext.contains('\\\\')\n        || ext.contains('/')\n        || ext.contains('.')\n    {\n        return None;\n    }\n    Some(ext.to_lowercase())\n}\n\nfn normalize_hint_to_native(dir_hint: &str) -> (String, bool) {\n    let native = dir_hint.replace('/', &std::path::MAIN_SEPARATOR.to_string());\n    let is_abs = Path::new(&native).is_absolute();\n    (native, is_abs)\n}\n\nfn last_segment(dir_hint: &str) -> &str {\n    dir_hint\n        .rsplit(|c| c == '/' || c == '\\\\')\n        .find(|seg| !seg.is_empty())\n        .unwrap_or(dir_hint)\n}\n\nfn resolve_dir_hint(home_dir: &Path, dir_hint: &str) -> Option<PathBuf> {\n    if dir_hint.is_empty() || contains_glob_meta(dir_hint) {\n        return None;\n    }\n\n    let candidate = if dir_hint == \"~\" {\n        home_dir.to_path_buf()\n    } else if let Some(rest) = dir_hint.strip_prefix(\"~/\") {\n        home_dir.join(rest)\n    } else {\n        let (native_hint, is_absolute) = normalize_hint_to_native(dir_hint);\n        if is_absolute {\n            PathBuf::from(native_hint)\n        } else {\n            home_dir.join(native_hint)\n        }\n    };\n\n    if candidate.is_dir() {\n        Some(candidate)\n    } else {\n        None\n    }\n}\n\nconst RESOLVE_DIRS_MAX: usize = 20;\n\nfn resolve_dirs_from_db(conn: &Connection, dir_hint: &str) -> Vec<String> {\n    if dir_hint.is_empty() || contains_glob_meta(dir_hint) {\n        return Vec::new();\n    }\n    let last_seg = last_segment(dir_hint);\n    let sep = std::path::MAIN_SEPARATOR;\n    let (native_hint, is_absolute) = normalize_hint_to_native(dir_hint);\n    let sep_str = sep.to_string();\n    let escaped_sep = escape_like(&sep_str);\n    let path_pattern = if is_absolute {\n        format!(\"%{}\", escape_like(&native_hint))\n    } else {\n        format!(\"%{escaped_sep}{}\", escape_like(&native_hint))\n    };\n    let fetch_limit = (RESOLVE_DIRS_MAX + 1) as i64;\n    let mut stmt = match conn.prepare(\n        \"SELECT path FROM entries WHERE name = ?1 COLLATE NOCASE AND is_dir = 1 AND path LIKE ?2 ESCAPE '\\\\' LIMIT ?3\",\n    ) {\n        Ok(s) => s,\n        Err(_) => return Vec::new(),\n    };\n    let rows = match stmt.query_map(params![last_seg, path_pattern, fetch_limit], |row| {\n        row.get::<_, String>(0)\n    }) {\n        Ok(r) => r,\n        Err(_) => return Vec::new(),\n    };\n    let dirs: Vec<String> = rows.filter_map(|r| r.ok()).collect();\n    if dirs.len() > RESOLVE_DIRS_MAX {\n        return Vec::new();\n    }\n    dirs\n}\n\nfn normalize_slashes(s: String) -> String {\n    s.replace('\\\\', \"/\")\n}\n\nfn resolve_ignore_path(raw: &str, base_dir: &Path, home_dir: &Path) -> Option<PathBuf> {\n    let trimmed = raw.trim();\n    if trimmed.is_empty() || trimmed.starts_with('#') || trimmed.starts_with('!') {\n        return None;\n    }\n\n    let mut path = if trimmed == \"~\" {\n        home_dir.to_path_buf()\n    } else if let Some(rest) = trimmed.strip_prefix(\"~/\") {\n        home_dir.join(rest)\n    } else {\n        PathBuf::from(trimmed)\n    };\n\n    if !path.is_absolute() {\n        path = base_dir.join(path);\n    }\n\n    Some(fs::canonicalize(&path).unwrap_or(path))\n}\n\nfn normalize_ignore_pattern(raw: &str, base_dir: &Path, home_dir: &Path) -> String {\n    let trimmed = raw.trim().trim_end_matches('/').to_string();\n    if trimmed == \"~\" {\n        return normalize_slashes(home_dir.to_string_lossy().to_string());\n    }\n    if let Some(rest) = trimmed.strip_prefix(\"~/\") {\n        return normalize_slashes(home_dir.join(rest).to_string_lossy().to_string());\n    }\n    if trimmed.starts_with('/') || trimmed.starts_with(\"**/\") {\n        return trimmed;\n    }\n    normalize_slashes(base_dir.join(&trimmed).to_string_lossy().to_string())\n}\n\nfn parse_ignore_pattern(raw: &str, base_dir: &Path, home_dir: &Path) -> Option<IgnorePattern> {\n    let trimmed = raw.trim().trim_end_matches('/');\n    if trimmed.is_empty() {\n        return None;\n    }\n\n    if let Some(segment) = trimmed.strip_prefix(\"**/\") {\n        if !segment.is_empty() && !segment.contains('/') && !contains_glob_meta(segment) {\n            return Some(IgnorePattern::AnySegment(segment.to_string()));\n        }\n    }\n\n    Some(IgnorePattern::Glob(normalize_ignore_pattern(\n        trimmed, base_dir, home_dir,\n    )))\n}\n\nfn ignore_pattern_key(pattern: &IgnorePattern) -> String {\n    match pattern {\n        IgnorePattern::AnySegment(segment) => format!(\"seg:{segment}\"),\n        IgnorePattern::Glob(glob) => format!(\"glob:{glob}\"),\n    }\n}\n\nfn find_file_upward(start: &Path, file_name: &str) -> Option<PathBuf> {\n    let mut current = Some(start);\n    while let Some(dir) = current {\n        let candidate = dir.join(file_name);\n        if candidate.is_file() {\n            return Some(candidate);\n        }\n        current = dir.parent();\n    }\n    None\n}\n\nfn find_git_root(start: &Path) -> Option<PathBuf> {\n    let mut current = Some(start);\n    while let Some(dir) = current {\n        let marker = dir.join(\".git\");\n        if marker.is_dir() || marker.is_file() {\n            return Some(dir.to_path_buf());\n        }\n        current = dir.parent();\n    }\n    None\n}\n\nfn load_pathignore_rules(home_dir: &Path, cwd: &Path) -> (Vec<PathBuf>, Vec<IgnorePattern>) {\n    let mut files = Vec::new();\n    if let Some(file) = find_file_upward(cwd, \".pathignore\") {\n        files.push(file);\n    } else {\n        files.push(cwd.join(\".pathignore\"));\n    }\n    let home_file = home_dir.join(\".pathignore\");\n    if !files.iter().any(|p| p == &home_file) {\n        files.push(home_file);\n    }\n\n    let mut roots = Vec::new();\n    let mut patterns = Vec::new();\n    let mut seen_roots = HashSet::new();\n    let mut seen_patterns = HashSet::new();\n\n    for file in files {\n        let Ok(contents) = fs::read_to_string(&file) else {\n            continue;\n        };\n        let base_dir = file.parent().unwrap_or_else(|| Path::new(\"/\"));\n        for line in contents.lines() {\n            let trimmed = line.trim();\n            if trimmed.is_empty() || trimmed.starts_with('#') || trimmed.starts_with('!') {\n                continue;\n            }\n\n            if contains_glob_meta(trimmed) {\n                let Some(pattern) = parse_ignore_pattern(trimmed, base_dir, home_dir) else {\n                    continue;\n                };\n                let key = ignore_pattern_key(&pattern);\n                if seen_patterns.insert(key) {\n                    patterns.push(pattern);\n                }\n                continue;\n            }\n\n            let Some(path) = resolve_ignore_path(trimmed, base_dir, home_dir) else {\n                continue;\n            };\n\n            let key = path.to_string_lossy().to_string();\n            if seen_roots.insert(key) {\n                roots.push(path);\n            }\n        }\n    }\n\n    (roots, patterns)\n}\n\nfn load_gitignore_roots(home_dir: &Path, cwd: &Path) -> Vec<PathBuf> {\n    let gitignore = if let Some(root) = find_git_root(cwd) {\n        root.join(\".gitignore\")\n    } else if let Some(file) = find_file_upward(&cwd, \".gitignore\") {\n        file\n    } else {\n        return Vec::new();\n    };\n    let contents = match fs::read_to_string(&gitignore) {\n        Ok(contents) => contents,\n        Err(_) => return Vec::new(),\n    };\n\n    let mut roots = Vec::new();\n    let mut seen = HashSet::new();\n\n    for line in contents.lines() {\n        let trimmed = line.trim();\n        if trimmed.is_empty() || trimmed.starts_with('#') || trimmed.starts_with('!') {\n            continue;\n        }\n        if contains_glob_meta(trimmed) || trimmed.contains('[') {\n            continue;\n        }\n\n        let normalized = trimmed.trim_start_matches('/').trim_end_matches('/');\n        if normalized.is_empty() {\n            continue;\n        }\n\n        let Some(path) = resolve_ignore_path(normalized, &cwd, home_dir) else {\n            continue;\n        };\n\n        let key = path.to_string_lossy().to_string();\n        if seen.insert(key) {\n            roots.push(path);\n        }\n    }\n\n    roots\n}\n\n#[cfg(target_os = \"macos\")]\nfn macos_tcc_ignore_roots(home_dir: &Path) -> Vec<PathBuf> {\n    let library = home_dir.join(\"Library\");\n    let app_support = library.join(\"Application Support\");\n    let caches = library.join(\"Caches\");\n\n    let dirs: Vec<PathBuf> = vec![\n        home_dir.join(\".Trash\"),\n        library.join(\"Accounts\"),\n        library.join(\"AppleMediaServices\"),\n        library.join(\"Assistant\").join(\"SiriVocabulary\"),\n        library.join(\"Autosave Information\"),\n        library.join(\"Biome\"),\n        library.join(\"Calendars\"),\n        library.join(\"com.apple.aiml.instrumentation\"),\n        library.join(\"ContainerManager\"),\n        library.join(\"Cookies\"),\n        library.join(\"CoreFollowUp\"),\n        library.join(\"Daemon Containers\"),\n        library.join(\"DoNotDisturb\"),\n        library.join(\"DuetExpertCenter\"),\n        library.join(\"Group Containers\"),\n        library.join(\"HomeKit\"),\n        library.join(\"Developer\").join(\"Xcode\").join(\"DerivedData\"),\n        library.join(\"IdentityServices\"),\n        library.join(\"IntelligencePlatform\"),\n        library.join(\"Mail\"),\n        library.join(\"Messages\"),\n        library.join(\"Metadata\").join(\"CoreSpotlight\"),\n        library.join(\"PersonalizationPortrait\"),\n        library.join(\"Reminders\"),\n        library.join(\"Safari\"),\n        library.join(\"Sharing\"),\n        library.join(\"Shortcuts\"),\n        library.join(\"StatusKit\"),\n        library.join(\"Suggestions\"),\n        library.join(\"Trial\"),\n        library.join(\"Weather\"),\n        app_support.join(\"AddressBook\"),\n        app_support.join(\"CallHistoryDB\"),\n        app_support.join(\"CallHistoryTransactions\"),\n        app_support.join(\"CloudDocs\"),\n        app_support.join(\"com.apple.avfoundation\"),\n        app_support.join(\"com.apple.sharedfilelist\"),\n        app_support.join(\"com.apple.TCC\"),\n        app_support.join(\"DifferentialPrivacy\"),\n        app_support.join(\"FaceTime\"),\n        app_support.join(\"FileProvider\"),\n        app_support.join(\"Knowledge\"),\n        caches.join(\"CloudKit\"),\n        caches.join(\"com.apple.ap.adprivacyd\"),\n        caches.join(\"com.apple.containermanagerd\"),\n        caches.join(\"com.apple.findmy.fmfcore\"),\n        caches.join(\"com.apple.findmy.fmipcore\"),\n        caches.join(\"com.apple.homed\"),\n        caches.join(\"com.apple.HomeKit\"),\n        caches.join(\"com.apple.Safari\"),\n        caches.join(\"FamilyCircle\"),\n    ];\n\n    dirs.into_iter().filter(|p| p.exists()).collect()\n}\n\n#[cfg(not(target_os = \"macos\"))]\nfn macos_tcc_ignore_roots(_home_dir: &Path) -> Vec<PathBuf> {\n    Vec::new()\n}\n\n/// Directories under home that generate heavy background I/O on Windows\n/// (browser caches, Windows Update temp files, UWP package state, etc.).\n/// Pruning these from the MFT subtree eliminates noisy USN records.\n#[cfg(target_os = \"windows\")]\nfn windows_noisy_roots(home_dir: &Path) -> Vec<PathBuf> {\n    let local = home_dir.join(\"AppData\").join(\"Local\");\n    let dirs = vec![\n        local.join(\"Temp\"),\n        local.join(\"Microsoft\"),\n        local.join(\"Google\"),\n        local.join(\"Packages\"),\n        // C:\\ system directories (Windows is deferred, not excluded)\n        PathBuf::from(\"C:\\\\$Recycle.Bin\"),\n        PathBuf::from(\"C:\\\\System Volume Information\"),\n        PathBuf::from(\"C:\\\\Recovery\"),\n        PathBuf::from(\"C:\\\\PerfLogs\"),\n    ];\n    dirs.into_iter().filter(|p| p.exists()).collect()\n}\n\n#[cfg(not(target_os = \"windows\"))]\nfn windows_noisy_roots(_home_dir: &Path) -> Vec<PathBuf> {\n    Vec::new()\n}\n\npub(crate) fn effective_ignore_rules(\n    home_dir: &Path,\n    cwd: &Path,\n    base_roots: &[PathBuf],\n    base_patterns: &[IgnorePattern],\n) -> (Vec<PathBuf>, Vec<IgnorePattern>) {\n    let mut roots = base_roots.to_vec();\n    let mut patterns = base_patterns.to_vec();\n    let mut seen: HashSet<String> = roots\n        .iter()\n        .map(|p| p.to_string_lossy().to_string())\n        .collect();\n    let mut seen_patterns: HashSet<String> = patterns.iter().map(ignore_pattern_key).collect();\n\n    let (pathignore_roots, pathignore_patterns) = load_pathignore_rules(home_dir, cwd);\n    for root in pathignore_roots\n        .into_iter()\n        .chain(load_gitignore_roots(home_dir, cwd).into_iter())\n        .chain(macos_tcc_ignore_roots(home_dir).into_iter())\n        .chain(windows_noisy_roots(home_dir).into_iter())\n    {\n        let key = root.to_string_lossy().to_string();\n        if seen.insert(key) {\n            roots.push(root);\n        }\n    }\n\n    for pattern in pathignore_patterns\n        .into_iter()\n        .chain(builtin_ignore_patterns(home_dir))\n    {\n        let key = ignore_pattern_key(&pattern);\n        if seen_patterns.insert(key) {\n            patterns.push(pattern);\n        }\n    }\n\n    (roots, patterns)\n}\n\nfn builtin_ignore_patterns(home_dir: &Path) -> Vec<IgnorePattern> {\n    let home = normalize_slashes(home_dir.to_string_lossy().to_string());\n    vec![\n        // ~/Library/Application Support/*/Cache*\n        IgnorePattern::Glob(format!(\"{home}/Library/Application Support/*/Cache*\")),\n        // ~/Library/Application Support/*/Code Cache\n        IgnorePattern::Glob(format!(\"{home}/Library/Application Support/*/Code Cache\")),\n        // ~/.rustup/toolchains/*/share/doc\n        IgnorePattern::Glob(format!(\"{home}/.rustup/toolchains/*/share/doc\")),\n        // ~/.pyenv/versions/*/lib\n        IgnorePattern::Glob(format!(\"{home}/.pyenv/versions/*/lib\")),\n    ]\n}\n\npub(crate) fn cached_effective_ignore_rules(state: &AppState) -> (Vec<PathBuf>, Vec<IgnorePattern>) {\n    let home_dir = &state.home_dir;\n    let cwd = &state.cwd;\n\n    let pathignore_mtime = find_file_upward(cwd, \".pathignore\")\n        .or_else(|| Some(home_dir.join(\".pathignore\")))\n        .and_then(|p| fs::metadata(&p).ok())\n        .and_then(|m| m.modified().ok());\n\n    let gitignore_mtime = find_git_root(cwd)\n        .map(|root| root.join(\".gitignore\"))\n        .or_else(|| find_file_upward(cwd, \".gitignore\"))\n        .and_then(|p| fs::metadata(&p).ok())\n        .and_then(|m| m.modified().ok());\n\n    let mut cache = state.ignore_cache.lock();\n    if let Some(ref cached) = *cache {\n        if cached.pathignore_mtime == pathignore_mtime && cached.gitignore_mtime == gitignore_mtime\n        {\n            return (cached.roots.clone(), cached.patterns.clone());\n        }\n    }\n\n    let (roots, patterns) = effective_ignore_rules(\n        home_dir,\n        cwd,\n        state.path_ignores.as_ref(),\n        state.path_ignore_patterns.as_ref(),\n    );\n\n    *cache = Some(IgnoreRulesCache {\n        roots: roots.clone(),\n        patterns: patterns.clone(),\n        pathignore_mtime,\n        gitignore_mtime,\n    });\n\n    (roots, patterns)\n}\n\nfn ignore_rules_fingerprint(roots: &[PathBuf], patterns: &[IgnorePattern]) -> u64 {\n    let mut hasher = std::collections::hash_map::DefaultHasher::new();\n    for root in roots {\n        normalize_slashes(root.to_string_lossy().to_string()).hash(&mut hasher);\n    }\n    for pattern in patterns {\n        ignore_pattern_key(pattern).hash(&mut hasher);\n    }\n    hasher.finish()\n}\n\nfn purge_ignored_entries(db_path: &Path, ignored_roots: &[PathBuf]) -> AppResult<()> {\n    if ignored_roots.is_empty() {\n        return Ok(());\n    }\n\n    let conn = db_connection(db_path)?;\n    for root in ignored_roots {\n        let root_str = root.to_string_lossy().to_string();\n        if root_str.is_empty() {\n            continue;\n        }\n\n        if root_str == \"/\" {\n            conn.execute(\"DELETE FROM entries\", [])\n                .map_err(|e| e.to_string())?;\n            break;\n        }\n\n        let prefix = root_str.trim_end_matches('/');\n        let descendant_like = format!(\"{}%\", escape_like(&format!(\"{prefix}/\")));\n        conn.execute(\n            \"DELETE FROM entries WHERE path = ?1 OR path LIKE ?2 ESCAPE '\\\\'\",\n            params![prefix, descendant_like],\n        )\n        .map_err(|e| e.to_string())?;\n    }\n\n    Ok(())\n}\n\nfn glob_match_path(pattern: &str, text: &str) -> bool {\n    let pat = pattern.as_bytes();\n    let txt = text.as_bytes();\n    let (pn, tn) = (pat.len(), txt.len());\n\n    let mut px = 0usize;\n    let mut tx = 0usize;\n    let mut star_px = usize::MAX;\n    let mut star_tx = 0usize;\n    let mut star_is_double = false;\n\n    while tx < tn {\n        if px < pn && px + 1 < pn && pat[px] == b'*' && pat[px + 1] == b'*' {\n            star_px = px;\n            star_tx = tx;\n            star_is_double = true;\n            px += 2;\n        } else if px < pn && pat[px] == b'*' {\n            star_px = px;\n            star_tx = tx;\n            star_is_double = false;\n            px += 1;\n        } else if px < pn && (pat[px] == b'?' && txt[tx] != b'/') {\n            px += 1;\n            tx += 1;\n        } else if px < pn && pat[px] == txt[tx] {\n            px += 1;\n            tx += 1;\n        } else if star_px != usize::MAX {\n            star_tx += 1;\n            if !star_is_double && txt[star_tx - 1] == b'/' {\n                return false;\n            }\n            px = if star_is_double {\n                star_px + 2\n            } else {\n                star_px + 1\n            };\n            tx = star_tx;\n        } else {\n            return false;\n        }\n    }\n\n    while px < pn && pat[px] == b'*' {\n        px += 1;\n    }\n\n    px == pn\n}\n\npub(crate) fn matches_ignore_pattern(path: &str, pattern: &IgnorePattern) -> bool {\n    match pattern {\n        IgnorePattern::AnySegment(segment) => {\n            let suffix = format!(\"/{segment}\");\n            let infix = format!(\"/{segment}/\");\n            path.ends_with(&suffix) || path.contains(&infix)\n        }\n        IgnorePattern::Glob(glob) => {\n            let mut cur = path;\n            loop {\n                if glob_match_path(glob, cur) {\n                    return true;\n                }\n\n                if cur == \"/\" {\n                    break;\n                }\n\n                let Some(pos) = cur.rfind('/') else {\n                    break;\n                };\n\n                cur = if pos == 0 { \"/\" } else { &cur[..pos] };\n            }\n            false\n        }\n    }\n}\n\npub(crate) fn should_skip_path(\n    path: &Path,\n    ignored_roots: &[PathBuf],\n    ignored_patterns: &[IgnorePattern],\n) -> bool {\n    should_skip_path_ext(path, ignored_roots, ignored_patterns, None, None)\n}\n\npub(crate) fn should_skip_path_ext(\n    path: &Path,\n    ignored_roots: &[PathBuf],\n    ignored_patterns: &[IgnorePattern],\n    gitignore: Option<&gitignore_filter::GitignoreFilter>,\n    is_dir_hint: Option<bool>,\n) -> bool {\n    let s = normalize_slashes(path.to_string_lossy().to_string());\n\n    // Single-component builtin names: check path segments\n    if s.split('/').any(|seg| {\n        BUILTIN_SKIP_NAMES.contains(&seg)\n            || BUILTIN_SKIP_SUFFIXES.iter().any(|suf| seg.ends_with(suf))\n    }) {\n        return true;\n    }\n\n    // Multi-component builtin paths\n    if BUILTIN_SKIP_PATHS.iter().any(|pat| {\n        let infix = format!(\"/{pat}/\");\n        let suffix = format!(\"/{pat}\");\n        s.contains(&infix) || s.ends_with(&suffix)\n    }) {\n        return true;\n    }\n\n    if ignored_roots\n        .iter()\n        .any(|root| path == root || path.starts_with(root))\n    {\n        return true;\n    }\n    if ignored_patterns\n        .iter()\n        .any(|pattern| matches_ignore_pattern(&s, pattern))\n    {\n        return true;\n    }\n    if let Some(gi) = gitignore {\n        let is_dir = is_dir_hint.unwrap_or_else(|| path.is_dir());\n        if gi.is_ignored(path, is_dir) {\n            return true;\n        }\n    }\n    false\n}\n\nfn extension_for(path: &Path, is_dir: bool) -> Option<String> {\n    if is_dir {\n        return None;\n    }\n\n    path.extension()\n        .and_then(|ext| ext.to_str())\n        .map(|ext| ext.to_lowercase())\n}\n\npub(crate) fn index_row_from_path_and_metadata(path: &Path, metadata: &fs::Metadata) -> Option<IndexRow> {\n    let is_dir = metadata.is_dir();\n\n    let name = path\n        .file_name()\n        .map(|v| v.to_string_lossy().to_string())\n        .or_else(|| {\n            if path == Path::new(\"/\") {\n                Some(\"/\".to_string())\n            } else {\n                None\n            }\n        })?;\n\n    let dir = path\n        .parent()\n        .map(|p| p.to_string_lossy().to_string())\n        .unwrap_or_else(|| \"/\".to_string());\n\n    let mtime = metadata\n        .modified()\n        .ok()\n        .and_then(|m| m.duration_since(UNIX_EPOCH).ok())\n        .map(|d| d.as_secs() as i64);\n\n    let size = if metadata.is_file() {\n        Some(metadata.len() as i64)\n    } else {\n        None\n    };\n\n    Some(IndexRow {\n        path: path.to_string_lossy().to_string(),\n        name,\n        dir,\n        is_dir: if is_dir { 1 } else { 0 },\n        ext: extension_for(path, is_dir),\n        mtime,\n        size,\n        indexed_at: now_epoch(),\n        run_id: 0,\n    })\n}\n\nfn index_row_from_path(path: &Path) -> Option<IndexRow> {\n    let metadata = fs::symlink_metadata(path).ok()?;\n    index_row_from_path_and_metadata(path, &metadata)\n}\n\nfn index_row_from_walkdir_entry(entry: &walkdir::DirEntry) -> Option<IndexRow> {\n    let metadata = entry.metadata().ok()?;\n    index_row_from_path_and_metadata(entry.path(), &metadata)\n}\n\nfn index_row_from_jwalk_entry(entry: &jwalk::DirEntry<((), ())>) -> Option<IndexRow> {\n    let metadata = entry.metadata().ok()?;\n    index_row_from_path_and_metadata(&entry.path(), &metadata)\n}\n\nfn collect_rows_recursive(\n    root: &Path,\n    ignored_roots: &[PathBuf],\n    ignored_patterns: &[IgnorePattern],\n) -> Vec<IndexRow> {\n    let mut rows = Vec::new();\n\n    let iter = WalkDir::new(root)\n        .follow_links(false)\n        .into_iter()\n        .filter_entry(|entry| !should_skip_path(entry.path(), ignored_roots, ignored_patterns));\n\n    for entry in iter.flatten() {\n        if let Some(row) = index_row_from_walkdir_entry(&entry) {\n            rows.push(row);\n        }\n    }\n\n    rows\n}\n\nfn entry_from_index_row(row: IndexRow) -> EntryDto {\n    EntryDto {\n        path: row.path,\n        name: row.name,\n        dir: row.dir,\n        is_dir: row.is_dir == 1,\n        ext: row.ext,\n        size: row.size,\n        mtime: row.mtime,\n    }\n}\n\npub fn entry_from_path(path: &Path) -> Option<EntryDto> {\n    index_row_from_path(path).map(entry_from_index_row)\n}\n\nfn entry_cmp(a: &EntryDto, b: &EntryDto, sort_by: &str, sort_dir: &str) -> Ordering {\n    match sort_by {\n        \"mtime\" => {\n            let lhs = a.mtime.unwrap_or(0);\n            let rhs = b.mtime.unwrap_or(0);\n            let primary = if sort_dir == \"desc\" {\n                rhs.cmp(&lhs)\n            } else {\n                lhs.cmp(&rhs)\n            };\n\n            if primary != Ordering::Equal {\n                return primary;\n            }\n\n            a.name\n                .to_lowercase()\n                .cmp(&b.name.to_lowercase())\n                .then(a.path.to_lowercase().cmp(&b.path.to_lowercase()))\n        }\n        \"dir\" => {\n            let lhs = a.dir.to_lowercase();\n            let rhs = b.dir.to_lowercase();\n            let primary = if sort_dir == \"desc\" {\n                rhs.cmp(&lhs)\n            } else {\n                lhs.cmp(&rhs)\n            };\n            if primary != Ordering::Equal {\n                return primary;\n            }\n            a.name.to_lowercase().cmp(&b.name.to_lowercase())\n        }\n        \"size\" => {\n            let lhs = a.size.unwrap_or(0);\n            let rhs = b.size.unwrap_or(0);\n            let primary = if sort_dir == \"desc\" {\n                rhs.cmp(&lhs)\n            } else {\n                lhs.cmp(&rhs)\n            };\n            if primary != Ordering::Equal {\n                return primary;\n            }\n            a.name\n                .to_lowercase()\n                .cmp(&b.name.to_lowercase())\n                .then(a.path.to_lowercase().cmp(&b.path.to_lowercase()))\n        }\n        _ => {\n            let lhs_name = a.name.to_lowercase();\n            let rhs_name = b.name.to_lowercase();\n            let primary = if sort_dir == \"desc\" {\n                rhs_name.cmp(&lhs_name)\n            } else {\n                lhs_name.cmp(&rhs_name)\n            };\n\n            if primary != Ordering::Equal {\n                return primary;\n            }\n\n            let lhs_path = a.path.to_lowercase();\n            let rhs_path = b.path.to_lowercase();\n            if sort_dir == \"desc\" {\n                rhs_path.cmp(&lhs_path)\n            } else {\n                lhs_path.cmp(&rhs_path)\n            }\n        }\n    }\n}\n\nfn relevance_rank(entry: &EntryDto, query_lower: &str, path_suffix: &str) -> u8 {\n    if query_lower.is_empty() {\n        return 255;\n    }\n\n    let name = entry.name.to_lowercase();\n    let path = entry.path.to_lowercase();\n\n    if name == query_lower {\n        return 0;\n    }\n    if name.starts_with(query_lower) {\n        return 1;\n    }\n    if name.contains(query_lower) {\n        return 2;\n    }\n    if path.ends_with(path_suffix) {\n        return 3;\n    }\n    if path.contains(query_lower) {\n        return 4;\n    }\n\n    5\n}\n\nfn path_depth(path: &str) -> usize {\n    Path::new(path).components().count()\n}\n\npub fn sort_entries(entries: &mut Vec<EntryDto>, sort_by: &str, sort_dir: &str) {\n    entries.sort_by(|a, b| entry_cmp(a, b, sort_by, sort_dir));\n}\n\nfn sort_entries_with_relevance(\n    entries: &mut Vec<EntryDto>,\n    query: &str,\n    sort_by: &str,\n    sort_dir: &str,\n) {\n    let query_lower = query.trim().to_lowercase();\n    if query_lower.is_empty() {\n        sort_entries(entries, sort_by, sort_dir);\n        return;\n    }\n    let path_suffix = format!(\"/{query_lower}\");\n\n    entries.sort_by(|a, b| {\n        let ra = relevance_rank(a, &query_lower, &path_suffix);\n        let rb = relevance_rank(b, &query_lower, &path_suffix);\n        if ra != rb {\n            return ra.cmp(&rb);\n        }\n\n        // For highly-relevant matches, prefer shallower paths first\n        // so `~/name` ranks above deep descendants with the same name.\n        if ra <= 3 {\n            let da = path_depth(&a.path);\n            let db = path_depth(&b.path);\n            if da != db {\n                return da.cmp(&db);\n            }\n        }\n\n        entry_cmp(a, b, sort_by, sort_dir)\n    });\n}\n\nfn filter_ignored_entries(\n    entries: Vec<EntryDto>,\n    ignored_roots: &[PathBuf],\n    ignored_patterns: &[IgnorePattern],\n) -> Vec<EntryDto> {\n    entries\n        .into_iter()\n        .filter(|entry| !should_skip_path(Path::new(&entry.path), ignored_roots, ignored_patterns))\n        .collect()\n}\n\nfn find_search(\n    home_dir: &Path,\n    ignored_roots: &[PathBuf],\n    ignored_patterns: &[IgnorePattern],\n    query: &str,\n    limit: usize,\n    sort_by: &str,\n    sort_dir: &str,\n) -> Vec<EntryDto> {\n    let trimmed = query.trim();\n    if trimmed.is_empty() || limit == 0 {\n        return Vec::new();\n    }\n\n    let mut search_root = home_dir.to_path_buf();\n    let mut dir_filter_pattern: Option<String> = None;\n    let mut name_filter_pattern: Option<String> = None;\n    let mut name_filter_glob = false;\n\n    if trimmed.contains('/') {\n        let last_slash = trimmed.rfind('/').unwrap();\n        let dir_part = trimmed[..last_slash].trim();\n        let name_part = trimmed[last_slash + 1..].trim();\n\n        if !dir_part.is_empty() {\n            let mut hinted = if dir_part == \"~\" {\n                Some(home_dir.to_path_buf())\n            } else if let Some(rest) = dir_part.strip_prefix(\"~/\") {\n                Some(home_dir.join(rest))\n            } else {\n                let p = PathBuf::from(dir_part);\n                if p.is_absolute() {\n                    Some(p)\n                } else if !dir_part.contains('*')\n                    && !dir_part.contains('?')\n                    && !dir_part.contains('[')\n                {\n                    Some(home_dir.join(dir_part))\n                } else {\n                    None\n                }\n            };\n\n            if let Some(path) = hinted.take() {\n                if path.exists() && path.is_dir() {\n                    search_root = path;\n                } else {\n                    dir_filter_pattern = Some(format!(\"*{}/*\", dir_part));\n                }\n            } else {\n                dir_filter_pattern = Some(format!(\"*{}/*\", dir_part));\n            }\n        }\n\n        if !name_part.is_empty() {\n            if name_part.contains('*') || name_part.contains('?') {\n                name_filter_pattern = Some(name_part.to_string());\n                name_filter_glob = true;\n            } else {\n                name_filter_pattern = Some(format!(\"*{}*\", name_part));\n            }\n        }\n    } else if trimmed.contains('*') || trimmed.contains('?') {\n        name_filter_pattern = Some(trimmed.to_string());\n        name_filter_glob = true;\n    } else {\n        name_filter_pattern = Some(format!(\"*{}*\", trimmed));\n    }\n\n    let mut cmd = Command::new(\"find\");\n    cmd.arg(&search_root);\n\n    if search_root == home_dir {\n        cmd.args([\"-maxdepth\", \"8\"]);\n    }\n\n    if let Some(dir_pattern) = dir_filter_pattern.as_deref() {\n        cmd.args([\"-ipath\", dir_pattern]);\n    }\n    if let Some(name_pattern) = name_filter_pattern.as_deref() {\n        cmd.args([\"-iname\", name_pattern]);\n    }\n    if name_filter_glob {\n        cmd.args([\"-type\", \"f\"]);\n    }\n\n    cmd.args([\"!\", \"-path\", \"*/.git/*\"])\n        .args([\"!\", \"-path\", \"*/node_modules/*\"])\n        .args([\"!\", \"-path\", \"*/.Trash/*\"])\n        .args([\"!\", \"-path\", \"*/.Trashes/*\"])\n        .args([\"!\", \"-path\", \"*/Library/Caches/*\"])\n        .stdout(Stdio::piped())\n        .stderr(Stdio::null());\n\n    let mut child = match cmd.spawn() {\n        Ok(c) => c,\n        Err(_) => return Vec::new(),\n    };\n\n    let stdout = match child.stdout.take() {\n        Some(s) => s,\n        None => return Vec::new(),\n    };\n\n    let reader = BufReader::new(stdout);\n    let mut entries = Vec::with_capacity(limit);\n\n    for line in reader.lines() {\n        let Ok(line) = line else { continue };\n        let path = PathBuf::from(&line);\n        if should_skip_path(&path, ignored_roots, ignored_patterns) {\n            continue;\n        }\n\n        if let Some(entry) = entry_from_path(&path) {\n            entries.push(entry);\n            if entries.len() >= limit {\n                break;\n            }\n        }\n    }\n\n    let _ = child.kill();\n    let _ = child.wait();\n\n    sort_entries_with_relevance(&mut entries, trimmed, sort_by, sort_dir);\n    entries\n}\n\npub(crate) fn upsert_rows(conn: &mut Connection, rows: &[IndexRow]) -> AppResult<usize> {\n    if rows.is_empty() {\n        return Ok(0);\n    }\n\n    let tx = conn.transaction().map_err(|e| e.to_string())?;\n    {\n        let mut stmt = tx\n            .prepare(\n                r#\"\n                INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n                VALUES(?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)\n                ON CONFLICT(path) DO UPDATE SET\n                  name = excluded.name,\n                  dir = excluded.dir,\n                  is_dir = excluded.is_dir,\n                  ext = excluded.ext,\n                  mtime = excluded.mtime,\n                  size = excluded.size,\n                  indexed_at = excluded.indexed_at,\n                  run_id = excluded.run_id\n                \"#,\n            )\n            .map_err(|e| e.to_string())?;\n\n        for row in rows {\n            stmt.execute(params![\n                row.path,\n                row.name,\n                row.dir,\n                row.is_dir,\n                row.ext,\n                row.mtime,\n                row.size,\n                row.indexed_at,\n                row.run_id\n            ])\n            .map_err(|e| e.to_string())?;\n        }\n    }\n    tx.commit().map_err(|e| e.to_string())?;\n    Ok(rows.len())\n}\n\npub(crate) fn delete_paths(conn: &mut Connection, raw_paths: &[String]) -> AppResult<usize> {\n    if raw_paths.is_empty() {\n        return Ok(0);\n    }\n\n    let tx = conn.transaction().map_err(|e| e.to_string())?;\n    let mut deleted = 0;\n\n    {\n        let mut stmt_exact = tx\n            .prepare(\"DELETE FROM entries WHERE path = ?1\")\n            .map_err(|e| e.to_string())?;\n        let mut stmt_children = tx\n            .prepare(\"DELETE FROM entries WHERE path >= ?1 AND path < ?2\")\n            .map_err(|e| e.to_string())?;\n\n        for path in raw_paths {\n            let is_root = path == \"/\" || path == \"\\\\\";\n            let normalized = if is_root {\n                path.clone()\n            } else {\n                path.trim_end_matches(&['/', '\\\\'][..]).to_string()\n            };\n\n            if normalized.is_empty() {\n                continue;\n            }\n\n            if is_root {\n                deleted += tx\n                    .execute(\"DELETE FROM entries\", [])\n                    .map_err(|e| e.to_string())?;\n                continue;\n            }\n\n            deleted += stmt_exact\n                .execute(params![&normalized])\n                .map_err(|e| e.to_string())?;\n\n            // Delete children using B-tree range scan: path >= \"{normalized}{sep}\" AND path < \"{normalized}\\x7F\"\n            // \\x7F (127) is higher than both '/' (47) and '\\' (92), so this captures all children.\n            let sep = std::path::MAIN_SEPARATOR;\n            let range_start = format!(\"{normalized}{sep}\");\n            let range_end = format!(\"{normalized}\\x7F\");\n            deleted += stmt_children\n                .execute(params![&range_start, &range_end])\n                .map_err(|e| e.to_string())?;\n        }\n    }\n\n    tx.commit().map_err(|e| e.to_string())?;\n    Ok(deleted)\n}\n\npub(crate) fn emit_index_state(app: &AppHandle, state: &str, message: Option<String>) {\n    let is_catchup = message.as_ref().map_or(false, |m| m.starts_with(\"Catchup:\"));\n    let _ = app.emit(\n        \"index_state\",\n        IndexStateEvent {\n            state: state.to_string(),\n            message,\n            is_catchup,\n        },\n    );\n}\n\npub(crate) fn emit_index_updated(\n    app: &AppHandle,\n    entries_count: u64,\n    last_updated: i64,\n    permission_errors: u64,\n) {\n    let _ = app.emit(\n        \"index_updated\",\n        IndexUpdatedEvent {\n            entries_count,\n            last_updated,\n            permission_errors,\n        },\n    );\n}\n\npub(crate) fn emit_index_progress(app: &AppHandle, scanned: u64, indexed: u64, current_path: String) {\n    let _ = app.emit(\n        \"index_progress\",\n        IndexProgressEvent {\n            scanned,\n            indexed,\n            current_path,\n        },\n    );\n}\n\npub(crate) fn set_state(state: &AppState, next: IndexState, message: Option<String>) {\n    let mut status = state.status.lock();\n    status.state = next;\n    status.message = message;\n}\n\npub(crate) fn set_progress(state: &AppState, scanned: u64, indexed: u64, current_path: &str) {\n    let mut status = state.status.lock();\n    status.scanned = scanned;\n    status.indexed = indexed;\n    status.current_path = current_path.to_string();\n}\n\nfn emit_status_counts(app: &AppHandle, state: &AppState) {\n    let status = state.status.lock();\n    emit_index_updated(\n        app,\n        status.entries_count,\n        status.last_updated.unwrap_or_else(now_epoch),\n        status.permission_errors,\n    );\n}\n\npub(crate) fn refresh_and_emit_status_counts(app: &AppHandle, state: &AppState) -> AppResult<()> {\n    let (entries_count, last_updated) = update_status_counts(state)?;\n    // Persist cached counts so next startup can read them instantly\n    if let Ok(conn) = db_connection(&state.db_path) {\n        let _ = set_meta(&conn, \"cached_entries_count\", &entries_count.to_string());\n        if let Some(lu) = last_updated {\n            let _ = set_meta(&conn, \"cached_last_updated\", &lu.to_string());\n        }\n    }\n    emit_status_counts(app, state);\n    Ok(())\n}\n\n/// Load cached entries count from meta table (instant) and emit Ready state + counts.\n/// Used on Windows startup paths where the index is already complete from a prior run.\n#[cfg(target_os = \"windows\")]\npub(crate) fn set_ready_with_cached_counts(app: &AppHandle, state: &AppState) {\n    let (count, last_updated) = db_connection(&state.db_path)\n        .ok()\n        .map(|conn| {\n            let c = get_meta(&conn, \"cached_entries_count\")\n                .and_then(|v| v.parse::<u64>().ok())\n                .unwrap_or(0);\n            let lu = get_meta(&conn, \"cached_last_updated\")\n                .and_then(|v| v.parse::<i64>().ok());\n            (c, lu)\n        })\n        .unwrap_or((0, None));\n\n    {\n        let mut status = state.status.lock();\n        status.state = IndexState::Ready;\n        status.entries_count = count;\n        status.last_updated = last_updated;\n    }\n\n    emit_index_state(app, \"Ready\", None);\n    emit_index_updated(app, count, last_updated.unwrap_or_else(now_epoch), 0);\n}\n\n#[cfg(target_os = \"macos\")]\nfn touch_status_updated(state: &AppState) {\n    state.status.lock().last_updated = Some(now_epoch());\n}\n\n#[cfg(not(target_os = \"windows\"))]\npub(crate) fn start_full_index_worker(app: AppHandle, state: AppState) -> AppResult<()> {\n    start_full_index_worker_inner(app, state, false)\n}\n\n#[cfg(target_os = \"windows\")]\npub(crate) fn start_full_index_worker_silent(app: AppHandle, state: AppState) -> AppResult<()> {\n    start_full_index_worker_inner(app, state, true)\n}\n\nfn start_full_index_worker_inner(app: AppHandle, state: AppState, silent: bool) -> AppResult<()> {\n    if state\n        .indexing_active\n        .compare_exchange(false, true, AtomicOrdering::AcqRel, AtomicOrdering::Acquire)\n        .is_err()\n    {\n        perf_log(\"index_start_skipped already_active=true\");\n        return Ok(());\n    }\n\n    // Mark index as incomplete -- cleared when run_incremental_index succeeds\n    if let Ok(c) = db_connection(&state.db_path) {\n        let _ = set_meta(&c, \"index_complete\", \"0\");\n    }\n\n    if !silent {\n        {\n            let mut status = state.status.lock();\n            status.state = IndexState::Indexing;\n            status.message = None;\n            status.scanned = 0;\n            status.indexed = 0;\n            status.current_path.clear();\n        }\n\n        emit_index_state(&app, \"Indexing\", None);\n        perf_log(\"index_state=Indexing\");\n    } else {\n        perf_log(\"index_start silent=true (background reindex)\");\n    }\n\n    std::thread::spawn(move || {\n        let result = run_incremental_index(&app, &state);\n        if let Err(ref err) = result {\n            eprintln!(\"[index] run_incremental_index failed: {err}\");\n            if !silent {\n                set_state(&state, IndexState::Error, Some(err.clone()));\n                emit_index_state(&app, \"Error\", Some(err.clone()));\n            }\n            // Silent mode: keep Ready state, just log the error\n        }\n        state.indexing_active.store(false, AtomicOrdering::Release);\n    });\n\n    Ok(())\n}\n\nfn is_deferred_dir(path: &Path, home_dir: &Path) -> bool {\n    path.parent() == Some(home_dir)\n        && path\n            .file_name()\n            .and_then(|n| n.to_str())\n            .map(|name| DEFERRED_DIR_NAMES.contains(&name))\n            .unwrap_or(false)\n}\n\nfn preload_existing_entries(\n    conn: &Connection,\n    dir_prefix: &str,\n) -> HashMap<String, (Option<i64>, Option<i64>)> {\n    let like_pattern = format!(\"{}/%\", escape_like(dir_prefix));\n    let mut stmt = match conn.prepare(\n        \"SELECT path, mtime, size FROM entries WHERE path LIKE ?1 ESCAPE '\\\\' OR path = ?2\",\n    ) {\n        Ok(s) => s,\n        Err(_) => return HashMap::new(),\n    };\n\n    let mut map = HashMap::new();\n    let rows = match stmt.query_map(params![like_pattern, dir_prefix], |row| {\n        Ok((\n            row.get::<_, String>(0)?,\n            row.get::<_, Option<i64>>(1)?,\n            row.get::<_, Option<i64>>(2)?,\n        ))\n    }) {\n        Ok(r) => r,\n        Err(_) => return map,\n    };\n\n    for row in rows.flatten() {\n        map.insert(row.0, (row.1, row.2));\n    }\n    map\n}\n\nfn stamp_run_id_batch(conn: &mut Connection, paths: &[String], run_id: i64) -> AppResult<()> {\n    if paths.is_empty() {\n        return Ok(());\n    }\n\n    let tx = conn.transaction().map_err(|e| e.to_string())?;\n    {\n        let mut stmt = tx\n            .prepare(\"UPDATE entries SET run_id = ?1 WHERE path = ?2\")\n            .map_err(|e| e.to_string())?;\n        for path in paths {\n            stmt.execute(params![run_id, path])\n                .map_err(|e| e.to_string())?;\n        }\n    }\n    tx.commit().map_err(|e| e.to_string())?;\n    Ok(())\n}\n\nfn run_incremental_index(app: &AppHandle, state: &AppState) -> AppResult<()> {\n    let started = Instant::now();\n    perf_log(format!(\n        \"index_run_start home={} db={}\",\n        state.home_dir.to_string_lossy(),\n        state.db_path.to_string_lossy(),\n    ));\n\n    let mut conn = db_connection(&state.db_path)?;\n    set_indexing_pragmas(&conn)?;\n\n    let result = run_incremental_index_inner(app, state, &mut conn);\n\n    let _ = conn.execute_batch(\"ANALYZE\");\n    let _ = restore_normal_pragmas(&conn);\n\n    match &result {\n        Ok(_) => {\n            let _ = set_meta(&conn, \"index_complete\", \"1\");\n            let snapshot = state.status.lock().clone();\n            perf_log(format!(\n                \"index_run_done elapsed_ms={} scanned={} indexed={} entries={} permission_errors={} message={:?}\",\n                started.elapsed().as_millis(),\n                snapshot.scanned,\n                snapshot.indexed,\n                snapshot.entries_count,\n                snapshot.permission_errors,\n                snapshot.message,\n            ));\n        }\n        Err(err) => {\n            perf_log(format!(\n                \"index_run_error elapsed_ms={} err={}\",\n                started.elapsed().as_millis(),\n                err,\n            ));\n        }\n    }\n\n    result\n}\n\nfn run_incremental_index_inner(\n    app: &AppHandle,\n    state: &AppState,\n    conn: &mut Connection,\n) -> AppResult<()> {\n\n    let (runtime_ignored_roots, runtime_ignored_patterns) = effective_ignore_rules(\n        &state.home_dir,\n        &state.cwd,\n        state.path_ignores.as_ref(),\n        state.path_ignore_patterns.as_ref(),\n    );\n    let gi_filter = state.gitignore.get();\n\n    let last_run_id: i64 = get_meta(conn, \"last_run_id\")\n        .and_then(|v| v.parse().ok())\n        .unwrap_or(0);\n    let current_run_id = last_run_id + 1;\n    // Fresh index: DB was empty, skip preload/stamp, single unlimited-depth pass\n    let is_fresh = last_run_id == 0;\n\n    let mut scanned: u64 = 0;\n    let mut indexed: u64 = 0;\n    let mut permission_errors: u64 = 0;\n    let mut current_path = String::new();\n    let mut batch: Vec<IndexRow> = Vec::with_capacity(BATCH_SIZE);\n    let mut stamp_batch: Vec<String> = Vec::with_capacity(BATCH_SIZE);\n    let mut last_emit = Instant::now();\n    let mut last_perf_emit = Instant::now();\n\n    // Preload scan_root-level entries (direct children only, not recursive)\n    let scan_str = state.scan_root.to_string_lossy().to_string();\n    let root_existing = preload_existing_entries(conn, &scan_str);\n\n    // Index scan_root itself\n    if let Some(mut row) = index_row_from_path(&state.scan_root) {\n        scanned += 1;\n        row.run_id = current_run_id;\n        if let Some((old_mtime, old_size)) = root_existing.get(&row.path) {\n            if *old_mtime == row.mtime && *old_size == row.size {\n                stamp_batch.push(row.path);\n            } else {\n                batch.push(row);\n            }\n        } else {\n            batch.push(row);\n        }\n    }\n\n    // Partition direct children into priority vs deferred\n    let mut priority_roots: Vec<PathBuf> = Vec::new();\n    let mut deferred_roots: Vec<PathBuf> = Vec::new();\n\n    if let Ok(entries) = fs::read_dir(&state.scan_root) {\n        for dir_entry in entries.flatten() {\n            let child_path = dir_entry.path();\n\n            if should_skip_path_ext(\n                &child_path,\n                &runtime_ignored_roots,\n                &runtime_ignored_patterns,\n                Some(&gi_filter),\n                None,\n            ) {\n                continue;\n            }\n\n            scanned += 1;\n            current_path = child_path.to_string_lossy().to_string();\n\n            if let Some(mut row) = index_row_from_path(&child_path) {\n                row.run_id = current_run_id;\n                if let Some((old_mtime, old_size)) = root_existing.get(&row.path) {\n                    if *old_mtime == row.mtime && *old_size == row.size {\n                        stamp_batch.push(row.path);\n                    } else {\n                        batch.push(row);\n                    }\n                } else {\n                    batch.push(row);\n                }\n            }\n\n            if child_path.is_dir() {\n                if is_deferred_dir(&child_path, &state.scan_root) {\n                    deferred_roots.push(child_path);\n                } else {\n                    priority_roots.push(child_path);\n                }\n            }\n        }\n    }\n\n\n    // Flush home-level stamp batch\n    if stamp_batch.len() >= BATCH_SIZE {\n        stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n        stamp_batch.clear();\n    }\n\n    priority_roots.sort();\n    deferred_roots.sort();\n\n    let roots: Vec<PathBuf> = priority_roots.into_iter().chain(deferred_roots).collect();\n    perf_log(format!(\n        \"index_scan_roots total={} priority+deferred\",\n        roots.len()\n    ));\n\n    // 2-pass indexing: shallow first (depth <= SHALLOW_SCAN_DEPTH), then deep\n    // Both passes use jwalk for parallel scanning\n    let arc_ignored_roots = Arc::new(runtime_ignored_roots.clone());\n    let arc_ignored_patterns = Arc::new(runtime_ignored_patterns.clone());\n\n\n    for pass in 0..2u8 {\n        // Fresh index: single unlimited-depth pass -- avoids double filesystem traversal\n        if pass == 1 && is_fresh {\n            break;\n        }\n        let pass_label = if pass == 0 { \"shallow\" } else { \"deep\" };\n        let pass_started = Instant::now();\n        let mut pass_scanned = 0u64;\n        let mut pass_indexed = 0u64;\n\n        for root in &roots {\n            let root_started = Instant::now();\n            let mut root_scanned = 0u64;\n            let mut root_indexed = 0u64;\n            let mut root_permission_errors = 0u64;\n            let root_str = root.to_string_lossy().to_string();\n\n            // Fresh index: DB is empty, preload is unnecessary\n            let existing = if is_fresh {\n                HashMap::new()\n            } else {\n                let e = preload_existing_entries(conn, &root_str);\n                e\n            };\n\n            let gi_ref = gi_filter.clone();\n            let skip_roots = arc_ignored_roots.clone();\n            let skip_patterns = arc_ignored_patterns.clone();\n\n            let mut builder = jwalk::WalkDir::new(root)\n                .follow_links(false)\n                .skip_hidden(false)\n                .parallelism(jwalk::Parallelism::RayonNewPool(jwalk_num_threads()));\n            // Fresh index: no depth limit -- walk everything in one pass\n            if pass == 0 && !is_fresh {\n                builder = builder.max_depth(SHALLOW_SCAN_DEPTH);\n            }\n            let walker = builder.process_read_dir(move |_depth, path, _state, children| {\n                children.retain(|entry_result| {\n                    entry_result\n                        .as_ref()\n                        .map(|entry| {\n                            let full_path = path.join(&entry.file_name);\n                            let is_dir = Some(entry.file_type.is_dir());\n                            !should_skip_path_ext(\n                                &full_path,\n                                &skip_roots,\n                                &skip_patterns,\n                                Some(&gi_ref),\n                                is_dir,\n                            )\n                        })\n                        .unwrap_or(false)\n                });\n            });\n\n            for result in walker {\n                match result {\n                    Ok(entry) => {\n                        let path = entry.path();\n                        if path == root.as_path() {\n                            continue;\n                        }\n\n                        // Pass 1 (incremental only): skip shallow entries already indexed in pass 0\n                        if pass == 1 && entry.depth <= SHALLOW_SCAN_DEPTH {\n                            continue;\n                        }\n\n                        scanned += 1;\n                        root_scanned += 1;\n                        current_path = path.to_string_lossy().to_string();\n\n                        if let Some(mut row) = index_row_from_jwalk_entry(&entry) {\n                            row.run_id = current_run_id;\n                            if is_fresh {\n                                // Fresh index: all entries are new, skip existing check\n                                indexed += 1;\n                                root_indexed += 1;\n                                batch.push(row);\n                            } else if let Some((old_mtime, old_size)) = existing.get(&row.path) {\n                                if *old_mtime == row.mtime && *old_size == row.size {\n                                    stamp_batch.push(row.path);\n                                } else {\n                                    indexed += 1;\n                                    root_indexed += 1;\n                                    batch.push(row);\n                                }\n                            } else {\n                                indexed += 1;\n                                root_indexed += 1;\n                                batch.push(row);\n                            }\n                        }\n\n                        if batch.len() >= BATCH_SIZE {\n                            upsert_rows(conn, &batch)?;\n                            batch.clear();\n                        }\n\n                        if stamp_batch.len() >= BATCH_SIZE {\n                            stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n                            stamp_batch.clear();\n                        }\n\n                        if last_emit.elapsed() >= Duration::from_millis(200) {\n                            set_progress(state, scanned, indexed, &current_path);\n                            emit_index_progress(app, scanned, indexed, current_path.clone());\n                            last_emit = Instant::now();\n                        }\n                        if perf_log_enabled() && last_perf_emit.elapsed() >= Duration::from_secs(1)\n                        {\n                            perf_log(format!(\n                                \"index_progress pass={} scanned={} indexed={} current_path={}\",\n                                pass_label, scanned, indexed, current_path\n                            ));\n                            last_perf_emit = Instant::now();\n                        }\n                    }\n                    Err(err) => {\n                        scanned += 1;\n                        root_scanned += 1;\n                        permission_errors += 1;\n                        root_permission_errors += 1;\n                        if permission_errors <= 20 || perf_log_enabled() {\n                            eprintln!(\"[index] permission error: {}\", err);\n                        }\n                    }\n                }\n            }\n\n            pass_scanned += root_scanned;\n            pass_indexed += root_indexed;\n\n            eprintln!(\"[timing]   walk_{} {} {}ms scanned={} indexed={} err={}\",\n                pass_label, root_str, root_started.elapsed().as_millis(),\n                root_scanned, root_indexed, root_permission_errors);\n            perf_log(format!(\n                \"index_root_done pass={} root={} elapsed_ms={} scanned={} indexed={} permission_errors={}\",\n                pass_label,\n                root.to_string_lossy(),\n                root_started.elapsed().as_millis(),\n                root_scanned,\n                root_indexed,\n                root_permission_errors,\n            ));\n        }\n\n        // Flush between passes\n        if !batch.is_empty() {\n            upsert_rows(conn, &batch)?;\n            batch.clear();\n        }\n        if !stamp_batch.is_empty() {\n            stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n            stamp_batch.clear();\n        }\n\n        perf_log(format!(\n            \"index_pass_done pass={} elapsed_ms={} scanned={} indexed={}\",\n            pass_label,\n            pass_started.elapsed().as_millis(),\n            pass_scanned,\n            pass_indexed,\n        ));\n\n        // After shallow pass (incremental only), emit progress so UI shows searchable state early\n        // Fresh index uses per-root emit above instead.\n        if pass == 0 && !is_fresh {\n            let _ = refresh_and_emit_status_counts(app, state);\n            let _ = app.emit(\n                \"index_updated\",\n                IndexUpdatedEvent {\n                    entries_count: state.status.lock().entries_count,\n                    last_updated: now_epoch(),\n                    permission_errors,\n                },\n            );\n        }\n    }\n\n    if !batch.is_empty() {\n        upsert_rows(conn, &batch)?;\n    }\n\n    if !stamp_batch.is_empty() {\n        stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n    }\n\n    set_progress(state, scanned, indexed, &current_path);\n    emit_index_progress(app, scanned, indexed, current_path.clone());\n\n    // Remove entries not seen in this run (deleted files)\n    // Fresh index: DB was empty before this run, no stale entries possible\n    let deleted_count: i64 = if is_fresh {\n        0\n    } else {\n        let count = conn\n            .query_row(\n                \"SELECT COUNT(*) FROM entries WHERE run_id < ?1\",\n                params![current_run_id],\n                |row| row.get(0),\n            )\n            .unwrap_or(0);\n        conn.execute(\n            \"DELETE FROM entries WHERE run_id < ?1\",\n            params![current_run_id],\n        )\n        .map_err(|e| e.to_string())?;\n        count\n    };\n\n    set_meta(conn, \"last_run_id\", &current_run_id.to_string())?;\n\n    if deleted_count > 0 || indexed > 0 {\n        invalidate_search_caches(state);\n    }\n\n    let (entries_count, last_updated) = update_status_counts(state)?;\n    // Persist cached counts for instant startup next time\n    let _ = set_meta(conn, \"cached_entries_count\", &entries_count.to_string());\n    if let Some(lu) = last_updated {\n        let _ = set_meta(conn, \"cached_last_updated\", &lu.to_string());\n    }\n    let updated_at = last_updated.unwrap_or_else(now_epoch);\n\n    {\n        let mut status = state.status.lock();\n        status.state = IndexState::Ready;\n        status.permission_errors = permission_errors;\n        status.scanned = scanned;\n        status.indexed = indexed;\n        status.current_path = current_path.clone();\n        status.message = if permission_errors > 0 {\n            Some(format!(\n                \"{} permission/access error(s) occurred.\",\n                permission_errors\n            ))\n        } else {\n            None\n        };\n    }\n    emit_index_progress(app, scanned, indexed, current_path);\n    emit_index_updated(app, entries_count, updated_at, permission_errors);\n    emit_index_state(\n        app,\n        \"Ready\",\n        if permission_errors > 0 {\n            Some(format!(\"{} permission/access error(s)\", permission_errors))\n        } else {\n            None\n        },\n    );\n    perf_log(format!(\n        \"index_state=Ready scanned={} indexed={} deleted={} entries={} permission_errors={}\",\n        scanned, indexed, deleted_count, entries_count, permission_errors\n    ));\n\n    Ok(())\n}\n\nfn trim_recent_ops(ops: &mut Vec<RecentOp>) {\n    let now = Instant::now();\n    ops.retain(|op| now.duration_since(op.at) <= RECENT_OP_TTL);\n}\n\nfn remember_op(\n    state: &AppState,\n    op_type: &'static str,\n    old_path: Option<String>,\n    new_path: Option<String>,\n) {\n    let mut ops = state.recent_ops.lock();\n    trim_recent_ops(&mut ops);\n    ops.push(RecentOp {\n        old_path,\n        new_path,\n        op_type,\n        at: Instant::now(),\n    });\n}\n\n#[cfg(any(target_os = \"macos\", target_os = \"windows\"))]\npub(crate) fn is_recently_touched(state: &AppState, path: &str) -> bool {\n    let mut ops = state.recent_ops.lock();\n    trim_recent_ops(&mut ops);\n\n    ops.iter().any(|op| match op.op_type {\n        \"rename\" | \"trash\" => {\n            op.old_path\n                .as_deref()\n                .map(|old| old == path)\n                .unwrap_or(false)\n                || op\n                    .new_path\n                    .as_deref()\n                    .map(|new| new == path)\n                    .unwrap_or(false)\n        }\n        _ => false,\n    })\n}\n\n#[cfg(target_os = \"macos\")]\nfn apply_path_changes(state: &AppState, paths: &[PathBuf]) -> AppResult<usize> {\n    let (ignored_roots, ignored_patterns) = cached_effective_ignore_rules(state);\n    let mut to_upsert_map: HashMap<String, IndexRow> = HashMap::new();\n    let mut to_delete = Vec::new();\n\n    for path in paths {\n        if should_skip_path(path, &ignored_roots, &ignored_patterns) {\n            continue;\n        }\n\n        let path_str = path.to_string_lossy().to_string();\n        if path_str.is_empty() {\n            continue;\n        }\n\n        if is_recently_touched(state, &path_str) {\n            continue;\n        }\n\n        match fs::symlink_metadata(path) {\n            Ok(metadata) => {\n                if let Some(row) = index_row_from_path_and_metadata(path, &metadata) {\n                    to_upsert_map.insert(row.path.clone(), row);\n                }\n            }\n            Err(_) => {\n                to_delete.push(path_str);\n            }\n        }\n    }\n\n    let to_upsert = to_upsert_map.into_values().collect::<Vec<_>>();\n\n    if to_upsert.is_empty() && to_delete.is_empty() {\n        return Ok(0);\n    }\n\n    let op_start = std::time::Instant::now();\n    let mut conn = db_connection(&state.db_path).map_err(|e| {\n        eprintln!(\n            \"[watcher] db_connection FAILED after {}ms: {} (upsert={} delete={} indexing_active={})\",\n            op_start.elapsed().as_millis(),\n            e,\n            to_upsert.len(),\n            to_delete.len(),\n            state.indexing_active.load(AtomicOrdering::Acquire)\n        );\n        e\n    })?;\n    let mut changed = 0;\n\n    changed += upsert_rows(&mut conn, &to_upsert)?;\n    changed += delete_paths(&mut conn, &to_delete)?;\n\n    Ok(changed)\n}\n\n#[cfg(target_os = \"macos\")]\nconst STATUS_EMIT_MIN_INTERVAL: Duration = Duration::from_secs(2);\n\n#[cfg(target_os = \"macos\")]\nconst DB_BUSY_RETRY_DELAY: Duration = Duration::from_secs(3);\n\n#[cfg(target_os = \"macos\")]\nfn process_watcher_paths(\n    app: &AppHandle,\n    state: &AppState,\n    pending: &mut HashSet<PathBuf>,\n    deadline: &mut Option<Instant>,\n    last_status_emit: &mut Instant,\n    pending_status_emit: &mut bool,\n) {\n    if pending.is_empty() {\n        return;\n    }\n\n    if state.indexing_active.load(AtomicOrdering::Acquire) {\n        return;\n    }\n\n    let mut batch: Vec<PathBuf> = pending.drain().collect();\n    batch.sort();\n\n    match apply_path_changes(state, &batch) {\n        Ok(changed) => {\n            *deadline = None;\n            if changed > 0 {\n                invalidate_search_caches(state);\n                touch_status_updated(state);\n                if last_status_emit.elapsed() >= STATUS_EMIT_MIN_INTERVAL {\n                    let _ = refresh_and_emit_status_counts(app, state);\n                    *last_status_emit = Instant::now();\n                    *pending_status_emit = false;\n                } else {\n                    *pending_status_emit = true;\n                }\n            }\n        }\n        Err(err) => {\n            let is_busy = err.contains(\"locked\") || err.contains(\"busy\");\n            if is_busy {\n                eprintln!(\n                    \"[watcher] DB busy, will retry in {}s: {} | batch_size={}\",\n                    DB_BUSY_RETRY_DELAY.as_secs(),\n                    err,\n                    batch.len()\n                );\n                for path in batch {\n                    pending.insert(path);\n                }\n                *deadline = Some(Instant::now() + DB_BUSY_RETRY_DELAY);\n                return;\n            }\n            eprintln!(\n                \"[watcher] process_watcher_paths ERROR: {} | batch_size={} indexing_active={}\",\n                err,\n                batch.len(),\n                state.indexing_active.load(AtomicOrdering::Acquire)\n            );\n            *deadline = None;\n            if state.indexing_active.load(AtomicOrdering::Acquire) {\n                return;\n            }\n            let mut status = state.status.lock();\n            if !matches!(status.state, IndexState::Indexing) {\n                status.state = IndexState::Error;\n            }\n            status.message = Some(format!(\"Watcher update failed: {err}\"));\n            drop(status);\n            emit_index_state(app, \"Error\", Some(format!(\"Watcher update failed: {err}\")));\n        }\n    }\n}\n\n#[cfg(target_os = \"macos\")]\nconst EVENT_ID_FLUSH_INTERVAL: Duration = Duration::from_secs(30);\n\n#[cfg(target_os = \"macos\")]\nfn persist_event_id(db_path: &Path, event_id: u64) -> AppResult<()> {\n    let conn = db_connection(db_path)?;\n    set_meta(&conn, \"last_event_id\", &event_id.to_string())\n}\n\n#[cfg(target_os = \"macos\")]\nconst MUST_SCAN_THRESHOLD: usize = 10;\n\n#[cfg(target_os = \"macos\")]\nfn start_fsevent_watcher_worker(\n    app: AppHandle,\n    state: AppState,\n    since_event_id: Option<u64>,\n    conditional: bool,\n) {\n    use std::sync::mpsc::{self, RecvTimeoutError};\n    std::thread::spawn(move || {\n        let (tx, rx) = mpsc::channel();\n\n        let mut watcher =\n            match mac::fsevent_watcher::FsEventWatcher::new(&state.home_dir, since_event_id, tx) {\n                Ok(w) => w,\n                Err(err) => {\n                    set_state(\n                        &state,\n                        IndexState::Error,\n                        Some(format!(\"FSEvents watcher initialization failed: {err}\")),\n                    );\n                    emit_index_state(\n                        &app,\n                        \"Error\",\n                        Some(format!(\"FSEvents watcher initialization failed: {err}\")),\n                    );\n                    return;\n                }\n            };\n\n        if conditional {\n            perf_log(\"conditional_startup: watcher started, awaiting history replay\");\n            set_state(&state, IndexState::Ready, None);\n            emit_index_state(&app, \"Ready\", None);\n        }\n\n        let mut pending_paths: HashSet<PathBuf> = HashSet::new();\n        let mut deadline: Option<Instant> = None;\n        let mut last_flush = Instant::now();\n        let mut last_status_emit = Instant::now();\n        let mut pending_status_emit = false;\n        let mut last_count_refresh = Instant::now();\n        let mut must_scan_count: usize = 0;\n        let mut replay_phase = conditional;\n        let mut full_scan_triggered = false;\n\n        loop {\n            let wait = match deadline {\n                Some(due) => {\n                    let now = Instant::now();\n                    if now >= due {\n                        Duration::from_millis(0)\n                    } else {\n                        due - now\n                    }\n                }\n                None => Duration::from_secs(1),\n            };\n            match rx.recv_timeout(wait) {\n                Ok(mac::fsevent_watcher::FsEvent::Paths(paths)) => {\n                    let (ignored_roots, ignored_patterns) = cached_effective_ignore_rules(&state);\n                    let prev_len = pending_paths.len();\n                    for path in paths {\n                        if !should_skip_path(&path, &ignored_roots, &ignored_patterns) {\n                            pending_paths.insert(path);\n                        }\n                    }\n                    if pending_paths.len() > prev_len {\n                        deadline = Some(Instant::now() + WATCH_DEBOUNCE);\n                    }\n                }\n                Ok(mac::fsevent_watcher::FsEvent::MustScanSubDirs(path)) => {\n                    must_scan_count += 1;\n                    if replay_phase\n                        && must_scan_count >= MUST_SCAN_THRESHOLD\n                        && !full_scan_triggered\n                    {\n                        perf_log(format!(\n                            \"conditional_startup: MustScanSubDirs={} >= threshold, triggering full scan\",\n                            must_scan_count\n                        ));\n                        full_scan_triggered = true;\n                        let _ = start_full_index_worker(app.clone(), state.clone());\n                    }\n                    if !state.indexing_active.load(AtomicOrdering::Acquire) {\n                        let (ignored_roots, ignored_patterns) =\n                            cached_effective_ignore_rules(&state);\n                        let rows = collect_rows_recursive(&path, &ignored_roots, &ignored_patterns);\n                        if !rows.is_empty() {\n                            eprintln!(\n                                \"[watcher] MustScanSubDirs DB write: rows={} path={}\",\n                                rows.len(),\n                                path.display()\n                            );\n                            if let Ok(mut conn) = db_connection(&state.db_path) {\n                                if upsert_rows(&mut conn, &rows).is_ok() {\n                                    invalidate_search_caches(&state);\n                                    touch_status_updated(&state);\n                                    if last_status_emit.elapsed() >= STATUS_EMIT_MIN_INTERVAL {\n                                        let _ = refresh_and_emit_status_counts(&app, &state);\n                                        last_status_emit = Instant::now();\n                                        pending_status_emit = false;\n                                    } else {\n                                        pending_status_emit = true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                Ok(mac::fsevent_watcher::FsEvent::HistoryDone) => {\n                    eprintln!(\n                        \"[watcher] HistoryDone: pending_paths={} indexing_active={}\",\n                        pending_paths.len(),\n                        state.indexing_active.load(AtomicOrdering::Acquire)\n                    );\n                    process_watcher_paths(\n                        &app,\n                        &state,\n                        &mut pending_paths,\n                        &mut deadline,\n                        &mut last_status_emit,\n                        &mut pending_status_emit,\n                    );\n                    if replay_phase {\n                        replay_phase = false;\n                        if !full_scan_triggered {\n                            perf_log(format!(\n                                \"conditional_startup: HistoryDone, MustScanSubDirs={}, skipping full scan\",\n                                must_scan_count\n                            ));\n                            let _ = refresh_and_emit_status_counts(&app, &state);\n                            last_status_emit = Instant::now();\n                            pending_status_emit = false;\n                        }\n                    }\n                }\n                Err(RecvTimeoutError::Timeout) => {}\n                Err(RecvTimeoutError::Disconnected) => break,\n            }\n\n            if let Some(due) = deadline {\n                if Instant::now() >= due {\n                    process_watcher_paths(\n                        &app,\n                        &state,\n                        &mut pending_paths,\n                        &mut deadline,\n                        &mut last_status_emit,\n                        &mut pending_status_emit,\n                    );\n                }\n            }\n\n            if pending_status_emit && last_status_emit.elapsed() >= STATUS_EMIT_MIN_INTERVAL {\n                let _ = refresh_and_emit_status_counts(&app, &state);\n                last_status_emit = Instant::now();\n                pending_status_emit = false;\n            }\n\n            // Periodic event_id flush\n            if last_flush.elapsed() >= EVENT_ID_FLUSH_INTERVAL {\n                let eid = watcher.last_event_id();\n                let _ = persist_event_id(&state.db_path, eid);\n                last_flush = Instant::now();\n            }\n\n            // Periodic count refresh to keep in-memory counts accurate\n            if last_count_refresh.elapsed() >= EVENT_ID_FLUSH_INTERVAL {\n                let _ = update_status_counts(&state);\n                last_count_refresh = Instant::now();\n            }\n        }\n\n        // Final flush on shutdown\n        let eid = watcher.last_event_id();\n        let _ = persist_event_id(&state.db_path, eid);\n        watcher.stop();\n    });\n}\n\nfn validate_new_name(new_name: &str) -> AppResult<String> {\n    let trimmed = new_name.trim();\n\n    if trimmed.is_empty() {\n        return Err(\"New name cannot be empty.\".to_string());\n    }\n    if trimmed.contains('/') {\n        return Err(\"New name cannot contain '/'.\".to_string());\n    }\n    if trimmed == \".\" || trimmed == \"..\" {\n        return Err(\"Invalid name.\".to_string());\n    }\n\n    Ok(trimmed.to_string())\n}\n\nfn row_to_entry(row: &rusqlite::Row<'_>) -> rusqlite::Result<EntryDto> {\n    Ok(EntryDto {\n        path: row.get(0)?,\n        name: row.get(1)?,\n        dir: row.get(2)?,\n        is_dir: row.get::<_, i64>(3)? == 1,\n        ext: row.get(4)?,\n        size: row.get(5)?,\n        mtime: row.get(6)?,\n    })\n}\n\n#[cfg(target_os = \"macos\")]\nfn safe_file_type(ext: &str) -> String {\n    if ext.eq_ignore_ascii_case(\"folder\") {\n        return \"public.folder\".to_string();\n    }\n\n    let filtered: String = ext\n        .chars()\n        .filter(|c| c.is_ascii_alphanumeric())\n        .collect::<String>()\n        .to_lowercase();\n\n    if filtered.is_empty() {\n        \"public.data\".to_string()\n    } else {\n        filtered\n    }\n}\n\n#[cfg(target_os = \"macos\")]\nfn load_system_icon_png(ext: &str) -> Option<Vec<u8>> {\n    let file_type = safe_file_type(ext);\n    let script = format!(\n        r#\"import AppKit\nimport Foundation\nlet image = NSWorkspace.shared.icon(forFileType: \"{file_type}\")\nimage.size = NSSize(width: 16, height: 16)\nif let tiff = image.tiffRepresentation,\n   let rep = NSBitmapImageRep(data: tiff),\n   let png = rep.representation(using: .png, properties: [:]) {{\n  FileHandle.standardOutput.write(png)\n}} else {{\n  exit(1)\n}}\n\"#\n    );\n\n    let output = Command::new(\"swift\").arg(\"-e\").arg(script).output().ok()?;\n    if output.status.success() && !output.stdout.is_empty() {\n        Some(output.stdout)\n    } else {\n        None\n    }\n}\n\n#[cfg(target_os = \"windows\")]\nfn load_system_icon_png(ext: &str) -> Option<Vec<u8>> {\n    win::icon::load_icon_png_by_ext(ext)\n}\n\n#[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\nfn load_system_icon_png(_ext: &str) -> Option<Vec<u8>> {\n    None\n}\n\n#[cfg(target_os = \"windows\")]\nfn is_per_file_icon_ext(ext: &str) -> bool {\n    matches!(ext, \"exe\" | \"lnk\" | \"ico\" | \"url\" | \"scr\" | \"appx\")\n}\n\n#[tauri::command]\nfn get_index_status(state: State<'_, AppState>) -> IndexStatusDto {\n    let started = Instant::now();\n    let snapshot = state.status.lock().clone();\n    let snapshot_state = snapshot.state.as_str().to_string();\n    let db_ready = state.db_ready.load(AtomicOrdering::Acquire);\n    let indexing_active = state.indexing_active.load(AtomicOrdering::Acquire);\n    let state_label = if matches!(snapshot.state, IndexState::Error) {\n        snapshot.state.as_str().to_string()\n    } else if matches!(snapshot.state, IndexState::Ready) {\n        \"Ready\".to_string()\n    } else if indexing_active || !db_ready {\n        \"Indexing\".to_string()\n    } else {\n        snapshot.state.as_str().to_string()\n    };\n    let dto = IndexStatusDto {\n        state: state_label,\n        entries_count: snapshot.entries_count,\n        last_updated: snapshot.last_updated,\n        permission_errors: snapshot.permission_errors,\n        message: snapshot.message,\n        scanned: snapshot.scanned,\n        indexed: snapshot.indexed,\n        current_path: snapshot.current_path,\n    };\n    if cfg!(debug_assertions) {\n        eprintln!(\n            \"[rpc/get_index_status] elapsed={}ms state={} snapshot_state={} db_ready={} indexing_active={} entries={} scanned={} indexed={}\",\n            started.elapsed().as_millis(),\n            dto.state,\n            snapshot_state,\n            db_ready,\n            indexing_active,\n            dto.entries_count,\n            dto.scanned,\n            dto.indexed,\n        );\n    }\n    dto\n}\n\n#[tauri::command]\nfn get_home_dir(state: State<'_, AppState>) -> String {\n    state.home_dir.to_string_lossy().to_string()\n}\n\n#[tauri::command]\nfn start_full_index(app: AppHandle, state: State<'_, AppState>) -> AppResult<()> {\n    #[cfg(target_os = \"windows\")]\n    {\n        win::start_windows_indexing(app, state.inner().clone());\n        Ok(())\n    }\n    #[cfg(not(target_os = \"windows\"))]\n    {\n        start_full_index_worker(app, state.inner().clone())\n    }\n}\n\n#[tauri::command]\nasync fn reset_index(app: AppHandle, state: State<'_, AppState>) -> AppResult<()> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        if state.indexing_active.load(AtomicOrdering::Acquire) {\n            return Err(\"Cannot reset while indexing is in progress.\".to_string());\n        }\n\n        // Stop existing file watcher and wait for it to fully exit\n        state.watcher_stop.store(true, AtomicOrdering::Release);\n        let deadline = std::time::Instant::now() + std::time::Duration::from_secs(5);\n        while state.watcher_active.load(AtomicOrdering::Acquire) {\n            if std::time::Instant::now() >= deadline {\n                eprintln!(\"[reset] watcher did not stop within 5s, proceeding anyway\");\n                break;\n            }\n            std::thread::sleep(std::time::Duration::from_millis(50));\n        }\n\n        let conn = db_connection(&state.db_path)?;\n        // Use synchronous=OFF + large cache to make the bulk DELETE fast\n        let _ = conn.execute_batch(\n            \"PRAGMA synchronous=OFF; PRAGMA cache_size=-131072;\",\n        );\n        conn.execute(\"DELETE FROM entries\", [])\n            .map_err(|e| e.to_string())?;\n        conn.execute(\"DELETE FROM meta\", [])\n            .map_err(|e| e.to_string())?;\n\n        {\n            let mut status = state.status.lock();\n            status.state = IndexState::Indexing;\n            status.entries_count = 0;\n            status.last_updated = None;\n            status.permission_errors = 0;\n            status.message = None;\n            status.scanned = 0;\n            status.indexed = 0;\n            status.current_path.clear();\n        }\n\n        invalidate_search_caches(&state);\n\n        emit_index_state(&app, \"Indexing\", None);\n        emit_index_updated(&app, 0, now_epoch(), 0);\n\n        // Allow new watcher to start\n        state.watcher_stop.store(false, AtomicOrdering::Release);\n\n        #[cfg(target_os = \"windows\")]\n        {\n            win::start_windows_indexing(app, state);\n            Ok(())\n        }\n        #[cfg(not(target_os = \"windows\"))]\n        {\n            start_full_index_worker(app, state)\n        }\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\nfn log_search(db_path: &Path, query: &str, mode: &str, results: &[EntryDto]) {\n    if !search_log_enabled() {\n        return;\n    }\n\n    let log_path = db_path.with_file_name(\"search.log\");\n    let Ok(mut f) = fs::OpenOptions::new()\n        .create(true)\n        .append(true)\n        .open(&log_path)\n    else {\n        return;\n    };\n    let top: Vec<&str> = results.iter().take(10).map(|e| e.name.as_str()).collect();\n    let _ = writeln!(\n        f,\n        \"[{}] Q={:?} MODE={} COUNT={} TOP={:?}\",\n        now_epoch(),\n        query,\n        mode,\n        results.len(),\n        top,\n    );\n}\n\nfn search_log_enabled() -> bool {\n    *SEARCH_LOG_ENABLED.get_or_init(|| env_truthy(\"FASTFIND_SEARCH_LOG\"))\n}\n\n/// Returns the total number of entries matching `query` without LIMIT/OFFSET.\n/// Returns `None` when the total is unknown or intentionally skipped.\nfn compute_total_count(\n    db_path: &Path,\n    home_dir: &Path,\n    execution: &SearchExecution,\n) -> Option<u32> {\n    // When fewer results than the limit were returned the total is exact.\n    if (execution.results.len() as u32) < execution.effective_limit {\n        return Some(\n            execution\n                .offset\n                .saturating_add(execution.results.len() as u32),\n        );\n    }\n    // For paginated pages after the first we leave total tracking to the frontend.\n    if execution.offset > 0 {\n        return None;\n    }\n    // Non-SQL fast paths already return all matching entries.\n    if execution.mode_label.starts_with(\"mem_\")\n        || execution.mode_label == \"spotlight\"\n        || execution.mode_label == \"spotlight_timeout\"\n        || execution.mode_label == \"find_fallback\"\n        || execution.mode_label == \"name_neg_cache\"\n    {\n        return Some(execution.results.len() as u32);\n    }\n    let Ok(conn) = db_connection_for_search(db_path) else {\n        return None;\n    };\n    let mode = parse_query(&execution.query);\n    let total = match mode {\n        SearchMode::Empty => conn\n            .query_row(\"SELECT COUNT(*) FROM entries\", [], |r| r.get(0))\n            .unwrap_or(0),\n        SearchMode::NameSearch { name_like } => {\n            let escaped = escape_like(&execution.query);\n            let prefix_like = format!(\"{}%\", escaped);\n            let prefix_count: u32 = conn\n                .query_row(\n                    \"SELECT COUNT(*) FROM entries WHERE name LIKE ?1 ESCAPE '\\\\'\",\n                    params![prefix_like],\n                    |r| r.get(0),\n                )\n                .unwrap_or(0);\n            if prefix_count > 0 {\n                prefix_count\n            } else {\n                // Phase-2 contains fallback was used.\n                conn.query_row(\n                    \"SELECT COUNT(*) FROM entries WHERE name LIKE ?1 ESCAPE '\\\\'\",\n                    params![name_like],\n                    |r| r.get(0),\n                )\n                .unwrap_or(0)\n            }\n        }\n        SearchMode::GlobName { name_like } => conn\n            .query_row(\n                \"SELECT COUNT(*) FROM entries WHERE name LIKE ?1 ESCAPE '\\\\'\",\n                params![name_like],\n                |r| r.get(0),\n            )\n            .unwrap_or(0),\n        SearchMode::ExtSearch { ext, .. } => conn\n            .query_row(\n                \"SELECT COUNT(*) FROM entries WHERE ext = ?1\",\n                params![ext],\n                |r| r.get(0),\n            )\n            .unwrap_or(0),\n        SearchMode::PathSearch {\n            name_like,\n            dir_hint,\n            ..\n        } => {\n            let resolved_dirs = resolve_dir_hint(home_dir, &dir_hint)\n                .map(|p| vec![p.to_string_lossy().to_string()])\n                .unwrap_or_default();\n            let resolved_dirs = if resolved_dirs.is_empty() {\n                resolve_dirs_from_db(&conn, &dir_hint)\n            } else {\n                resolved_dirs\n            };\n\n            if !resolved_dirs.is_empty() {\n                let mut sql_params: Vec<SqlValue> = Vec::new();\n                let mut dir_conditions = Vec::new();\n                let sep = std::path::MAIN_SEPARATOR;\n                for d in &resolved_dirs {\n                    let i = sql_params.len();\n                    let pfx = format!(\"{d}{sep}\");\n                    let pfx_end = format!(\"{d}\\x7F\");\n                    sql_params.push(SqlValue::Text(d.clone()));\n                    sql_params.push(SqlValue::Text(pfx));\n                    sql_params.push(SqlValue::Text(pfx_end));\n                    dir_conditions.push(format!(\n                        \"(e.dir = ?{} OR (e.dir >= ?{} AND e.dir < ?{}))\",\n                        i + 1,\n                        i + 2,\n                        i + 3\n                    ));\n                }\n                let dir_where = dir_conditions.join(\" OR \");\n                let name_filter = if name_like == \"%\" {\n                    String::new()\n                } else {\n                    let ext_shortcut = extract_ext_from_like(&name_like);\n                    if let Some(ext_val) = ext_shortcut {\n                        let i = sql_params.len();\n                        sql_params.push(SqlValue::Text(ext_val));\n                        format!(\" AND e.ext = ?{}\", i + 1)\n                    } else {\n                        let i = sql_params.len();\n                        sql_params.push(SqlValue::Text(name_like.clone()));\n                        format!(\" AND e.name LIKE ?{} ESCAPE '\\\\'\", i + 1)\n                    }\n                };\n                let sql =\n                    format!(\"SELECT COUNT(*) FROM entries e WHERE ({dir_where}){name_filter}\");\n                conn.query_row(&sql, params_from_iter(sql_params.iter()), |r| r.get(0))\n                    .unwrap_or(0)\n            } else {\n                let sep = std::path::MAIN_SEPARATOR;\n                let native_hint = dir_hint.replace('/', &sep.to_string());\n                let escaped_sep = escape_like(&sep.to_string());\n                let dir_suffix = escape_like(&native_hint);\n                let dir_like_exact = format!(\"%{escaped_sep}{dir_suffix}\");\n                let dir_like_sub = format!(\"%{escaped_sep}{dir_suffix}{escaped_sep}%\");\n                let ext_shortcut = extract_ext_from_like(&name_like);\n                if let Some(ext_val) = ext_shortcut {\n                    conn.query_row(\n                        \"SELECT COUNT(*) FROM entries e WHERE e.ext = ?1 AND (e.dir LIKE ?2 ESCAPE '\\\\' OR e.dir LIKE ?3 ESCAPE '\\\\')\",\n                        params![ext_val, dir_like_exact, dir_like_sub],\n                        |r| r.get(0),\n                    )\n                    .unwrap_or(0)\n                } else if name_like == \"%\" {\n                    conn.query_row(\n                        \"SELECT COUNT(*) FROM entries e WHERE e.dir LIKE ?1 ESCAPE '\\\\' OR e.dir LIKE ?2 ESCAPE '\\\\'\",\n                        params![dir_like_exact, dir_like_sub],\n                        |r| r.get(0),\n                    )\n                    .unwrap_or(0)\n                } else {\n                    conn.query_row(\n                        \"SELECT COUNT(*) FROM entries e WHERE (e.dir LIKE ?1 ESCAPE '\\\\' OR e.dir LIKE ?2 ESCAPE '\\\\') AND e.name LIKE ?3 ESCAPE '\\\\'\",\n                        params![dir_like_exact, dir_like_sub, name_like],\n                        |r| r.get(0),\n                    )\n                    .unwrap_or(0)\n                }\n            }\n        }\n    };\n\n    Some(total)\n}\n\nfn execute_search(\n    state: &AppState,\n    query: String,\n    limit: Option<u32>,\n    offset: Option<u32>,\n    sort_by: Option<String>,\n    sort_dir: Option<String>,\n) -> AppResult<SearchExecution> {\n    let query = query.trim().to_string();\n    let base_limit = limit.unwrap_or(DEFAULT_LIMIT).clamp(1, MAX_LIMIT);\n    let effective_limit = if !query.is_empty() && query.chars().count() <= 1 {\n        base_limit.min(SHORT_QUERY_LIMIT)\n    } else {\n        base_limit\n    };\n    let offset = offset.unwrap_or(0);\n\n    let sort_by = sort_by.unwrap_or_else(|| \"name\".to_string());\n    let sort_dir = sort_dir.unwrap_or_else(|| \"asc\".to_string());\n    let (runtime_ignored_roots, runtime_ignored_patterns) = cached_effective_ignore_rules(state);\n\n    #[cfg(target_os = \"macos\")]\n    if !state.db_ready.load(AtomicOrdering::Acquire) {\n        let spotlight = mac::spotlight_search::search_spotlight(&state.home_dir, &query);\n        let mode_label = if spotlight.entries.is_empty() {\n            \"db_not_ready\".to_string()\n        } else if spotlight.timed_out {\n            \"spotlight_timeout\".to_string()\n        } else {\n            \"spotlight\".to_string()\n        };\n        perf_log(format!(\n            \"spotlight_fallback db_not_ready query={:?} results={} timed_out={}\",\n            query,\n            spotlight.entries.len(),\n            spotlight.timed_out\n        ));\n        return Ok(SearchExecution {\n            query,\n            sort_by,\n            sort_dir,\n            effective_limit,\n            offset,\n            mode_label,\n            results: spotlight.entries,\n        });\n    }\n\n    let is_indexing = matches!(state.status.lock().state, IndexState::Indexing);\n    let order_by = sort_clause(&sort_by, &sort_dir, \"e.\");\n\n    let mut results = Vec::with_capacity(effective_limit as usize);\n    let mode = parse_query(&query);\n    let is_name_mode = matches!(&mode, SearchMode::NameSearch { .. });\n    let allow_find_fallback = !is_indexing\n        && matches!(\n            &mode,\n            SearchMode::GlobName { .. } | SearchMode::ExtSearch { .. }\n        );\n    let mut mode_label = match &mode {\n        SearchMode::Empty => \"empty\",\n        SearchMode::NameSearch { .. } => \"name\",\n        SearchMode::GlobName { .. } => \"glob\",\n        SearchMode::ExtSearch { .. } => \"ext\",\n        SearchMode::PathSearch { .. } => \"path\",\n    }\n    .to_string();\n\n    // Fast path: search in-memory index if available (DB upsert still in progress)\n    {\n        let guard = state.mem_index.read();\n        if let Some(ref mi) = *guard {\n            let mem_results = mem_search::search_mem_index(\n                mi, &query, &mode, effective_limit, offset, &sort_by, &sort_dir,\n            );\n            mode_label = format!(\"mem_{mode_label}\");\n            return Ok(SearchExecution {\n                query,\n                sort_by,\n                sort_dir,\n                effective_limit,\n                offset,\n                mode_label,\n                results: mem_results,\n            });\n        }\n    }\n\n    if is_name_mode && !is_indexing && offset == 0 {\n        if let Some(cache_hit) = negative_name_cache_lookup(state, &query) {\n            if cache_hit.age >= WATCH_DEBOUNCE\n                && cache_hit.age <= NEGATIVE_CACHE_FALLBACK_WINDOW\n                && !cache_hit.fallback_checked\n            {\n                let fallback_results = find_search(\n                    &state.home_dir,\n                    &runtime_ignored_roots,\n                    &runtime_ignored_patterns,\n                    &query,\n                    effective_limit as usize,\n                    &sort_by,\n                    &sort_dir,\n                );\n                if !fallback_results.is_empty() {\n                    remove_negative_name_query(state, &cache_hit.query_lower);\n                    perf_log(format!(\n                        \"search_negative_cache_fallback_hit query={:?} age_ms={} results={}\",\n                        query,\n                        cache_hit.age.as_millis(),\n                        fallback_results.len()\n                    ));\n                    return Ok(SearchExecution {\n                        query,\n                        sort_by,\n                        sort_dir,\n                        effective_limit,\n                        offset,\n                        mode_label: \"find_fallback\".to_string(),\n                        results: fallback_results,\n                    });\n                }\n                mark_negative_name_fallback_checked(state, &cache_hit.query_lower);\n            }\n\n            perf_log(format!(\n                \"search_negative_cache_hit query={:?} age_ms={}\",\n                query,\n                cache_hit.age.as_millis()\n            ));\n            return Ok(SearchExecution {\n                query,\n                sort_by,\n                sort_dir,\n                effective_limit,\n                offset,\n                mode_label: \"name_neg_cache\".to_string(),\n                results: Vec::new(),\n            });\n        }\n    }\n\n    #[cfg(target_os = \"macos\")]\n    let db_unavailable;\n    match db_connection_for_search(&state.db_path) {\n        Ok(conn) => {\n            #[cfg(target_os = \"macos\")]\n            { db_unavailable = false; }\n            match &mode {\n                SearchMode::Empty => {\n                    let sql = format!(\n                        r#\"\n                        SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                        FROM entries e\n                        ORDER BY {order_by}\n                        LIMIT ?1 OFFSET ?2\n                        \"#,\n                    );\n                    let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                    let rows = stmt\n                        .query_map(params![effective_limit, offset], row_to_entry)\n                        .map_err(|e| e.to_string())?;\n                    for row in rows {\n                        results.push(row.map_err(|e| e.to_string())?);\n                    }\n                }\n\n                SearchMode::NameSearch { name_like } => {\n                    let escaped_query = escape_like(&query);\n                    let exact_query = query.clone();\n                    let prefix_like = format!(\"{}%\", escaped_query);\n                    let bare_order = sort_clause(&sort_by, &sort_dir, \"\");\n\n                    if offset == 0 {\n                        let exact_sql = format!(\n                            r#\"\n                            SELECT path, name, dir, is_dir, ext, size, mtime\n                            FROM entries\n                            WHERE name COLLATE NOCASE = ?1\n                            ORDER BY {bare_order}\n                            LIMIT ?2\n                            \"#,\n                        );\n                        let mut stmt = conn.prepare(&exact_sql).map_err(|e| e.to_string())?;\n                        let rows = stmt\n                            .query_map(params![exact_query, effective_limit], row_to_entry)\n                            .map_err(|e| e.to_string())?;\n                        for row in rows {\n                            results.push(row.map_err(|e| e.to_string())?);\n                        }\n                    }\n\n                    if (results.len() as u32) < effective_limit {\n                        let remaining = effective_limit - results.len() as u32;\n                        let adj_offset = if offset > 0 {\n                            offset.saturating_sub(results.len() as u32)\n                        } else {\n                            0\n                        };\n\n                        // Try indexed prefix search first; fall back to unindexed if\n                        // the index is temporarily unavailable (during background DB\n                        // rebuild the index may be dropped then recreated).\n                        let prefix_sql_indexed = format!(\n                            r#\"\n                            SELECT path, name, dir, is_dir, ext, size, mtime\n                            FROM entries INDEXED BY idx_entries_name_nocase\n                            WHERE name LIKE ?1 ESCAPE '\\'\n                              AND name COLLATE NOCASE != ?2\n                            ORDER BY {bare_order}\n                            LIMIT ?3 OFFSET ?4\n                            \"#,\n                        );\n                        let prefix_sql_fallback = format!(\n                            r#\"\n                            SELECT path, name, dir, is_dir, ext, size, mtime\n                            FROM entries\n                            WHERE name LIKE ?1 ESCAPE '\\'\n                              AND name COLLATE NOCASE != ?2\n                            ORDER BY {bare_order}\n                            LIMIT ?3 OFFSET ?4\n                            \"#,\n                        );\n                        let mut stmt = match conn.prepare(&prefix_sql_indexed) {\n                            Ok(s) => s,\n                            Err(_) => {\n                                eprintln!(\"[search] idx_entries_name_nocase unavailable, using fallback\");\n                                conn.prepare(&prefix_sql_fallback).map_err(|e| e.to_string())?\n                            }\n                        };\n                        let rows = stmt\n                            .query_map(\n                                params![prefix_like, exact_query, remaining, adj_offset],\n                                row_to_entry,\n                            )\n                            .map_err(|e| e.to_string())?;\n                        for row in rows {\n                            results.push(row.map_err(|e| e.to_string())?);\n                        }\n                    }\n\n                    if results.is_empty() && offset == 0 {\n                        // Phase 2: contains-match (LIKE '%q%') with tight time budget.\n                        // Combines probe + fetch in one pass to avoid double scan overhead.\n                        let phase2_start = Instant::now();\n                        conn.progress_handler(\n                            2_000,\n                            Some(move || phase2_start.elapsed().as_millis() > 5),\n                        );\n\n                        {\n\n                            let phase2_sql = format!(\n                                r#\"\n                                SELECT path, name, dir, is_dir, ext, size, mtime\n                                FROM entries\n                                WHERE name LIKE ?1 ESCAPE '\\'\n                                  AND name COLLATE NOCASE != ?2\n                                  AND name NOT LIKE ?3 ESCAPE '\\'\n                                ORDER BY {bare_order}\n                                LIMIT ?4\n                                \"#,\n                            );\n                            if let Ok(mut stmt2) = conn.prepare(&phase2_sql) {\n                                if let Ok(rows2) = stmt2.query_map(\n                                    params![name_like, exact_query, prefix_like, effective_limit],\n                                    row_to_entry,\n                                ) {\n                                    for row in rows2 {\n                                        match row {\n                                            Ok(entry) => results.push(entry),\n                                            Err(_) => break,\n                                        }\n                                    }\n                                }\n                            }\n                        }\n\n                        conn.progress_handler(0, None::<fn() -> bool>);\n                    }\n                }\n\n                SearchMode::GlobName { name_like } => {\n                    let sql = format!(\n                        r#\"\n                        SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                        FROM entries e\n                        WHERE e.name LIKE ?1 ESCAPE '\\'\n                        ORDER BY {order_by}\n                        LIMIT ?2 OFFSET ?3\n                        \"#,\n                    );\n                    let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                    let rows = stmt\n                        .query_map(params![name_like, effective_limit, offset], row_to_entry)\n                        .map_err(|e| e.to_string())?;\n                    for row in rows {\n                        results.push(row.map_err(|e| e.to_string())?);\n                    }\n                }\n\n                SearchMode::ExtSearch { ext, name_like: _ } => {\n                    let sql = format!(\n                        r#\"\n                        SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                        FROM entries e\n                        WHERE e.ext = ?1\n                        ORDER BY {order_by}\n                        LIMIT ?2 OFFSET ?3\n                        \"#,\n                    );\n                    let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                    let rows = stmt\n                        .query_map(params![ext, effective_limit, offset], row_to_entry)\n                        .map_err(|e| e.to_string())?;\n                    for row in rows {\n                        results.push(row.map_err(|e| e.to_string())?);\n                    }\n                }\n\n                SearchMode::PathSearch {\n                    path_like: _,\n                    name_like,\n                    dir_hint,\n                } => {\n                    let resolved_dirs: Vec<String> = resolve_dir_hint(&state.home_dir, dir_hint)\n                        .map(|p| vec![p.to_string_lossy().to_string()])\n                        .unwrap_or_default();\n                    let resolved_dirs = if resolved_dirs.is_empty() {\n                        resolve_dirs_from_db(&conn, dir_hint)\n                    } else {\n                        resolved_dirs\n                    };\n\n                    if !resolved_dirs.is_empty() {\n                        let ext_shortcut = extract_ext_from_like(name_like);\n                        let mut sql_params: Vec<SqlValue> = Vec::new();\n                        let mut dir_conditions = Vec::new();\n                        let sep = std::path::MAIN_SEPARATOR;\n\n                        for d in &resolved_dirs {\n                            let i = sql_params.len();\n                            let pfx = format!(\"{d}{sep}\");\n                            let pfx_end = format!(\"{d}\\x7F\");\n                            sql_params.push(SqlValue::Text(d.clone()));\n                            sql_params.push(SqlValue::Text(pfx));\n                            sql_params.push(SqlValue::Text(pfx_end));\n                            dir_conditions.push(format!(\n                                \"(e.dir = ?{} OR (e.dir >= ?{} AND e.dir < ?{}))\",\n                                i + 1,\n                                i + 2,\n                                i + 3\n                            ));\n                        }\n                        let dir_where = dir_conditions.join(\" OR \");\n\n                        let name_filter = if name_like == \"%\" {\n                            String::new()\n                        } else if let Some(ref ext_val) = ext_shortcut {\n                            let i = sql_params.len();\n                            sql_params.push(SqlValue::Text(ext_val.clone()));\n                            format!(\" AND e.ext = ?{}\", i + 1)\n                        } else {\n                            let i = sql_params.len();\n                            sql_params.push(SqlValue::Text(name_like.clone()));\n                            format!(\" AND e.name LIKE ?{} ESCAPE '\\\\'\", i + 1)\n                        };\n\n                        let limit_idx = sql_params.len() + 1;\n                        let offset_idx = sql_params.len() + 2;\n                        sql_params.push(SqlValue::Integer(effective_limit as i64));\n                        sql_params.push(SqlValue::Integer(offset as i64));\n\n                        let sql = format!(\n                            r#\"\n                            SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                            FROM entries e\n                            WHERE ({dir_where}){name_filter}\n                            ORDER BY {order_by}\n                            LIMIT ?{limit_idx} OFFSET ?{offset_idx}\n                            \"#,\n                        );\n                        let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                        let rows = stmt\n                            .query_map(params_from_iter(sql_params.iter()), row_to_entry)\n                            .map_err(|e| e.to_string())?;\n                        for row in rows {\n                            results.push(row.map_err(|e| e.to_string())?);\n                        }\n                    } else {\n                        let sep = std::path::MAIN_SEPARATOR;\n                        let sep_str = sep.to_string();\n                        let escaped_sep = escape_like(&sep_str);\n                        let (native_hint, is_absolute) = normalize_hint_to_native(dir_hint);\n                        let dir_suffix = escape_like(&native_hint);\n                        let dir_prefix = if is_absolute {\n                            String::new()\n                        } else {\n                            escaped_sep.clone()\n                        };\n                        let dir_like_exact = format!(\"%{dir_prefix}{dir_suffix}\");\n                        let dir_like_sub = format!(\"%{dir_prefix}{dir_suffix}{escaped_sep}%\");\n                        let ext_shortcut = extract_ext_from_like(name_like);\n\n                        if let Some(ext_val) = ext_shortcut {\n                            let sql = format!(\n                                r#\"\n                                SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                                FROM entries e\n                                WHERE e.ext = ?1\n                                  AND (e.dir LIKE ?2 ESCAPE '\\' OR e.dir LIKE ?3 ESCAPE '\\')\n                                ORDER BY {order_by}\n                                LIMIT ?4 OFFSET ?5\n                                \"#,\n                            );\n                            let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                            let rows = stmt\n                                .query_map(\n                                    params![\n                                        ext_val,\n                                        dir_like_exact,\n                                        dir_like_sub,\n                                        effective_limit,\n                                        offset\n                                    ],\n                                    row_to_entry,\n                                )\n                                .map_err(|e| e.to_string())?;\n                            for row in rows {\n                                results.push(row.map_err(|e| e.to_string())?);\n                            }\n                        } else if name_like == \"%\" {\n                            // Directory listing: no name filter needed, no time budget\n                            let sql = format!(\n                                r#\"\n                                SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                                FROM entries e\n                                WHERE e.dir LIKE ?1 ESCAPE '\\' OR e.dir LIKE ?2 ESCAPE '\\'\n                                ORDER BY {order_by}\n                                LIMIT ?3 OFFSET ?4\n                                \"#,\n                            );\n                            let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                            let rows = stmt\n                                .query_map(\n                                    params![dir_like_exact, dir_like_sub, effective_limit, offset],\n                                    row_to_entry,\n                                )\n                                .map_err(|e| e.to_string())?;\n                            for row in rows {\n                                results.push(row.map_err(|e| e.to_string())?);\n                            }\n                        } else {\n                            // Phase A: fast prefix search via name index\n                            // \"%main%\" -> strip leading '%' -> \"main%\" can use idx_entries_name_nocase\n                            let prefix_like = if name_like.starts_with('%') {\n                                let rest = &name_like[1..];\n                                if !rest.is_empty() && !rest.starts_with('%') {\n                                    Some(rest.to_string())\n                                } else {\n                                    None\n                                }\n                            } else {\n                                // Already a prefix pattern (e.g. \"test%\"), use as-is\n                                Some(name_like.clone())\n                            };\n\n                            if offset == 0 {\n                                if let Some(ref pfx) = prefix_like {\n                                    let sql = format!(\n                                        r#\"\n                                        SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                                        FROM entries e INDEXED BY idx_entries_name_nocase\n                                        WHERE e.name LIKE ?1 ESCAPE '\\'\n                                          AND (e.dir LIKE ?2 ESCAPE '\\' OR e.dir LIKE ?3 ESCAPE '\\')\n                                        ORDER BY {order_by}\n                                        LIMIT ?4\n                                        \"#,\n                                    );\n                                    if let Ok(mut stmt) = conn.prepare(&sql) {\n                                        if let Ok(rows) = stmt.query_map(\n                                            params![\n                                                pfx,\n                                                dir_like_exact,\n                                                dir_like_sub,\n                                                effective_limit\n                                            ],\n                                            row_to_entry,\n                                        ) {\n                                            for row in rows {\n                                                match row {\n                                                    Ok(entry) => results.push(entry),\n                                                    Err(_) => break,\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n\n                            // Phase B: time-budgeted contains fallback if prefix found too few\n                            if results.len() < effective_limit as usize {\n                                let path_start = Instant::now();\n                                conn.progress_handler(\n                                    2_000,\n                                    Some(move || path_start.elapsed().as_millis() > 5),\n                                );\n\n                                let sql = format!(\n                                    r#\"\n                                    SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                                    FROM entries e\n                                    WHERE (e.dir LIKE ?1 ESCAPE '\\' OR e.dir LIKE ?2 ESCAPE '\\')\n                                      AND e.name LIKE ?3 ESCAPE '\\'\n                                    ORDER BY {order_by}\n                                    LIMIT ?4 OFFSET ?5\n                                    \"#,\n                                );\n                                if let Ok(mut stmt) = conn.prepare(&sql) {\n                                    if let Ok(rows) = stmt.query_map(\n                                        params![\n                                            dir_like_exact,\n                                            dir_like_sub,\n                                            name_like,\n                                            effective_limit,\n                                            offset\n                                        ],\n                                        row_to_entry,\n                                    ) {\n                                        for row in rows {\n                                            match row {\n                                                Ok(entry) => results.push(entry),\n                                                Err(_) => break,\n                                            }\n                                        }\n                                    }\n                                }\n\n                                conn.progress_handler(0, None::<fn() -> bool>);\n\n                                // Deduplicate (Phase A prefix results overlap with Phase B contains)\n                                let mut seen = std::collections::HashSet::new();\n                                results.retain(|e| seen.insert(e.path.clone()));\n                                results.truncate(effective_limit as usize);\n                            }\n                        }\n                    }\n                }\n            }\n\n            if results.is_empty() && !query.is_empty() && offset == 0 && allow_find_fallback {\n                results = find_search(\n                    &state.home_dir,\n                    &runtime_ignored_roots,\n                    &runtime_ignored_patterns,\n                    &query,\n                    effective_limit as usize,\n                    &sort_by,\n                    &sort_dir,\n                );\n                mode_label = \"find_fallback\".to_string();\n            }\n        }\n        Err(_) => {\n            #[cfg(target_os = \"macos\")]\n            { db_unavailable = true; }\n            perf_log(format!(\"search_db_unavailable query={:?}\", query));\n        }\n    }\n\n    #[cfg(target_os = \"macos\")]\n    if !query.is_empty() && offset == 0 {\n        let should_spotlight = if results.is_empty() {\n            true\n        } else if results.len() >= effective_limit as usize {\n            false\n        } else {\n            is_indexing || db_unavailable\n        };\n        if should_spotlight {\n            let spotlight = mac::spotlight_search::search_spotlight(&state.home_dir, &query);\n            if !spotlight.entries.is_empty() {\n                if results.is_empty() {\n                    perf_log(format!(\n                        \"spotlight_fallback empty_results query={:?} results={} timed_out={}\",\n                        query,\n                        spotlight.entries.len(),\n                        spotlight.timed_out\n                    ));\n                    results = spotlight.entries;\n                    mode_label = if spotlight.timed_out {\n                        \"spotlight_timeout\".to_string()\n                    } else {\n                        \"spotlight\".to_string()\n                    };\n                } else {\n                    let existing_paths: std::collections::HashSet<String> =\n                        results.iter().map(|e| e.path.clone()).collect();\n                    let mut merged_count = 0usize;\n                    for entry in spotlight.entries {\n                        if !existing_paths.contains(&entry.path) {\n                            results.push(entry);\n                            merged_count += 1;\n                        }\n                    }\n                    if merged_count > 0 {\n                        perf_log(format!(\n                            \"spotlight_merge indexing query={:?} merged={} timed_out={}\",\n                            query, merged_count, spotlight.timed_out\n                        ));\n                        mode_label = format!(\"{}_+spotlight\", mode_label);\n                    }\n                }\n            }\n        }\n    }\n\n    results = filter_ignored_entries(results, &runtime_ignored_roots, &runtime_ignored_patterns);\n    results.truncate(effective_limit as usize);\n    if offset == 0 {\n        if sort_by == \"name\" {\n            sort_entries_with_relevance(&mut results, &query, &sort_by, &sort_dir);\n        } else {\n            sort_entries(&mut results, &sort_by, &sort_dir);\n        }\n    }\n    if is_name_mode && !is_indexing && offset == 0 && results.is_empty() && !query.is_empty() {\n        remember_negative_name_query(state, &query);\n    }\n\n    Ok(SearchExecution {\n        query,\n        sort_by,\n        sort_dir,\n        effective_limit,\n        offset,\n        mode_label,\n        results,\n    })\n}\n\n#[tauri::command]\nasync fn search(\n    _app: AppHandle,\n    query: String,\n    limit: Option<u32>,\n    offset: Option<u32>,\n    sort_by: Option<String>,\n    sort_dir: Option<String>,\n    include_total: Option<bool>,\n    state: State<'_, AppState>,\n) -> AppResult<SearchResultDto> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        let rpc_started = Instant::now();\n        let execute_started = Instant::now();\n        let execution = execute_search(&state, query, limit, offset, sort_by, sort_dir)?;\n        let execute_elapsed_ms = execute_started.elapsed().as_secs_f64() * 1000.0;\n\n        log_search(\n            &state.db_path,\n            &execution.query,\n            &execution.mode_label,\n            &execution.results,\n        );\n\n        if perf_log_enabled() {\n            let top: Vec<&str> = execution\n                .results\n                .iter()\n                .take(5)\n                .map(|entry| entry.name.as_str())\n                .collect();\n            perf_log(format!(\n                \"search query={:?} mode={} sort={}/{} limit={} offset={} results={} elapsed_ms={:.3} top={:?}\",\n                execution.query,\n                execution.mode_label,\n                execution.sort_by,\n                execution.sort_dir,\n                execution.effective_limit,\n                execution.offset,\n                execution.results.len(),\n                execute_elapsed_ms,\n                top,\n            ));\n        }\n\n        let include_total = include_total.unwrap_or(true);\n        let count_started = Instant::now();\n        let (total_count, total_known) = if include_total {\n            match compute_total_count(&state.db_path, &state.home_dir, &execution) {\n                Some(v) => (v, true),\n                None => (0, false),\n            }\n        } else {\n            (0, false)\n        };\n        let count_elapsed_ms = if include_total {\n            count_started.elapsed().as_secs_f64() * 1000.0\n        } else {\n            0.0\n        };\n\n        let rpc_elapsed_ms = rpc_started.elapsed().as_secs_f64() * 1000.0;\n        if cfg!(debug_assertions) {\n            let db_ready = state.db_ready.load(AtomicOrdering::Acquire);\n            let indexing_active = state.indexing_active.load(AtomicOrdering::Acquire);\n            eprintln!(\n                \"[rpc/search] total={:.3}ms execute={:.3}ms total_count={:.3}ms include_total={} query={:?} mode={} sort={}/{} limit={} offset={} results={} total_count={} total_known={} db_ready={} indexing_active={}\",\n                rpc_elapsed_ms,\n                execute_elapsed_ms,\n                count_elapsed_ms,\n                include_total,\n                execution.query,\n                execution.mode_label,\n                execution.sort_by,\n                execution.sort_dir,\n                execution.effective_limit,\n                execution.offset,\n                execution.results.len(),\n                total_count,\n                total_known,\n                db_ready,\n                indexing_active,\n            );\n        }\n        Ok(SearchResultDto {\n            entries: execution.results,\n            mode_label: execution.mode_label,\n            total_count,\n            total_known,\n        })\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nasync fn quick_look(path: String) -> AppResult<()> {\n    tauri::async_runtime::spawn_blocking(move || {\n        #[cfg(target_os = \"macos\")]\n        {\n            Command::new(\"qlmanage\")\n                .args([\"-p\", &path])\n                .stdout(std::process::Stdio::null())\n                .stderr(std::process::Stdio::null())\n                .spawn()\n                .map_err(|e| e.to_string())?;\n        }\n        #[cfg(target_os = \"windows\")]\n        {\n            Command::new(\"explorer\")\n                .arg(&path)\n                .spawn()\n                .map_err(|e| e.to_string())?;\n        }\n        #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n        {\n            Command::new(\"xdg-open\")\n                .arg(&path)\n                .spawn()\n                .map_err(|e| e.to_string())?;\n        }\n        Ok(())\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nasync fn open(paths: Vec<String>) -> AppResult<()> {\n    tauri::async_runtime::spawn_blocking(move || {\n        for path in &paths {\n            #[cfg(target_os = \"macos\")]\n            {\n                let output = Command::new(\"open\")\n                    .arg(path)\n                    .output()\n                    .map_err(|e| e.to_string())?;\n\n                if !output.status.success() && Path::new(path).is_dir() {\n                    let fallback = Command::new(\"open\")\n                        .args([\"-R\", path])\n                        .status()\n                        .map_err(|e| e.to_string())?;\n\n                    if !fallback.success() {\n                        return Err(format!(\"Failed to open: {path}\"));\n                    }\n                } else if !output.status.success() {\n                    let stderr = String::from_utf8_lossy(&output.stderr);\n                    return Err(format!(\"Failed to open: {path} ({stderr})\",));\n                }\n            }\n            #[cfg(target_os = \"windows\")]\n            {\n                let mut cmd = Command::new(\"cmd\");\n                cmd.raw_arg(format!(\"/C start \\\"\\\" \\\"{}\\\"\", path.replace('\"', \"\")));\n                let status = cmd.status().map_err(|e| e.to_string())?;\n                if !status.success() {\n                    return Err(format!(\"Failed to open: {path}\"));\n                }\n            }\n            #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n            {\n                let status = Command::new(\"xdg-open\")\n                    .arg(path)\n                    .status()\n                    .map_err(|e| e.to_string())?;\n                if !status.success() {\n                    return Err(format!(\"Failed to open: {path}\"));\n                }\n            }\n        }\n\n        Ok(())\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\nfn reveal_in_finder_impl(paths: Vec<String>) -> AppResult<()> {\n    if paths.is_empty() {\n        return Ok(());\n    }\n\n    #[cfg(target_os = \"macos\")]\n    {\n        if paths.len() == 1 {\n            let status = Command::new(\"open\")\n                .arg(\"-R\")\n                .arg(&paths[0])\n                .status()\n                .map_err(|e| e.to_string())?;\n\n            if !status.success() {\n                return Err(format!(\"Failed to reveal in Finder: {}\", paths[0]));\n            }\n\n            return Ok(());\n        }\n\n        let mut unique_parents: HashSet<PathBuf> = HashSet::new();\n        for path in &paths {\n            let p = PathBuf::from(path);\n            if let Some(parent) = p.parent() {\n                unique_parents.insert(parent.to_path_buf());\n            }\n        }\n\n        for parent in unique_parents {\n            let status = Command::new(\"open\")\n                .arg(&parent)\n                .status()\n                .map_err(|e| e.to_string())?;\n\n            if !status.success() {\n                return Err(format!(\n                    \"Failed to open in Finder: {}\",\n                    parent.to_string_lossy()\n                ));\n            }\n        }\n    }\n\n    #[cfg(target_os = \"windows\")]\n    {\n        for path in &paths {\n            let mut cmd = Command::new(\"explorer\");\n            cmd.raw_arg(format!(\"/select,\\\"{}\\\"\", path.replace('\"', \"\")));\n            let _ = cmd.status();\n        }\n    }\n\n    #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n    {\n        for path in &paths {\n            let target = Path::new(path);\n            let dir = if target.is_dir() {\n                path.as_str()\n            } else {\n                target\n                    .parent()\n                    .map(|p| p.to_str().unwrap_or(\"/\"))\n                    .unwrap_or(\"/\")\n            };\n            let _ = Command::new(\"xdg-open\").arg(dir).status();\n        }\n    }\n\n    Ok(())\n}\n\nfn copy_with_command(program: &str, args: &[&str], text: &str) -> AppResult<()> {\n    let mut child = Command::new(program)\n        .args(args)\n        .stdin(Stdio::piped())\n        .spawn()\n        .map_err(|e| format!(\"Failed to run {program}: {e}\"))?;\n\n    if let Some(mut stdin) = child.stdin.take() {\n        stdin\n            .write_all(text.as_bytes())\n            .map_err(|e| format!(\"Failed to write to clipboard: {e}\"))?;\n    } else {\n        return Err(\"Cannot open clipboard input stream.\".to_string());\n    }\n\n    let status = child\n        .wait()\n        .map_err(|e| format!(\"Failed to wait for {program}: {e}\"))?;\n\n    if status.success() {\n        Ok(())\n    } else {\n        Err(format!(\"{program} execution failed.\"))\n    }\n}\n\n#[cfg(target_os = \"macos\")]\nfn copy_text_to_clipboard(text: &str) -> AppResult<()> {\n    copy_with_command(\"pbcopy\", &[], text)\n}\n\n#[cfg(target_os = \"windows\")]\nfn copy_text_to_clipboard(text: &str) -> AppResult<()> {\n    copy_with_command(\"cmd\", &[\"/C\", \"clip\"], text)\n}\n\n#[cfg(all(unix, not(target_os = \"macos\")))]\nfn copy_text_to_clipboard(text: &str) -> AppResult<()> {\n    let mut last_error = None;\n\n    match copy_with_command(\"wl-copy\", &[], text) {\n        Ok(()) => return Ok(()),\n        Err(err) => last_error = Some(err),\n    }\n    match copy_with_command(\"xclip\", &[\"-selection\", \"clipboard\"], text) {\n        Ok(()) => return Ok(()),\n        Err(err) => last_error = Some(err),\n    }\n    match copy_with_command(\"xsel\", &[\"--clipboard\", \"--input\"], text) {\n        Ok(()) => return Ok(()),\n        Err(err) => last_error = Some(err),\n    }\n\n    Err(last_error.unwrap_or_else(|| {\n        \"No supported clipboard tool found. Please install wl-copy, xclip, or xsel.\".to_string()\n    }))\n}\n\n#[tauri::command]\nasync fn open_with(path: String) -> AppResult<()> {\n    tauri::async_runtime::spawn_blocking(move || reveal_in_finder_impl(vec![path]))\n        .await\n        .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nasync fn reveal_in_finder(paths: Vec<String>) -> AppResult<()> {\n    tauri::async_runtime::spawn_blocking(move || reveal_in_finder_impl(paths))\n        .await\n        .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nfn copy_paths(paths: Vec<String>) -> AppResult<()> {\n    copy_text_to_clipboard(&paths.join(\"\\n\"))\n}\n\n#[cfg(target_os = \"macos\")]\nfn copy_files_to_clipboard(paths: &[String]) -> AppResult<()> {\n    if paths.is_empty() {\n        return Ok(());\n    }\n    let file_exprs: Vec<String> = paths\n        .iter()\n        .map(|p| {\n            let escaped = p.replace('\\\\', \"\\\\\\\\\").replace('\"', \"\\\\\\\"\");\n            format!(\"POSIX file \\\"{}\\\"\", escaped)\n        })\n        .collect();\n    let script = if file_exprs.len() == 1 {\n        format!(\"set the clipboard to {}\", file_exprs[0])\n    } else {\n        format!(\"set the clipboard to {{{}}}\", file_exprs.join(\", \"))\n    };\n    let status = Command::new(\"osascript\")\n        .arg(\"-e\")\n        .arg(&script)\n        .status()\n        .map_err(|e| e.to_string())?;\n    if !status.success() {\n        return Err(\"Failed to copy files to clipboard\".to_string());\n    }\n    Ok(())\n}\n\n#[cfg(target_os = \"macos\")]\n#[tauri::command]\nfn copy_files(paths: Vec<String>) -> AppResult<()> {\n    copy_files_to_clipboard(&paths)\n}\n\n#[cfg(not(target_os = \"macos\"))]\n#[tauri::command]\nfn copy_files(_paths: Vec<String>) -> AppResult<()> {\n    Err(\"copy_files is only supported on macOS\".to_string())\n}\n\n#[tauri::command]\nasync fn move_to_trash(\n    paths: Vec<String>,\n    app: AppHandle,\n    state: State<'_, AppState>,\n) -> AppResult<()> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        let mut deleted_targets = Vec::new();\n\n        for path in &paths {\n            trash::delete(path).map_err(|e| e.to_string())?;\n            remember_op(&state, \"trash\", Some(path.clone()), None);\n            deleted_targets.push(path.clone());\n        }\n\n        let mut conn = db_connection(&state.db_path)?;\n        let _ = delete_paths(&mut conn, &deleted_targets)?;\n        invalidate_search_caches(&state);\n\n        refresh_and_emit_status_counts(&app, &state)?;\n        Ok(())\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nasync fn rename(\n    path: String,\n    new_name: String,\n    app: AppHandle,\n    state: State<'_, AppState>,\n) -> AppResult<EntryDto> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        let validated_name = validate_new_name(&new_name)?;\n        let old_path = PathBuf::from(&path);\n\n        if !old_path.exists() {\n            return Err(\"Source file does not exist.\".to_string());\n        }\n\n        let parent = old_path\n            .parent()\n            .ok_or_else(|| \"Parent directory not found.\".to_string())?;\n\n        let new_path = parent.join(&validated_name);\n        if new_path == old_path {\n            let meta = fs::symlink_metadata(&old_path).ok();\n            return Ok(EntryDto {\n                path: path.clone(),\n                name: old_path\n                    .file_name()\n                    .map(|v| v.to_string_lossy().to_string())\n                    .unwrap_or_else(|| validated_name.clone()),\n                dir: parent.to_string_lossy().to_string(),\n                is_dir: old_path.is_dir(),\n                ext: extension_for(&old_path, old_path.is_dir()),\n                size: meta\n                    .as_ref()\n                    .filter(|m| m.is_file())\n                    .map(|m| m.len() as i64),\n                mtime: meta\n                    .and_then(|m| m.modified().ok())\n                    .and_then(|m| m.duration_since(UNIX_EPOCH).ok())\n                    .map(|d| d.as_secs() as i64),\n            });\n        }\n\n        if new_path.exists() {\n            return Err(\"A file/folder with the same name already exists.\".to_string());\n        }\n\n        let original_is_dir = old_path.is_dir();\n        fs::rename(&old_path, &new_path).map_err(|e| e.to_string())?;\n\n        let mut conn = db_connection(&state.db_path)?;\n        let _ = delete_paths(&mut conn, &[path.clone()])?;\n\n        if original_is_dir {\n            let rows =\n                collect_rows_recursive(&new_path, &state.path_ignores, &state.path_ignore_patterns);\n            for chunk in rows.chunks(BATCH_SIZE) {\n                let _ = upsert_rows(&mut conn, chunk)?;\n            }\n        } else {\n            let row = index_row_from_path(&new_path)\n                .ok_or_else(|| \"Cannot read renamed file info.\".to_string())?;\n            let _ = upsert_rows(&mut conn, &[row])?;\n        }\n\n        invalidate_search_caches(&state);\n\n        remember_op(\n            &state,\n            \"rename\",\n            Some(old_path.to_string_lossy().to_string()),\n            Some(new_path.to_string_lossy().to_string()),\n        );\n\n        refresh_and_emit_status_counts(&app, &state)?;\n\n        let new_meta = fs::symlink_metadata(&new_path).ok();\n        Ok(EntryDto {\n            path: new_path.to_string_lossy().to_string(),\n            name: validated_name,\n            dir: parent.to_string_lossy().to_string(),\n            is_dir: original_is_dir,\n            ext: extension_for(&new_path, original_is_dir),\n            size: new_meta\n                .as_ref()\n                .filter(|m| m.is_file())\n                .map(|m| m.len() as i64),\n            mtime: new_meta\n                .and_then(|m| m.modified().ok())\n                .and_then(|m| m.duration_since(UNIX_EPOCH).ok())\n                .map(|d| d.as_secs() as i64),\n        })\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nasync fn fd_search(\n    query: String,\n    limit: Option<u32>,\n    offset: Option<u32>,\n    sort_by: Option<String>,\n    sort_dir: Option<String>,\n    state: State<'_, AppState>,\n) -> AppResult<FdSearchResultDto> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        let query = query.trim().to_string();\n        let limit = limit.unwrap_or(500).clamp(1, 5000) as usize;\n        let offset = offset.unwrap_or(0) as usize;\n        let sort_by = sort_by.unwrap_or_else(|| \"name\".to_string());\n        let sort_dir = sort_dir.unwrap_or_else(|| \"asc\".to_string());\n        let (runtime_ignored_roots, runtime_ignored_patterns) =\n            cached_effective_ignore_rules(&state);\n        let ignore_fingerprint =\n            ignore_rules_fingerprint(&runtime_ignored_roots, &runtime_ignored_patterns);\n\n        if query.is_empty() {\n            return Ok(FdSearchResultDto {\n                entries: Vec::new(),\n                total: 0,\n                timed_out: false,\n            });\n        }\n\n        {\n            let cache = state.fd_search_cache.lock();\n            if let Some(cached) = cache.as_ref() {\n                let cache_hit = cached.query == query\n                    && cached.sort_by == sort_by\n                    && cached.sort_dir == sort_dir\n                    && cached.ignore_fingerprint == ignore_fingerprint;\n                if cache_hit {\n                    let total = cached.entries.len() as u64;\n                    let end = (offset + limit).min(cached.entries.len());\n                    let page = if offset < cached.entries.len() {\n                        cached.entries[offset..end].to_vec()\n                    } else {\n                        Vec::new()\n                    };\n                    return Ok(FdSearchResultDto {\n                        entries: page,\n                        total,\n                        timed_out: false,\n                    });\n                }\n            }\n        }\n\n        let result = fd_search::run_fd_search(\n            &state.scan_root,\n            &runtime_ignored_roots,\n            &runtime_ignored_patterns,\n            &query,\n            &sort_by,\n            &sort_dir,\n        );\n        let total = result.entries.len() as u64;\n        let end = (offset + limit).min(result.entries.len());\n        let page = if offset < result.entries.len() {\n            result.entries[offset..end].to_vec()\n        } else {\n            Vec::new()\n        };\n\n        {\n            let mut cache = state.fd_search_cache.lock();\n            *cache = Some(FdSearchCache {\n                query: query.clone(),\n                sort_by: sort_by.clone(),\n                sort_dir: sort_dir.clone(),\n                ignore_fingerprint,\n                entries: result.entries,\n            });\n        }\n\n        Ok(FdSearchResultDto {\n            entries: page,\n            total,\n            timed_out: result.timed_out,\n        })\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nfn frontend_log(msg: String) {\n    eprintln!(\"{msg}\");\n}\n\n#[tauri::command]\nfn mark_frontend_ready(state: State<'_, AppState>) {\n    state.frontend_ready.store(true, AtomicOrdering::Release);\n    if cfg!(debug_assertions) {\n        eprintln!(\"[startup] frontend_ready=true\");\n    }\n}\n\n#[tauri::command]\nfn get_platform() -> String {\n    if cfg!(target_os = \"windows\") {\n        \"windows\".to_string()\n    } else if cfg!(target_os = \"macos\") {\n        \"macos\".to_string()\n    } else {\n        \"linux\".to_string()\n    }\n}\n\n#[cfg(target_os = \"windows\")]\n#[tauri::command]\nasync fn show_context_menu(\n    paths: Vec<String>,\n    x: f64,\n    y: f64,\n    _single_selection: bool,\n    app: AppHandle,\n) -> AppResult<()> {\n    let window = app\n        .get_webview_window(\"main\")\n        .ok_or_else(|| \"Main window not found\".to_string())?;\n\n    let scale = window.scale_factor().map_err(|e| e.to_string())?;\n    let win_pos = window.inner_position().map_err(|e| e.to_string())?;\n    let screen_x = win_pos.x + (x * scale) as i32;\n    let screen_y = win_pos.y + (y * scale) as i32;\n\n    let hwnd_raw = window.hwnd().map_err(|e| e.to_string())?.0 as isize;\n\n    // TrackPopupMenu must run on the thread that owns the HWND (main UI thread).\n    // Use a channel to relay the result back to the async context.\n    let (tx, rx) = std::sync::mpsc::sync_channel::<Result<(), String>>(1);\n\n    app.run_on_main_thread(move || {\n        let result = win::context_menu::show(hwnd_raw, &paths, screen_x, screen_y);\n        let _ = tx.send(result);\n    })\n    .map_err(|e| e.to_string())?;\n\n    tauri::async_runtime::spawn_blocking(move || {\n        rx.recv().map_err(|e| format!(\"context menu channel: {e}\"))?\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[cfg(target_os = \"macos\")]\n#[tauri::command]\nasync fn show_context_menu(\n    _paths: Vec<String>,\n    x: f64,\n    y: f64,\n    single_selection: bool,\n    app: AppHandle,\n) -> AppResult<()> {\n    use tauri::menu::{IsMenuItem, Menu, MenuItem, PredefinedMenuItem};\n\n    let window = app\n        .get_webview_window(\"main\")\n        .ok_or_else(|| \"Main window not found\".to_string())?;\n\n    let (tx, rx) = std::sync::mpsc::sync_channel::<Result<(), String>>(1);\n\n    let app_clone = app.clone();\n    app.run_on_main_thread(move || {\n        let app = app_clone;\n        let result = (|| -> Result<(), tauri::Error> {\n            let open = MenuItem::with_id(&app, \"ctx_open\", \"Open\", true, None::<&str>)?;\n            let quick_look =\n                MenuItem::with_id(&app, \"ctx_quick_look\", \"Quick Look\", true, None::<&str>)?;\n            let open_with =\n                MenuItem::with_id(&app, \"ctx_open_with\", \"Open With...\", true, None::<&str>)?;\n            let sep1 = PredefinedMenuItem::separator(&app)?;\n            let reveal = MenuItem::with_id(\n                &app,\n                \"ctx_reveal\",\n                \"Reveal in Finder\",\n                true,\n                None::<&str>,\n            )?;\n            let sep2 = PredefinedMenuItem::separator(&app)?;\n            let copy_files =\n                MenuItem::with_id(&app, \"ctx_copy_files\", \"Copy\", true, None::<&str>)?;\n            let copy_path =\n                MenuItem::with_id(&app, \"ctx_copy_path\", \"Copy Path\", true, None::<&str>)?;\n            let sep3 = PredefinedMenuItem::separator(&app)?;\n            let trash = MenuItem::with_id(\n                &app,\n                \"ctx_trash\",\n                \"Move to Trash\",\n                true,\n                None::<&str>,\n            )?;\n            let rename =\n                MenuItem::with_id(&app, \"ctx_rename\", \"Rename\", true, None::<&str>)?;\n\n            let mut items: Vec<&dyn IsMenuItem<tauri::Wry>> = vec![\n                &open, &quick_look, &open_with, &sep1, &reveal, &sep2, &copy_files, &copy_path, &sep3, &trash,\n            ];\n            if single_selection {\n                items.push(&rename);\n            }\n\n            let menu = Menu::with_items(&app, &items)?;\n            // Position is window-relative logical pixels, matching clientX/clientY.\n            window.popup_menu_at(&menu, tauri::LogicalPosition::new(x, y))?;\n            Ok(())\n        })();\n        let _ = tx.send(result.map_err(|e| e.to_string()));\n    })\n    .map_err(|e| e.to_string())?;\n\n    tauri::async_runtime::spawn_blocking(move || {\n        rx.recv().map_err(|e| format!(\"context menu channel: {e}\"))?\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[cfg(not(any(target_os = \"windows\", target_os = \"macos\")))]\n#[tauri::command]\nasync fn show_context_menu(\n    _paths: Vec<String>,\n    _x: f64,\n    _y: f64,\n    _single_selection: bool,\n    _app: AppHandle,\n) -> AppResult<()> {\n    Err(\"Native context menu is only supported on Windows and macOS\".to_string())\n}\n\n#[tauri::command]\nasync fn set_native_theme(theme: String, app: AppHandle) -> AppResult<()> {\n    let window = app\n        .get_webview_window(\"main\")\n        .ok_or_else(|| \"Main window not found\".to_string())?;\n    let t = if theme == \"light\" {\n        tauri::Theme::Light\n    } else {\n        tauri::Theme::Dark\n    };\n    window.set_theme(Some(t)).map_err(|e| e.to_string())\n}\n\n#[tauri::command]\nasync fn get_file_icon(\n    path: Option<String>,\n    ext: String,\n    state: State<'_, AppState>,\n) -> AppResult<Vec<u8>> {\n    let state = state.inner().clone();\n    Ok(tauri::async_runtime::spawn_blocking(move || {\n        let ext_lower = if ext.trim().is_empty() {\n            \"__default__\".to_string()\n        } else {\n            ext.to_lowercase()\n        };\n\n        #[cfg(target_os = \"windows\")]\n        let cache_key = {\n            if is_per_file_icon_ext(&ext_lower) {\n                path.as_deref().unwrap_or(&ext_lower).to_string()\n            } else {\n                ext_lower.clone()\n            }\n        };\n        #[cfg(not(target_os = \"windows\"))]\n        let cache_key = ext_lower.clone();\n\n        if let Some(cached) = state.icon_cache.lock().get(&cache_key).cloned() {\n            return cached;\n        }\n\n        #[cfg(target_os = \"windows\")]\n        let icon = {\n            let from_path = path\n                .as_deref()\n                .filter(|p| !p.is_empty())\n                .and_then(win::icon::load_icon_png);\n            from_path.or_else(|| load_system_icon_png(&ext_lower))\n        };\n        #[cfg(not(target_os = \"windows\"))]\n        let icon = {\n            let _ = path;\n            load_system_icon_png(&ext_lower)\n        };\n\n        let icon = icon.unwrap_or_default();\n        state.icon_cache.lock().insert(cache_key, icon.clone());\n        icon\n    })\n    .await\n    .unwrap_or_default())\n}\n\nfn default_bench_cases() -> Vec<BenchCase> {\n    vec![\n        BenchCase {\n            id: \"TC01_exact_name\",\n            query: \"report_00042\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC02_prefix_name\",\n            query: \"report_00\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 10,\n        },\n        BenchCase {\n            id: \"TC03_contains_name\",\n            query: \"invoice\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC04_ext_md\",\n            query: \"*.md\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC05_path_glob_png\",\n            query: \"Desktop/ *.png\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC06_path_term\",\n            query: \"Projects/rust\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC07_path_ext_rs\",\n            query: \"Projects/ *.rs\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC08_no_match\",\n            query: \"zzzz_not_exists_12345\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 0,\n        },\n    ]\n}\n\nfn bench_iterations() -> u32 {\n    std::env::var(\"EVERYTHING_BENCH_ITERATIONS\")\n        .ok()\n        .and_then(|v| v.parse::<u32>().ok())\n        .map(|v| v.clamp(1, 50))\n        .unwrap_or(5)\n}\n\nfn bench_wait_timeout() -> Duration {\n    let seconds = std::env::var(\"EVERYTHING_BENCH_WAIT_SEC\")\n        .ok()\n        .and_then(|v| v.parse::<u64>().ok())\n        .map(|v| v.clamp(10, 7200))\n        .unwrap_or(1800);\n    Duration::from_secs(seconds)\n}\n\nfn bench_run_label() -> String {\n    std::env::var(\"EVERYTHING_BENCH_RUN_LABEL\")\n        .ok()\n        .filter(|v| !v.trim().is_empty())\n        .unwrap_or_else(|| format!(\"run-{}\", now_epoch()))\n}\n\nfn bench_output_path(db_path: &Path, run_label: &str) -> PathBuf {\n    std::env::var(\"EVERYTHING_BENCH_OUTPUT\")\n        .ok()\n        .filter(|v| !v.trim().is_empty())\n        .map(PathBuf::from)\n        .unwrap_or_else(|| db_path.with_file_name(format!(\"bench-report-{run_label}.json\")))\n}\n\nfn write_bench_report(path: &Path, report: &BenchReport) -> AppResult<()> {\n    let json = serde_json::to_string_pretty(report).map_err(|e| e.to_string())?;\n    fs::write(path, json).map_err(|e| e.to_string())\n}\n\nfn start_bench_runner(app_handle: AppHandle, state: AppState) {\n    std::thread::spawn(move || {\n        let run_label = bench_run_label();\n        let output_path = bench_output_path(&state.db_path, &run_label);\n        let iterations = bench_iterations();\n        let wait_timeout = bench_wait_timeout();\n        let started_at = now_epoch();\n\n        perf_log(format!(\n            \"bench_start run_label={} output={} iterations={} wait_timeout_s={}\",\n            run_label,\n            output_path.to_string_lossy(),\n            iterations,\n            wait_timeout.as_secs(),\n        ));\n\n        let wait_started = Instant::now();\n        let mut saw_indexing = false;\n        let index_snapshot: IndexStatus;\n        loop {\n            let snapshot = state.status.lock().clone();\n            let active = state.indexing_active.load(AtomicOrdering::Acquire)\n                || matches!(snapshot.state, IndexState::Indexing);\n\n            if active {\n                saw_indexing = true;\n            }\n\n            if state.db_ready.load(AtomicOrdering::Acquire) && saw_indexing && !active {\n                index_snapshot = snapshot;\n                break;\n            }\n\n            if wait_started.elapsed() >= wait_timeout {\n                let report = BenchReport {\n                    run_label: run_label.clone(),\n                    started_at,\n                    completed_at: now_epoch(),\n                    home_dir: state.home_dir.to_string_lossy().to_string(),\n                    db_path: state.db_path.to_string_lossy().to_string(),\n                    index_wait_ms: wait_started.elapsed().as_millis(),\n                    index_scanned: snapshot.scanned,\n                    index_indexed: snapshot.indexed,\n                    index_entries_count: snapshot.entries_count,\n                    index_permission_errors: snapshot.permission_errors,\n                    index_message: Some(\"Timed out waiting for index ready\".to_string()),\n                    search_iterations: iterations,\n                    search_results: Vec::new(),\n                };\n                let _ = write_bench_report(&output_path, &report);\n                perf_log(format!(\n                    \"bench_timeout run_label={} waited_ms={}\",\n                    run_label,\n                    wait_started.elapsed().as_millis()\n                ));\n                if env_truthy(\"EVERYTHING_BENCH_EXIT\") {\n                    app_handle.exit(2);\n                }\n                return;\n            }\n\n            std::thread::sleep(Duration::from_millis(200));\n        }\n\n        let index_wait_ms = wait_started.elapsed().as_millis();\n        perf_log(format!(\n            \"bench_index_ready run_label={} waited_ms={} scanned={} indexed={} entries={} permission_errors={}\",\n            run_label,\n            index_wait_ms,\n            index_snapshot.scanned,\n            index_snapshot.indexed,\n            index_snapshot.entries_count,\n            index_snapshot.permission_errors,\n        ));\n\n        let mut search_results = Vec::new();\n        for case in default_bench_cases() {\n            let mut elapsed_sum = 0.0f64;\n            let mut success_count = 0u32;\n            let mut result_count = 0usize;\n            let mut mode = String::new();\n            let mut top_results = Vec::new();\n            let mut case_error = None;\n\n            for iter in 1..=iterations {\n                let started = Instant::now();\n                match execute_search(\n                    &state,\n                    case.query.to_string(),\n                    Some(case.limit),\n                    Some(case.offset),\n                    Some(case.sort_by.to_string()),\n                    Some(case.sort_dir.to_string()),\n                ) {\n                    Ok(execution) => {\n                        let elapsed_ms = started.elapsed().as_secs_f64() * 1000.0;\n                        elapsed_sum += elapsed_ms;\n                        success_count += 1;\n                        result_count = execution.results.len();\n                        mode = execution.mode_label;\n                        top_results = execution\n                            .results\n                            .iter()\n                            .take(5)\n                            .map(|entry| entry.path.clone())\n                            .collect();\n\n                        perf_log(format!(\n                            \"bench_query run_label={} case={} iter={}/{} query={:?} mode={} results={} elapsed_ms={:.3}\",\n                            run_label,\n                            case.id,\n                            iter,\n                            iterations,\n                            case.query,\n                            mode,\n                            result_count,\n                            elapsed_ms\n                        ));\n                    }\n                    Err(err) => {\n                        case_error = Some(err);\n                        break;\n                    }\n                }\n            }\n\n            let elapsed_ms = if success_count > 0 {\n                elapsed_sum / success_count as f64\n            } else {\n                0.0\n            };\n            let passed = case_error.is_none() && result_count >= case.expected_min_results;\n\n            search_results.push(BenchCaseResult {\n                id: case.id.to_string(),\n                query: case.query.to_string(),\n                mode,\n                sort_by: case.sort_by.to_string(),\n                sort_dir: case.sort_dir.to_string(),\n                limit: case.limit,\n                offset: case.offset,\n                elapsed_ms,\n                result_count,\n                expected_min_results: case.expected_min_results,\n                passed,\n                top_results,\n                error: case_error,\n            });\n        }\n\n        let report = BenchReport {\n            run_label: run_label.clone(),\n            started_at,\n            completed_at: now_epoch(),\n            home_dir: state.home_dir.to_string_lossy().to_string(),\n            db_path: state.db_path.to_string_lossy().to_string(),\n            index_wait_ms,\n            index_scanned: index_snapshot.scanned,\n            index_indexed: index_snapshot.indexed,\n            index_entries_count: index_snapshot.entries_count,\n            index_permission_errors: index_snapshot.permission_errors,\n            index_message: index_snapshot.message.clone(),\n            search_iterations: iterations,\n            search_results,\n        };\n\n        match write_bench_report(&output_path, &report) {\n            Ok(()) => perf_log(format!(\n                \"bench_report_written run_label={} path={}\",\n                run_label,\n                output_path.to_string_lossy()\n            )),\n            Err(err) => perf_log(format!(\n                \"bench_report_write_error run_label={} path={} err={}\",\n                run_label,\n                output_path.to_string_lossy(),\n                err\n            )),\n        }\n\n        if env_truthy(\"EVERYTHING_BENCH_EXIT\") {\n            app_handle.exit(0);\n        }\n    });\n}\n\n#[cfg(target_os = \"macos\")]\nfn register_global_shortcut(app: &AppHandle) -> AppResult<()> {\n    let shortcut = Shortcut::new(Some(Modifiers::SUPER | Modifiers::SHIFT), Code::Space);\n\n    app.global_shortcut()\n        .on_shortcut(shortcut, move |app_handle, _, _| {\n            if let Some(window) = app_handle.get_webview_window(\"main\") {\n                let _ = window.show();\n                let _ = window.unminimize();\n                let _ = window.set_focus();\n            }\n            let _ = app_handle.emit(\"focus_search\", ());\n        })\n        .map_err(|e| format!(\"Failed to register global shortcut: {e}\"))\n}\n\n#[cfg(not(target_os = \"macos\"))]\nfn register_global_shortcut(_app: &AppHandle) -> AppResult<()> {\n    Ok(())\n}\n\nfn setup_app(app: &mut tauri::App) -> AppResult<()> {\n    let setup_started = std::time::Instant::now();\n    eprintln!(\"[startup] setup_app() entered\");\n    let bench_mode = bench_mode_enabled();\n\n    #[cfg(target_os = \"macos\")]\n    if let Some(window) = app.get_webview_window(\"main\") {\n        use tauri::window::Color;\n        let is_dark = window\n            .theme()\n            .map(|t| t == tauri::Theme::Dark)\n            .unwrap_or(false);\n        let bg = if is_dark {\n            Color(0x1f, 0x1f, 0x1f, 0xff)\n        } else {\n            Color(0xf4, 0xf5, 0xf7, 0xff)\n        };\n        let _ = window.set_background_color(Some(bg));\n        let _ = window.show();\n    }\n\n    #[cfg(target_os = \"windows\")]\n    if let Some(window) = app.get_webview_window(\"main\") {\n        eprintln!(\"[startup +{}ms] windows setup: before window.show()\", startup_elapsed_ms());\n        use tauri::window::Color;\n        let is_dark = window.theme().map(|t| t == tauri::Theme::Dark).unwrap_or(false);\n        let bg = if is_dark {\n            Color(0x1f, 0x1f, 0x1f, 0xff)\n        } else {\n            Color(0xf4, 0xf5, 0xf7, 0xff)\n        };\n        let _ = window.set_background_color(Some(bg));\n        if let Err(e) = window.set_decorations(false) {\n            eprintln!(\n                \"[startup +{}ms] windows setup: set_decorations(false) failed: {}\",\n                startup_elapsed_ms(),\n                e\n            );\n        }\n        let _ = window.show();\n        eprintln!(\"[startup +{}ms] windows setup: window.show() returned\", startup_elapsed_ms());\n    }\n\n    let app_data_dir = app\n        .path()\n        .app_data_dir()\n        .map_err(|e| format!(\"Failed to get app data dir: {e}\"))?;\n    fs::create_dir_all(&app_data_dir).map_err(|e| e.to_string())?;\n\n    let db_path = app_data_dir.join(\"index.db\");\n    let home_dir = PathBuf::from(\n        std::env::var(\"HOME\")\n            .or_else(|_| std::env::var(\"USERPROFILE\"))\n            .unwrap_or_else(|_| if cfg!(windows) { \"C:\\\\\".to_string() } else { \"/\".to_string() }),\n    );\n    let scan_root = if cfg!(windows) {\n        PathBuf::from(\"C:\\\\\")\n    } else {\n        home_dir.clone()\n    };\n    let cwd = std::env::current_dir().unwrap_or_else(|_| home_dir.clone());\n    eprintln!(\"[startup] +{}ms loading pathignore rules...\", setup_started.elapsed().as_millis());\n    let (mut path_ignores, path_ignore_patterns) = load_pathignore_rules(&home_dir, &cwd);\n    if !path_ignores.iter().any(|r| r == &app_data_dir) {\n        path_ignores.push(app_data_dir.clone());\n    }\n    for root in load_gitignore_roots(&home_dir, &cwd) {\n        if !path_ignores.iter().any(|r| r == &root) {\n            path_ignores.push(root);\n        }\n    }\n    eprintln!(\"[startup] +{}ms pathignore done\", setup_started.elapsed().as_millis());\n\n    let gitignore = Arc::new(gitignore_filter::LazyGitignoreFilter::new(home_dir.clone()));\n\n    let state = AppState {\n        db_path,\n        home_dir,\n        scan_root,\n        cwd,\n        path_ignores: Arc::new(path_ignores),\n        path_ignore_patterns: Arc::new(path_ignore_patterns),\n        db_ready: Arc::new(AtomicBool::new(false)),\n        indexing_active: Arc::new(AtomicBool::new(false)),\n        status: Arc::new(Mutex::new(IndexStatus::default())),\n        recent_ops: Arc::new(Mutex::new(Vec::new())),\n        icon_cache: Arc::new(Mutex::new(HashMap::new())),\n        fd_search_cache: Arc::new(Mutex::new(None)),\n        negative_name_cache: Arc::new(Mutex::new(HashMap::new())),\n        ignore_cache: Arc::new(Mutex::new(None)),\n        gitignore,\n        mem_index: Arc::new(RwLock::new(None)),\n        watcher_stop: Arc::new(AtomicBool::new(false)),\n        watcher_active: Arc::new(AtomicBool::new(false)),\n        frontend_ready: Arc::new(AtomicBool::new(false)),\n    };\n\n    eprintln!(\"[startup] +{}ms AppState created\", setup_started.elapsed().as_millis());\n    app.manage(state.clone());\n    if !bench_mode {\n        register_global_shortcut(&app.handle())?;\n    }\n    // Context menu item IDs use the \"ctx_\" prefix by convention.\n    // All matching IDs are forwarded as \"context_menu_action\" events to the frontend.\n    #[cfg(target_os = \"macos\")]\n    {\n        app.handle().on_menu_event(|app, event| {\n            let action = match event.id().as_ref() {\n                \"ctx_open\" => \"open\",\n                \"ctx_quick_look\" => \"quick_look\",\n                \"ctx_open_with\" => \"open_with\",\n                \"ctx_reveal\" => \"reveal\",\n                \"ctx_copy_files\" => \"copy_files\",\n                \"ctx_copy_path\" => \"copy_path\",\n                \"ctx_trash\" => \"trash\",\n                \"ctx_rename\" => \"rename\",\n                _ => return,\n            };\n            let _ = app.emit(\"context_menu_action\", action);\n        });\n    }\n    eprintln!(\"[startup] +{}ms global shortcut registered\", setup_started.elapsed().as_millis());\n    if bench_mode {\n        if let Some(window) = app.get_webview_window(\"main\") {\n            let _ = window.hide();\n        }\n    }\n\n    eprintln!(\"[startup] +{}ms setup_app() done, spawning init thread\", setup_started.elapsed().as_millis());\n\n    let app_handle = app.handle().clone();\n    std::thread::spawn(move || {\n        let thread_started = std::time::Instant::now();\n        eprintln!(\"[startup/thread] init thread started\");\n\n        eprintln!(\"[startup/thread] +{}ms calling init_db...\", thread_started.elapsed().as_millis());\n        if let Err(err) = init_db(&state.db_path) {\n            set_state(&state, IndexState::Error, Some(err.clone()));\n            emit_index_state(&app_handle, \"Error\", Some(err));\n            return;\n        }\n        eprintln!(\"[startup/thread] +{}ms init_db done\", thread_started.elapsed().as_millis());\n\n        state.db_ready.store(true, AtomicOrdering::Release);\n        eprintln!(\"[startup/thread] +{}ms db_ready=true -- launching indexing immediately\", thread_started.elapsed().as_millis());\n\n        // Deferred housekeeping -- purge + status counts run in background\n        {\n            let hk_app = app_handle.clone();\n            let hk_state = state.clone();\n            std::thread::spawn(move || {\n                // Brief pause so indexing thread can start first\n                std::thread::sleep(std::time::Duration::from_millis(500));\n                let hk_started = std::time::Instant::now();\n                let _ = refresh_and_emit_status_counts(&hk_app, &hk_state);\n                eprintln!(\"[startup/housekeeping] refresh_and_emit_status_counts done in {}ms\", hk_started.elapsed().as_millis());\n                // Wait for frontend readiness so initial paint and first input are not contended by purge I/O.\n                const FRONTEND_READY_TIMEOUT: Duration = Duration::from_secs(180);\n                const POST_READY_GRACE: Duration = Duration::from_secs(2);\n                let wait_started = std::time::Instant::now();\n                while !hk_state.frontend_ready.load(AtomicOrdering::Acquire)\n                    && wait_started.elapsed() < FRONTEND_READY_TIMEOUT\n                {\n                    std::thread::sleep(Duration::from_millis(50));\n                }\n                if hk_state.frontend_ready.load(AtomicOrdering::Acquire) {\n                    eprintln!(\n                        \"[startup/housekeeping] frontend_ready observed after {}ms; purging in {}ms\",\n                        wait_started.elapsed().as_millis(),\n                        POST_READY_GRACE.as_millis()\n                    );\n                } else {\n                    eprintln!(\n                        \"[startup/housekeeping] frontend_ready wait timed out after {}ms; proceeding with purge\",\n                        FRONTEND_READY_TIMEOUT.as_millis()\n                    );\n                }\n                std::thread::sleep(POST_READY_GRACE);\n                let purge_started = std::time::Instant::now();\n                if let Err(err) = purge_ignored_entries(&hk_state.db_path, &hk_state.path_ignores) {\n                    eprintln!(\"[startup/housekeeping] purge_ignored_entries failed: {err}\");\n                } else {\n                    eprintln!(\n                        \"[startup/housekeeping] purge_ignored_entries done in {}ms\",\n                        purge_started.elapsed().as_millis()\n                    );\n                }\n                eprintln!(\"[startup/housekeeping] all done in {}ms\", hk_started.elapsed().as_millis());\n            });\n        }\n\n        #[cfg(target_os = \"macos\")]\n        {\n            if bench_mode {\n                let _ = start_full_index_worker(app_handle.clone(), state.clone());\n            } else {\n                let (stored_event_id, index_complete) = db_connection(&state.db_path)\n                    .ok()\n                    .map(|c| {\n                        let eid = get_meta(&c, \"last_event_id\")\n                            .and_then(|v| v.parse::<u64>().ok());\n                        let complete = get_meta(&c, \"index_complete\")\n                            .map(|v| v == \"1\")\n                            .unwrap_or(false);\n                        (eid, complete)\n                    })\n                    .unwrap_or((None, false));\n\n                if stored_event_id.is_some() && index_complete {\n                    // Conditional startup: try watcher replay first, skip full scan if OK\n                    start_fsevent_watcher_worker(\n                        app_handle.clone(),\n                        state.clone(),\n                        stored_event_id,\n                        true,\n                    );\n                } else {\n                    if !index_complete {\n                        eprintln!(\"[mac] index incomplete; starting full index\");\n                    }\n                    let _ = start_full_index_worker(app_handle.clone(), state.clone());\n                    start_fsevent_watcher_worker(app_handle.clone(), state.clone(), None, false);\n                }\n            }\n        }\n\n        #[cfg(target_os = \"windows\")]\n        {\n            win::start_windows_indexing(app_handle.clone(), state.clone());\n        }\n\n        #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n        {\n            let _ = start_full_index_worker(app_handle.clone(), state.clone());\n        }\n\n        if bench_mode {\n            start_bench_runner(app_handle.clone(), state.clone());\n        }\n\n        #[cfg(not(target_os = \"windows\"))]\n        if !bench_mode {\n            let icon_cache = state.icon_cache.clone();\n            std::thread::spawn(move || {\n                let exts = [\n                    \"txt\", \"pdf\", \"png\", \"jpg\", \"md\", \"json\", \"swift\", \"rs\", \"js\", \"ts\", \"html\",\n                    \"css\", \"py\", \"zip\", \"dmg\", \"app\", \"doc\", \"xls\", \"ppt\", \"mov\",\n                ];\n                for ext in &exts {\n                    let key = ext.to_string();\n                    if icon_cache.lock().contains_key(&key) {\n                        continue;\n                    }\n                    if let Some(icon) = load_system_icon_png(ext) {\n                        icon_cache.lock().insert(key, icon);\n                    }\n                }\n            });\n        }\n    });\n\n    Ok(())\n}\n\n#[cfg_attr(mobile, tauri::mobile_entry_point)]\npub fn run() {\n    let _ = STARTUP_T0.set(Instant::now());\n    eprintln!(\"[startup +{}ms] run() entered\", startup_elapsed_ms());\n    #[cfg(target_os = \"windows\")]\n    if cfg!(debug_assertions) {\n        // Safety: called at program start before any threads are spawned.\n        // Will require `unsafe` block when migrating to Rust edition 2024.\n        std::env::set_var(\n            \"WEBVIEW2_ADDITIONAL_BROWSER_ARGUMENTS\",\n            \"--no-proxy-server --disable-http-cache --disk-cache-size=1 --media-cache-size=1\",\n        );\n        eprintln!(\n            \"[startup +{}ms] set REDACTED --disable-http-cache --disk-cache-size=1 --media-cache-size=1\",\n            startup_elapsed_ms()\n        );\n    }\n    let mut builder = tauri::Builder::default()\n        .plugin(tauri_plugin_decorum::init())\n        .plugin(tauri_plugin_drag::init())\n        .plugin(tauri_plugin_global_shortcut::Builder::new().build());\n\n    if !cfg!(debug_assertions) {\n        builder = builder.plugin(tauri_plugin_window_state::Builder::default().build());\n    } else {\n        eprintln!(\n            \"[startup +{}ms] debug mode: window-state plugin disabled for startup A/B test\",\n            startup_elapsed_ms()\n        );\n    }\n\n    builder\n        .on_page_load(|window, payload| {\n            eprintln!(\n                \"[startup/page +{}ms] on_page_load label={} event={:?} url={}\",\n                startup_elapsed_ms(),\n                window.label(),\n                payload.event(),\n                payload.url()\n            );\n        })\n        .setup(|app| {\n            setup_app(app).map_err(|e| {\n                Box::<dyn std::error::Error>::from(io::Error::new(io::ErrorKind::Other, e))\n            })\n        })\n        .invoke_handler(tauri::generate_handler![\n            get_index_status,\n            get_home_dir,\n            start_full_index,\n            reset_index,\n            search,\n            fd_search,\n            quick_look,\n            open,\n            open_with,\n            reveal_in_finder,\n            copy_paths,\n            copy_files,\n            move_to_trash,\n            rename,\n            get_file_icon,\n            get_platform,\n            show_context_menu,\n            set_native_theme,\n            frontend_log,\n            mark_frontend_ready\n        ])\n        .run(tauri::generate_context!())\n        .expect(\"error while running tauri application\");\n}\n\nfn main() {\n    run();\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::time::{SystemTime, UNIX_EPOCH};\n\n    fn mk_entry(path: &str, name: &str) -> EntryDto {\n        let parent = Path::new(path)\n            .parent()\n            .map(|p| p.to_string_lossy().to_string())\n            .unwrap_or_else(|| \"/\".to_string());\n        EntryDto {\n            path: path.to_string(),\n            name: name.to_string(),\n            dir: parent,\n            is_dir: false,\n            ext: None,\n            size: None,\n            mtime: None,\n        }\n    }\n\n    fn temp_case_dir(case: &str) -> PathBuf {\n        let stamp = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .map(|d| d.as_nanos())\n            .unwrap_or(0);\n        let base = if cfg!(target_os = \"windows\") {\n            std::env::current_dir()\n                .map(|dir| dir.join(\"tmp-test-dirs\"))\n                .unwrap_or_else(|_| std::env::temp_dir())\n        } else {\n            std::env::temp_dir()\n        };\n        base.join(format!(\n            \"everything_{case}_{}_{}\",\n            std::process::id(),\n            stamp\n        ))\n    }\n\n    fn test_state_for(db_path: PathBuf, home_dir: PathBuf, cwd: PathBuf) -> AppState {\n        AppState {\n            db_path,\n            home_dir: home_dir.clone(),\n            scan_root: home_dir.clone(),\n            cwd,\n            path_ignores: Arc::new(Vec::new()),\n            path_ignore_patterns: Arc::new(Vec::new()),\n            db_ready: Arc::new(AtomicBool::new(true)),\n            indexing_active: Arc::new(AtomicBool::new(false)),\n            status: Arc::new(Mutex::new(IndexStatus::default())),\n            recent_ops: Arc::new(Mutex::new(Vec::new())),\n            icon_cache: Arc::new(Mutex::new(HashMap::new())),\n            fd_search_cache: Arc::new(Mutex::new(None)),\n            negative_name_cache: Arc::new(Mutex::new(HashMap::new())),\n            ignore_cache: Arc::new(Mutex::new(None)),\n            gitignore: Arc::new(gitignore_filter::LazyGitignoreFilter::new(home_dir.clone())),\n            mem_index: Arc::new(RwLock::new(None)),\n            watcher_stop: Arc::new(AtomicBool::new(false)),\n            watcher_active: Arc::new(AtomicBool::new(false)),\n            frontend_ready: Arc::new(AtomicBool::new(true)),\n        }\n    }\n\n    #[test]\n    fn should_skip_path_for_ignored_descendant() {\n        let ignored = vec![PathBuf::from(\n            \"/Users/al02402336/Library/Developer/Xcode/DerivedData\",\n        )];\n        let target = Path::new(\n            \"REDACTED\",\n        );\n\n        assert!(should_skip_path(target, &ignored, &[]));\n    }\n\n    #[test]\n    fn filter_ignored_entries_removes_pathignore_matches() {\n        let ignored = vec![PathBuf::from(\n            \"/Users/al02402336/Library/Developer/Xcode/DerivedData\",\n        )];\n        let entries = vec![\n            mk_entry(\n                \"REDACTED\",\n                \"-Users-al02402336-a_desktop\",\n            ),\n            mk_entry(\"/Users/al02402336/a_desktop\", \"a_desktop\"),\n        ];\n\n        let filtered = filter_ignored_entries(entries, &ignored, &[]);\n\n        assert_eq!(filtered.len(), 1);\n        assert_eq!(filtered[0].path, \"/Users/al02402336/a_desktop\");\n    }\n\n    #[test]\n    fn should_skip_path_for_glob_any_segment_target() {\n        let patterns = vec![IgnorePattern::AnySegment(\"target\".to_string())];\n\n        assert!(should_skip_path(\n            Path::new(\"/Users/al02402336/work/rust/target\"),\n            &[],\n            &patterns\n        ));\n        assert!(should_skip_path(\n            Path::new(\"/Users/al02402336/work/rust/target/debug/deps/foo.o\"),\n            &[],\n            &patterns\n        ));\n        assert!(!should_skip_path(\n            Path::new(\"/Users/al02402336/work/rust/targets/debug/deps/foo.o\"),\n            &[],\n            &patterns\n        ));\n    }\n\n    #[test]\n    fn relevance_sort_prefers_shallow_exact_match() {\n        let mut entries = vec![\n            mk_entry(\"/Users/al02402336/work/a_desktop\", \"a_desktop\"),\n            mk_entry(\"/Users/al02402336/a_desktop\", \"a_desktop\"),\n            mk_entry(\n                \"/Users/al02402336/Library/Developer/Xcode/DerivedData/-Users-al02402336-a_desktop\",\n                \"-Users-al02402336-a_desktop\",\n            ),\n        ];\n\n        sort_entries_with_relevance(&mut entries, \"a_desktop\", \"name\", \"asc\");\n\n        assert_eq!(entries[0].path, \"/Users/al02402336/a_desktop\");\n    }\n\n    #[test]\n    fn resolved_dir_range_excludes_sibling_with_same_prefix() {\n        let dir_exact = \"/Users/user/Projects\";\n        let dir_prefix = format!(\"{}/\", dir_exact);\n        let dir_prefix_end = format!(\"{}0\", dir_exact);\n\n        let in_scope = |dir: &str| {\n            dir == dir_exact || (dir >= dir_prefix.as_str() && dir < dir_prefix_end.as_str())\n        };\n\n        assert!(in_scope(\"/Users/user/Projects\"));\n        assert!(in_scope(\"/Users/user/Projects/src\"));\n        assert!(in_scope(\"/Users/user/Projects/src/deeper\"));\n\n        assert!(!in_scope(\"/Users/user/Projects-archived\"));\n        assert!(!in_scope(\"/Users/user/Projects.archived\"));\n        assert!(!in_scope(\"/Users/user/Projects_archived\"));\n        assert!(!in_scope(\"/Users/user/Projectz\"));\n    }\n\n    #[test]\n    fn delete_paths_root_clears_all_entries() {\n        let root = temp_case_dir(\"delete_paths_root\");\n        let dir_a = root.join(\"alpha\");\n        let dir_b = root.join(\"beta\").join(\"nested\");\n        fs::create_dir_all(&dir_a).unwrap();\n        fs::create_dir_all(&dir_b).unwrap();\n\n        let db_path = root.join(\"index.db\");\n        init_db(&db_path).unwrap();\n        let mut conn = db_connection(&db_path).unwrap();\n        let now = now_epoch();\n\n        for (path, name, dir, ext) in [\n            (dir_a.join(\"a.txt\"), \"a.txt\", dir_a.clone(), \"txt\"),\n            (dir_b.join(\"b.rs\"), \"b.rs\", dir_b.clone(), \"rs\"),\n        ] {\n            conn.execute(\n                \"INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n                 VALUES(?1, ?2, ?3, 0, ?4, NULL, NULL, ?5, 1)\",\n                params![\n                    path.to_string_lossy().to_string(),\n                    name,\n                    dir.to_string_lossy().to_string(),\n                    ext,\n                    now\n                ],\n            )\n            .unwrap();\n        }\n\n        let deleted = delete_paths(&mut conn, &[\"/\".to_string()]).unwrap();\n        assert!(deleted >= 2);\n\n        let remaining: i64 = conn\n            .query_row(\"SELECT COUNT(*) FROM entries\", [], |row| row.get(0))\n            .unwrap();\n        assert_eq!(remaining, 0);\n\n        let _ = fs::remove_dir_all(root);\n    }\n\n    #[test]\n    fn execute_search_resolved_path_does_not_include_prefixed_sibling_dirs() {\n        let root = temp_case_dir(\"resolved_path_scope_execute\");\n        let projects_src = root.join(\"Projects\").join(\"src\");\n        let archived_src = root.join(\"Projects-archived\").join(\"src\");\n        fs::create_dir_all(&projects_src).unwrap();\n        fs::create_dir_all(&archived_src).unwrap();\n\n        let db_path = root.join(\"index.db\");\n        init_db(&db_path).unwrap();\n        let conn = db_connection(&db_path).unwrap();\n        let now = now_epoch();\n\n        let project_path = projects_src.join(\"main.rs\");\n        let archived_path = archived_src.join(\"legacy.rs\");\n\n        conn.execute(\n            \"INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n             VALUES(?1, ?2, ?3, 0, ?4, NULL, NULL, ?5, 1)\",\n            params![\n                project_path.to_string_lossy().to_string(),\n                \"main.rs\",\n                projects_src.to_string_lossy().to_string(),\n                \"rs\",\n                now\n            ],\n        )\n        .unwrap();\n\n        conn.execute(\n            \"INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n             VALUES(?1, ?2, ?3, 0, ?4, NULL, NULL, ?5, 1)\",\n            params![\n                archived_path.to_string_lossy().to_string(),\n                \"legacy.rs\",\n                archived_src.to_string_lossy().to_string(),\n                \"rs\",\n                now\n            ],\n        )\n        .unwrap();\n\n        let state = test_state_for(db_path.clone(), root.clone(), root.clone());\n        let result = execute_search(\n            &state,\n            \"Projects/ *.rs\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        assert!(result\n            .results\n            .iter()\n            .any(|entry| entry.path == project_path.to_string_lossy()));\n        assert!(result\n            .results\n            .iter()\n            .all(|entry| !entry.path.contains(\"Projects-archived\")));\n\n        let _ = fs::remove_dir_all(root);\n    }\n\n    #[test]\n    fn find_file_upward_locates_repo_level_pathignore() {\n        let root = temp_case_dir(\"pathignore_upward\");\n        let nested = root.join(\"src-tauri\").join(\"target\");\n        fs::create_dir_all(&nested).unwrap();\n        fs::write(root.join(\".pathignore\"), \"node_modules\\n\").unwrap();\n\n        let found = find_file_upward(&nested, \".pathignore\");\n        assert_eq!(found, Some(root.join(\".pathignore\")));\n\n        let _ = fs::remove_dir_all(root);\n    }\n\n    #[test]\n    fn find_git_root_works_from_nested_directory() {\n        let root = temp_case_dir(\"git_root\");\n        let nested = root.join(\"src-tauri\").join(\"target\");\n        fs::create_dir_all(&nested).unwrap();\n        fs::create_dir_all(root.join(\".git\")).unwrap();\n\n        let found = find_git_root(&nested);\n        assert_eq!(found, Some(root.clone()));\n\n        let _ = fs::remove_dir_all(root);\n    }\n\n    #[test]\n    fn extract_ext_from_like_rejects_multi_dot() {\n        assert_eq!(extract_ext_from_like(\"%.tar.gz\"), None);\n        assert_eq!(extract_ext_from_like(\"%.d.ts\"), None);\n        assert_eq!(extract_ext_from_like(\"%.rs\"), Some(\"rs\".to_string()));\n        assert_eq!(extract_ext_from_like(\"%.png\"), Some(\"png\".to_string()));\n    }\n\n    #[test]\n    fn negative_cache_fallback_removes_matched_key_not_query() {\n        let state = test_state_for(\n            PathBuf::from(\"/tmp/neg_cache_test.db\"),\n            PathBuf::from(\"/tmp\"),\n            PathBuf::from(\"/tmp\"),\n        );\n\n        remember_negative_name_query(&state, \"abc\");\n\n        let hit = negative_name_cache_lookup(&state, \"xabc\");\n        assert!(hit.is_some());\n        assert_eq!(hit.unwrap().query_lower, \"abc\");\n\n        remove_negative_name_query(&state, \"abc\");\n\n        let hit_after = negative_name_cache_lookup(&state, \"xabc\");\n        assert!(hit_after.is_none());\n    }\n\n    #[test]\n    fn dir_listing_deep_nested_path_without_time_budget() {\n        let root = temp_case_dir(\"dir_listing_deep\");\n        // Simulate: ~/Library/Containers/jp.naver.line.mac/Data/Library/Containers/jp.naver.line/log/\n        let deep_dir = root\n            .join(\"Library\")\n            .join(\"Containers\")\n            .join(\"jp.naver.line.mac\")\n            .join(\"Data\")\n            .join(\"Library\")\n            .join(\"Containers\")\n            .join(\"jp.naver.line\")\n            .join(\"log\");\n        let sub_dir = deep_dir.join(\"archive\");\n        fs::create_dir_all(&deep_dir).unwrap();\n        fs::create_dir_all(&sub_dir).unwrap();\n\n        let db_path = root.join(\"index.db\");\n        init_db(&db_path).unwrap();\n        let conn = db_connection(&db_path).unwrap();\n        let now = now_epoch();\n\n        let file1 = deep_dir.join(\"20260211_14.txt\");\n        let file2 = sub_dir.join(\"old.log\");\n        for (path, name, dir, ext) in [\n            (&file1, \"20260211_14.txt\", &deep_dir, \"txt\"),\n            (&file2, \"old.log\", &sub_dir, \"log\"),\n        ] {\n            conn.execute(\n                \"INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n                 VALUES(?1, ?2, ?3, 0, ?4, NULL, NULL, ?5, 1)\",\n                params![\n                    path.to_string_lossy().to_string(),\n                    name,\n                    dir.to_string_lossy().to_string(),\n                    ext,\n                    now\n                ],\n            )\n            .unwrap();\n        }\n\n        let state = test_state_for(db_path, root.clone(), root.clone());\n\n        // Query: \"jp.naver.line/log/\" - dir listing, name_like = \"%\"\n        let result = execute_search(\n            &state,\n            \"jp.naver.line/log/\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        assert_eq!(\n            result.results.len(),\n            2,\n            \"should find both files under log/ and log/archive/\"\n        );\n        let names: Vec<&str> = result.results.iter().map(|e| e.name.as_str()).collect();\n        assert!(names.contains(&\"20260211_14.txt\"));\n        assert!(names.contains(&\"old.log\"));\n\n        // Query with glob: \"jp.naver.line/log/ *\"\n        let result2 = execute_search(\n            &state,\n            \"jp.naver.line/log/ *\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        assert_eq!(\n            result2.results.len(),\n            2,\n            \"glob * should also list all files\"\n        );\n\n        // Query with trailing dot: \"jp.naver.line/log/ *.\" - name_like becomes \"%.\"\n        let result3 = execute_search(\n            &state,\n            \"jp.naver.line/log/ *.\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        // \"*.\" matches files ending with \".\" - none of our test files end with \".\"\n        // so this correctly returns 0 (this is expected, NOT a bug)\n        assert_eq!(\n            result3.results.len(),\n            0,\n            \"*. matches only files ending with dot\"\n        );\n\n        // But plain \"/\" at end should list all\n        let result4 = execute_search(\n            &state,\n            \"jp.naver.line/log/\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        assert_eq!(\n            result4.results.len(),\n            2,\n            \"trailing slash should list all files\"\n        );\n\n        let _ = fs::remove_dir_all(root);\n    }\n\n    #[test]\n    fn path_search_multi_dot_ext_uses_like_not_ext_shortcut() {\n        let root = temp_case_dir(\"multi_dot_ext\");\n        let proj_dir = root.join(\"Projects\");\n        fs::create_dir_all(&proj_dir).unwrap();\n\n        let db_path = root.join(\"index.db\");\n        init_db(&db_path).unwrap();\n        let conn = db_connection(&db_path).unwrap();\n        let now = now_epoch();\n\n        let file_path = proj_dir.join(\"archive.tar.gz\");\n        conn.execute(\n            \"INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n             VALUES(?1, ?2, ?3, 0, ?4, NULL, NULL, ?5, 1)\",\n            params![\n                file_path.to_string_lossy().to_string(),\n                \"archive.tar.gz\",\n                proj_dir.to_string_lossy().to_string(),\n                \"gz\",\n                now\n            ],\n        )\n        .unwrap();\n\n        let state = test_state_for(db_path, root.clone(), root.clone());\n        let result = execute_search(\n            &state,\n            \"Projects/ *.tar.gz\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        assert_eq!(result.results.len(), 1);\n        assert!(result.results[0].name == \"archive.tar.gz\");\n\n        let _ = fs::remove_dir_all(root);\n    }\n}\n","structuredPatch":[{"oldStart":2009,"oldLines":8,"newStart":2009,"newLines":33,"lines":["     let mut conn = db_connection(&state.db_path)?;","     set_indexing_pragmas(&conn)?;"," ","+    // For fresh index (empty DB), drop secondary indexes before bulk insert and","+    // recreate them after. This avoids per-row BTREE maintenance on every insert,","+    // which can be 3-5x faster when loading hundreds of thousands of rows.","+    let is_fresh_run: bool = get_meta(&conn, \"last_run_id\")","+        .and_then(|v| v.parse::<i64>().ok())","+        .unwrap_or(0)","+        == 0;","+    if is_fresh_run {","+        let _ = conn.execute_batch(","+            \"DROP INDEX IF EXISTS idx_entries_dir_ext_name_nocase;","+             DROP INDEX IF EXISTS idx_entries_mtime;","+             DROP INDEX IF EXISTS idx_entries_name_nocase;","+             DROP INDEX IF EXISTS idx_entries_ext_name;\",","+        );","+    }","+","     let result = run_incremental_index_inner(app, state, &mut conn);"," ","+    if is_fresh_run {","+        let _ = conn.execute_batch(","+            \"CREATE INDEX IF NOT EXISTS idx_entries_dir_ext_name_nocase ON entries(dir, ext, name COLLATE NOCASE);","+             CREATE INDEX IF NOT EXISTS idx_entries_mtime ON entries(mtime);","+             CREATE INDEX IF NOT EXISTS idx_entries_name_nocase ON entries(name COLLATE NOCASE);","+             CREATE INDEX IF NOT EXISTS idx_entries_ext_name ON entries(ext, name COLLATE NOCASE);\",","+        );","+    }","+","     let _ = conn.execute_batch(\"ANALYZE\");","     let _ = restore_normal_pragmas(&conn);"," "]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"9d100d43-acec-414b-b8cc-dea453c86a77"}
{"parentUuid":"306a5af0-0801-4ae6-b3e0-902e6bbf05d3","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01RZvtAQiNaQUXaDBj9ggRnf","type":"message","role":"assistant","content":[{"type":"text","text":"ì´ì œ fresh index ì‹œ ë” í° ë°°ì¹˜ í¬ê¸°ë¥¼ ì‚¬ìš©í•˜ë„ë¡ í•©ë‹ˆë‹¤."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":638,"cache_read_input_tokens":154267,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":638},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNiqmhbhNMSjJco6Dfj1","type":"assistant","uuid":"2898c33d-ff47-486a-bdac-9f69dafc5f54","timestamp":"2026-02-22T07:35:23.629Z"}
{"parentUuid":"2898c33d-ff47-486a-bdac-9f69dafc5f54","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01RZvtAQiNaQUXaDBj9ggRnf","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EdxEPJTeL7PrhWrYWL2Yqk","name":"Read","input":{"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","offset":2075,"limit":15},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":638,"cache_read_input_tokens":154267,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":638},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNiqmhbhNMSjJco6Dfj1","type":"assistant","uuid":"4dd8ea31-0042-4de4-98f6-499a6c0ece77","timestamp":"2026-02-22T07:35:24.389Z"}
{"parentUuid":"4dd8ea31-0042-4de4-98f6-499a6c0ece77","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01EdxEPJTeL7PrhWrYWL2Yqk","toolUseID":"toolu_01EdxEPJTeL7PrhWrYWL2Yqk","timestamp":"2026-02-22T07:35:24.401Z","uuid":"9d3af29b-25ec-4109-a924-6cc24246f5f0"}
{"parentUuid":"4dd8ea31-0042-4de4-98f6-499a6c0ece77","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EdxEPJTeL7PrhWrYWL2Yqk","type":"tool_result","content":"  2075â†’        &state.home_dir,\n  2076â†’        &state.cwd,\n  2077â†’        state.path_ignores.as_ref(),\n  2078â†’        state.path_ignore_patterns.as_ref(),\n  2079â†’    );\n  2080â†’    let gi_filter = state.gitignore.get();\n  2081â†’\n  2082â†’    let last_run_id: i64 = get_meta(conn, \"last_run_id\")\n  2083â†’        .and_then(|v| v.parse().ok())\n  2084â†’        .unwrap_or(0);\n  2085â†’    let current_run_id = last_run_id + 1;\n  2086â†’    // Fresh index: DB was empty, skip preload/stamp, single unlimited-depth pass\n  2087â†’    let is_fresh = last_run_id == 0;\n  2088â†’\n  2089â†’    let mut scanned: u64 = 0;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"d8175143-1412-460f-830b-a66e398a393c","timestamp":"2026-02-22T07:35:24.400Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src-tauri/src/main.rs","content":"        &state.home_dir,\n        &state.cwd,\n        state.path_ignores.as_ref(),\n        state.path_ignore_patterns.as_ref(),\n    );\n    let gi_filter = state.gitignore.get();\n\n    let last_run_id: i64 = get_meta(conn, \"last_run_id\")\n        .and_then(|v| v.parse().ok())\n        .unwrap_or(0);\n    let current_run_id = last_run_id + 1;\n    // Fresh index: DB was empty, skip preload/stamp, single unlimited-depth pass\n    let is_fresh = last_run_id == 0;\n\n    let mut scanned: u64 = 0;","numLines":15,"startLine":2075,"totalLines":5782}},"sourceToolAssistantUUID":"4dd8ea31-0042-4de4-98f6-499a6c0ece77"}
{"parentUuid":"d8175143-1412-460f-830b-a66e398a393c","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01DG1WARd627J9cPpMSqhvLu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XhtvUnBGcGmYixYcJPrDFj","name":"Read","input":{"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","offset":2089,"limit":10},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":582,"cache_read_input_tokens":154905,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":582},"output_tokens":18,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNiqysqQVzjw8WNPS7zi","type":"assistant","uuid":"62ef4b35-673b-40c3-b00d-dab9dc8e792d","timestamp":"2026-02-22T07:35:26.739Z"}
{"parentUuid":"62ef4b35-673b-40c3-b00d-dab9dc8e792d","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01XhtvUnBGcGmYixYcJPrDFj","toolUseID":"toolu_01XhtvUnBGcGmYixYcJPrDFj","timestamp":"2026-02-22T07:35:26.754Z","uuid":"85a37b49-b078-4909-821a-dd2d4fd045fd"}
{"parentUuid":"62ef4b35-673b-40c3-b00d-dab9dc8e792d","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XhtvUnBGcGmYixYcJPrDFj","type":"tool_result","content":"  2089â†’    let mut scanned: u64 = 0;\n  2090â†’    let mut indexed: u64 = 0;\n  2091â†’    let mut permission_errors: u64 = 0;\n  2092â†’    let mut current_path = String::new();\n  2093â†’    let mut batch: Vec<IndexRow> = Vec::with_capacity(BATCH_SIZE);\n  2094â†’    let mut stamp_batch: Vec<String> = Vec::with_capacity(BATCH_SIZE);\n  2095â†’    let mut last_emit = Instant::now();\n  2096â†’    let mut last_perf_emit = Instant::now();\n  2097â†’\n  2098â†’    // Preload scan_root-level entries (direct children only, not recursive)\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"03fbc07c-d579-4968-97ff-c4a906fa87bf","timestamp":"2026-02-22T07:35:26.753Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src-tauri/src/main.rs","content":"    let mut scanned: u64 = 0;\n    let mut indexed: u64 = 0;\n    let mut permission_errors: u64 = 0;\n    let mut current_path = String::new();\n    let mut batch: Vec<IndexRow> = Vec::with_capacity(BATCH_SIZE);\n    let mut stamp_batch: Vec<String> = Vec::with_capacity(BATCH_SIZE);\n    let mut last_emit = Instant::now();\n    let mut last_perf_emit = Instant::now();\n\n    // Preload scan_root-level entries (direct children only, not recursive)","numLines":10,"startLine":2089,"totalLines":5782}},"sourceToolAssistantUUID":"62ef4b35-673b-40c3-b00d-dab9dc8e792d"}
{"parentUuid":"03fbc07c-d579-4968-97ff-c4a906fa87bf","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_017jYzGMh4tShBUEiqVwr5cB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0178pJ2ntewgW8TKVLRsJQ31","name":"Edit","input":{"replace_all":false,"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","old_string":"    let mut scanned: u64 = 0;\n    let mut indexed: u64 = 0;\n    let mut permission_errors: u64 = 0;\n    let mut current_path = String::new();\n    let mut batch: Vec<IndexRow> = Vec::with_capacity(BATCH_SIZE);\n    let mut stamp_batch: Vec<String> = Vec::with_capacity(BATCH_SIZE);","new_string":"    // Fresh index has no secondary indexes to maintain, so we can use larger\n    // batches to reduce transaction overhead (fewer commits = faster).\n    let flush_batch_size = if is_fresh { BATCH_SIZE * 5 } else { BATCH_SIZE };\n\n    let mut scanned: u64 = 0;\n    let mut indexed: u64 = 0;\n    let mut permission_errors: u64 = 0;\n    let mut current_path = String::new();\n    let mut batch: Vec<IndexRow> = Vec::with_capacity(flush_batch_size);\n    let mut stamp_batch: Vec<String> = Vec::with_capacity(flush_batch_size);"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":389,"cache_read_input_tokens":155487,"output_tokens":391,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":389,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYNirB3Huw69f7GBR7XBm","type":"assistant","uuid":"0954ab97-68a4-4e61-8cad-76f773e1bad1","timestamp":"2026-02-22T07:35:32.275Z"}
{"parentUuid":"0954ab97-68a4-4e61-8cad-76f773e1bad1","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_0178pJ2ntewgW8TKVLRsJQ31","toolUseID":"toolu_0178pJ2ntewgW8TKVLRsJQ31","timestamp":"2026-02-22T07:35:32.284Z","uuid":"5e7c37cc-dabf-460f-a2d7-e2aa7c73e24a"}
{"parentUuid":"0954ab97-68a4-4e61-8cad-76f773e1bad1","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0178pJ2ntewgW8TKVLRsJQ31","type":"tool_result","content":"The file /Users/al02402336/everything/src-tauri/src/main.rs has been updated successfully."}]},"uuid":"c6f14f34-4d9b-4c10-ad2a-6d02d2fb1554","timestamp":"2026-02-22T07:35:32.283Z","toolUseResult":{"filePath":"/Users/al02402336/everything/src-tauri/src/main.rs","oldString":"    let mut scanned: u64 = 0;\n    let mut indexed: u64 = 0;\n    let mut permission_errors: u64 = 0;\n    let mut current_path = String::new();\n    let mut batch: Vec<IndexRow> = Vec::with_capacity(BATCH_SIZE);\n    let mut stamp_batch: Vec<String> = Vec::with_capacity(BATCH_SIZE);","newString":"    // Fresh index has no secondary indexes to maintain, so we can use larger\n    // batches to reduce transaction overhead (fewer commits = faster).\n    let flush_batch_size = if is_fresh { BATCH_SIZE * 5 } else { BATCH_SIZE };\n\n    let mut scanned: u64 = 0;\n    let mut indexed: u64 = 0;\n    let mut permission_errors: u64 = 0;\n    let mut current_path = String::new();\n    let mut batch: Vec<IndexRow> = Vec::with_capacity(flush_batch_size);\n    let mut stamp_batch: Vec<String> = Vec::with_capacity(flush_batch_size);","originalFile":"#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\n\nuse std::{\n    cmp::Ordering,\n    collections::{HashMap, HashSet},\n    fs,\n    hash::{Hash, Hasher},\n    io::{self, BufRead, BufReader, Write},\n    path::{Path, PathBuf},\n    process::{Command, Stdio},\n    sync::{\n        atomic::{AtomicBool, Ordering as AtomicOrdering},\n        Arc, OnceLock,\n    },\n    time::{Duration, Instant, SystemTime, UNIX_EPOCH},\n};\n\nuse parking_lot::{Mutex, RwLock};\nuse rusqlite::{params, params_from_iter, types::Value as SqlValue, Connection};\nuse serde::Serialize;\nuse tauri::{AppHandle, Emitter, Manager, State};\n#[cfg(target_os = \"macos\")]\nuse tauri_plugin_global_shortcut::{Code, GlobalShortcutExt, Modifiers, Shortcut};\n#[cfg(target_os = \"windows\")]\nuse std::os::windows::process::CommandExt;\nuse walkdir::WalkDir;\n\nmod fd_search;\nmod gitignore_filter;\n#[cfg(target_os = \"macos\")]\nmod mac;\nmod mem_search;\nmod query;\n#[cfg(target_os = \"windows\")]\nmod win;\nuse fd_search::{FdSearchCache, FdSearchResultDto};\nuse query::{escape_like, parse_query, SearchMode};\n\nconst DEFAULT_LIMIT: u32 = 300;\nconst SHORT_QUERY_LIMIT: u32 = 100;\nconst MAX_LIMIT: u32 = 1000;\npub(crate) const BATCH_SIZE: usize = 10_000;\nconst RECENT_OP_TTL: Duration = Duration::from_secs(2);\npub(crate) const WATCH_DEBOUNCE: Duration = Duration::from_millis(300);\nconst NEGATIVE_CACHE_TTL: Duration = Duration::from_secs(60);\nconst NEGATIVE_CACHE_FALLBACK_WINDOW: Duration = Duration::from_millis(550);\nconst DB_VERSION: i32 = 4;\nconst DEFERRED_DIR_NAMES: &[&str] = &[\n    \"Library\", \".Trash\", \".Trashes\",\n    // Windows system directories (deferred when scan_root is C:\\)\n    \"Windows\", \"Program Files\", \"Program Files (x86)\",\n    \"$Recycle.Bin\", \"System Volume Information\", \"Recovery\", \"PerfLogs\",\n];\nconst SHALLOW_SCAN_DEPTH: usize = 6;\nfn jwalk_num_threads() -> usize {\n    std::thread::available_parallelism()\n        .map(|n| (n.get() / 2).max(4).min(16))\n        .unwrap_or(8)\n}\n\npub(crate) const BUILTIN_SKIP_NAMES: &[&str] = &[\n    \".git\",\n    \"node_modules\",\n    \".Trash\",\n    \".Trashes\",\n    \".npm\",\n    \".cache\",\n    \"CMakeFiles\",\n    \".qtc_clangd\",\n    \"__pycache__\",\n    \".gradle\",\n    \"DerivedData\",\n];\n\n/// Path segments whose name ends with one of these suffixes are skipped.\n/// e.g. \"*.build\" skips Xcode intermediate build directories like \"MyApp.build\".\npub(crate) const BUILTIN_SKIP_SUFFIXES: &[&str] = &[\n    \".build\", // Xcode intermediate build dir (MyApp.build, Objects-normal, etc.)\n];\n\npub(crate) const BUILTIN_SKIP_PATHS: &[&str] = &[\n    // macOS\n    \"Library/Caches\",\n    \"Library/Developer/CoreSimulator\",\n    \"Library/Logs\",\n    // Cross-platform\n    \".vscode/extensions\",\n    // Windows: noisy system directories under AppData\n    \"AppData/Local/Temp\",\n    \"AppData/Local/Microsoft\",\n    \"AppData/Local/Google\",\n    \"AppData/Local/Packages\",\n];\n\ntype AppResult<T> = Result<T, String>;\nstatic SEARCH_LOG_ENABLED: OnceLock<bool> = OnceLock::new();\nstatic PERF_LOG_ENABLED: OnceLock<bool> = OnceLock::new();\nstatic BENCH_MODE_ENABLED: OnceLock<bool> = OnceLock::new();\nstatic STARTUP_T0: OnceLock<Instant> = OnceLock::new();\n\nfn startup_elapsed_ms() -> u128 {\n    STARTUP_T0\n        .get()\n        .map(|started| started.elapsed().as_millis())\n        .unwrap_or(0)\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct EntryDto {\n    pub path: String,\n    pub name: String,\n    pub dir: String,\n    pub is_dir: bool,\n    pub ext: Option<String>,\n    pub size: Option<i64>,\n    pub mtime: Option<i64>,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct IndexStatusDto {\n    state: String,\n    entries_count: u64,\n    last_updated: Option<i64>,\n    permission_errors: u64,\n    message: Option<String>,\n    scanned: u64,\n    indexed: u64,\n    current_path: String,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct IndexProgressEvent {\n    scanned: u64,\n    indexed: u64,\n    current_path: String,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct IndexStateEvent {\n    state: String,\n    message: Option<String>,\n    is_catchup: bool,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct IndexUpdatedEvent {\n    entries_count: u64,\n    last_updated: i64,\n    permission_errors: u64,\n}\n\n#[derive(Debug, Clone)]\nstruct SearchExecution {\n    query: String,\n    sort_by: String,\n    sort_dir: String,\n    effective_limit: u32,\n    offset: u32,\n    mode_label: String,\n    results: Vec<EntryDto>,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct SearchResultDto {\n    entries: Vec<EntryDto>,\n    mode_label: String,\n    /// Total number of results matching the query (ignoring LIMIT/OFFSET).\n    total_count: u32,\n    /// True when total_count is exact. False means frontend should treat it as unknown.\n    total_known: bool,\n}\n\n#[allow(dead_code)]\n#[derive(Debug, Clone)]\nstruct BenchCase {\n    id: &'static str,\n    query: &'static str,\n    sort_by: &'static str,\n    sort_dir: &'static str,\n    limit: u32,\n    offset: u32,\n    expected_min_results: usize,\n}\n\n#[allow(dead_code)]\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct BenchCaseResult {\n    id: String,\n    query: String,\n    mode: String,\n    sort_by: String,\n    sort_dir: String,\n    limit: u32,\n    offset: u32,\n    elapsed_ms: f64,\n    result_count: usize,\n    expected_min_results: usize,\n    passed: bool,\n    top_results: Vec<String>,\n    error: Option<String>,\n}\n\n#[allow(dead_code)]\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct BenchReport {\n    run_label: String,\n    started_at: i64,\n    completed_at: i64,\n    home_dir: String,\n    db_path: String,\n    index_wait_ms: u128,\n    index_scanned: u64,\n    index_indexed: u64,\n    index_entries_count: u64,\n    index_permission_errors: u64,\n    index_message: Option<String>,\n    search_iterations: u32,\n    search_results: Vec<BenchCaseResult>,\n}\n\n#[derive(Debug, Clone)]\npub(crate) enum IndexState {\n    Ready,\n    Indexing,\n    Error,\n}\n\nimpl IndexState {\n    fn as_str(&self) -> &'static str {\n        match self {\n            Self::Ready => \"Ready\",\n            Self::Indexing => \"Indexing\",\n            Self::Error => \"Error\",\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct IndexStatus {\n    pub(crate) state: IndexState,\n    pub(crate) entries_count: u64,\n    pub(crate) last_updated: Option<i64>,\n    pub(crate) permission_errors: u64,\n    pub(crate) message: Option<String>,\n    pub(crate) scanned: u64,\n    pub(crate) indexed: u64,\n    pub(crate) current_path: String,\n}\n\nimpl Default for IndexStatus {\n    fn default() -> Self {\n        Self {\n            state: IndexState::Indexing,\n            entries_count: 0,\n            last_updated: None,\n            permission_errors: 0,\n            message: None,\n            scanned: 0,\n            indexed: 0,\n            current_path: String::new(),\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\n#[allow(dead_code)]\npub(crate) struct RecentOp {\n    old_path: Option<String>,\n    new_path: Option<String>,\n    op_type: &'static str,\n    at: Instant,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub(crate) enum IgnorePattern {\n    AnySegment(String),\n    Glob(String),\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct IgnoreRulesCache {\n    roots: Vec<PathBuf>,\n    patterns: Vec<IgnorePattern>,\n    pathignore_mtime: Option<SystemTime>,\n    gitignore_mtime: Option<SystemTime>,\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct AppState {\n    pub(crate) db_path: PathBuf,\n    pub(crate) home_dir: PathBuf,\n    pub(crate) scan_root: PathBuf,\n    pub(crate) cwd: PathBuf,\n    pub(crate) path_ignores: Arc<Vec<PathBuf>>,\n    pub(crate) path_ignore_patterns: Arc<Vec<IgnorePattern>>,\n    pub(crate) db_ready: Arc<AtomicBool>,\n    pub(crate) indexing_active: Arc<AtomicBool>,\n    pub(crate) status: Arc<Mutex<IndexStatus>>,\n    pub(crate) recent_ops: Arc<Mutex<Vec<RecentOp>>>,\n    pub(crate) icon_cache: Arc<Mutex<HashMap<String, Vec<u8>>>>,\n    pub(crate) fd_search_cache: Arc<Mutex<Option<FdSearchCache>>>,\n    pub(crate) negative_name_cache: Arc<Mutex<HashMap<String, NegativeNameEntry>>>,\n    pub(crate) ignore_cache: Arc<Mutex<Option<IgnoreRulesCache>>>,\n    pub(crate) gitignore: Arc<gitignore_filter::LazyGitignoreFilter>,\n    /// In-memory index for instant search while DB upsert runs in background.\n    /// Set by MFT scan, cleared after background DB upsert completes.\n    pub(crate) mem_index: Arc<RwLock<Option<Arc<mem_search::MemIndex>>>>,\n    /// Signal to stop the file watcher (RDCW / USN). Set to true on reset_index.\n    pub(crate) watcher_stop: Arc<AtomicBool>,\n    /// Set to true while a file watcher event loop is running.\n    pub(crate) watcher_active: Arc<AtomicBool>,\n    /// Set to true once frontend onMount has completed enough to accept user input.\n    pub(crate) frontend_ready: Arc<AtomicBool>,\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct NegativeNameEntry {\n    created_at: Instant,\n    fallback_checked: bool,\n}\n\n#[derive(Debug, Clone)]\nstruct NegativeCacheHit {\n    query_lower: String,\n    age: Duration,\n    fallback_checked: bool,\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct IndexRow {\n    pub(crate) path: String,\n    pub(crate) name: String,\n    pub(crate) dir: String,\n    pub(crate) is_dir: i64,\n    pub(crate) ext: Option<String>,\n    pub(crate) mtime: Option<i64>,\n    pub(crate) size: Option<i64>,\n    pub(crate) indexed_at: i64,\n    pub(crate) run_id: i64,\n}\n\npub(crate) fn now_epoch() -> i64 {\n    SystemTime::now()\n        .duration_since(UNIX_EPOCH)\n        .map(|d| d.as_secs() as i64)\n        .unwrap_or_default()\n}\n\nfn env_truthy(key: &str) -> bool {\n    std::env::var(key)\n        .ok()\n        .map(|value| {\n            matches!(\n                value.trim().to_ascii_lowercase().as_str(),\n                \"1\" | \"true\" | \"yes\" | \"on\"\n            )\n        })\n        .unwrap_or(false)\n}\n\nfn bench_mode_enabled() -> bool {\n    *BENCH_MODE_ENABLED.get_or_init(|| env_truthy(\"EVERYTHING_BENCH\"))\n}\n\nfn perf_log_enabled() -> bool {\n    *PERF_LOG_ENABLED.get_or_init(|| env_truthy(\"FASTFIND_PERF_LOG\") || bench_mode_enabled())\n}\n\npub(crate) fn perf_log(message: impl AsRef<str>) {\n    if perf_log_enabled() {\n        eprintln!(\"[perf] {}\", message.as_ref());\n    }\n}\n\nfn db_connection_with_timeout(db_path: &Path, busy_timeout_ms: u32) -> AppResult<Connection> {\n    let conn = Connection::open(db_path).map_err(|e| e.to_string())?;\n    conn.execute_batch(&format!(\n        r#\"\n        PRAGMA journal_mode=WAL;\n        PRAGMA synchronous=NORMAL;\n        PRAGMA temp_store=MEMORY;\n        PRAGMA busy_timeout={busy_timeout_ms};\n        \"#,\n    ))\n    .map_err(|e| e.to_string())?;\n    Ok(conn)\n}\n\npub(crate) fn db_connection(db_path: &Path) -> AppResult<Connection> {\n    db_connection_with_timeout(db_path, 3000)\n}\n\nfn db_connection_for_search(db_path: &Path) -> AppResult<Connection> {\n    let conn = db_connection_with_timeout(db_path, 500)?;\n    conn.execute_batch(\n        \"PRAGMA cache_size = -32768;\n         PRAGMA mmap_size = 268435456;\",\n    )\n    .map_err(|e| e.to_string())?;\n    Ok(conn)\n}\n\npub(crate) fn set_indexing_pragmas(conn: &Connection) -> AppResult<()> {\n    conn.execute_batch(\n        r#\"\n        PRAGMA synchronous = OFF;\n        PRAGMA cache_size = -131072;\n        PRAGMA mmap_size = 536870912;\n        PRAGMA wal_autocheckpoint = 0;\n        \"#,\n    )\n    .map_err(|e| e.to_string())\n}\n\npub(crate) fn restore_normal_pragmas(conn: &Connection) -> AppResult<()> {\n    conn.execute_batch(\n        r#\"\n        PRAGMA synchronous = NORMAL;\n        PRAGMA cache_size = -16384;\n        PRAGMA mmap_size = 268435456;\n        PRAGMA wal_autocheckpoint = 1000;\n        \"#,\n    )\n    .map_err(|e| e.to_string())?;\n    conn.execute_batch(\"PRAGMA wal_checkpoint(TRUNCATE);\")\n        .map_err(|e| e.to_string())?;\n    Ok(())\n}\n\nfn init_db(db_path: &Path) -> AppResult<()> {\n    let t = Instant::now();\n    let conn = db_connection(db_path)?;\n    eprintln!(\"[init_db] +{}ms db_connection opened\", t.elapsed().as_millis());\n\n    let current_version: i32 = conn\n        .query_row(\"PRAGMA user_version\", [], |row| row.get(0))\n        .unwrap_or(0);\n    if current_version != DB_VERSION {\n        conn.execute_batch(\n            r#\"\n            DROP TRIGGER IF EXISTS entries_ai;\n            DROP TRIGGER IF EXISTS entries_ad;\n            DROP TRIGGER IF EXISTS entries_au;\n            DROP TABLE IF EXISTS entries_fts;\n            DROP TABLE IF EXISTS entries;\n            \"#,\n        )\n        .map_err(|e| e.to_string())?;\n        conn.execute_batch(&format!(\"PRAGMA user_version = {};\", DB_VERSION))\n            .map_err(|e| e.to_string())?;\n    }\n    eprintln!(\"[init_db] +{}ms version check done (v={})\", t.elapsed().as_millis(), current_version);\n\n    conn.execute_batch(\n        r#\"\n        CREATE TABLE IF NOT EXISTS entries (\n          id INTEGER PRIMARY KEY,\n          path TEXT NOT NULL UNIQUE,\n          name TEXT NOT NULL,\n          dir TEXT NOT NULL,\n          is_dir INTEGER NOT NULL,\n          ext TEXT,\n          mtime INTEGER,\n          size INTEGER,\n          indexed_at INTEGER NOT NULL,\n          run_id INTEGER NOT NULL DEFAULT 0\n        );\n\n        CREATE INDEX IF NOT EXISTS idx_entries_dir_ext_name_nocase ON entries(dir, ext, name COLLATE NOCASE);\n        CREATE INDEX IF NOT EXISTS idx_entries_mtime ON entries(mtime);\n        CREATE INDEX IF NOT EXISTS idx_entries_name_nocase ON entries(name COLLATE NOCASE);\n        CREATE INDEX IF NOT EXISTS idx_entries_ext_name ON entries(ext, name COLLATE NOCASE);\n\n        CREATE TABLE IF NOT EXISTS meta (\n          key TEXT PRIMARY KEY,\n          value TEXT NOT NULL\n        );\n        \"#,\n    )\n    .map_err(|e| e.to_string())?;\n    eprintln!(\"[init_db] +{}ms schema ensured\", t.elapsed().as_millis());\n\n    let legacy_index_migration_key = \"migration_drop_idx_entries_dir_name_nocase_v1\";\n    let migrated = get_meta(&conn, legacy_index_migration_key)\n        .map(|v| v == \"1\")\n        .unwrap_or(false);\n    if !migrated {\n        conn.execute_batch(\"DROP INDEX IF EXISTS idx_entries_dir_name_nocase;\")\n            .map_err(|e| e.to_string())?;\n        set_meta(&conn, legacy_index_migration_key, \"1\")?;\n    }\n    eprintln!(\"[init_db] +{}ms total\", t.elapsed().as_millis());\n\n    Ok(())\n}\n\npub(crate) fn get_meta(conn: &Connection, key: &str) -> Option<String> {\n    conn.query_row(\n        \"SELECT value FROM meta WHERE key = ?1\",\n        params![key],\n        |row| row.get(0),\n    )\n    .ok()\n}\n\npub(crate) fn set_meta(conn: &Connection, key: &str, value: &str) -> AppResult<()> {\n    conn.execute(\n        \"INSERT OR REPLACE INTO meta(key, value) VALUES(?1, ?2)\",\n        params![key, value],\n    )\n    .map_err(|e| e.to_string())?;\n    Ok(())\n}\n\nfn update_counts(state: &AppState) -> AppResult<(u64, Option<i64>)> {\n    let conn = db_connection(&state.db_path)?;\n\n    let entries_count = conn\n        .query_row(\"SELECT COUNT(*) FROM entries\", [], |row| {\n            row.get::<_, i64>(0)\n        })\n        .map_err(|e| e.to_string())?\n        .max(0) as u64;\n\n    let last_updated = conn\n        .query_row(\"SELECT MAX(indexed_at) FROM entries\", [], |row| {\n            row.get::<_, Option<i64>>(0)\n        })\n        .map_err(|e| e.to_string())?;\n\n    Ok((entries_count, last_updated))\n}\n\npub(crate) fn update_status_counts(state: &AppState) -> AppResult<(u64, Option<i64>)> {\n    let (entries_count, last_updated) = update_counts(state)?;\n    let mut status = state.status.lock();\n    status.entries_count = entries_count;\n    status.last_updated = last_updated;\n    Ok((entries_count, last_updated))\n}\n\npub(crate) fn invalidate_search_caches(state: &AppState) {\n    state.fd_search_cache.lock().take();\n    state.negative_name_cache.lock().clear();\n}\n\nfn prune_negative_name_cache(cache: &mut HashMap<String, NegativeNameEntry>) {\n    let now = Instant::now();\n    cache.retain(|_, entry| now.duration_since(entry.created_at) <= NEGATIVE_CACHE_TTL);\n}\n\nfn negative_name_cache_lookup(state: &AppState, query: &str) -> Option<NegativeCacheHit> {\n    if query.is_empty() {\n        return None;\n    }\n    let q = query.to_lowercase();\n    let now = Instant::now();\n    let mut cache = state.negative_name_cache.lock();\n    prune_negative_name_cache(&mut cache);\n    cache\n        .iter()\n        .filter(|(key, _)| q.contains(key.as_str()))\n        .max_by_key(|(key, _)| key.len())\n        .map(|(key, entry)| NegativeCacheHit {\n            query_lower: key.clone(),\n            age: now.duration_since(entry.created_at),\n            fallback_checked: entry.fallback_checked,\n        })\n}\n\nfn remember_negative_name_query(state: &AppState, query: &str) {\n    if query.is_empty() {\n        return;\n    }\n    let normalized = query.to_lowercase();\n    let mut cache = state.negative_name_cache.lock();\n    prune_negative_name_cache(&mut cache);\n\n    if cache.contains_key(&normalized) {\n        return;\n    }\n\n    cache.insert(\n        normalized,\n        NegativeNameEntry {\n            created_at: Instant::now(),\n            fallback_checked: false,\n        },\n    );\n    const MAX_NEGATIVE_CACHE: usize = 512;\n    if cache.len() > MAX_NEGATIVE_CACHE {\n        let mut entries: Vec<_> =\n            cache.iter().map(|(k, v)| (k.clone(), v.created_at)).collect();\n        entries.sort_by_key(|(_, t)| *t);\n        let drop_count = cache.len() - MAX_NEGATIVE_CACHE;\n        for (key, _) in entries.into_iter().take(drop_count) {\n            cache.remove(&key);\n        }\n    }\n}\n\nfn remove_negative_name_query(state: &AppState, query: &str) {\n    if query.is_empty() {\n        return;\n    }\n    let normalized = query.to_lowercase();\n    state.negative_name_cache.lock().remove(&normalized);\n}\n\nfn mark_negative_name_fallback_checked(state: &AppState, query_lower: &str) {\n    let mut cache = state.negative_name_cache.lock();\n    if let Some(entry) = cache.get_mut(query_lower) {\n        entry.fallback_checked = true;\n    }\n}\n\nfn sort_clause(sort_by: &str, sort_dir: &str, prefix: &str) -> String {\n    match (sort_by, sort_dir) {\n        (\"name\", \"desc\") => {\n            format!(\"{prefix}name COLLATE NOCASE DESC, {prefix}path COLLATE NOCASE DESC\")\n        }\n        (\"mtime\", \"asc\") => {\n            format!(\"COALESCE({prefix}mtime, 0) ASC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        (\"mtime\", \"desc\") => {\n            format!(\"COALESCE({prefix}mtime, 0) DESC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        (\"dir\", \"asc\") => {\n            format!(\"{prefix}dir COLLATE NOCASE ASC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        (\"dir\", \"desc\") => {\n            format!(\"{prefix}dir COLLATE NOCASE DESC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        (\"size\", \"asc\") => {\n            format!(\"{prefix}size IS NULL ASC, {prefix}size ASC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        (\"size\", \"desc\") => {\n            format!(\"{prefix}size IS NULL ASC, {prefix}size DESC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        _ => format!(\"{prefix}name COLLATE NOCASE ASC, {prefix}path COLLATE NOCASE ASC\"),\n    }\n}\n\nfn contains_glob_meta(s: &str) -> bool {\n    s.contains('*') || s.contains('?')\n}\n\n/// Detect if a LIKE pattern is a pure extension filter (e.g. `%.rs`).\n/// Returns the lowercase extension if matched, None otherwise.\nfn extract_ext_from_like(like_pattern: &str) -> Option<String> {\n    let rest = like_pattern.strip_prefix('%')?;\n    let ext = rest.strip_prefix('.')?;\n    if ext.is_empty()\n        || ext.contains('%')\n        || ext.contains('_')\n        || ext.contains('\\\\')\n        || ext.contains('/')\n        || ext.contains('.')\n    {\n        return None;\n    }\n    Some(ext.to_lowercase())\n}\n\nfn normalize_hint_to_native(dir_hint: &str) -> (String, bool) {\n    let native = dir_hint.replace('/', &std::path::MAIN_SEPARATOR.to_string());\n    let is_abs = Path::new(&native).is_absolute();\n    (native, is_abs)\n}\n\nfn last_segment(dir_hint: &str) -> &str {\n    dir_hint\n        .rsplit(|c| c == '/' || c == '\\\\')\n        .find(|seg| !seg.is_empty())\n        .unwrap_or(dir_hint)\n}\n\nfn resolve_dir_hint(home_dir: &Path, dir_hint: &str) -> Option<PathBuf> {\n    if dir_hint.is_empty() || contains_glob_meta(dir_hint) {\n        return None;\n    }\n\n    let candidate = if dir_hint == \"~\" {\n        home_dir.to_path_buf()\n    } else if let Some(rest) = dir_hint.strip_prefix(\"~/\") {\n        home_dir.join(rest)\n    } else {\n        let (native_hint, is_absolute) = normalize_hint_to_native(dir_hint);\n        if is_absolute {\n            PathBuf::from(native_hint)\n        } else {\n            home_dir.join(native_hint)\n        }\n    };\n\n    if candidate.is_dir() {\n        Some(candidate)\n    } else {\n        None\n    }\n}\n\nconst RESOLVE_DIRS_MAX: usize = 20;\n\nfn resolve_dirs_from_db(conn: &Connection, dir_hint: &str) -> Vec<String> {\n    if dir_hint.is_empty() || contains_glob_meta(dir_hint) {\n        return Vec::new();\n    }\n    let last_seg = last_segment(dir_hint);\n    let sep = std::path::MAIN_SEPARATOR;\n    let (native_hint, is_absolute) = normalize_hint_to_native(dir_hint);\n    let sep_str = sep.to_string();\n    let escaped_sep = escape_like(&sep_str);\n    let path_pattern = if is_absolute {\n        format!(\"%{}\", escape_like(&native_hint))\n    } else {\n        format!(\"%{escaped_sep}{}\", escape_like(&native_hint))\n    };\n    let fetch_limit = (RESOLVE_DIRS_MAX + 1) as i64;\n    let mut stmt = match conn.prepare(\n        \"SELECT path FROM entries WHERE name = ?1 COLLATE NOCASE AND is_dir = 1 AND path LIKE ?2 ESCAPE '\\\\' LIMIT ?3\",\n    ) {\n        Ok(s) => s,\n        Err(_) => return Vec::new(),\n    };\n    let rows = match stmt.query_map(params![last_seg, path_pattern, fetch_limit], |row| {\n        row.get::<_, String>(0)\n    }) {\n        Ok(r) => r,\n        Err(_) => return Vec::new(),\n    };\n    let dirs: Vec<String> = rows.filter_map(|r| r.ok()).collect();\n    if dirs.len() > RESOLVE_DIRS_MAX {\n        return Vec::new();\n    }\n    dirs\n}\n\nfn normalize_slashes(s: String) -> String {\n    s.replace('\\\\', \"/\")\n}\n\nfn resolve_ignore_path(raw: &str, base_dir: &Path, home_dir: &Path) -> Option<PathBuf> {\n    let trimmed = raw.trim();\n    if trimmed.is_empty() || trimmed.starts_with('#') || trimmed.starts_with('!') {\n        return None;\n    }\n\n    let mut path = if trimmed == \"~\" {\n        home_dir.to_path_buf()\n    } else if let Some(rest) = trimmed.strip_prefix(\"~/\") {\n        home_dir.join(rest)\n    } else {\n        PathBuf::from(trimmed)\n    };\n\n    if !path.is_absolute() {\n        path = base_dir.join(path);\n    }\n\n    Some(fs::canonicalize(&path).unwrap_or(path))\n}\n\nfn normalize_ignore_pattern(raw: &str, base_dir: &Path, home_dir: &Path) -> String {\n    let trimmed = raw.trim().trim_end_matches('/').to_string();\n    if trimmed == \"~\" {\n        return normalize_slashes(home_dir.to_string_lossy().to_string());\n    }\n    if let Some(rest) = trimmed.strip_prefix(\"~/\") {\n        return normalize_slashes(home_dir.join(rest).to_string_lossy().to_string());\n    }\n    if trimmed.starts_with('/') || trimmed.starts_with(\"**/\") {\n        return trimmed;\n    }\n    normalize_slashes(base_dir.join(&trimmed).to_string_lossy().to_string())\n}\n\nfn parse_ignore_pattern(raw: &str, base_dir: &Path, home_dir: &Path) -> Option<IgnorePattern> {\n    let trimmed = raw.trim().trim_end_matches('/');\n    if trimmed.is_empty() {\n        return None;\n    }\n\n    if let Some(segment) = trimmed.strip_prefix(\"**/\") {\n        if !segment.is_empty() && !segment.contains('/') && !contains_glob_meta(segment) {\n            return Some(IgnorePattern::AnySegment(segment.to_string()));\n        }\n    }\n\n    Some(IgnorePattern::Glob(normalize_ignore_pattern(\n        trimmed, base_dir, home_dir,\n    )))\n}\n\nfn ignore_pattern_key(pattern: &IgnorePattern) -> String {\n    match pattern {\n        IgnorePattern::AnySegment(segment) => format!(\"seg:{segment}\"),\n        IgnorePattern::Glob(glob) => format!(\"glob:{glob}\"),\n    }\n}\n\nfn find_file_upward(start: &Path, file_name: &str) -> Option<PathBuf> {\n    let mut current = Some(start);\n    while let Some(dir) = current {\n        let candidate = dir.join(file_name);\n        if candidate.is_file() {\n            return Some(candidate);\n        }\n        current = dir.parent();\n    }\n    None\n}\n\nfn find_git_root(start: &Path) -> Option<PathBuf> {\n    let mut current = Some(start);\n    while let Some(dir) = current {\n        let marker = dir.join(\".git\");\n        if marker.is_dir() || marker.is_file() {\n            return Some(dir.to_path_buf());\n        }\n        current = dir.parent();\n    }\n    None\n}\n\nfn load_pathignore_rules(home_dir: &Path, cwd: &Path) -> (Vec<PathBuf>, Vec<IgnorePattern>) {\n    let mut files = Vec::new();\n    if let Some(file) = find_file_upward(cwd, \".pathignore\") {\n        files.push(file);\n    } else {\n        files.push(cwd.join(\".pathignore\"));\n    }\n    let home_file = home_dir.join(\".pathignore\");\n    if !files.iter().any(|p| p == &home_file) {\n        files.push(home_file);\n    }\n\n    let mut roots = Vec::new();\n    let mut patterns = Vec::new();\n    let mut seen_roots = HashSet::new();\n    let mut seen_patterns = HashSet::new();\n\n    for file in files {\n        let Ok(contents) = fs::read_to_string(&file) else {\n            continue;\n        };\n        let base_dir = file.parent().unwrap_or_else(|| Path::new(\"/\"));\n        for line in contents.lines() {\n            let trimmed = line.trim();\n            if trimmed.is_empty() || trimmed.starts_with('#') || trimmed.starts_with('!') {\n                continue;\n            }\n\n            if contains_glob_meta(trimmed) {\n                let Some(pattern) = parse_ignore_pattern(trimmed, base_dir, home_dir) else {\n                    continue;\n                };\n                let key = ignore_pattern_key(&pattern);\n                if seen_patterns.insert(key) {\n                    patterns.push(pattern);\n                }\n                continue;\n            }\n\n            let Some(path) = resolve_ignore_path(trimmed, base_dir, home_dir) else {\n                continue;\n            };\n\n            let key = path.to_string_lossy().to_string();\n            if seen_roots.insert(key) {\n                roots.push(path);\n            }\n        }\n    }\n\n    (roots, patterns)\n}\n\nfn load_gitignore_roots(home_dir: &Path, cwd: &Path) -> Vec<PathBuf> {\n    let gitignore = if let Some(root) = find_git_root(cwd) {\n        root.join(\".gitignore\")\n    } else if let Some(file) = find_file_upward(&cwd, \".gitignore\") {\n        file\n    } else {\n        return Vec::new();\n    };\n    let contents = match fs::read_to_string(&gitignore) {\n        Ok(contents) => contents,\n        Err(_) => return Vec::new(),\n    };\n\n    let mut roots = Vec::new();\n    let mut seen = HashSet::new();\n\n    for line in contents.lines() {\n        let trimmed = line.trim();\n        if trimmed.is_empty() || trimmed.starts_with('#') || trimmed.starts_with('!') {\n            continue;\n        }\n        if contains_glob_meta(trimmed) || trimmed.contains('[') {\n            continue;\n        }\n\n        let normalized = trimmed.trim_start_matches('/').trim_end_matches('/');\n        if normalized.is_empty() {\n            continue;\n        }\n\n        let Some(path) = resolve_ignore_path(normalized, &cwd, home_dir) else {\n            continue;\n        };\n\n        let key = path.to_string_lossy().to_string();\n        if seen.insert(key) {\n            roots.push(path);\n        }\n    }\n\n    roots\n}\n\n#[cfg(target_os = \"macos\")]\nfn macos_tcc_ignore_roots(home_dir: &Path) -> Vec<PathBuf> {\n    let library = home_dir.join(\"Library\");\n    let app_support = library.join(\"Application Support\");\n    let caches = library.join(\"Caches\");\n\n    let dirs: Vec<PathBuf> = vec![\n        home_dir.join(\".Trash\"),\n        library.join(\"Accounts\"),\n        library.join(\"AppleMediaServices\"),\n        library.join(\"Assistant\").join(\"SiriVocabulary\"),\n        library.join(\"Autosave Information\"),\n        library.join(\"Biome\"),\n        library.join(\"Calendars\"),\n        library.join(\"com.apple.aiml.instrumentation\"),\n        library.join(\"ContainerManager\"),\n        library.join(\"Cookies\"),\n        library.join(\"CoreFollowUp\"),\n        library.join(\"Daemon Containers\"),\n        library.join(\"DoNotDisturb\"),\n        library.join(\"DuetExpertCenter\"),\n        library.join(\"Group Containers\"),\n        library.join(\"HomeKit\"),\n        library.join(\"Developer\").join(\"Xcode\").join(\"DerivedData\"),\n        library.join(\"IdentityServices\"),\n        library.join(\"IntelligencePlatform\"),\n        library.join(\"Mail\"),\n        library.join(\"Messages\"),\n        library.join(\"Metadata\").join(\"CoreSpotlight\"),\n        library.join(\"PersonalizationPortrait\"),\n        library.join(\"Reminders\"),\n        library.join(\"Safari\"),\n        library.join(\"Sharing\"),\n        library.join(\"Shortcuts\"),\n        library.join(\"StatusKit\"),\n        library.join(\"Suggestions\"),\n        library.join(\"Trial\"),\n        library.join(\"Weather\"),\n        app_support.join(\"AddressBook\"),\n        app_support.join(\"CallHistoryDB\"),\n        app_support.join(\"CallHistoryTransactions\"),\n        app_support.join(\"CloudDocs\"),\n        app_support.join(\"com.apple.avfoundation\"),\n        app_support.join(\"com.apple.sharedfilelist\"),\n        app_support.join(\"com.apple.TCC\"),\n        app_support.join(\"DifferentialPrivacy\"),\n        app_support.join(\"FaceTime\"),\n        app_support.join(\"FileProvider\"),\n        app_support.join(\"Knowledge\"),\n        caches.join(\"CloudKit\"),\n        caches.join(\"com.apple.ap.adprivacyd\"),\n        caches.join(\"com.apple.containermanagerd\"),\n        caches.join(\"com.apple.findmy.fmfcore\"),\n        caches.join(\"com.apple.findmy.fmipcore\"),\n        caches.join(\"com.apple.homed\"),\n        caches.join(\"com.apple.HomeKit\"),\n        caches.join(\"com.apple.Safari\"),\n        caches.join(\"FamilyCircle\"),\n    ];\n\n    dirs.into_iter().filter(|p| p.exists()).collect()\n}\n\n#[cfg(not(target_os = \"macos\"))]\nfn macos_tcc_ignore_roots(_home_dir: &Path) -> Vec<PathBuf> {\n    Vec::new()\n}\n\n/// Directories under home that generate heavy background I/O on Windows\n/// (browser caches, Windows Update temp files, UWP package state, etc.).\n/// Pruning these from the MFT subtree eliminates noisy USN records.\n#[cfg(target_os = \"windows\")]\nfn windows_noisy_roots(home_dir: &Path) -> Vec<PathBuf> {\n    let local = home_dir.join(\"AppData\").join(\"Local\");\n    let dirs = vec![\n        local.join(\"Temp\"),\n        local.join(\"Microsoft\"),\n        local.join(\"Google\"),\n        local.join(\"Packages\"),\n        // C:\\ system directories (Windows is deferred, not excluded)\n        PathBuf::from(\"C:\\\\$Recycle.Bin\"),\n        PathBuf::from(\"C:\\\\System Volume Information\"),\n        PathBuf::from(\"C:\\\\Recovery\"),\n        PathBuf::from(\"C:\\\\PerfLogs\"),\n    ];\n    dirs.into_iter().filter(|p| p.exists()).collect()\n}\n\n#[cfg(not(target_os = \"windows\"))]\nfn windows_noisy_roots(_home_dir: &Path) -> Vec<PathBuf> {\n    Vec::new()\n}\n\npub(crate) fn effective_ignore_rules(\n    home_dir: &Path,\n    cwd: &Path,\n    base_roots: &[PathBuf],\n    base_patterns: &[IgnorePattern],\n) -> (Vec<PathBuf>, Vec<IgnorePattern>) {\n    let mut roots = base_roots.to_vec();\n    let mut patterns = base_patterns.to_vec();\n    let mut seen: HashSet<String> = roots\n        .iter()\n        .map(|p| p.to_string_lossy().to_string())\n        .collect();\n    let mut seen_patterns: HashSet<String> = patterns.iter().map(ignore_pattern_key).collect();\n\n    let (pathignore_roots, pathignore_patterns) = load_pathignore_rules(home_dir, cwd);\n    for root in pathignore_roots\n        .into_iter()\n        .chain(load_gitignore_roots(home_dir, cwd).into_iter())\n        .chain(macos_tcc_ignore_roots(home_dir).into_iter())\n        .chain(windows_noisy_roots(home_dir).into_iter())\n    {\n        let key = root.to_string_lossy().to_string();\n        if seen.insert(key) {\n            roots.push(root);\n        }\n    }\n\n    for pattern in pathignore_patterns\n        .into_iter()\n        .chain(builtin_ignore_patterns(home_dir))\n    {\n        let key = ignore_pattern_key(&pattern);\n        if seen_patterns.insert(key) {\n            patterns.push(pattern);\n        }\n    }\n\n    (roots, patterns)\n}\n\nfn builtin_ignore_patterns(home_dir: &Path) -> Vec<IgnorePattern> {\n    let home = normalize_slashes(home_dir.to_string_lossy().to_string());\n    vec![\n        // ~/Library/Application Support/*/Cache*\n        IgnorePattern::Glob(format!(\"{home}/Library/Application Support/*/Cache*\")),\n        // ~/Library/Application Support/*/Code Cache\n        IgnorePattern::Glob(format!(\"{home}/Library/Application Support/*/Code Cache\")),\n        // ~/.rustup/toolchains/*/share/doc\n        IgnorePattern::Glob(format!(\"{home}/.rustup/toolchains/*/share/doc\")),\n        // ~/.pyenv/versions/*/lib\n        IgnorePattern::Glob(format!(\"{home}/.pyenv/versions/*/lib\")),\n    ]\n}\n\npub(crate) fn cached_effective_ignore_rules(state: &AppState) -> (Vec<PathBuf>, Vec<IgnorePattern>) {\n    let home_dir = &state.home_dir;\n    let cwd = &state.cwd;\n\n    let pathignore_mtime = find_file_upward(cwd, \".pathignore\")\n        .or_else(|| Some(home_dir.join(\".pathignore\")))\n        .and_then(|p| fs::metadata(&p).ok())\n        .and_then(|m| m.modified().ok());\n\n    let gitignore_mtime = find_git_root(cwd)\n        .map(|root| root.join(\".gitignore\"))\n        .or_else(|| find_file_upward(cwd, \".gitignore\"))\n        .and_then(|p| fs::metadata(&p).ok())\n        .and_then(|m| m.modified().ok());\n\n    let mut cache = state.ignore_cache.lock();\n    if let Some(ref cached) = *cache {\n        if cached.pathignore_mtime == pathignore_mtime && cached.gitignore_mtime == gitignore_mtime\n        {\n            return (cached.roots.clone(), cached.patterns.clone());\n        }\n    }\n\n    let (roots, patterns) = effective_ignore_rules(\n        home_dir,\n        cwd,\n        state.path_ignores.as_ref(),\n        state.path_ignore_patterns.as_ref(),\n    );\n\n    *cache = Some(IgnoreRulesCache {\n        roots: roots.clone(),\n        patterns: patterns.clone(),\n        pathignore_mtime,\n        gitignore_mtime,\n    });\n\n    (roots, patterns)\n}\n\nfn ignore_rules_fingerprint(roots: &[PathBuf], patterns: &[IgnorePattern]) -> u64 {\n    let mut hasher = std::collections::hash_map::DefaultHasher::new();\n    for root in roots {\n        normalize_slashes(root.to_string_lossy().to_string()).hash(&mut hasher);\n    }\n    for pattern in patterns {\n        ignore_pattern_key(pattern).hash(&mut hasher);\n    }\n    hasher.finish()\n}\n\nfn purge_ignored_entries(db_path: &Path, ignored_roots: &[PathBuf]) -> AppResult<()> {\n    if ignored_roots.is_empty() {\n        return Ok(());\n    }\n\n    let conn = db_connection(db_path)?;\n    for root in ignored_roots {\n        let root_str = root.to_string_lossy().to_string();\n        if root_str.is_empty() {\n            continue;\n        }\n\n        if root_str == \"/\" {\n            conn.execute(\"DELETE FROM entries\", [])\n                .map_err(|e| e.to_string())?;\n            break;\n        }\n\n        let prefix = root_str.trim_end_matches('/');\n        let descendant_like = format!(\"{}%\", escape_like(&format!(\"{prefix}/\")));\n        conn.execute(\n            \"DELETE FROM entries WHERE path = ?1 OR path LIKE ?2 ESCAPE '\\\\'\",\n            params![prefix, descendant_like],\n        )\n        .map_err(|e| e.to_string())?;\n    }\n\n    Ok(())\n}\n\nfn glob_match_path(pattern: &str, text: &str) -> bool {\n    let pat = pattern.as_bytes();\n    let txt = text.as_bytes();\n    let (pn, tn) = (pat.len(), txt.len());\n\n    let mut px = 0usize;\n    let mut tx = 0usize;\n    let mut star_px = usize::MAX;\n    let mut star_tx = 0usize;\n    let mut star_is_double = false;\n\n    while tx < tn {\n        if px < pn && px + 1 < pn && pat[px] == b'*' && pat[px + 1] == b'*' {\n            star_px = px;\n            star_tx = tx;\n            star_is_double = true;\n            px += 2;\n        } else if px < pn && pat[px] == b'*' {\n            star_px = px;\n            star_tx = tx;\n            star_is_double = false;\n            px += 1;\n        } else if px < pn && (pat[px] == b'?' && txt[tx] != b'/') {\n            px += 1;\n            tx += 1;\n        } else if px < pn && pat[px] == txt[tx] {\n            px += 1;\n            tx += 1;\n        } else if star_px != usize::MAX {\n            star_tx += 1;\n            if !star_is_double && txt[star_tx - 1] == b'/' {\n                return false;\n            }\n            px = if star_is_double {\n                star_px + 2\n            } else {\n                star_px + 1\n            };\n            tx = star_tx;\n        } else {\n            return false;\n        }\n    }\n\n    while px < pn && pat[px] == b'*' {\n        px += 1;\n    }\n\n    px == pn\n}\n\npub(crate) fn matches_ignore_pattern(path: &str, pattern: &IgnorePattern) -> bool {\n    match pattern {\n        IgnorePattern::AnySegment(segment) => {\n            let suffix = format!(\"/{segment}\");\n            let infix = format!(\"/{segment}/\");\n            path.ends_with(&suffix) || path.contains(&infix)\n        }\n        IgnorePattern::Glob(glob) => {\n            let mut cur = path;\n            loop {\n                if glob_match_path(glob, cur) {\n                    return true;\n                }\n\n                if cur == \"/\" {\n                    break;\n                }\n\n                let Some(pos) = cur.rfind('/') else {\n                    break;\n                };\n\n                cur = if pos == 0 { \"/\" } else { &cur[..pos] };\n            }\n            false\n        }\n    }\n}\n\npub(crate) fn should_skip_path(\n    path: &Path,\n    ignored_roots: &[PathBuf],\n    ignored_patterns: &[IgnorePattern],\n) -> bool {\n    should_skip_path_ext(path, ignored_roots, ignored_patterns, None, None)\n}\n\npub(crate) fn should_skip_path_ext(\n    path: &Path,\n    ignored_roots: &[PathBuf],\n    ignored_patterns: &[IgnorePattern],\n    gitignore: Option<&gitignore_filter::GitignoreFilter>,\n    is_dir_hint: Option<bool>,\n) -> bool {\n    let s = normalize_slashes(path.to_string_lossy().to_string());\n\n    // Single-component builtin names: check path segments\n    if s.split('/').any(|seg| {\n        BUILTIN_SKIP_NAMES.contains(&seg)\n            || BUILTIN_SKIP_SUFFIXES.iter().any(|suf| seg.ends_with(suf))\n    }) {\n        return true;\n    }\n\n    // Multi-component builtin paths\n    if BUILTIN_SKIP_PATHS.iter().any(|pat| {\n        let infix = format!(\"/{pat}/\");\n        let suffix = format!(\"/{pat}\");\n        s.contains(&infix) || s.ends_with(&suffix)\n    }) {\n        return true;\n    }\n\n    if ignored_roots\n        .iter()\n        .any(|root| path == root || path.starts_with(root))\n    {\n        return true;\n    }\n    if ignored_patterns\n        .iter()\n        .any(|pattern| matches_ignore_pattern(&s, pattern))\n    {\n        return true;\n    }\n    if let Some(gi) = gitignore {\n        let is_dir = is_dir_hint.unwrap_or_else(|| path.is_dir());\n        if gi.is_ignored(path, is_dir) {\n            return true;\n        }\n    }\n    false\n}\n\nfn extension_for(path: &Path, is_dir: bool) -> Option<String> {\n    if is_dir {\n        return None;\n    }\n\n    path.extension()\n        .and_then(|ext| ext.to_str())\n        .map(|ext| ext.to_lowercase())\n}\n\npub(crate) fn index_row_from_path_and_metadata(path: &Path, metadata: &fs::Metadata) -> Option<IndexRow> {\n    let is_dir = metadata.is_dir();\n\n    let name = path\n        .file_name()\n        .map(|v| v.to_string_lossy().to_string())\n        .or_else(|| {\n            if path == Path::new(\"/\") {\n                Some(\"/\".to_string())\n            } else {\n                None\n            }\n        })?;\n\n    let dir = path\n        .parent()\n        .map(|p| p.to_string_lossy().to_string())\n        .unwrap_or_else(|| \"/\".to_string());\n\n    let mtime = metadata\n        .modified()\n        .ok()\n        .and_then(|m| m.duration_since(UNIX_EPOCH).ok())\n        .map(|d| d.as_secs() as i64);\n\n    let size = if metadata.is_file() {\n        Some(metadata.len() as i64)\n    } else {\n        None\n    };\n\n    Some(IndexRow {\n        path: path.to_string_lossy().to_string(),\n        name,\n        dir,\n        is_dir: if is_dir { 1 } else { 0 },\n        ext: extension_for(path, is_dir),\n        mtime,\n        size,\n        indexed_at: now_epoch(),\n        run_id: 0,\n    })\n}\n\nfn index_row_from_path(path: &Path) -> Option<IndexRow> {\n    let metadata = fs::symlink_metadata(path).ok()?;\n    index_row_from_path_and_metadata(path, &metadata)\n}\n\nfn index_row_from_walkdir_entry(entry: &walkdir::DirEntry) -> Option<IndexRow> {\n    let metadata = entry.metadata().ok()?;\n    index_row_from_path_and_metadata(entry.path(), &metadata)\n}\n\nfn index_row_from_jwalk_entry(entry: &jwalk::DirEntry<((), ())>) -> Option<IndexRow> {\n    let metadata = entry.metadata().ok()?;\n    index_row_from_path_and_metadata(&entry.path(), &metadata)\n}\n\nfn collect_rows_recursive(\n    root: &Path,\n    ignored_roots: &[PathBuf],\n    ignored_patterns: &[IgnorePattern],\n) -> Vec<IndexRow> {\n    let mut rows = Vec::new();\n\n    let iter = WalkDir::new(root)\n        .follow_links(false)\n        .into_iter()\n        .filter_entry(|entry| !should_skip_path(entry.path(), ignored_roots, ignored_patterns));\n\n    for entry in iter.flatten() {\n        if let Some(row) = index_row_from_walkdir_entry(&entry) {\n            rows.push(row);\n        }\n    }\n\n    rows\n}\n\nfn entry_from_index_row(row: IndexRow) -> EntryDto {\n    EntryDto {\n        path: row.path,\n        name: row.name,\n        dir: row.dir,\n        is_dir: row.is_dir == 1,\n        ext: row.ext,\n        size: row.size,\n        mtime: row.mtime,\n    }\n}\n\npub fn entry_from_path(path: &Path) -> Option<EntryDto> {\n    index_row_from_path(path).map(entry_from_index_row)\n}\n\nfn entry_cmp(a: &EntryDto, b: &EntryDto, sort_by: &str, sort_dir: &str) -> Ordering {\n    match sort_by {\n        \"mtime\" => {\n            let lhs = a.mtime.unwrap_or(0);\n            let rhs = b.mtime.unwrap_or(0);\n            let primary = if sort_dir == \"desc\" {\n                rhs.cmp(&lhs)\n            } else {\n                lhs.cmp(&rhs)\n            };\n\n            if primary != Ordering::Equal {\n                return primary;\n            }\n\n            a.name\n                .to_lowercase()\n                .cmp(&b.name.to_lowercase())\n                .then(a.path.to_lowercase().cmp(&b.path.to_lowercase()))\n        }\n        \"dir\" => {\n            let lhs = a.dir.to_lowercase();\n            let rhs = b.dir.to_lowercase();\n            let primary = if sort_dir == \"desc\" {\n                rhs.cmp(&lhs)\n            } else {\n                lhs.cmp(&rhs)\n            };\n            if primary != Ordering::Equal {\n                return primary;\n            }\n            a.name.to_lowercase().cmp(&b.name.to_lowercase())\n        }\n        \"size\" => {\n            let lhs = a.size.unwrap_or(0);\n            let rhs = b.size.unwrap_or(0);\n            let primary = if sort_dir == \"desc\" {\n                rhs.cmp(&lhs)\n            } else {\n                lhs.cmp(&rhs)\n            };\n            if primary != Ordering::Equal {\n                return primary;\n            }\n            a.name\n                .to_lowercase()\n                .cmp(&b.name.to_lowercase())\n                .then(a.path.to_lowercase().cmp(&b.path.to_lowercase()))\n        }\n        _ => {\n            let lhs_name = a.name.to_lowercase();\n            let rhs_name = b.name.to_lowercase();\n            let primary = if sort_dir == \"desc\" {\n                rhs_name.cmp(&lhs_name)\n            } else {\n                lhs_name.cmp(&rhs_name)\n            };\n\n            if primary != Ordering::Equal {\n                return primary;\n            }\n\n            let lhs_path = a.path.to_lowercase();\n            let rhs_path = b.path.to_lowercase();\n            if sort_dir == \"desc\" {\n                rhs_path.cmp(&lhs_path)\n            } else {\n                lhs_path.cmp(&rhs_path)\n            }\n        }\n    }\n}\n\nfn relevance_rank(entry: &EntryDto, query_lower: &str, path_suffix: &str) -> u8 {\n    if query_lower.is_empty() {\n        return 255;\n    }\n\n    let name = entry.name.to_lowercase();\n    let path = entry.path.to_lowercase();\n\n    if name == query_lower {\n        return 0;\n    }\n    if name.starts_with(query_lower) {\n        return 1;\n    }\n    if name.contains(query_lower) {\n        return 2;\n    }\n    if path.ends_with(path_suffix) {\n        return 3;\n    }\n    if path.contains(query_lower) {\n        return 4;\n    }\n\n    5\n}\n\nfn path_depth(path: &str) -> usize {\n    Path::new(path).components().count()\n}\n\npub fn sort_entries(entries: &mut Vec<EntryDto>, sort_by: &str, sort_dir: &str) {\n    entries.sort_by(|a, b| entry_cmp(a, b, sort_by, sort_dir));\n}\n\nfn sort_entries_with_relevance(\n    entries: &mut Vec<EntryDto>,\n    query: &str,\n    sort_by: &str,\n    sort_dir: &str,\n) {\n    let query_lower = query.trim().to_lowercase();\n    if query_lower.is_empty() {\n        sort_entries(entries, sort_by, sort_dir);\n        return;\n    }\n    let path_suffix = format!(\"/{query_lower}\");\n\n    entries.sort_by(|a, b| {\n        let ra = relevance_rank(a, &query_lower, &path_suffix);\n        let rb = relevance_rank(b, &query_lower, &path_suffix);\n        if ra != rb {\n            return ra.cmp(&rb);\n        }\n\n        // For highly-relevant matches, prefer shallower paths first\n        // so `~/name` ranks above deep descendants with the same name.\n        if ra <= 3 {\n            let da = path_depth(&a.path);\n            let db = path_depth(&b.path);\n            if da != db {\n                return da.cmp(&db);\n            }\n        }\n\n        entry_cmp(a, b, sort_by, sort_dir)\n    });\n}\n\nfn filter_ignored_entries(\n    entries: Vec<EntryDto>,\n    ignored_roots: &[PathBuf],\n    ignored_patterns: &[IgnorePattern],\n) -> Vec<EntryDto> {\n    entries\n        .into_iter()\n        .filter(|entry| !should_skip_path(Path::new(&entry.path), ignored_roots, ignored_patterns))\n        .collect()\n}\n\nfn find_search(\n    home_dir: &Path,\n    ignored_roots: &[PathBuf],\n    ignored_patterns: &[IgnorePattern],\n    query: &str,\n    limit: usize,\n    sort_by: &str,\n    sort_dir: &str,\n) -> Vec<EntryDto> {\n    let trimmed = query.trim();\n    if trimmed.is_empty() || limit == 0 {\n        return Vec::new();\n    }\n\n    let mut search_root = home_dir.to_path_buf();\n    let mut dir_filter_pattern: Option<String> = None;\n    let mut name_filter_pattern: Option<String> = None;\n    let mut name_filter_glob = false;\n\n    if trimmed.contains('/') {\n        let last_slash = trimmed.rfind('/').unwrap();\n        let dir_part = trimmed[..last_slash].trim();\n        let name_part = trimmed[last_slash + 1..].trim();\n\n        if !dir_part.is_empty() {\n            let mut hinted = if dir_part == \"~\" {\n                Some(home_dir.to_path_buf())\n            } else if let Some(rest) = dir_part.strip_prefix(\"~/\") {\n                Some(home_dir.join(rest))\n            } else {\n                let p = PathBuf::from(dir_part);\n                if p.is_absolute() {\n                    Some(p)\n                } else if !dir_part.contains('*')\n                    && !dir_part.contains('?')\n                    && !dir_part.contains('[')\n                {\n                    Some(home_dir.join(dir_part))\n                } else {\n                    None\n                }\n            };\n\n            if let Some(path) = hinted.take() {\n                if path.exists() && path.is_dir() {\n                    search_root = path;\n                } else {\n                    dir_filter_pattern = Some(format!(\"*{}/*\", dir_part));\n                }\n            } else {\n                dir_filter_pattern = Some(format!(\"*{}/*\", dir_part));\n            }\n        }\n\n        if !name_part.is_empty() {\n            if name_part.contains('*') || name_part.contains('?') {\n                name_filter_pattern = Some(name_part.to_string());\n                name_filter_glob = true;\n            } else {\n                name_filter_pattern = Some(format!(\"*{}*\", name_part));\n            }\n        }\n    } else if trimmed.contains('*') || trimmed.contains('?') {\n        name_filter_pattern = Some(trimmed.to_string());\n        name_filter_glob = true;\n    } else {\n        name_filter_pattern = Some(format!(\"*{}*\", trimmed));\n    }\n\n    let mut cmd = Command::new(\"find\");\n    cmd.arg(&search_root);\n\n    if search_root == home_dir {\n        cmd.args([\"-maxdepth\", \"8\"]);\n    }\n\n    if let Some(dir_pattern) = dir_filter_pattern.as_deref() {\n        cmd.args([\"-ipath\", dir_pattern]);\n    }\n    if let Some(name_pattern) = name_filter_pattern.as_deref() {\n        cmd.args([\"-iname\", name_pattern]);\n    }\n    if name_filter_glob {\n        cmd.args([\"-type\", \"f\"]);\n    }\n\n    cmd.args([\"!\", \"-path\", \"*/.git/*\"])\n        .args([\"!\", \"-path\", \"*/node_modules/*\"])\n        .args([\"!\", \"-path\", \"*/.Trash/*\"])\n        .args([\"!\", \"-path\", \"*/.Trashes/*\"])\n        .args([\"!\", \"-path\", \"*/Library/Caches/*\"])\n        .stdout(Stdio::piped())\n        .stderr(Stdio::null());\n\n    let mut child = match cmd.spawn() {\n        Ok(c) => c,\n        Err(_) => return Vec::new(),\n    };\n\n    let stdout = match child.stdout.take() {\n        Some(s) => s,\n        None => return Vec::new(),\n    };\n\n    let reader = BufReader::new(stdout);\n    let mut entries = Vec::with_capacity(limit);\n\n    for line in reader.lines() {\n        let Ok(line) = line else { continue };\n        let path = PathBuf::from(&line);\n        if should_skip_path(&path, ignored_roots, ignored_patterns) {\n            continue;\n        }\n\n        if let Some(entry) = entry_from_path(&path) {\n            entries.push(entry);\n            if entries.len() >= limit {\n                break;\n            }\n        }\n    }\n\n    let _ = child.kill();\n    let _ = child.wait();\n\n    sort_entries_with_relevance(&mut entries, trimmed, sort_by, sort_dir);\n    entries\n}\n\npub(crate) fn upsert_rows(conn: &mut Connection, rows: &[IndexRow]) -> AppResult<usize> {\n    if rows.is_empty() {\n        return Ok(0);\n    }\n\n    let tx = conn.transaction().map_err(|e| e.to_string())?;\n    {\n        let mut stmt = tx\n            .prepare(\n                r#\"\n                INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n                VALUES(?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)\n                ON CONFLICT(path) DO UPDATE SET\n                  name = excluded.name,\n                  dir = excluded.dir,\n                  is_dir = excluded.is_dir,\n                  ext = excluded.ext,\n                  mtime = excluded.mtime,\n                  size = excluded.size,\n                  indexed_at = excluded.indexed_at,\n                  run_id = excluded.run_id\n                \"#,\n            )\n            .map_err(|e| e.to_string())?;\n\n        for row in rows {\n            stmt.execute(params![\n                row.path,\n                row.name,\n                row.dir,\n                row.is_dir,\n                row.ext,\n                row.mtime,\n                row.size,\n                row.indexed_at,\n                row.run_id\n            ])\n            .map_err(|e| e.to_string())?;\n        }\n    }\n    tx.commit().map_err(|e| e.to_string())?;\n    Ok(rows.len())\n}\n\npub(crate) fn delete_paths(conn: &mut Connection, raw_paths: &[String]) -> AppResult<usize> {\n    if raw_paths.is_empty() {\n        return Ok(0);\n    }\n\n    let tx = conn.transaction().map_err(|e| e.to_string())?;\n    let mut deleted = 0;\n\n    {\n        let mut stmt_exact = tx\n            .prepare(\"DELETE FROM entries WHERE path = ?1\")\n            .map_err(|e| e.to_string())?;\n        let mut stmt_children = tx\n            .prepare(\"DELETE FROM entries WHERE path >= ?1 AND path < ?2\")\n            .map_err(|e| e.to_string())?;\n\n        for path in raw_paths {\n            let is_root = path == \"/\" || path == \"\\\\\";\n            let normalized = if is_root {\n                path.clone()\n            } else {\n                path.trim_end_matches(&['/', '\\\\'][..]).to_string()\n            };\n\n            if normalized.is_empty() {\n                continue;\n            }\n\n            if is_root {\n                deleted += tx\n                    .execute(\"DELETE FROM entries\", [])\n                    .map_err(|e| e.to_string())?;\n                continue;\n            }\n\n            deleted += stmt_exact\n                .execute(params![&normalized])\n                .map_err(|e| e.to_string())?;\n\n            // Delete children using B-tree range scan: path >= \"{normalized}{sep}\" AND path < \"{normalized}\\x7F\"\n            // \\x7F (127) is higher than both '/' (47) and '\\' (92), so this captures all children.\n            let sep = std::path::MAIN_SEPARATOR;\n            let range_start = format!(\"{normalized}{sep}\");\n            let range_end = format!(\"{normalized}\\x7F\");\n            deleted += stmt_children\n                .execute(params![&range_start, &range_end])\n                .map_err(|e| e.to_string())?;\n        }\n    }\n\n    tx.commit().map_err(|e| e.to_string())?;\n    Ok(deleted)\n}\n\npub(crate) fn emit_index_state(app: &AppHandle, state: &str, message: Option<String>) {\n    let is_catchup = message.as_ref().map_or(false, |m| m.starts_with(\"Catchup:\"));\n    let _ = app.emit(\n        \"index_state\",\n        IndexStateEvent {\n            state: state.to_string(),\n            message,\n            is_catchup,\n        },\n    );\n}\n\npub(crate) fn emit_index_updated(\n    app: &AppHandle,\n    entries_count: u64,\n    last_updated: i64,\n    permission_errors: u64,\n) {\n    let _ = app.emit(\n        \"index_updated\",\n        IndexUpdatedEvent {\n            entries_count,\n            last_updated,\n            permission_errors,\n        },\n    );\n}\n\npub(crate) fn emit_index_progress(app: &AppHandle, scanned: u64, indexed: u64, current_path: String) {\n    let _ = app.emit(\n        \"index_progress\",\n        IndexProgressEvent {\n            scanned,\n            indexed,\n            current_path,\n        },\n    );\n}\n\npub(crate) fn set_state(state: &AppState, next: IndexState, message: Option<String>) {\n    let mut status = state.status.lock();\n    status.state = next;\n    status.message = message;\n}\n\npub(crate) fn set_progress(state: &AppState, scanned: u64, indexed: u64, current_path: &str) {\n    let mut status = state.status.lock();\n    status.scanned = scanned;\n    status.indexed = indexed;\n    status.current_path = current_path.to_string();\n}\n\nfn emit_status_counts(app: &AppHandle, state: &AppState) {\n    let status = state.status.lock();\n    emit_index_updated(\n        app,\n        status.entries_count,\n        status.last_updated.unwrap_or_else(now_epoch),\n        status.permission_errors,\n    );\n}\n\npub(crate) fn refresh_and_emit_status_counts(app: &AppHandle, state: &AppState) -> AppResult<()> {\n    let (entries_count, last_updated) = update_status_counts(state)?;\n    // Persist cached counts so next startup can read them instantly\n    if let Ok(conn) = db_connection(&state.db_path) {\n        let _ = set_meta(&conn, \"cached_entries_count\", &entries_count.to_string());\n        if let Some(lu) = last_updated {\n            let _ = set_meta(&conn, \"cached_last_updated\", &lu.to_string());\n        }\n    }\n    emit_status_counts(app, state);\n    Ok(())\n}\n\n/// Load cached entries count from meta table (instant) and emit Ready state + counts.\n/// Used on Windows startup paths where the index is already complete from a prior run.\n#[cfg(target_os = \"windows\")]\npub(crate) fn set_ready_with_cached_counts(app: &AppHandle, state: &AppState) {\n    let (count, last_updated) = db_connection(&state.db_path)\n        .ok()\n        .map(|conn| {\n            let c = get_meta(&conn, \"cached_entries_count\")\n                .and_then(|v| v.parse::<u64>().ok())\n                .unwrap_or(0);\n            let lu = get_meta(&conn, \"cached_last_updated\")\n                .and_then(|v| v.parse::<i64>().ok());\n            (c, lu)\n        })\n        .unwrap_or((0, None));\n\n    {\n        let mut status = state.status.lock();\n        status.state = IndexState::Ready;\n        status.entries_count = count;\n        status.last_updated = last_updated;\n    }\n\n    emit_index_state(app, \"Ready\", None);\n    emit_index_updated(app, count, last_updated.unwrap_or_else(now_epoch), 0);\n}\n\n#[cfg(target_os = \"macos\")]\nfn touch_status_updated(state: &AppState) {\n    state.status.lock().last_updated = Some(now_epoch());\n}\n\n#[cfg(not(target_os = \"windows\"))]\npub(crate) fn start_full_index_worker(app: AppHandle, state: AppState) -> AppResult<()> {\n    start_full_index_worker_inner(app, state, false)\n}\n\n#[cfg(target_os = \"windows\")]\npub(crate) fn start_full_index_worker_silent(app: AppHandle, state: AppState) -> AppResult<()> {\n    start_full_index_worker_inner(app, state, true)\n}\n\nfn start_full_index_worker_inner(app: AppHandle, state: AppState, silent: bool) -> AppResult<()> {\n    if state\n        .indexing_active\n        .compare_exchange(false, true, AtomicOrdering::AcqRel, AtomicOrdering::Acquire)\n        .is_err()\n    {\n        perf_log(\"index_start_skipped already_active=true\");\n        return Ok(());\n    }\n\n    // Mark index as incomplete -- cleared when run_incremental_index succeeds\n    if let Ok(c) = db_connection(&state.db_path) {\n        let _ = set_meta(&c, \"index_complete\", \"0\");\n    }\n\n    if !silent {\n        {\n            let mut status = state.status.lock();\n            status.state = IndexState::Indexing;\n            status.message = None;\n            status.scanned = 0;\n            status.indexed = 0;\n            status.current_path.clear();\n        }\n\n        emit_index_state(&app, \"Indexing\", None);\n        perf_log(\"index_state=Indexing\");\n    } else {\n        perf_log(\"index_start silent=true (background reindex)\");\n    }\n\n    std::thread::spawn(move || {\n        let result = run_incremental_index(&app, &state);\n        if let Err(ref err) = result {\n            eprintln!(\"[index] run_incremental_index failed: {err}\");\n            if !silent {\n                set_state(&state, IndexState::Error, Some(err.clone()));\n                emit_index_state(&app, \"Error\", Some(err.clone()));\n            }\n            // Silent mode: keep Ready state, just log the error\n        }\n        state.indexing_active.store(false, AtomicOrdering::Release);\n    });\n\n    Ok(())\n}\n\nfn is_deferred_dir(path: &Path, home_dir: &Path) -> bool {\n    path.parent() == Some(home_dir)\n        && path\n            .file_name()\n            .and_then(|n| n.to_str())\n            .map(|name| DEFERRED_DIR_NAMES.contains(&name))\n            .unwrap_or(false)\n}\n\nfn preload_existing_entries(\n    conn: &Connection,\n    dir_prefix: &str,\n) -> HashMap<String, (Option<i64>, Option<i64>)> {\n    let like_pattern = format!(\"{}/%\", escape_like(dir_prefix));\n    let mut stmt = match conn.prepare(\n        \"SELECT path, mtime, size FROM entries WHERE path LIKE ?1 ESCAPE '\\\\' OR path = ?2\",\n    ) {\n        Ok(s) => s,\n        Err(_) => return HashMap::new(),\n    };\n\n    let mut map = HashMap::new();\n    let rows = match stmt.query_map(params![like_pattern, dir_prefix], |row| {\n        Ok((\n            row.get::<_, String>(0)?,\n            row.get::<_, Option<i64>>(1)?,\n            row.get::<_, Option<i64>>(2)?,\n        ))\n    }) {\n        Ok(r) => r,\n        Err(_) => return map,\n    };\n\n    for row in rows.flatten() {\n        map.insert(row.0, (row.1, row.2));\n    }\n    map\n}\n\nfn stamp_run_id_batch(conn: &mut Connection, paths: &[String], run_id: i64) -> AppResult<()> {\n    if paths.is_empty() {\n        return Ok(());\n    }\n\n    let tx = conn.transaction().map_err(|e| e.to_string())?;\n    {\n        let mut stmt = tx\n            .prepare(\"UPDATE entries SET run_id = ?1 WHERE path = ?2\")\n            .map_err(|e| e.to_string())?;\n        for path in paths {\n            stmt.execute(params![run_id, path])\n                .map_err(|e| e.to_string())?;\n        }\n    }\n    tx.commit().map_err(|e| e.to_string())?;\n    Ok(())\n}\n\nfn run_incremental_index(app: &AppHandle, state: &AppState) -> AppResult<()> {\n    let started = Instant::now();\n    perf_log(format!(\n        \"index_run_start home={} db={}\",\n        state.home_dir.to_string_lossy(),\n        state.db_path.to_string_lossy(),\n    ));\n\n    let mut conn = db_connection(&state.db_path)?;\n    set_indexing_pragmas(&conn)?;\n\n    // For fresh index (empty DB), drop secondary indexes before bulk insert and\n    // recreate them after. This avoids per-row BTREE maintenance on every insert,\n    // which can be 3-5x faster when loading hundreds of thousands of rows.\n    let is_fresh_run: bool = get_meta(&conn, \"last_run_id\")\n        .and_then(|v| v.parse::<i64>().ok())\n        .unwrap_or(0)\n        == 0;\n    if is_fresh_run {\n        let _ = conn.execute_batch(\n            \"DROP INDEX IF EXISTS idx_entries_dir_ext_name_nocase;\n             DROP INDEX IF EXISTS idx_entries_mtime;\n             DROP INDEX IF EXISTS idx_entries_name_nocase;\n             DROP INDEX IF EXISTS idx_entries_ext_name;\",\n        );\n    }\n\n    let result = run_incremental_index_inner(app, state, &mut conn);\n\n    if is_fresh_run {\n        let _ = conn.execute_batch(\n            \"CREATE INDEX IF NOT EXISTS idx_entries_dir_ext_name_nocase ON entries(dir, ext, name COLLATE NOCASE);\n             CREATE INDEX IF NOT EXISTS idx_entries_mtime ON entries(mtime);\n             CREATE INDEX IF NOT EXISTS idx_entries_name_nocase ON entries(name COLLATE NOCASE);\n             CREATE INDEX IF NOT EXISTS idx_entries_ext_name ON entries(ext, name COLLATE NOCASE);\",\n        );\n    }\n\n    let _ = conn.execute_batch(\"ANALYZE\");\n    let _ = restore_normal_pragmas(&conn);\n\n    match &result {\n        Ok(_) => {\n            let _ = set_meta(&conn, \"index_complete\", \"1\");\n            let snapshot = state.status.lock().clone();\n            perf_log(format!(\n                \"index_run_done elapsed_ms={} scanned={} indexed={} entries={} permission_errors={} message={:?}\",\n                started.elapsed().as_millis(),\n                snapshot.scanned,\n                snapshot.indexed,\n                snapshot.entries_count,\n                snapshot.permission_errors,\n                snapshot.message,\n            ));\n        }\n        Err(err) => {\n            perf_log(format!(\n                \"index_run_error elapsed_ms={} err={}\",\n                started.elapsed().as_millis(),\n                err,\n            ));\n        }\n    }\n\n    result\n}\n\nfn run_incremental_index_inner(\n    app: &AppHandle,\n    state: &AppState,\n    conn: &mut Connection,\n) -> AppResult<()> {\n\n    let (runtime_ignored_roots, runtime_ignored_patterns) = effective_ignore_rules(\n        &state.home_dir,\n        &state.cwd,\n        state.path_ignores.as_ref(),\n        state.path_ignore_patterns.as_ref(),\n    );\n    let gi_filter = state.gitignore.get();\n\n    let last_run_id: i64 = get_meta(conn, \"last_run_id\")\n        .and_then(|v| v.parse().ok())\n        .unwrap_or(0);\n    let current_run_id = last_run_id + 1;\n    // Fresh index: DB was empty, skip preload/stamp, single unlimited-depth pass\n    let is_fresh = last_run_id == 0;\n\n    let mut scanned: u64 = 0;\n    let mut indexed: u64 = 0;\n    let mut permission_errors: u64 = 0;\n    let mut current_path = String::new();\n    let mut batch: Vec<IndexRow> = Vec::with_capacity(BATCH_SIZE);\n    let mut stamp_batch: Vec<String> = Vec::with_capacity(BATCH_SIZE);\n    let mut last_emit = Instant::now();\n    let mut last_perf_emit = Instant::now();\n\n    // Preload scan_root-level entries (direct children only, not recursive)\n    let scan_str = state.scan_root.to_string_lossy().to_string();\n    let root_existing = preload_existing_entries(conn, &scan_str);\n\n    // Index scan_root itself\n    if let Some(mut row) = index_row_from_path(&state.scan_root) {\n        scanned += 1;\n        row.run_id = current_run_id;\n        if let Some((old_mtime, old_size)) = root_existing.get(&row.path) {\n            if *old_mtime == row.mtime && *old_size == row.size {\n                stamp_batch.push(row.path);\n            } else {\n                batch.push(row);\n            }\n        } else {\n            batch.push(row);\n        }\n    }\n\n    // Partition direct children into priority vs deferred\n    let mut priority_roots: Vec<PathBuf> = Vec::new();\n    let mut deferred_roots: Vec<PathBuf> = Vec::new();\n\n    if let Ok(entries) = fs::read_dir(&state.scan_root) {\n        for dir_entry in entries.flatten() {\n            let child_path = dir_entry.path();\n\n            if should_skip_path_ext(\n                &child_path,\n                &runtime_ignored_roots,\n                &runtime_ignored_patterns,\n                Some(&gi_filter),\n                None,\n            ) {\n                continue;\n            }\n\n            scanned += 1;\n            current_path = child_path.to_string_lossy().to_string();\n\n            if let Some(mut row) = index_row_from_path(&child_path) {\n                row.run_id = current_run_id;\n                if let Some((old_mtime, old_size)) = root_existing.get(&row.path) {\n                    if *old_mtime == row.mtime && *old_size == row.size {\n                        stamp_batch.push(row.path);\n                    } else {\n                        batch.push(row);\n                    }\n                } else {\n                    batch.push(row);\n                }\n            }\n\n            if child_path.is_dir() {\n                if is_deferred_dir(&child_path, &state.scan_root) {\n                    deferred_roots.push(child_path);\n                } else {\n                    priority_roots.push(child_path);\n                }\n            }\n        }\n    }\n\n\n    // Flush home-level stamp batch\n    if stamp_batch.len() >= BATCH_SIZE {\n        stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n        stamp_batch.clear();\n    }\n\n    priority_roots.sort();\n    deferred_roots.sort();\n\n    let roots: Vec<PathBuf> = priority_roots.into_iter().chain(deferred_roots).collect();\n    perf_log(format!(\n        \"index_scan_roots total={} priority+deferred\",\n        roots.len()\n    ));\n\n    // 2-pass indexing: shallow first (depth <= SHALLOW_SCAN_DEPTH), then deep\n    // Both passes use jwalk for parallel scanning\n    let arc_ignored_roots = Arc::new(runtime_ignored_roots.clone());\n    let arc_ignored_patterns = Arc::new(runtime_ignored_patterns.clone());\n\n\n    for pass in 0..2u8 {\n        // Fresh index: single unlimited-depth pass -- avoids double filesystem traversal\n        if pass == 1 && is_fresh {\n            break;\n        }\n        let pass_label = if pass == 0 { \"shallow\" } else { \"deep\" };\n        let pass_started = Instant::now();\n        let mut pass_scanned = 0u64;\n        let mut pass_indexed = 0u64;\n\n        for root in &roots {\n            let root_started = Instant::now();\n            let mut root_scanned = 0u64;\n            let mut root_indexed = 0u64;\n            let mut root_permission_errors = 0u64;\n            let root_str = root.to_string_lossy().to_string();\n\n            // Fresh index: DB is empty, preload is unnecessary\n            let existing = if is_fresh {\n                HashMap::new()\n            } else {\n                let e = preload_existing_entries(conn, &root_str);\n                e\n            };\n\n            let gi_ref = gi_filter.clone();\n            let skip_roots = arc_ignored_roots.clone();\n            let skip_patterns = arc_ignored_patterns.clone();\n\n            let mut builder = jwalk::WalkDir::new(root)\n                .follow_links(false)\n                .skip_hidden(false)\n                .parallelism(jwalk::Parallelism::RayonNewPool(jwalk_num_threads()));\n            // Fresh index: no depth limit -- walk everything in one pass\n            if pass == 0 && !is_fresh {\n                builder = builder.max_depth(SHALLOW_SCAN_DEPTH);\n            }\n            let walker = builder.process_read_dir(move |_depth, path, _state, children| {\n                children.retain(|entry_result| {\n                    entry_result\n                        .as_ref()\n                        .map(|entry| {\n                            let full_path = path.join(&entry.file_name);\n                            let is_dir = Some(entry.file_type.is_dir());\n                            !should_skip_path_ext(\n                                &full_path,\n                                &skip_roots,\n                                &skip_patterns,\n                                Some(&gi_ref),\n                                is_dir,\n                            )\n                        })\n                        .unwrap_or(false)\n                });\n            });\n\n            for result in walker {\n                match result {\n                    Ok(entry) => {\n                        let path = entry.path();\n                        if path == root.as_path() {\n                            continue;\n                        }\n\n                        // Pass 1 (incremental only): skip shallow entries already indexed in pass 0\n                        if pass == 1 && entry.depth <= SHALLOW_SCAN_DEPTH {\n                            continue;\n                        }\n\n                        scanned += 1;\n                        root_scanned += 1;\n                        current_path = path.to_string_lossy().to_string();\n\n                        if let Some(mut row) = index_row_from_jwalk_entry(&entry) {\n                            row.run_id = current_run_id;\n                            if is_fresh {\n                                // Fresh index: all entries are new, skip existing check\n                                indexed += 1;\n                                root_indexed += 1;\n                                batch.push(row);\n                            } else if let Some((old_mtime, old_size)) = existing.get(&row.path) {\n                                if *old_mtime == row.mtime && *old_size == row.size {\n                                    stamp_batch.push(row.path);\n                                } else {\n                                    indexed += 1;\n                                    root_indexed += 1;\n                                    batch.push(row);\n                                }\n                            } else {\n                                indexed += 1;\n                                root_indexed += 1;\n                                batch.push(row);\n                            }\n                        }\n\n                        if batch.len() >= BATCH_SIZE {\n                            upsert_rows(conn, &batch)?;\n                            batch.clear();\n                        }\n\n                        if stamp_batch.len() >= BATCH_SIZE {\n                            stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n                            stamp_batch.clear();\n                        }\n\n                        if last_emit.elapsed() >= Duration::from_millis(200) {\n                            set_progress(state, scanned, indexed, &current_path);\n                            emit_index_progress(app, scanned, indexed, current_path.clone());\n                            last_emit = Instant::now();\n                        }\n                        if perf_log_enabled() && last_perf_emit.elapsed() >= Duration::from_secs(1)\n                        {\n                            perf_log(format!(\n                                \"index_progress pass={} scanned={} indexed={} current_path={}\",\n                                pass_label, scanned, indexed, current_path\n                            ));\n                            last_perf_emit = Instant::now();\n                        }\n                    }\n                    Err(err) => {\n                        scanned += 1;\n                        root_scanned += 1;\n                        permission_errors += 1;\n                        root_permission_errors += 1;\n                        if permission_errors <= 20 || perf_log_enabled() {\n                            eprintln!(\"[index] permission error: {}\", err);\n                        }\n                    }\n                }\n            }\n\n            pass_scanned += root_scanned;\n            pass_indexed += root_indexed;\n\n            eprintln!(\"[timing]   walk_{} {} {}ms scanned={} indexed={} err={}\",\n                pass_label, root_str, root_started.elapsed().as_millis(),\n                root_scanned, root_indexed, root_permission_errors);\n            perf_log(format!(\n                \"index_root_done pass={} root={} elapsed_ms={} scanned={} indexed={} permission_errors={}\",\n                pass_label,\n                root.to_string_lossy(),\n                root_started.elapsed().as_millis(),\n                root_scanned,\n                root_indexed,\n                root_permission_errors,\n            ));\n        }\n\n        // Flush between passes\n        if !batch.is_empty() {\n            upsert_rows(conn, &batch)?;\n            batch.clear();\n        }\n        if !stamp_batch.is_empty() {\n            stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n            stamp_batch.clear();\n        }\n\n        perf_log(format!(\n            \"index_pass_done pass={} elapsed_ms={} scanned={} indexed={}\",\n            pass_label,\n            pass_started.elapsed().as_millis(),\n            pass_scanned,\n            pass_indexed,\n        ));\n\n        // After shallow pass (incremental only), emit progress so UI shows searchable state early\n        // Fresh index uses per-root emit above instead.\n        if pass == 0 && !is_fresh {\n            let _ = refresh_and_emit_status_counts(app, state);\n            let _ = app.emit(\n                \"index_updated\",\n                IndexUpdatedEvent {\n                    entries_count: state.status.lock().entries_count,\n                    last_updated: now_epoch(),\n                    permission_errors,\n                },\n            );\n        }\n    }\n\n    if !batch.is_empty() {\n        upsert_rows(conn, &batch)?;\n    }\n\n    if !stamp_batch.is_empty() {\n        stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n    }\n\n    set_progress(state, scanned, indexed, &current_path);\n    emit_index_progress(app, scanned, indexed, current_path.clone());\n\n    // Remove entries not seen in this run (deleted files)\n    // Fresh index: DB was empty before this run, no stale entries possible\n    let deleted_count: i64 = if is_fresh {\n        0\n    } else {\n        let count = conn\n            .query_row(\n                \"SELECT COUNT(*) FROM entries WHERE run_id < ?1\",\n                params![current_run_id],\n                |row| row.get(0),\n            )\n            .unwrap_or(0);\n        conn.execute(\n            \"DELETE FROM entries WHERE run_id < ?1\",\n            params![current_run_id],\n        )\n        .map_err(|e| e.to_string())?;\n        count\n    };\n\n    set_meta(conn, \"last_run_id\", &current_run_id.to_string())?;\n\n    if deleted_count > 0 || indexed > 0 {\n        invalidate_search_caches(state);\n    }\n\n    let (entries_count, last_updated) = update_status_counts(state)?;\n    // Persist cached counts for instant startup next time\n    let _ = set_meta(conn, \"cached_entries_count\", &entries_count.to_string());\n    if let Some(lu) = last_updated {\n        let _ = set_meta(conn, \"cached_last_updated\", &lu.to_string());\n    }\n    let updated_at = last_updated.unwrap_or_else(now_epoch);\n\n    {\n        let mut status = state.status.lock();\n        status.state = IndexState::Ready;\n        status.permission_errors = permission_errors;\n        status.scanned = scanned;\n        status.indexed = indexed;\n        status.current_path = current_path.clone();\n        status.message = if permission_errors > 0 {\n            Some(format!(\n                \"{} permission/access error(s) occurred.\",\n                permission_errors\n            ))\n        } else {\n            None\n        };\n    }\n    emit_index_progress(app, scanned, indexed, current_path);\n    emit_index_updated(app, entries_count, updated_at, permission_errors);\n    emit_index_state(\n        app,\n        \"Ready\",\n        if permission_errors > 0 {\n            Some(format!(\"{} permission/access error(s)\", permission_errors))\n        } else {\n            None\n        },\n    );\n    perf_log(format!(\n        \"index_state=Ready scanned={} indexed={} deleted={} entries={} permission_errors={}\",\n        scanned, indexed, deleted_count, entries_count, permission_errors\n    ));\n\n    Ok(())\n}\n\nfn trim_recent_ops(ops: &mut Vec<RecentOp>) {\n    let now = Instant::now();\n    ops.retain(|op| now.duration_since(op.at) <= RECENT_OP_TTL);\n}\n\nfn remember_op(\n    state: &AppState,\n    op_type: &'static str,\n    old_path: Option<String>,\n    new_path: Option<String>,\n) {\n    let mut ops = state.recent_ops.lock();\n    trim_recent_ops(&mut ops);\n    ops.push(RecentOp {\n        old_path,\n        new_path,\n        op_type,\n        at: Instant::now(),\n    });\n}\n\n#[cfg(any(target_os = \"macos\", target_os = \"windows\"))]\npub(crate) fn is_recently_touched(state: &AppState, path: &str) -> bool {\n    let mut ops = state.recent_ops.lock();\n    trim_recent_ops(&mut ops);\n\n    ops.iter().any(|op| match op.op_type {\n        \"rename\" | \"trash\" => {\n            op.old_path\n                .as_deref()\n                .map(|old| old == path)\n                .unwrap_or(false)\n                || op\n                    .new_path\n                    .as_deref()\n                    .map(|new| new == path)\n                    .unwrap_or(false)\n        }\n        _ => false,\n    })\n}\n\n#[cfg(target_os = \"macos\")]\nfn apply_path_changes(state: &AppState, paths: &[PathBuf]) -> AppResult<usize> {\n    let (ignored_roots, ignored_patterns) = cached_effective_ignore_rules(state);\n    let mut to_upsert_map: HashMap<String, IndexRow> = HashMap::new();\n    let mut to_delete = Vec::new();\n\n    for path in paths {\n        if should_skip_path(path, &ignored_roots, &ignored_patterns) {\n            continue;\n        }\n\n        let path_str = path.to_string_lossy().to_string();\n        if path_str.is_empty() {\n            continue;\n        }\n\n        if is_recently_touched(state, &path_str) {\n            continue;\n        }\n\n        match fs::symlink_metadata(path) {\n            Ok(metadata) => {\n                if let Some(row) = index_row_from_path_and_metadata(path, &metadata) {\n                    to_upsert_map.insert(row.path.clone(), row);\n                }\n            }\n            Err(_) => {\n                to_delete.push(path_str);\n            }\n        }\n    }\n\n    let to_upsert = to_upsert_map.into_values().collect::<Vec<_>>();\n\n    if to_upsert.is_empty() && to_delete.is_empty() {\n        return Ok(0);\n    }\n\n    let op_start = std::time::Instant::now();\n    let mut conn = db_connection(&state.db_path).map_err(|e| {\n        eprintln!(\n            \"[watcher] db_connection FAILED after {}ms: {} (upsert={} delete={} indexing_active={})\",\n            op_start.elapsed().as_millis(),\n            e,\n            to_upsert.len(),\n            to_delete.len(),\n            state.indexing_active.load(AtomicOrdering::Acquire)\n        );\n        e\n    })?;\n    let mut changed = 0;\n\n    changed += upsert_rows(&mut conn, &to_upsert)?;\n    changed += delete_paths(&mut conn, &to_delete)?;\n\n    Ok(changed)\n}\n\n#[cfg(target_os = \"macos\")]\nconst STATUS_EMIT_MIN_INTERVAL: Duration = Duration::from_secs(2);\n\n#[cfg(target_os = \"macos\")]\nconst DB_BUSY_RETRY_DELAY: Duration = Duration::from_secs(3);\n\n#[cfg(target_os = \"macos\")]\nfn process_watcher_paths(\n    app: &AppHandle,\n    state: &AppState,\n    pending: &mut HashSet<PathBuf>,\n    deadline: &mut Option<Instant>,\n    last_status_emit: &mut Instant,\n    pending_status_emit: &mut bool,\n) {\n    if pending.is_empty() {\n        return;\n    }\n\n    if state.indexing_active.load(AtomicOrdering::Acquire) {\n        return;\n    }\n\n    let mut batch: Vec<PathBuf> = pending.drain().collect();\n    batch.sort();\n\n    match apply_path_changes(state, &batch) {\n        Ok(changed) => {\n            *deadline = None;\n            if changed > 0 {\n                invalidate_search_caches(state);\n                touch_status_updated(state);\n                if last_status_emit.elapsed() >= STATUS_EMIT_MIN_INTERVAL {\n                    let _ = refresh_and_emit_status_counts(app, state);\n                    *last_status_emit = Instant::now();\n                    *pending_status_emit = false;\n                } else {\n                    *pending_status_emit = true;\n                }\n            }\n        }\n        Err(err) => {\n            let is_busy = err.contains(\"locked\") || err.contains(\"busy\");\n            if is_busy {\n                eprintln!(\n                    \"[watcher] DB busy, will retry in {}s: {} | batch_size={}\",\n                    DB_BUSY_RETRY_DELAY.as_secs(),\n                    err,\n                    batch.len()\n                );\n                for path in batch {\n                    pending.insert(path);\n                }\n                *deadline = Some(Instant::now() + DB_BUSY_RETRY_DELAY);\n                return;\n            }\n            eprintln!(\n                \"[watcher] process_watcher_paths ERROR: {} | batch_size={} indexing_active={}\",\n                err,\n                batch.len(),\n                state.indexing_active.load(AtomicOrdering::Acquire)\n            );\n            *deadline = None;\n            if state.indexing_active.load(AtomicOrdering::Acquire) {\n                return;\n            }\n            let mut status = state.status.lock();\n            if !matches!(status.state, IndexState::Indexing) {\n                status.state = IndexState::Error;\n            }\n            status.message = Some(format!(\"Watcher update failed: {err}\"));\n            drop(status);\n            emit_index_state(app, \"Error\", Some(format!(\"Watcher update failed: {err}\")));\n        }\n    }\n}\n\n#[cfg(target_os = \"macos\")]\nconst EVENT_ID_FLUSH_INTERVAL: Duration = Duration::from_secs(30);\n\n#[cfg(target_os = \"macos\")]\nfn persist_event_id(db_path: &Path, event_id: u64) -> AppResult<()> {\n    let conn = db_connection(db_path)?;\n    set_meta(&conn, \"last_event_id\", &event_id.to_string())\n}\n\n#[cfg(target_os = \"macos\")]\nconst MUST_SCAN_THRESHOLD: usize = 10;\n\n#[cfg(target_os = \"macos\")]\nfn start_fsevent_watcher_worker(\n    app: AppHandle,\n    state: AppState,\n    since_event_id: Option<u64>,\n    conditional: bool,\n) {\n    use std::sync::mpsc::{self, RecvTimeoutError};\n    std::thread::spawn(move || {\n        let (tx, rx) = mpsc::channel();\n\n        let mut watcher =\n            match mac::fsevent_watcher::FsEventWatcher::new(&state.home_dir, since_event_id, tx) {\n                Ok(w) => w,\n                Err(err) => {\n                    set_state(\n                        &state,\n                        IndexState::Error,\n                        Some(format!(\"FSEvents watcher initialization failed: {err}\")),\n                    );\n                    emit_index_state(\n                        &app,\n                        \"Error\",\n                        Some(format!(\"FSEvents watcher initialization failed: {err}\")),\n                    );\n                    return;\n                }\n            };\n\n        if conditional {\n            perf_log(\"conditional_startup: watcher started, awaiting history replay\");\n            set_state(&state, IndexState::Ready, None);\n            emit_index_state(&app, \"Ready\", None);\n        }\n\n        let mut pending_paths: HashSet<PathBuf> = HashSet::new();\n        let mut deadline: Option<Instant> = None;\n        let mut last_flush = Instant::now();\n        let mut last_status_emit = Instant::now();\n        let mut pending_status_emit = false;\n        let mut last_count_refresh = Instant::now();\n        let mut must_scan_count: usize = 0;\n        let mut replay_phase = conditional;\n        let mut full_scan_triggered = false;\n\n        loop {\n            let wait = match deadline {\n                Some(due) => {\n                    let now = Instant::now();\n                    if now >= due {\n                        Duration::from_millis(0)\n                    } else {\n                        due - now\n                    }\n                }\n                None => Duration::from_secs(1),\n            };\n            match rx.recv_timeout(wait) {\n                Ok(mac::fsevent_watcher::FsEvent::Paths(paths)) => {\n                    let (ignored_roots, ignored_patterns) = cached_effective_ignore_rules(&state);\n                    let prev_len = pending_paths.len();\n                    for path in paths {\n                        if !should_skip_path(&path, &ignored_roots, &ignored_patterns) {\n                            pending_paths.insert(path);\n                        }\n                    }\n                    if pending_paths.len() > prev_len {\n                        deadline = Some(Instant::now() + WATCH_DEBOUNCE);\n                    }\n                }\n                Ok(mac::fsevent_watcher::FsEvent::MustScanSubDirs(path)) => {\n                    must_scan_count += 1;\n                    if replay_phase\n                        && must_scan_count >= MUST_SCAN_THRESHOLD\n                        && !full_scan_triggered\n                    {\n                        perf_log(format!(\n                            \"conditional_startup: MustScanSubDirs={} >= threshold, triggering full scan\",\n                            must_scan_count\n                        ));\n                        full_scan_triggered = true;\n                        let _ = start_full_index_worker(app.clone(), state.clone());\n                    }\n                    if !state.indexing_active.load(AtomicOrdering::Acquire) {\n                        let (ignored_roots, ignored_patterns) =\n                            cached_effective_ignore_rules(&state);\n                        let rows = collect_rows_recursive(&path, &ignored_roots, &ignored_patterns);\n                        if !rows.is_empty() {\n                            eprintln!(\n                                \"[watcher] MustScanSubDirs DB write: rows={} path={}\",\n                                rows.len(),\n                                path.display()\n                            );\n                            if let Ok(mut conn) = db_connection(&state.db_path) {\n                                if upsert_rows(&mut conn, &rows).is_ok() {\n                                    invalidate_search_caches(&state);\n                                    touch_status_updated(&state);\n                                    if last_status_emit.elapsed() >= STATUS_EMIT_MIN_INTERVAL {\n                                        let _ = refresh_and_emit_status_counts(&app, &state);\n                                        last_status_emit = Instant::now();\n                                        pending_status_emit = false;\n                                    } else {\n                                        pending_status_emit = true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                Ok(mac::fsevent_watcher::FsEvent::HistoryDone) => {\n                    eprintln!(\n                        \"[watcher] HistoryDone: pending_paths={} indexing_active={}\",\n                        pending_paths.len(),\n                        state.indexing_active.load(AtomicOrdering::Acquire)\n                    );\n                    process_watcher_paths(\n                        &app,\n                        &state,\n                        &mut pending_paths,\n                        &mut deadline,\n                        &mut last_status_emit,\n                        &mut pending_status_emit,\n                    );\n                    if replay_phase {\n                        replay_phase = false;\n                        if !full_scan_triggered {\n                            perf_log(format!(\n                                \"conditional_startup: HistoryDone, MustScanSubDirs={}, skipping full scan\",\n                                must_scan_count\n                            ));\n                            let _ = refresh_and_emit_status_counts(&app, &state);\n                            last_status_emit = Instant::now();\n                            pending_status_emit = false;\n                        }\n                    }\n                }\n                Err(RecvTimeoutError::Timeout) => {}\n                Err(RecvTimeoutError::Disconnected) => break,\n            }\n\n            if let Some(due) = deadline {\n                if Instant::now() >= due {\n                    process_watcher_paths(\n                        &app,\n                        &state,\n                        &mut pending_paths,\n                        &mut deadline,\n                        &mut last_status_emit,\n                        &mut pending_status_emit,\n                    );\n                }\n            }\n\n            if pending_status_emit && last_status_emit.elapsed() >= STATUS_EMIT_MIN_INTERVAL {\n                let _ = refresh_and_emit_status_counts(&app, &state);\n                last_status_emit = Instant::now();\n                pending_status_emit = false;\n            }\n\n            // Periodic event_id flush\n            if last_flush.elapsed() >= EVENT_ID_FLUSH_INTERVAL {\n                let eid = watcher.last_event_id();\n                let _ = persist_event_id(&state.db_path, eid);\n                last_flush = Instant::now();\n            }\n\n            // Periodic count refresh to keep in-memory counts accurate\n            if last_count_refresh.elapsed() >= EVENT_ID_FLUSH_INTERVAL {\n                let _ = update_status_counts(&state);\n                last_count_refresh = Instant::now();\n            }\n        }\n\n        // Final flush on shutdown\n        let eid = watcher.last_event_id();\n        let _ = persist_event_id(&state.db_path, eid);\n        watcher.stop();\n    });\n}\n\nfn validate_new_name(new_name: &str) -> AppResult<String> {\n    let trimmed = new_name.trim();\n\n    if trimmed.is_empty() {\n        return Err(\"New name cannot be empty.\".to_string());\n    }\n    if trimmed.contains('/') {\n        return Err(\"New name cannot contain '/'.\".to_string());\n    }\n    if trimmed == \".\" || trimmed == \"..\" {\n        return Err(\"Invalid name.\".to_string());\n    }\n\n    Ok(trimmed.to_string())\n}\n\nfn row_to_entry(row: &rusqlite::Row<'_>) -> rusqlite::Result<EntryDto> {\n    Ok(EntryDto {\n        path: row.get(0)?,\n        name: row.get(1)?,\n        dir: row.get(2)?,\n        is_dir: row.get::<_, i64>(3)? == 1,\n        ext: row.get(4)?,\n        size: row.get(5)?,\n        mtime: row.get(6)?,\n    })\n}\n\n#[cfg(target_os = \"macos\")]\nfn safe_file_type(ext: &str) -> String {\n    if ext.eq_ignore_ascii_case(\"folder\") {\n        return \"public.folder\".to_string();\n    }\n\n    let filtered: String = ext\n        .chars()\n        .filter(|c| c.is_ascii_alphanumeric())\n        .collect::<String>()\n        .to_lowercase();\n\n    if filtered.is_empty() {\n        \"public.data\".to_string()\n    } else {\n        filtered\n    }\n}\n\n#[cfg(target_os = \"macos\")]\nfn load_system_icon_png(ext: &str) -> Option<Vec<u8>> {\n    let file_type = safe_file_type(ext);\n    let script = format!(\n        r#\"import AppKit\nimport Foundation\nlet image = NSWorkspace.shared.icon(forFileType: \"{file_type}\")\nimage.size = NSSize(width: 16, height: 16)\nif let tiff = image.tiffRepresentation,\n   let rep = NSBitmapImageRep(data: tiff),\n   let png = rep.representation(using: .png, properties: [:]) {{\n  FileHandle.standardOutput.write(png)\n}} else {{\n  exit(1)\n}}\n\"#\n    );\n\n    let output = Command::new(\"swift\").arg(\"-e\").arg(script).output().ok()?;\n    if output.status.success() && !output.stdout.is_empty() {\n        Some(output.stdout)\n    } else {\n        None\n    }\n}\n\n#[cfg(target_os = \"windows\")]\nfn load_system_icon_png(ext: &str) -> Option<Vec<u8>> {\n    win::icon::load_icon_png_by_ext(ext)\n}\n\n#[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\nfn load_system_icon_png(_ext: &str) -> Option<Vec<u8>> {\n    None\n}\n\n#[cfg(target_os = \"windows\")]\nfn is_per_file_icon_ext(ext: &str) -> bool {\n    matches!(ext, \"exe\" | \"lnk\" | \"ico\" | \"url\" | \"scr\" | \"appx\")\n}\n\n#[tauri::command]\nfn get_index_status(state: State<'_, AppState>) -> IndexStatusDto {\n    let started = Instant::now();\n    let snapshot = state.status.lock().clone();\n    let snapshot_state = snapshot.state.as_str().to_string();\n    let db_ready = state.db_ready.load(AtomicOrdering::Acquire);\n    let indexing_active = state.indexing_active.load(AtomicOrdering::Acquire);\n    let state_label = if matches!(snapshot.state, IndexState::Error) {\n        snapshot.state.as_str().to_string()\n    } else if matches!(snapshot.state, IndexState::Ready) {\n        \"Ready\".to_string()\n    } else if indexing_active || !db_ready {\n        \"Indexing\".to_string()\n    } else {\n        snapshot.state.as_str().to_string()\n    };\n    let dto = IndexStatusDto {\n        state: state_label,\n        entries_count: snapshot.entries_count,\n        last_updated: snapshot.last_updated,\n        permission_errors: snapshot.permission_errors,\n        message: snapshot.message,\n        scanned: snapshot.scanned,\n        indexed: snapshot.indexed,\n        current_path: snapshot.current_path,\n    };\n    if cfg!(debug_assertions) {\n        eprintln!(\n            \"[rpc/get_index_status] elapsed={}ms state={} snapshot_state={} db_ready={} indexing_active={} entries={} scanned={} indexed={}\",\n            started.elapsed().as_millis(),\n            dto.state,\n            snapshot_state,\n            db_ready,\n            indexing_active,\n            dto.entries_count,\n            dto.scanned,\n            dto.indexed,\n        );\n    }\n    dto\n}\n\n#[tauri::command]\nfn get_home_dir(state: State<'_, AppState>) -> String {\n    state.home_dir.to_string_lossy().to_string()\n}\n\n#[tauri::command]\nfn start_full_index(app: AppHandle, state: State<'_, AppState>) -> AppResult<()> {\n    #[cfg(target_os = \"windows\")]\n    {\n        win::start_windows_indexing(app, state.inner().clone());\n        Ok(())\n    }\n    #[cfg(not(target_os = \"windows\"))]\n    {\n        start_full_index_worker(app, state.inner().clone())\n    }\n}\n\n#[tauri::command]\nasync fn reset_index(app: AppHandle, state: State<'_, AppState>) -> AppResult<()> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        if state.indexing_active.load(AtomicOrdering::Acquire) {\n            return Err(\"Cannot reset while indexing is in progress.\".to_string());\n        }\n\n        // Stop existing file watcher and wait for it to fully exit\n        state.watcher_stop.store(true, AtomicOrdering::Release);\n        let deadline = std::time::Instant::now() + std::time::Duration::from_secs(5);\n        while state.watcher_active.load(AtomicOrdering::Acquire) {\n            if std::time::Instant::now() >= deadline {\n                eprintln!(\"[reset] watcher did not stop within 5s, proceeding anyway\");\n                break;\n            }\n            std::thread::sleep(std::time::Duration::from_millis(50));\n        }\n\n        let conn = db_connection(&state.db_path)?;\n        // Use synchronous=OFF + large cache to make the bulk DELETE fast\n        let _ = conn.execute_batch(\n            \"PRAGMA synchronous=OFF; PRAGMA cache_size=-131072;\",\n        );\n        conn.execute(\"DELETE FROM entries\", [])\n            .map_err(|e| e.to_string())?;\n        conn.execute(\"DELETE FROM meta\", [])\n            .map_err(|e| e.to_string())?;\n\n        {\n            let mut status = state.status.lock();\n            status.state = IndexState::Indexing;\n            status.entries_count = 0;\n            status.last_updated = None;\n            status.permission_errors = 0;\n            status.message = None;\n            status.scanned = 0;\n            status.indexed = 0;\n            status.current_path.clear();\n        }\n\n        invalidate_search_caches(&state);\n\n        emit_index_state(&app, \"Indexing\", None);\n        emit_index_updated(&app, 0, now_epoch(), 0);\n\n        // Allow new watcher to start\n        state.watcher_stop.store(false, AtomicOrdering::Release);\n\n        #[cfg(target_os = \"windows\")]\n        {\n            win::start_windows_indexing(app, state);\n            Ok(())\n        }\n        #[cfg(not(target_os = \"windows\"))]\n        {\n            start_full_index_worker(app, state)\n        }\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\nfn log_search(db_path: &Path, query: &str, mode: &str, results: &[EntryDto]) {\n    if !search_log_enabled() {\n        return;\n    }\n\n    let log_path = db_path.with_file_name(\"search.log\");\n    let Ok(mut f) = fs::OpenOptions::new()\n        .create(true)\n        .append(true)\n        .open(&log_path)\n    else {\n        return;\n    };\n    let top: Vec<&str> = results.iter().take(10).map(|e| e.name.as_str()).collect();\n    let _ = writeln!(\n        f,\n        \"[{}] Q={:?} MODE={} COUNT={} TOP={:?}\",\n        now_epoch(),\n        query,\n        mode,\n        results.len(),\n        top,\n    );\n}\n\nfn search_log_enabled() -> bool {\n    *SEARCH_LOG_ENABLED.get_or_init(|| env_truthy(\"FASTFIND_SEARCH_LOG\"))\n}\n\n/// Returns the total number of entries matching `query` without LIMIT/OFFSET.\n/// Returns `None` when the total is unknown or intentionally skipped.\nfn compute_total_count(\n    db_path: &Path,\n    home_dir: &Path,\n    execution: &SearchExecution,\n) -> Option<u32> {\n    // When fewer results than the limit were returned the total is exact.\n    if (execution.results.len() as u32) < execution.effective_limit {\n        return Some(\n            execution\n                .offset\n                .saturating_add(execution.results.len() as u32),\n        );\n    }\n    // For paginated pages after the first we leave total tracking to the frontend.\n    if execution.offset > 0 {\n        return None;\n    }\n    // Non-SQL fast paths already return all matching entries.\n    if execution.mode_label.starts_with(\"mem_\")\n        || execution.mode_label == \"spotlight\"\n        || execution.mode_label == \"spotlight_timeout\"\n        || execution.mode_label == \"find_fallback\"\n        || execution.mode_label == \"name_neg_cache\"\n    {\n        return Some(execution.results.len() as u32);\n    }\n    let Ok(conn) = db_connection_for_search(db_path) else {\n        return None;\n    };\n    let mode = parse_query(&execution.query);\n    let total = match mode {\n        SearchMode::Empty => conn\n            .query_row(\"SELECT COUNT(*) FROM entries\", [], |r| r.get(0))\n            .unwrap_or(0),\n        SearchMode::NameSearch { name_like } => {\n            let escaped = escape_like(&execution.query);\n            let prefix_like = format!(\"{}%\", escaped);\n            let prefix_count: u32 = conn\n                .query_row(\n                    \"SELECT COUNT(*) FROM entries WHERE name LIKE ?1 ESCAPE '\\\\'\",\n                    params![prefix_like],\n                    |r| r.get(0),\n                )\n                .unwrap_or(0);\n            if prefix_count > 0 {\n                prefix_count\n            } else {\n                // Phase-2 contains fallback was used.\n                conn.query_row(\n                    \"SELECT COUNT(*) FROM entries WHERE name LIKE ?1 ESCAPE '\\\\'\",\n                    params![name_like],\n                    |r| r.get(0),\n                )\n                .unwrap_or(0)\n            }\n        }\n        SearchMode::GlobName { name_like } => conn\n            .query_row(\n                \"SELECT COUNT(*) FROM entries WHERE name LIKE ?1 ESCAPE '\\\\'\",\n                params![name_like],\n                |r| r.get(0),\n            )\n            .unwrap_or(0),\n        SearchMode::ExtSearch { ext, .. } => conn\n            .query_row(\n                \"SELECT COUNT(*) FROM entries WHERE ext = ?1\",\n                params![ext],\n                |r| r.get(0),\n            )\n            .unwrap_or(0),\n        SearchMode::PathSearch {\n            name_like,\n            dir_hint,\n            ..\n        } => {\n            let resolved_dirs = resolve_dir_hint(home_dir, &dir_hint)\n                .map(|p| vec![p.to_string_lossy().to_string()])\n                .unwrap_or_default();\n            let resolved_dirs = if resolved_dirs.is_empty() {\n                resolve_dirs_from_db(&conn, &dir_hint)\n            } else {\n                resolved_dirs\n            };\n\n            if !resolved_dirs.is_empty() {\n                let mut sql_params: Vec<SqlValue> = Vec::new();\n                let mut dir_conditions = Vec::new();\n                let sep = std::path::MAIN_SEPARATOR;\n                for d in &resolved_dirs {\n                    let i = sql_params.len();\n                    let pfx = format!(\"{d}{sep}\");\n                    let pfx_end = format!(\"{d}\\x7F\");\n                    sql_params.push(SqlValue::Text(d.clone()));\n                    sql_params.push(SqlValue::Text(pfx));\n                    sql_params.push(SqlValue::Text(pfx_end));\n                    dir_conditions.push(format!(\n                        \"(e.dir = ?{} OR (e.dir >= ?{} AND e.dir < ?{}))\",\n                        i + 1,\n                        i + 2,\n                        i + 3\n                    ));\n                }\n                let dir_where = dir_conditions.join(\" OR \");\n                let name_filter = if name_like == \"%\" {\n                    String::new()\n                } else {\n                    let ext_shortcut = extract_ext_from_like(&name_like);\n                    if let Some(ext_val) = ext_shortcut {\n                        let i = sql_params.len();\n                        sql_params.push(SqlValue::Text(ext_val));\n                        format!(\" AND e.ext = ?{}\", i + 1)\n                    } else {\n                        let i = sql_params.len();\n                        sql_params.push(SqlValue::Text(name_like.clone()));\n                        format!(\" AND e.name LIKE ?{} ESCAPE '\\\\'\", i + 1)\n                    }\n                };\n                let sql =\n                    format!(\"SELECT COUNT(*) FROM entries e WHERE ({dir_where}){name_filter}\");\n                conn.query_row(&sql, params_from_iter(sql_params.iter()), |r| r.get(0))\n                    .unwrap_or(0)\n            } else {\n                let sep = std::path::MAIN_SEPARATOR;\n                let native_hint = dir_hint.replace('/', &sep.to_string());\n                let escaped_sep = escape_like(&sep.to_string());\n                let dir_suffix = escape_like(&native_hint);\n                let dir_like_exact = format!(\"%{escaped_sep}{dir_suffix}\");\n                let dir_like_sub = format!(\"%{escaped_sep}{dir_suffix}{escaped_sep}%\");\n                let ext_shortcut = extract_ext_from_like(&name_like);\n                if let Some(ext_val) = ext_shortcut {\n                    conn.query_row(\n                        \"SELECT COUNT(*) FROM entries e WHERE e.ext = ?1 AND (e.dir LIKE ?2 ESCAPE '\\\\' OR e.dir LIKE ?3 ESCAPE '\\\\')\",\n                        params![ext_val, dir_like_exact, dir_like_sub],\n                        |r| r.get(0),\n                    )\n                    .unwrap_or(0)\n                } else if name_like == \"%\" {\n                    conn.query_row(\n                        \"SELECT COUNT(*) FROM entries e WHERE e.dir LIKE ?1 ESCAPE '\\\\' OR e.dir LIKE ?2 ESCAPE '\\\\'\",\n                        params![dir_like_exact, dir_like_sub],\n                        |r| r.get(0),\n                    )\n                    .unwrap_or(0)\n                } else {\n                    conn.query_row(\n                        \"SELECT COUNT(*) FROM entries e WHERE (e.dir LIKE ?1 ESCAPE '\\\\' OR e.dir LIKE ?2 ESCAPE '\\\\') AND e.name LIKE ?3 ESCAPE '\\\\'\",\n                        params![dir_like_exact, dir_like_sub, name_like],\n                        |r| r.get(0),\n                    )\n                    .unwrap_or(0)\n                }\n            }\n        }\n    };\n\n    Some(total)\n}\n\nfn execute_search(\n    state: &AppState,\n    query: String,\n    limit: Option<u32>,\n    offset: Option<u32>,\n    sort_by: Option<String>,\n    sort_dir: Option<String>,\n) -> AppResult<SearchExecution> {\n    let query = query.trim().to_string();\n    let base_limit = limit.unwrap_or(DEFAULT_LIMIT).clamp(1, MAX_LIMIT);\n    let effective_limit = if !query.is_empty() && query.chars().count() <= 1 {\n        base_limit.min(SHORT_QUERY_LIMIT)\n    } else {\n        base_limit\n    };\n    let offset = offset.unwrap_or(0);\n\n    let sort_by = sort_by.unwrap_or_else(|| \"name\".to_string());\n    let sort_dir = sort_dir.unwrap_or_else(|| \"asc\".to_string());\n    let (runtime_ignored_roots, runtime_ignored_patterns) = cached_effective_ignore_rules(state);\n\n    #[cfg(target_os = \"macos\")]\n    if !state.db_ready.load(AtomicOrdering::Acquire) {\n        let spotlight = mac::spotlight_search::search_spotlight(&state.home_dir, &query);\n        let mode_label = if spotlight.entries.is_empty() {\n            \"db_not_ready\".to_string()\n        } else if spotlight.timed_out {\n            \"spotlight_timeout\".to_string()\n        } else {\n            \"spotlight\".to_string()\n        };\n        perf_log(format!(\n            \"spotlight_fallback db_not_ready query={:?} results={} timed_out={}\",\n            query,\n            spotlight.entries.len(),\n            spotlight.timed_out\n        ));\n        return Ok(SearchExecution {\n            query,\n            sort_by,\n            sort_dir,\n            effective_limit,\n            offset,\n            mode_label,\n            results: spotlight.entries,\n        });\n    }\n\n    let is_indexing = matches!(state.status.lock().state, IndexState::Indexing);\n    let order_by = sort_clause(&sort_by, &sort_dir, \"e.\");\n\n    let mut results = Vec::with_capacity(effective_limit as usize);\n    let mode = parse_query(&query);\n    let is_name_mode = matches!(&mode, SearchMode::NameSearch { .. });\n    let allow_find_fallback = !is_indexing\n        && matches!(\n            &mode,\n            SearchMode::GlobName { .. } | SearchMode::ExtSearch { .. }\n        );\n    let mut mode_label = match &mode {\n        SearchMode::Empty => \"empty\",\n        SearchMode::NameSearch { .. } => \"name\",\n        SearchMode::GlobName { .. } => \"glob\",\n        SearchMode::ExtSearch { .. } => \"ext\",\n        SearchMode::PathSearch { .. } => \"path\",\n    }\n    .to_string();\n\n    // Fast path: search in-memory index if available (DB upsert still in progress)\n    {\n        let guard = state.mem_index.read();\n        if let Some(ref mi) = *guard {\n            let mem_results = mem_search::search_mem_index(\n                mi, &query, &mode, effective_limit, offset, &sort_by, &sort_dir,\n            );\n            mode_label = format!(\"mem_{mode_label}\");\n            return Ok(SearchExecution {\n                query,\n                sort_by,\n                sort_dir,\n                effective_limit,\n                offset,\n                mode_label,\n                results: mem_results,\n            });\n        }\n    }\n\n    if is_name_mode && !is_indexing && offset == 0 {\n        if let Some(cache_hit) = negative_name_cache_lookup(state, &query) {\n            if cache_hit.age >= WATCH_DEBOUNCE\n                && cache_hit.age <= NEGATIVE_CACHE_FALLBACK_WINDOW\n                && !cache_hit.fallback_checked\n            {\n                let fallback_results = find_search(\n                    &state.home_dir,\n                    &runtime_ignored_roots,\n                    &runtime_ignored_patterns,\n                    &query,\n                    effective_limit as usize,\n                    &sort_by,\n                    &sort_dir,\n                );\n                if !fallback_results.is_empty() {\n                    remove_negative_name_query(state, &cache_hit.query_lower);\n                    perf_log(format!(\n                        \"search_negative_cache_fallback_hit query={:?} age_ms={} results={}\",\n                        query,\n                        cache_hit.age.as_millis(),\n                        fallback_results.len()\n                    ));\n                    return Ok(SearchExecution {\n                        query,\n                        sort_by,\n                        sort_dir,\n                        effective_limit,\n                        offset,\n                        mode_label: \"find_fallback\".to_string(),\n                        results: fallback_results,\n                    });\n                }\n                mark_negative_name_fallback_checked(state, &cache_hit.query_lower);\n            }\n\n            perf_log(format!(\n                \"search_negative_cache_hit query={:?} age_ms={}\",\n                query,\n                cache_hit.age.as_millis()\n            ));\n            return Ok(SearchExecution {\n                query,\n                sort_by,\n                sort_dir,\n                effective_limit,\n                offset,\n                mode_label: \"name_neg_cache\".to_string(),\n                results: Vec::new(),\n            });\n        }\n    }\n\n    #[cfg(target_os = \"macos\")]\n    let db_unavailable;\n    match db_connection_for_search(&state.db_path) {\n        Ok(conn) => {\n            #[cfg(target_os = \"macos\")]\n            { db_unavailable = false; }\n            match &mode {\n                SearchMode::Empty => {\n                    let sql = format!(\n                        r#\"\n                        SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                        FROM entries e\n                        ORDER BY {order_by}\n                        LIMIT ?1 OFFSET ?2\n                        \"#,\n                    );\n                    let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                    let rows = stmt\n                        .query_map(params![effective_limit, offset], row_to_entry)\n                        .map_err(|e| e.to_string())?;\n                    for row in rows {\n                        results.push(row.map_err(|e| e.to_string())?);\n                    }\n                }\n\n                SearchMode::NameSearch { name_like } => {\n                    let escaped_query = escape_like(&query);\n                    let exact_query = query.clone();\n                    let prefix_like = format!(\"{}%\", escaped_query);\n                    let bare_order = sort_clause(&sort_by, &sort_dir, \"\");\n\n                    if offset == 0 {\n                        let exact_sql = format!(\n                            r#\"\n                            SELECT path, name, dir, is_dir, ext, size, mtime\n                            FROM entries\n                            WHERE name COLLATE NOCASE = ?1\n                            ORDER BY {bare_order}\n                            LIMIT ?2\n                            \"#,\n                        );\n                        let mut stmt = conn.prepare(&exact_sql).map_err(|e| e.to_string())?;\n                        let rows = stmt\n                            .query_map(params![exact_query, effective_limit], row_to_entry)\n                            .map_err(|e| e.to_string())?;\n                        for row in rows {\n                            results.push(row.map_err(|e| e.to_string())?);\n                        }\n                    }\n\n                    if (results.len() as u32) < effective_limit {\n                        let remaining = effective_limit - results.len() as u32;\n                        let adj_offset = if offset > 0 {\n                            offset.saturating_sub(results.len() as u32)\n                        } else {\n                            0\n                        };\n\n                        // Try indexed prefix search first; fall back to unindexed if\n                        // the index is temporarily unavailable (during background DB\n                        // rebuild the index may be dropped then recreated).\n                        let prefix_sql_indexed = format!(\n                            r#\"\n                            SELECT path, name, dir, is_dir, ext, size, mtime\n                            FROM entries INDEXED BY idx_entries_name_nocase\n                            WHERE name LIKE ?1 ESCAPE '\\'\n                              AND name COLLATE NOCASE != ?2\n                            ORDER BY {bare_order}\n                            LIMIT ?3 OFFSET ?4\n                            \"#,\n                        );\n                        let prefix_sql_fallback = format!(\n                            r#\"\n                            SELECT path, name, dir, is_dir, ext, size, mtime\n                            FROM entries\n                            WHERE name LIKE ?1 ESCAPE '\\'\n                              AND name COLLATE NOCASE != ?2\n                            ORDER BY {bare_order}\n                            LIMIT ?3 OFFSET ?4\n                            \"#,\n                        );\n                        let mut stmt = match conn.prepare(&prefix_sql_indexed) {\n                            Ok(s) => s,\n                            Err(_) => {\n                                eprintln!(\"[search] idx_entries_name_nocase unavailable, using fallback\");\n                                conn.prepare(&prefix_sql_fallback).map_err(|e| e.to_string())?\n                            }\n                        };\n                        let rows = stmt\n                            .query_map(\n                                params![prefix_like, exact_query, remaining, adj_offset],\n                                row_to_entry,\n                            )\n                            .map_err(|e| e.to_string())?;\n                        for row in rows {\n                            results.push(row.map_err(|e| e.to_string())?);\n                        }\n                    }\n\n                    if results.is_empty() && offset == 0 {\n                        // Phase 2: contains-match (LIKE '%q%') with tight time budget.\n                        // Combines probe + fetch in one pass to avoid double scan overhead.\n                        let phase2_start = Instant::now();\n                        conn.progress_handler(\n                            2_000,\n                            Some(move || phase2_start.elapsed().as_millis() > 5),\n                        );\n\n                        {\n\n                            let phase2_sql = format!(\n                                r#\"\n                                SELECT path, name, dir, is_dir, ext, size, mtime\n                                FROM entries\n                                WHERE name LIKE ?1 ESCAPE '\\'\n                                  AND name COLLATE NOCASE != ?2\n                                  AND name NOT LIKE ?3 ESCAPE '\\'\n                                ORDER BY {bare_order}\n                                LIMIT ?4\n                                \"#,\n                            );\n                            if let Ok(mut stmt2) = conn.prepare(&phase2_sql) {\n                                if let Ok(rows2) = stmt2.query_map(\n                                    params![name_like, exact_query, prefix_like, effective_limit],\n                                    row_to_entry,\n                                ) {\n                                    for row in rows2 {\n                                        match row {\n                                            Ok(entry) => results.push(entry),\n                                            Err(_) => break,\n                                        }\n                                    }\n                                }\n                            }\n                        }\n\n                        conn.progress_handler(0, None::<fn() -> bool>);\n                    }\n                }\n\n                SearchMode::GlobName { name_like } => {\n                    let sql = format!(\n                        r#\"\n                        SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                        FROM entries e\n                        WHERE e.name LIKE ?1 ESCAPE '\\'\n                        ORDER BY {order_by}\n                        LIMIT ?2 OFFSET ?3\n                        \"#,\n                    );\n                    let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                    let rows = stmt\n                        .query_map(params![name_like, effective_limit, offset], row_to_entry)\n                        .map_err(|e| e.to_string())?;\n                    for row in rows {\n                        results.push(row.map_err(|e| e.to_string())?);\n                    }\n                }\n\n                SearchMode::ExtSearch { ext, name_like: _ } => {\n                    let sql = format!(\n                        r#\"\n                        SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                        FROM entries e\n                        WHERE e.ext = ?1\n                        ORDER BY {order_by}\n                        LIMIT ?2 OFFSET ?3\n                        \"#,\n                    );\n                    let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                    let rows = stmt\n                        .query_map(params![ext, effective_limit, offset], row_to_entry)\n                        .map_err(|e| e.to_string())?;\n                    for row in rows {\n                        results.push(row.map_err(|e| e.to_string())?);\n                    }\n                }\n\n                SearchMode::PathSearch {\n                    path_like: _,\n                    name_like,\n                    dir_hint,\n                } => {\n                    let resolved_dirs: Vec<String> = resolve_dir_hint(&state.home_dir, dir_hint)\n                        .map(|p| vec![p.to_string_lossy().to_string()])\n                        .unwrap_or_default();\n                    let resolved_dirs = if resolved_dirs.is_empty() {\n                        resolve_dirs_from_db(&conn, dir_hint)\n                    } else {\n                        resolved_dirs\n                    };\n\n                    if !resolved_dirs.is_empty() {\n                        let ext_shortcut = extract_ext_from_like(name_like);\n                        let mut sql_params: Vec<SqlValue> = Vec::new();\n                        let mut dir_conditions = Vec::new();\n                        let sep = std::path::MAIN_SEPARATOR;\n\n                        for d in &resolved_dirs {\n                            let i = sql_params.len();\n                            let pfx = format!(\"{d}{sep}\");\n                            let pfx_end = format!(\"{d}\\x7F\");\n                            sql_params.push(SqlValue::Text(d.clone()));\n                            sql_params.push(SqlValue::Text(pfx));\n                            sql_params.push(SqlValue::Text(pfx_end));\n                            dir_conditions.push(format!(\n                                \"(e.dir = ?{} OR (e.dir >= ?{} AND e.dir < ?{}))\",\n                                i + 1,\n                                i + 2,\n                                i + 3\n                            ));\n                        }\n                        let dir_where = dir_conditions.join(\" OR \");\n\n                        let name_filter = if name_like == \"%\" {\n                            String::new()\n                        } else if let Some(ref ext_val) = ext_shortcut {\n                            let i = sql_params.len();\n                            sql_params.push(SqlValue::Text(ext_val.clone()));\n                            format!(\" AND e.ext = ?{}\", i + 1)\n                        } else {\n                            let i = sql_params.len();\n                            sql_params.push(SqlValue::Text(name_like.clone()));\n                            format!(\" AND e.name LIKE ?{} ESCAPE '\\\\'\", i + 1)\n                        };\n\n                        let limit_idx = sql_params.len() + 1;\n                        let offset_idx = sql_params.len() + 2;\n                        sql_params.push(SqlValue::Integer(effective_limit as i64));\n                        sql_params.push(SqlValue::Integer(offset as i64));\n\n                        let sql = format!(\n                            r#\"\n                            SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                            FROM entries e\n                            WHERE ({dir_where}){name_filter}\n                            ORDER BY {order_by}\n                            LIMIT ?{limit_idx} OFFSET ?{offset_idx}\n                            \"#,\n                        );\n                        let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                        let rows = stmt\n                            .query_map(params_from_iter(sql_params.iter()), row_to_entry)\n                            .map_err(|e| e.to_string())?;\n                        for row in rows {\n                            results.push(row.map_err(|e| e.to_string())?);\n                        }\n                    } else {\n                        let sep = std::path::MAIN_SEPARATOR;\n                        let sep_str = sep.to_string();\n                        let escaped_sep = escape_like(&sep_str);\n                        let (native_hint, is_absolute) = normalize_hint_to_native(dir_hint);\n                        let dir_suffix = escape_like(&native_hint);\n                        let dir_prefix = if is_absolute {\n                            String::new()\n                        } else {\n                            escaped_sep.clone()\n                        };\n                        let dir_like_exact = format!(\"%{dir_prefix}{dir_suffix}\");\n                        let dir_like_sub = format!(\"%{dir_prefix}{dir_suffix}{escaped_sep}%\");\n                        let ext_shortcut = extract_ext_from_like(name_like);\n\n                        if let Some(ext_val) = ext_shortcut {\n                            let sql = format!(\n                                r#\"\n                                SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                                FROM entries e\n                                WHERE e.ext = ?1\n                                  AND (e.dir LIKE ?2 ESCAPE '\\' OR e.dir LIKE ?3 ESCAPE '\\')\n                                ORDER BY {order_by}\n                                LIMIT ?4 OFFSET ?5\n                                \"#,\n                            );\n                            let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                            let rows = stmt\n                                .query_map(\n                                    params![\n                                        ext_val,\n                                        dir_like_exact,\n                                        dir_like_sub,\n                                        effective_limit,\n                                        offset\n                                    ],\n                                    row_to_entry,\n                                )\n                                .map_err(|e| e.to_string())?;\n                            for row in rows {\n                                results.push(row.map_err(|e| e.to_string())?);\n                            }\n                        } else if name_like == \"%\" {\n                            // Directory listing: no name filter needed, no time budget\n                            let sql = format!(\n                                r#\"\n                                SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                                FROM entries e\n                                WHERE e.dir LIKE ?1 ESCAPE '\\' OR e.dir LIKE ?2 ESCAPE '\\'\n                                ORDER BY {order_by}\n                                LIMIT ?3 OFFSET ?4\n                                \"#,\n                            );\n                            let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                            let rows = stmt\n                                .query_map(\n                                    params![dir_like_exact, dir_like_sub, effective_limit, offset],\n                                    row_to_entry,\n                                )\n                                .map_err(|e| e.to_string())?;\n                            for row in rows {\n                                results.push(row.map_err(|e| e.to_string())?);\n                            }\n                        } else {\n                            // Phase A: fast prefix search via name index\n                            // \"%main%\" -> strip leading '%' -> \"main%\" can use idx_entries_name_nocase\n                            let prefix_like = if name_like.starts_with('%') {\n                                let rest = &name_like[1..];\n                                if !rest.is_empty() && !rest.starts_with('%') {\n                                    Some(rest.to_string())\n                                } else {\n                                    None\n                                }\n                            } else {\n                                // Already a prefix pattern (e.g. \"test%\"), use as-is\n                                Some(name_like.clone())\n                            };\n\n                            if offset == 0 {\n                                if let Some(ref pfx) = prefix_like {\n                                    let sql = format!(\n                                        r#\"\n                                        SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                                        FROM entries e INDEXED BY idx_entries_name_nocase\n                                        WHERE e.name LIKE ?1 ESCAPE '\\'\n                                          AND (e.dir LIKE ?2 ESCAPE '\\' OR e.dir LIKE ?3 ESCAPE '\\')\n                                        ORDER BY {order_by}\n                                        LIMIT ?4\n                                        \"#,\n                                    );\n                                    if let Ok(mut stmt) = conn.prepare(&sql) {\n                                        if let Ok(rows) = stmt.query_map(\n                                            params![\n                                                pfx,\n                                                dir_like_exact,\n                                                dir_like_sub,\n                                                effective_limit\n                                            ],\n                                            row_to_entry,\n                                        ) {\n                                            for row in rows {\n                                                match row {\n                                                    Ok(entry) => results.push(entry),\n                                                    Err(_) => break,\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n\n                            // Phase B: time-budgeted contains fallback if prefix found too few\n                            if results.len() < effective_limit as usize {\n                                let path_start = Instant::now();\n                                conn.progress_handler(\n                                    2_000,\n                                    Some(move || path_start.elapsed().as_millis() > 5),\n                                );\n\n                                let sql = format!(\n                                    r#\"\n                                    SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                                    FROM entries e\n                                    WHERE (e.dir LIKE ?1 ESCAPE '\\' OR e.dir LIKE ?2 ESCAPE '\\')\n                                      AND e.name LIKE ?3 ESCAPE '\\'\n                                    ORDER BY {order_by}\n                                    LIMIT ?4 OFFSET ?5\n                                    \"#,\n                                );\n                                if let Ok(mut stmt) = conn.prepare(&sql) {\n                                    if let Ok(rows) = stmt.query_map(\n                                        params![\n                                            dir_like_exact,\n                                            dir_like_sub,\n                                            name_like,\n                                            effective_limit,\n                                            offset\n                                        ],\n                                        row_to_entry,\n                                    ) {\n                                        for row in rows {\n                                            match row {\n                                                Ok(entry) => results.push(entry),\n                                                Err(_) => break,\n                                            }\n                                        }\n                                    }\n                                }\n\n                                conn.progress_handler(0, None::<fn() -> bool>);\n\n                                // Deduplicate (Phase A prefix results overlap with Phase B contains)\n                                let mut seen = std::collections::HashSet::new();\n                                results.retain(|e| seen.insert(e.path.clone()));\n                                results.truncate(effective_limit as usize);\n                            }\n                        }\n                    }\n                }\n            }\n\n            if results.is_empty() && !query.is_empty() && offset == 0 && allow_find_fallback {\n                results = find_search(\n                    &state.home_dir,\n                    &runtime_ignored_roots,\n                    &runtime_ignored_patterns,\n                    &query,\n                    effective_limit as usize,\n                    &sort_by,\n                    &sort_dir,\n                );\n                mode_label = \"find_fallback\".to_string();\n            }\n        }\n        Err(_) => {\n            #[cfg(target_os = \"macos\")]\n            { db_unavailable = true; }\n            perf_log(format!(\"search_db_unavailable query={:?}\", query));\n        }\n    }\n\n    #[cfg(target_os = \"macos\")]\n    if !query.is_empty() && offset == 0 {\n        let should_spotlight = if results.is_empty() {\n            true\n        } else if results.len() >= effective_limit as usize {\n            false\n        } else {\n            is_indexing || db_unavailable\n        };\n        if should_spotlight {\n            let spotlight = mac::spotlight_search::search_spotlight(&state.home_dir, &query);\n            if !spotlight.entries.is_empty() {\n                if results.is_empty() {\n                    perf_log(format!(\n                        \"spotlight_fallback empty_results query={:?} results={} timed_out={}\",\n                        query,\n                        spotlight.entries.len(),\n                        spotlight.timed_out\n                    ));\n                    results = spotlight.entries;\n                    mode_label = if spotlight.timed_out {\n                        \"spotlight_timeout\".to_string()\n                    } else {\n                        \"spotlight\".to_string()\n                    };\n                } else {\n                    let existing_paths: std::collections::HashSet<String> =\n                        results.iter().map(|e| e.path.clone()).collect();\n                    let mut merged_count = 0usize;\n                    for entry in spotlight.entries {\n                        if !existing_paths.contains(&entry.path) {\n                            results.push(entry);\n                            merged_count += 1;\n                        }\n                    }\n                    if merged_count > 0 {\n                        perf_log(format!(\n                            \"spotlight_merge indexing query={:?} merged={} timed_out={}\",\n                            query, merged_count, spotlight.timed_out\n                        ));\n                        mode_label = format!(\"{}_+spotlight\", mode_label);\n                    }\n                }\n            }\n        }\n    }\n\n    results = filter_ignored_entries(results, &runtime_ignored_roots, &runtime_ignored_patterns);\n    results.truncate(effective_limit as usize);\n    if offset == 0 {\n        if sort_by == \"name\" {\n            sort_entries_with_relevance(&mut results, &query, &sort_by, &sort_dir);\n        } else {\n            sort_entries(&mut results, &sort_by, &sort_dir);\n        }\n    }\n    if is_name_mode && !is_indexing && offset == 0 && results.is_empty() && !query.is_empty() {\n        remember_negative_name_query(state, &query);\n    }\n\n    Ok(SearchExecution {\n        query,\n        sort_by,\n        sort_dir,\n        effective_limit,\n        offset,\n        mode_label,\n        results,\n    })\n}\n\n#[tauri::command]\nasync fn search(\n    _app: AppHandle,\n    query: String,\n    limit: Option<u32>,\n    offset: Option<u32>,\n    sort_by: Option<String>,\n    sort_dir: Option<String>,\n    include_total: Option<bool>,\n    state: State<'_, AppState>,\n) -> AppResult<SearchResultDto> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        let rpc_started = Instant::now();\n        let execute_started = Instant::now();\n        let execution = execute_search(&state, query, limit, offset, sort_by, sort_dir)?;\n        let execute_elapsed_ms = execute_started.elapsed().as_secs_f64() * 1000.0;\n\n        log_search(\n            &state.db_path,\n            &execution.query,\n            &execution.mode_label,\n            &execution.results,\n        );\n\n        if perf_log_enabled() {\n            let top: Vec<&str> = execution\n                .results\n                .iter()\n                .take(5)\n                .map(|entry| entry.name.as_str())\n                .collect();\n            perf_log(format!(\n                \"search query={:?} mode={} sort={}/{} limit={} offset={} results={} elapsed_ms={:.3} top={:?}\",\n                execution.query,\n                execution.mode_label,\n                execution.sort_by,\n                execution.sort_dir,\n                execution.effective_limit,\n                execution.offset,\n                execution.results.len(),\n                execute_elapsed_ms,\n                top,\n            ));\n        }\n\n        let include_total = include_total.unwrap_or(true);\n        let count_started = Instant::now();\n        let (total_count, total_known) = if include_total {\n            match compute_total_count(&state.db_path, &state.home_dir, &execution) {\n                Some(v) => (v, true),\n                None => (0, false),\n            }\n        } else {\n            (0, false)\n        };\n        let count_elapsed_ms = if include_total {\n            count_started.elapsed().as_secs_f64() * 1000.0\n        } else {\n            0.0\n        };\n\n        let rpc_elapsed_ms = rpc_started.elapsed().as_secs_f64() * 1000.0;\n        if cfg!(debug_assertions) {\n            let db_ready = state.db_ready.load(AtomicOrdering::Acquire);\n            let indexing_active = state.indexing_active.load(AtomicOrdering::Acquire);\n            eprintln!(\n                \"[rpc/search] total={:.3}ms execute={:.3}ms total_count={:.3}ms include_total={} query={:?} mode={} sort={}/{} limit={} offset={} results={} total_count={} total_known={} db_ready={} indexing_active={}\",\n                rpc_elapsed_ms,\n                execute_elapsed_ms,\n                count_elapsed_ms,\n                include_total,\n                execution.query,\n                execution.mode_label,\n                execution.sort_by,\n                execution.sort_dir,\n                execution.effective_limit,\n                execution.offset,\n                execution.results.len(),\n                total_count,\n                total_known,\n                db_ready,\n                indexing_active,\n            );\n        }\n        Ok(SearchResultDto {\n            entries: execution.results,\n            mode_label: execution.mode_label,\n            total_count,\n            total_known,\n        })\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nasync fn quick_look(path: String) -> AppResult<()> {\n    tauri::async_runtime::spawn_blocking(move || {\n        #[cfg(target_os = \"macos\")]\n        {\n            Command::new(\"qlmanage\")\n                .args([\"-p\", &path])\n                .stdout(std::process::Stdio::null())\n                .stderr(std::process::Stdio::null())\n                .spawn()\n                .map_err(|e| e.to_string())?;\n        }\n        #[cfg(target_os = \"windows\")]\n        {\n            Command::new(\"explorer\")\n                .arg(&path)\n                .spawn()\n                .map_err(|e| e.to_string())?;\n        }\n        #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n        {\n            Command::new(\"xdg-open\")\n                .arg(&path)\n                .spawn()\n                .map_err(|e| e.to_string())?;\n        }\n        Ok(())\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nasync fn open(paths: Vec<String>) -> AppResult<()> {\n    tauri::async_runtime::spawn_blocking(move || {\n        for path in &paths {\n            #[cfg(target_os = \"macos\")]\n            {\n                let output = Command::new(\"open\")\n                    .arg(path)\n                    .output()\n                    .map_err(|e| e.to_string())?;\n\n                if !output.status.success() && Path::new(path).is_dir() {\n                    let fallback = Command::new(\"open\")\n                        .args([\"-R\", path])\n                        .status()\n                        .map_err(|e| e.to_string())?;\n\n                    if !fallback.success() {\n                        return Err(format!(\"Failed to open: {path}\"));\n                    }\n                } else if !output.status.success() {\n                    let stderr = String::from_utf8_lossy(&output.stderr);\n                    return Err(format!(\"Failed to open: {path} ({stderr})\",));\n                }\n            }\n            #[cfg(target_os = \"windows\")]\n            {\n                let mut cmd = Command::new(\"cmd\");\n                cmd.raw_arg(format!(\"/C start \\\"\\\" \\\"{}\\\"\", path.replace('\"', \"\")));\n                let status = cmd.status().map_err(|e| e.to_string())?;\n                if !status.success() {\n                    return Err(format!(\"Failed to open: {path}\"));\n                }\n            }\n            #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n            {\n                let status = Command::new(\"xdg-open\")\n                    .arg(path)\n                    .status()\n                    .map_err(|e| e.to_string())?;\n                if !status.success() {\n                    return Err(format!(\"Failed to open: {path}\"));\n                }\n            }\n        }\n\n        Ok(())\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\nfn reveal_in_finder_impl(paths: Vec<String>) -> AppResult<()> {\n    if paths.is_empty() {\n        return Ok(());\n    }\n\n    #[cfg(target_os = \"macos\")]\n    {\n        if paths.len() == 1 {\n            let status = Command::new(\"open\")\n                .arg(\"-R\")\n                .arg(&paths[0])\n                .status()\n                .map_err(|e| e.to_string())?;\n\n            if !status.success() {\n                return Err(format!(\"Failed to reveal in Finder: {}\", paths[0]));\n            }\n\n            return Ok(());\n        }\n\n        let mut unique_parents: HashSet<PathBuf> = HashSet::new();\n        for path in &paths {\n            let p = PathBuf::from(path);\n            if let Some(parent) = p.parent() {\n                unique_parents.insert(parent.to_path_buf());\n            }\n        }\n\n        for parent in unique_parents {\n            let status = Command::new(\"open\")\n                .arg(&parent)\n                .status()\n                .map_err(|e| e.to_string())?;\n\n            if !status.success() {\n                return Err(format!(\n                    \"Failed to open in Finder: {}\",\n                    parent.to_string_lossy()\n                ));\n            }\n        }\n    }\n\n    #[cfg(target_os = \"windows\")]\n    {\n        for path in &paths {\n            let mut cmd = Command::new(\"explorer\");\n            cmd.raw_arg(format!(\"/select,\\\"{}\\\"\", path.replace('\"', \"\")));\n            let _ = cmd.status();\n        }\n    }\n\n    #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n    {\n        for path in &paths {\n            let target = Path::new(path);\n            let dir = if target.is_dir() {\n                path.as_str()\n            } else {\n                target\n                    .parent()\n                    .map(|p| p.to_str().unwrap_or(\"/\"))\n                    .unwrap_or(\"/\")\n            };\n            let _ = Command::new(\"xdg-open\").arg(dir).status();\n        }\n    }\n\n    Ok(())\n}\n\nfn copy_with_command(program: &str, args: &[&str], text: &str) -> AppResult<()> {\n    let mut child = Command::new(program)\n        .args(args)\n        .stdin(Stdio::piped())\n        .spawn()\n        .map_err(|e| format!(\"Failed to run {program}: {e}\"))?;\n\n    if let Some(mut stdin) = child.stdin.take() {\n        stdin\n            .write_all(text.as_bytes())\n            .map_err(|e| format!(\"Failed to write to clipboard: {e}\"))?;\n    } else {\n        return Err(\"Cannot open clipboard input stream.\".to_string());\n    }\n\n    let status = child\n        .wait()\n        .map_err(|e| format!(\"Failed to wait for {program}: {e}\"))?;\n\n    if status.success() {\n        Ok(())\n    } else {\n        Err(format!(\"{program} execution failed.\"))\n    }\n}\n\n#[cfg(target_os = \"macos\")]\nfn copy_text_to_clipboard(text: &str) -> AppResult<()> {\n    copy_with_command(\"pbcopy\", &[], text)\n}\n\n#[cfg(target_os = \"windows\")]\nfn copy_text_to_clipboard(text: &str) -> AppResult<()> {\n    copy_with_command(\"cmd\", &[\"/C\", \"clip\"], text)\n}\n\n#[cfg(all(unix, not(target_os = \"macos\")))]\nfn copy_text_to_clipboard(text: &str) -> AppResult<()> {\n    let mut last_error = None;\n\n    match copy_with_command(\"wl-copy\", &[], text) {\n        Ok(()) => return Ok(()),\n        Err(err) => last_error = Some(err),\n    }\n    match copy_with_command(\"xclip\", &[\"-selection\", \"clipboard\"], text) {\n        Ok(()) => return Ok(()),\n        Err(err) => last_error = Some(err),\n    }\n    match copy_with_command(\"xsel\", &[\"--clipboard\", \"--input\"], text) {\n        Ok(()) => return Ok(()),\n        Err(err) => last_error = Some(err),\n    }\n\n    Err(last_error.unwrap_or_else(|| {\n        \"No supported clipboard tool found. Please install wl-copy, xclip, or xsel.\".to_string()\n    }))\n}\n\n#[tauri::command]\nasync fn open_with(path: String) -> AppResult<()> {\n    tauri::async_runtime::spawn_blocking(move || reveal_in_finder_impl(vec![path]))\n        .await\n        .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nasync fn reveal_in_finder(paths: Vec<String>) -> AppResult<()> {\n    tauri::async_runtime::spawn_blocking(move || reveal_in_finder_impl(paths))\n        .await\n        .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nfn copy_paths(paths: Vec<String>) -> AppResult<()> {\n    copy_text_to_clipboard(&paths.join(\"\\n\"))\n}\n\n#[cfg(target_os = \"macos\")]\nfn copy_files_to_clipboard(paths: &[String]) -> AppResult<()> {\n    if paths.is_empty() {\n        return Ok(());\n    }\n    let file_exprs: Vec<String> = paths\n        .iter()\n        .map(|p| {\n            let escaped = p.replace('\\\\', \"\\\\\\\\\").replace('\"', \"\\\\\\\"\");\n            format!(\"POSIX file \\\"{}\\\"\", escaped)\n        })\n        .collect();\n    let script = if file_exprs.len() == 1 {\n        format!(\"set the clipboard to {}\", file_exprs[0])\n    } else {\n        format!(\"set the clipboard to {{{}}}\", file_exprs.join(\", \"))\n    };\n    let status = Command::new(\"osascript\")\n        .arg(\"-e\")\n        .arg(&script)\n        .status()\n        .map_err(|e| e.to_string())?;\n    if !status.success() {\n        return Err(\"Failed to copy files to clipboard\".to_string());\n    }\n    Ok(())\n}\n\n#[cfg(target_os = \"macos\")]\n#[tauri::command]\nfn copy_files(paths: Vec<String>) -> AppResult<()> {\n    copy_files_to_clipboard(&paths)\n}\n\n#[cfg(not(target_os = \"macos\"))]\n#[tauri::command]\nfn copy_files(_paths: Vec<String>) -> AppResult<()> {\n    Err(\"copy_files is only supported on macOS\".to_string())\n}\n\n#[tauri::command]\nasync fn move_to_trash(\n    paths: Vec<String>,\n    app: AppHandle,\n    state: State<'_, AppState>,\n) -> AppResult<()> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        let mut deleted_targets = Vec::new();\n\n        for path in &paths {\n            trash::delete(path).map_err(|e| e.to_string())?;\n            remember_op(&state, \"trash\", Some(path.clone()), None);\n            deleted_targets.push(path.clone());\n        }\n\n        let mut conn = db_connection(&state.db_path)?;\n        let _ = delete_paths(&mut conn, &deleted_targets)?;\n        invalidate_search_caches(&state);\n\n        refresh_and_emit_status_counts(&app, &state)?;\n        Ok(())\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nasync fn rename(\n    path: String,\n    new_name: String,\n    app: AppHandle,\n    state: State<'_, AppState>,\n) -> AppResult<EntryDto> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        let validated_name = validate_new_name(&new_name)?;\n        let old_path = PathBuf::from(&path);\n\n        if !old_path.exists() {\n            return Err(\"Source file does not exist.\".to_string());\n        }\n\n        let parent = old_path\n            .parent()\n            .ok_or_else(|| \"Parent directory not found.\".to_string())?;\n\n        let new_path = parent.join(&validated_name);\n        if new_path == old_path {\n            let meta = fs::symlink_metadata(&old_path).ok();\n            return Ok(EntryDto {\n                path: path.clone(),\n                name: old_path\n                    .file_name()\n                    .map(|v| v.to_string_lossy().to_string())\n                    .unwrap_or_else(|| validated_name.clone()),\n                dir: parent.to_string_lossy().to_string(),\n                is_dir: old_path.is_dir(),\n                ext: extension_for(&old_path, old_path.is_dir()),\n                size: meta\n                    .as_ref()\n                    .filter(|m| m.is_file())\n                    .map(|m| m.len() as i64),\n                mtime: meta\n                    .and_then(|m| m.modified().ok())\n                    .and_then(|m| m.duration_since(UNIX_EPOCH).ok())\n                    .map(|d| d.as_secs() as i64),\n            });\n        }\n\n        if new_path.exists() {\n            return Err(\"A file/folder with the same name already exists.\".to_string());\n        }\n\n        let original_is_dir = old_path.is_dir();\n        fs::rename(&old_path, &new_path).map_err(|e| e.to_string())?;\n\n        let mut conn = db_connection(&state.db_path)?;\n        let _ = delete_paths(&mut conn, &[path.clone()])?;\n\n        if original_is_dir {\n            let rows =\n                collect_rows_recursive(&new_path, &state.path_ignores, &state.path_ignore_patterns);\n            for chunk in rows.chunks(BATCH_SIZE) {\n                let _ = upsert_rows(&mut conn, chunk)?;\n            }\n        } else {\n            let row = index_row_from_path(&new_path)\n                .ok_or_else(|| \"Cannot read renamed file info.\".to_string())?;\n            let _ = upsert_rows(&mut conn, &[row])?;\n        }\n\n        invalidate_search_caches(&state);\n\n        remember_op(\n            &state,\n            \"rename\",\n            Some(old_path.to_string_lossy().to_string()),\n            Some(new_path.to_string_lossy().to_string()),\n        );\n\n        refresh_and_emit_status_counts(&app, &state)?;\n\n        let new_meta = fs::symlink_metadata(&new_path).ok();\n        Ok(EntryDto {\n            path: new_path.to_string_lossy().to_string(),\n            name: validated_name,\n            dir: parent.to_string_lossy().to_string(),\n            is_dir: original_is_dir,\n            ext: extension_for(&new_path, original_is_dir),\n            size: new_meta\n                .as_ref()\n                .filter(|m| m.is_file())\n                .map(|m| m.len() as i64),\n            mtime: new_meta\n                .and_then(|m| m.modified().ok())\n                .and_then(|m| m.duration_since(UNIX_EPOCH).ok())\n                .map(|d| d.as_secs() as i64),\n        })\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nasync fn fd_search(\n    query: String,\n    limit: Option<u32>,\n    offset: Option<u32>,\n    sort_by: Option<String>,\n    sort_dir: Option<String>,\n    state: State<'_, AppState>,\n) -> AppResult<FdSearchResultDto> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        let query = query.trim().to_string();\n        let limit = limit.unwrap_or(500).clamp(1, 5000) as usize;\n        let offset = offset.unwrap_or(0) as usize;\n        let sort_by = sort_by.unwrap_or_else(|| \"name\".to_string());\n        let sort_dir = sort_dir.unwrap_or_else(|| \"asc\".to_string());\n        let (runtime_ignored_roots, runtime_ignored_patterns) =\n            cached_effective_ignore_rules(&state);\n        let ignore_fingerprint =\n            ignore_rules_fingerprint(&runtime_ignored_roots, &runtime_ignored_patterns);\n\n        if query.is_empty() {\n            return Ok(FdSearchResultDto {\n                entries: Vec::new(),\n                total: 0,\n                timed_out: false,\n            });\n        }\n\n        {\n            let cache = state.fd_search_cache.lock();\n            if let Some(cached) = cache.as_ref() {\n                let cache_hit = cached.query == query\n                    && cached.sort_by == sort_by\n                    && cached.sort_dir == sort_dir\n                    && cached.ignore_fingerprint == ignore_fingerprint;\n                if cache_hit {\n                    let total = cached.entries.len() as u64;\n                    let end = (offset + limit).min(cached.entries.len());\n                    let page = if offset < cached.entries.len() {\n                        cached.entries[offset..end].to_vec()\n                    } else {\n                        Vec::new()\n                    };\n                    return Ok(FdSearchResultDto {\n                        entries: page,\n                        total,\n                        timed_out: false,\n                    });\n                }\n            }\n        }\n\n        let result = fd_search::run_fd_search(\n            &state.scan_root,\n            &runtime_ignored_roots,\n            &runtime_ignored_patterns,\n            &query,\n            &sort_by,\n            &sort_dir,\n        );\n        let total = result.entries.len() as u64;\n        let end = (offset + limit).min(result.entries.len());\n        let page = if offset < result.entries.len() {\n            result.entries[offset..end].to_vec()\n        } else {\n            Vec::new()\n        };\n\n        {\n            let mut cache = state.fd_search_cache.lock();\n            *cache = Some(FdSearchCache {\n                query: query.clone(),\n                sort_by: sort_by.clone(),\n                sort_dir: sort_dir.clone(),\n                ignore_fingerprint,\n                entries: result.entries,\n            });\n        }\n\n        Ok(FdSearchResultDto {\n            entries: page,\n            total,\n            timed_out: result.timed_out,\n        })\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nfn frontend_log(msg: String) {\n    eprintln!(\"{msg}\");\n}\n\n#[tauri::command]\nfn mark_frontend_ready(state: State<'_, AppState>) {\n    state.frontend_ready.store(true, AtomicOrdering::Release);\n    if cfg!(debug_assertions) {\n        eprintln!(\"[startup] frontend_ready=true\");\n    }\n}\n\n#[tauri::command]\nfn get_platform() -> String {\n    if cfg!(target_os = \"windows\") {\n        \"windows\".to_string()\n    } else if cfg!(target_os = \"macos\") {\n        \"macos\".to_string()\n    } else {\n        \"linux\".to_string()\n    }\n}\n\n#[cfg(target_os = \"windows\")]\n#[tauri::command]\nasync fn show_context_menu(\n    paths: Vec<String>,\n    x: f64,\n    y: f64,\n    _single_selection: bool,\n    app: AppHandle,\n) -> AppResult<()> {\n    let window = app\n        .get_webview_window(\"main\")\n        .ok_or_else(|| \"Main window not found\".to_string())?;\n\n    let scale = window.scale_factor().map_err(|e| e.to_string())?;\n    let win_pos = window.inner_position().map_err(|e| e.to_string())?;\n    let screen_x = win_pos.x + (x * scale) as i32;\n    let screen_y = win_pos.y + (y * scale) as i32;\n\n    let hwnd_raw = window.hwnd().map_err(|e| e.to_string())?.0 as isize;\n\n    // TrackPopupMenu must run on the thread that owns the HWND (main UI thread).\n    // Use a channel to relay the result back to the async context.\n    let (tx, rx) = std::sync::mpsc::sync_channel::<Result<(), String>>(1);\n\n    app.run_on_main_thread(move || {\n        let result = win::context_menu::show(hwnd_raw, &paths, screen_x, screen_y);\n        let _ = tx.send(result);\n    })\n    .map_err(|e| e.to_string())?;\n\n    tauri::async_runtime::spawn_blocking(move || {\n        rx.recv().map_err(|e| format!(\"context menu channel: {e}\"))?\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[cfg(target_os = \"macos\")]\n#[tauri::command]\nasync fn show_context_menu(\n    _paths: Vec<String>,\n    x: f64,\n    y: f64,\n    single_selection: bool,\n    app: AppHandle,\n) -> AppResult<()> {\n    use tauri::menu::{IsMenuItem, Menu, MenuItem, PredefinedMenuItem};\n\n    let window = app\n        .get_webview_window(\"main\")\n        .ok_or_else(|| \"Main window not found\".to_string())?;\n\n    let (tx, rx) = std::sync::mpsc::sync_channel::<Result<(), String>>(1);\n\n    let app_clone = app.clone();\n    app.run_on_main_thread(move || {\n        let app = app_clone;\n        let result = (|| -> Result<(), tauri::Error> {\n            let open = MenuItem::with_id(&app, \"ctx_open\", \"Open\", true, None::<&str>)?;\n            let quick_look =\n                MenuItem::with_id(&app, \"ctx_quick_look\", \"Quick Look\", true, None::<&str>)?;\n            let open_with =\n                MenuItem::with_id(&app, \"ctx_open_with\", \"Open With...\", true, None::<&str>)?;\n            let sep1 = PredefinedMenuItem::separator(&app)?;\n            let reveal = MenuItem::with_id(\n                &app,\n                \"ctx_reveal\",\n                \"Reveal in Finder\",\n                true,\n                None::<&str>,\n            )?;\n            let sep2 = PredefinedMenuItem::separator(&app)?;\n            let copy_files =\n                MenuItem::with_id(&app, \"ctx_copy_files\", \"Copy\", true, None::<&str>)?;\n            let copy_path =\n                MenuItem::with_id(&app, \"ctx_copy_path\", \"Copy Path\", true, None::<&str>)?;\n            let sep3 = PredefinedMenuItem::separator(&app)?;\n            let trash = MenuItem::with_id(\n                &app,\n                \"ctx_trash\",\n                \"Move to Trash\",\n                true,\n                None::<&str>,\n            )?;\n            let rename =\n                MenuItem::with_id(&app, \"ctx_rename\", \"Rename\", true, None::<&str>)?;\n\n            let mut items: Vec<&dyn IsMenuItem<tauri::Wry>> = vec![\n                &open, &quick_look, &open_with, &sep1, &reveal, &sep2, &copy_files, &copy_path, &sep3, &trash,\n            ];\n            if single_selection {\n                items.push(&rename);\n            }\n\n            let menu = Menu::with_items(&app, &items)?;\n            // Position is window-relative logical pixels, matching clientX/clientY.\n            window.popup_menu_at(&menu, tauri::LogicalPosition::new(x, y))?;\n            Ok(())\n        })();\n        let _ = tx.send(result.map_err(|e| e.to_string()));\n    })\n    .map_err(|e| e.to_string())?;\n\n    tauri::async_runtime::spawn_blocking(move || {\n        rx.recv().map_err(|e| format!(\"context menu channel: {e}\"))?\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[cfg(not(any(target_os = \"windows\", target_os = \"macos\")))]\n#[tauri::command]\nasync fn show_context_menu(\n    _paths: Vec<String>,\n    _x: f64,\n    _y: f64,\n    _single_selection: bool,\n    _app: AppHandle,\n) -> AppResult<()> {\n    Err(\"Native context menu is only supported on Windows and macOS\".to_string())\n}\n\n#[tauri::command]\nasync fn set_native_theme(theme: String, app: AppHandle) -> AppResult<()> {\n    let window = app\n        .get_webview_window(\"main\")\n        .ok_or_else(|| \"Main window not found\".to_string())?;\n    let t = if theme == \"light\" {\n        tauri::Theme::Light\n    } else {\n        tauri::Theme::Dark\n    };\n    window.set_theme(Some(t)).map_err(|e| e.to_string())\n}\n\n#[tauri::command]\nasync fn get_file_icon(\n    path: Option<String>,\n    ext: String,\n    state: State<'_, AppState>,\n) -> AppResult<Vec<u8>> {\n    let state = state.inner().clone();\n    Ok(tauri::async_runtime::spawn_blocking(move || {\n        let ext_lower = if ext.trim().is_empty() {\n            \"__default__\".to_string()\n        } else {\n            ext.to_lowercase()\n        };\n\n        #[cfg(target_os = \"windows\")]\n        let cache_key = {\n            if is_per_file_icon_ext(&ext_lower) {\n                path.as_deref().unwrap_or(&ext_lower).to_string()\n            } else {\n                ext_lower.clone()\n            }\n        };\n        #[cfg(not(target_os = \"windows\"))]\n        let cache_key = ext_lower.clone();\n\n        if let Some(cached) = state.icon_cache.lock().get(&cache_key).cloned() {\n            return cached;\n        }\n\n        #[cfg(target_os = \"windows\")]\n        let icon = {\n            let from_path = path\n                .as_deref()\n                .filter(|p| !p.is_empty())\n                .and_then(win::icon::load_icon_png);\n            from_path.or_else(|| load_system_icon_png(&ext_lower))\n        };\n        #[cfg(not(target_os = \"windows\"))]\n        let icon = {\n            let _ = path;\n            load_system_icon_png(&ext_lower)\n        };\n\n        let icon = icon.unwrap_or_default();\n        state.icon_cache.lock().insert(cache_key, icon.clone());\n        icon\n    })\n    .await\n    .unwrap_or_default())\n}\n\nfn default_bench_cases() -> Vec<BenchCase> {\n    vec![\n        BenchCase {\n            id: \"TC01_exact_name\",\n            query: \"report_00042\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC02_prefix_name\",\n            query: \"report_00\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 10,\n        },\n        BenchCase {\n            id: \"TC03_contains_name\",\n            query: \"invoice\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC04_ext_md\",\n            query: \"*.md\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC05_path_glob_png\",\n            query: \"Desktop/ *.png\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC06_path_term\",\n            query: \"Projects/rust\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC07_path_ext_rs\",\n            query: \"Projects/ *.rs\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC08_no_match\",\n            query: \"zzzz_not_exists_12345\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 0,\n        },\n    ]\n}\n\nfn bench_iterations() -> u32 {\n    std::env::var(\"EVERYTHING_BENCH_ITERATIONS\")\n        .ok()\n        .and_then(|v| v.parse::<u32>().ok())\n        .map(|v| v.clamp(1, 50))\n        .unwrap_or(5)\n}\n\nfn bench_wait_timeout() -> Duration {\n    let seconds = std::env::var(\"EVERYTHING_BENCH_WAIT_SEC\")\n        .ok()\n        .and_then(|v| v.parse::<u64>().ok())\n        .map(|v| v.clamp(10, 7200))\n        .unwrap_or(1800);\n    Duration::from_secs(seconds)\n}\n\nfn bench_run_label() -> String {\n    std::env::var(\"EVERYTHING_BENCH_RUN_LABEL\")\n        .ok()\n        .filter(|v| !v.trim().is_empty())\n        .unwrap_or_else(|| format!(\"run-{}\", now_epoch()))\n}\n\nfn bench_output_path(db_path: &Path, run_label: &str) -> PathBuf {\n    std::env::var(\"EVERYTHING_BENCH_OUTPUT\")\n        .ok()\n        .filter(|v| !v.trim().is_empty())\n        .map(PathBuf::from)\n        .unwrap_or_else(|| db_path.with_file_name(format!(\"bench-report-{run_label}.json\")))\n}\n\nfn write_bench_report(path: &Path, report: &BenchReport) -> AppResult<()> {\n    let json = serde_json::to_string_pretty(report).map_err(|e| e.to_string())?;\n    fs::write(path, json).map_err(|e| e.to_string())\n}\n\nfn start_bench_runner(app_handle: AppHandle, state: AppState) {\n    std::thread::spawn(move || {\n        let run_label = bench_run_label();\n        let output_path = bench_output_path(&state.db_path, &run_label);\n        let iterations = bench_iterations();\n        let wait_timeout = bench_wait_timeout();\n        let started_at = now_epoch();\n\n        perf_log(format!(\n            \"bench_start run_label={} output={} iterations={} wait_timeout_s={}\",\n            run_label,\n            output_path.to_string_lossy(),\n            iterations,\n            wait_timeout.as_secs(),\n        ));\n\n        let wait_started = Instant::now();\n        let mut saw_indexing = false;\n        let index_snapshot: IndexStatus;\n        loop {\n            let snapshot = state.status.lock().clone();\n            let active = state.indexing_active.load(AtomicOrdering::Acquire)\n                || matches!(snapshot.state, IndexState::Indexing);\n\n            if active {\n                saw_indexing = true;\n            }\n\n            if state.db_ready.load(AtomicOrdering::Acquire) && saw_indexing && !active {\n                index_snapshot = snapshot;\n                break;\n            }\n\n            if wait_started.elapsed() >= wait_timeout {\n                let report = BenchReport {\n                    run_label: run_label.clone(),\n                    started_at,\n                    completed_at: now_epoch(),\n                    home_dir: state.home_dir.to_string_lossy().to_string(),\n                    db_path: state.db_path.to_string_lossy().to_string(),\n                    index_wait_ms: wait_started.elapsed().as_millis(),\n                    index_scanned: snapshot.scanned,\n                    index_indexed: snapshot.indexed,\n                    index_entries_count: snapshot.entries_count,\n                    index_permission_errors: snapshot.permission_errors,\n                    index_message: Some(\"Timed out waiting for index ready\".to_string()),\n                    search_iterations: iterations,\n                    search_results: Vec::new(),\n                };\n                let _ = write_bench_report(&output_path, &report);\n                perf_log(format!(\n                    \"bench_timeout run_label={} waited_ms={}\",\n                    run_label,\n                    wait_started.elapsed().as_millis()\n                ));\n                if env_truthy(\"EVERYTHING_BENCH_EXIT\") {\n                    app_handle.exit(2);\n                }\n                return;\n            }\n\n            std::thread::sleep(Duration::from_millis(200));\n        }\n\n        let index_wait_ms = wait_started.elapsed().as_millis();\n        perf_log(format!(\n            \"bench_index_ready run_label={} waited_ms={} scanned={} indexed={} entries={} permission_errors={}\",\n            run_label,\n            index_wait_ms,\n            index_snapshot.scanned,\n            index_snapshot.indexed,\n            index_snapshot.entries_count,\n            index_snapshot.permission_errors,\n        ));\n\n        let mut search_results = Vec::new();\n        for case in default_bench_cases() {\n            let mut elapsed_sum = 0.0f64;\n            let mut success_count = 0u32;\n            let mut result_count = 0usize;\n            let mut mode = String::new();\n            let mut top_results = Vec::new();\n            let mut case_error = None;\n\n            for iter in 1..=iterations {\n                let started = Instant::now();\n                match execute_search(\n                    &state,\n                    case.query.to_string(),\n                    Some(case.limit),\n                    Some(case.offset),\n                    Some(case.sort_by.to_string()),\n                    Some(case.sort_dir.to_string()),\n                ) {\n                    Ok(execution) => {\n                        let elapsed_ms = started.elapsed().as_secs_f64() * 1000.0;\n                        elapsed_sum += elapsed_ms;\n                        success_count += 1;\n                        result_count = execution.results.len();\n                        mode = execution.mode_label;\n                        top_results = execution\n                            .results\n                            .iter()\n                            .take(5)\n                            .map(|entry| entry.path.clone())\n                            .collect();\n\n                        perf_log(format!(\n                            \"bench_query run_label={} case={} iter={}/{} query={:?} mode={} results={} elapsed_ms={:.3}\",\n                            run_label,\n                            case.id,\n                            iter,\n                            iterations,\n                            case.query,\n                            mode,\n                            result_count,\n                            elapsed_ms\n                        ));\n                    }\n                    Err(err) => {\n                        case_error = Some(err);\n                        break;\n                    }\n                }\n            }\n\n            let elapsed_ms = if success_count > 0 {\n                elapsed_sum / success_count as f64\n            } else {\n                0.0\n            };\n            let passed = case_error.is_none() && result_count >= case.expected_min_results;\n\n            search_results.push(BenchCaseResult {\n                id: case.id.to_string(),\n                query: case.query.to_string(),\n                mode,\n                sort_by: case.sort_by.to_string(),\n                sort_dir: case.sort_dir.to_string(),\n                limit: case.limit,\n                offset: case.offset,\n                elapsed_ms,\n                result_count,\n                expected_min_results: case.expected_min_results,\n                passed,\n                top_results,\n                error: case_error,\n            });\n        }\n\n        let report = BenchReport {\n            run_label: run_label.clone(),\n            started_at,\n            completed_at: now_epoch(),\n            home_dir: state.home_dir.to_string_lossy().to_string(),\n            db_path: state.db_path.to_string_lossy().to_string(),\n            index_wait_ms,\n            index_scanned: index_snapshot.scanned,\n            index_indexed: index_snapshot.indexed,\n            index_entries_count: index_snapshot.entries_count,\n            index_permission_errors: index_snapshot.permission_errors,\n            index_message: index_snapshot.message.clone(),\n            search_iterations: iterations,\n            search_results,\n        };\n\n        match write_bench_report(&output_path, &report) {\n            Ok(()) => perf_log(format!(\n                \"bench_report_written run_label={} path={}\",\n                run_label,\n                output_path.to_string_lossy()\n            )),\n            Err(err) => perf_log(format!(\n                \"bench_report_write_error run_label={} path={} err={}\",\n                run_label,\n                output_path.to_string_lossy(),\n                err\n            )),\n        }\n\n        if env_truthy(\"EVERYTHING_BENCH_EXIT\") {\n            app_handle.exit(0);\n        }\n    });\n}\n\n#[cfg(target_os = \"macos\")]\nfn register_global_shortcut(app: &AppHandle) -> AppResult<()> {\n    let shortcut = Shortcut::new(Some(Modifiers::SUPER | Modifiers::SHIFT), Code::Space);\n\n    app.global_shortcut()\n        .on_shortcut(shortcut, move |app_handle, _, _| {\n            if let Some(window) = app_handle.get_webview_window(\"main\") {\n                let _ = window.show();\n                let _ = window.unminimize();\n                let _ = window.set_focus();\n            }\n            let _ = app_handle.emit(\"focus_search\", ());\n        })\n        .map_err(|e| format!(\"Failed to register global shortcut: {e}\"))\n}\n\n#[cfg(not(target_os = \"macos\"))]\nfn register_global_shortcut(_app: &AppHandle) -> AppResult<()> {\n    Ok(())\n}\n\nfn setup_app(app: &mut tauri::App) -> AppResult<()> {\n    let setup_started = std::time::Instant::now();\n    eprintln!(\"[startup] setup_app() entered\");\n    let bench_mode = bench_mode_enabled();\n\n    #[cfg(target_os = \"macos\")]\n    if let Some(window) = app.get_webview_window(\"main\") {\n        use tauri::window::Color;\n        let is_dark = window\n            .theme()\n            .map(|t| t == tauri::Theme::Dark)\n            .unwrap_or(false);\n        let bg = if is_dark {\n            Color(0x1f, 0x1f, 0x1f, 0xff)\n        } else {\n            Color(0xf4, 0xf5, 0xf7, 0xff)\n        };\n        let _ = window.set_background_color(Some(bg));\n        let _ = window.show();\n    }\n\n    #[cfg(target_os = \"windows\")]\n    if let Some(window) = app.get_webview_window(\"main\") {\n        eprintln!(\"[startup +{}ms] windows setup: before window.show()\", startup_elapsed_ms());\n        use tauri::window::Color;\n        let is_dark = window.theme().map(|t| t == tauri::Theme::Dark).unwrap_or(false);\n        let bg = if is_dark {\n            Color(0x1f, 0x1f, 0x1f, 0xff)\n        } else {\n            Color(0xf4, 0xf5, 0xf7, 0xff)\n        };\n        let _ = window.set_background_color(Some(bg));\n        if let Err(e) = window.set_decorations(false) {\n            eprintln!(\n                \"[startup +{}ms] windows setup: set_decorations(false) failed: {}\",\n                startup_elapsed_ms(),\n                e\n            );\n        }\n        let _ = window.show();\n        eprintln!(\"[startup +{}ms] windows setup: window.show() returned\", startup_elapsed_ms());\n    }\n\n    let app_data_dir = app\n        .path()\n        .app_data_dir()\n        .map_err(|e| format!(\"Failed to get app data dir: {e}\"))?;\n    fs::create_dir_all(&app_data_dir).map_err(|e| e.to_string())?;\n\n    let db_path = app_data_dir.join(\"index.db\");\n    let home_dir = PathBuf::from(\n        std::env::var(\"HOME\")\n            .or_else(|_| std::env::var(\"USERPROFILE\"))\n            .unwrap_or_else(|_| if cfg!(windows) { \"C:\\\\\".to_string() } else { \"/\".to_string() }),\n    );\n    let scan_root = if cfg!(windows) {\n        PathBuf::from(\"C:\\\\\")\n    } else {\n        home_dir.clone()\n    };\n    let cwd = std::env::current_dir().unwrap_or_else(|_| home_dir.clone());\n    eprintln!(\"[startup] +{}ms loading pathignore rules...\", setup_started.elapsed().as_millis());\n    let (mut path_ignores, path_ignore_patterns) = load_pathignore_rules(&home_dir, &cwd);\n    if !path_ignores.iter().any(|r| r == &app_data_dir) {\n        path_ignores.push(app_data_dir.clone());\n    }\n    for root in load_gitignore_roots(&home_dir, &cwd) {\n        if !path_ignores.iter().any(|r| r == &root) {\n            path_ignores.push(root);\n        }\n    }\n    eprintln!(\"[startup] +{}ms pathignore done\", setup_started.elapsed().as_millis());\n\n    let gitignore = Arc::new(gitignore_filter::LazyGitignoreFilter::new(home_dir.clone()));\n\n    let state = AppState {\n        db_path,\n        home_dir,\n        scan_root,\n        cwd,\n        path_ignores: Arc::new(path_ignores),\n        path_ignore_patterns: Arc::new(path_ignore_patterns),\n        db_ready: Arc::new(AtomicBool::new(false)),\n        indexing_active: Arc::new(AtomicBool::new(false)),\n        status: Arc::new(Mutex::new(IndexStatus::default())),\n        recent_ops: Arc::new(Mutex::new(Vec::new())),\n        icon_cache: Arc::new(Mutex::new(HashMap::new())),\n        fd_search_cache: Arc::new(Mutex::new(None)),\n        negative_name_cache: Arc::new(Mutex::new(HashMap::new())),\n        ignore_cache: Arc::new(Mutex::new(None)),\n        gitignore,\n        mem_index: Arc::new(RwLock::new(None)),\n        watcher_stop: Arc::new(AtomicBool::new(false)),\n        watcher_active: Arc::new(AtomicBool::new(false)),\n        frontend_ready: Arc::new(AtomicBool::new(false)),\n    };\n\n    eprintln!(\"[startup] +{}ms AppState created\", setup_started.elapsed().as_millis());\n    app.manage(state.clone());\n    if !bench_mode {\n        register_global_shortcut(&app.handle())?;\n    }\n    // Context menu item IDs use the \"ctx_\" prefix by convention.\n    // All matching IDs are forwarded as \"context_menu_action\" events to the frontend.\n    #[cfg(target_os = \"macos\")]\n    {\n        app.handle().on_menu_event(|app, event| {\n            let action = match event.id().as_ref() {\n                \"ctx_open\" => \"open\",\n                \"ctx_quick_look\" => \"quick_look\",\n                \"ctx_open_with\" => \"open_with\",\n                \"ctx_reveal\" => \"reveal\",\n                \"ctx_copy_files\" => \"copy_files\",\n                \"ctx_copy_path\" => \"copy_path\",\n                \"ctx_trash\" => \"trash\",\n                \"ctx_rename\" => \"rename\",\n                _ => return,\n            };\n            let _ = app.emit(\"context_menu_action\", action);\n        });\n    }\n    eprintln!(\"[startup] +{}ms global shortcut registered\", setup_started.elapsed().as_millis());\n    if bench_mode {\n        if let Some(window) = app.get_webview_window(\"main\") {\n            let _ = window.hide();\n        }\n    }\n\n    eprintln!(\"[startup] +{}ms setup_app() done, spawning init thread\", setup_started.elapsed().as_millis());\n\n    let app_handle = app.handle().clone();\n    std::thread::spawn(move || {\n        let thread_started = std::time::Instant::now();\n        eprintln!(\"[startup/thread] init thread started\");\n\n        eprintln!(\"[startup/thread] +{}ms calling init_db...\", thread_started.elapsed().as_millis());\n        if let Err(err) = init_db(&state.db_path) {\n            set_state(&state, IndexState::Error, Some(err.clone()));\n            emit_index_state(&app_handle, \"Error\", Some(err));\n            return;\n        }\n        eprintln!(\"[startup/thread] +{}ms init_db done\", thread_started.elapsed().as_millis());\n\n        state.db_ready.store(true, AtomicOrdering::Release);\n        eprintln!(\"[startup/thread] +{}ms db_ready=true -- launching indexing immediately\", thread_started.elapsed().as_millis());\n\n        // Deferred housekeeping -- purge + status counts run in background\n        {\n            let hk_app = app_handle.clone();\n            let hk_state = state.clone();\n            std::thread::spawn(move || {\n                // Brief pause so indexing thread can start first\n                std::thread::sleep(std::time::Duration::from_millis(500));\n                let hk_started = std::time::Instant::now();\n                let _ = refresh_and_emit_status_counts(&hk_app, &hk_state);\n                eprintln!(\"[startup/housekeeping] refresh_and_emit_status_counts done in {}ms\", hk_started.elapsed().as_millis());\n                // Wait for frontend readiness so initial paint and first input are not contended by purge I/O.\n                const FRONTEND_READY_TIMEOUT: Duration = Duration::from_secs(180);\n                const POST_READY_GRACE: Duration = Duration::from_secs(2);\n                let wait_started = std::time::Instant::now();\n                while !hk_state.frontend_ready.load(AtomicOrdering::Acquire)\n                    && wait_started.elapsed() < FRONTEND_READY_TIMEOUT\n                {\n                    std::thread::sleep(Duration::from_millis(50));\n                }\n                if hk_state.frontend_ready.load(AtomicOrdering::Acquire) {\n                    eprintln!(\n                        \"[startup/housekeeping] frontend_ready observed after {}ms; purging in {}ms\",\n                        wait_started.elapsed().as_millis(),\n                        POST_READY_GRACE.as_millis()\n                    );\n                } else {\n                    eprintln!(\n                        \"[startup/housekeeping] frontend_ready wait timed out after {}ms; proceeding with purge\",\n                        FRONTEND_READY_TIMEOUT.as_millis()\n                    );\n                }\n                std::thread::sleep(POST_READY_GRACE);\n                let purge_started = std::time::Instant::now();\n                if let Err(err) = purge_ignored_entries(&hk_state.db_path, &hk_state.path_ignores) {\n                    eprintln!(\"[startup/housekeeping] purge_ignored_entries failed: {err}\");\n                } else {\n                    eprintln!(\n                        \"[startup/housekeeping] purge_ignored_entries done in {}ms\",\n                        purge_started.elapsed().as_millis()\n                    );\n                }\n                eprintln!(\"[startup/housekeeping] all done in {}ms\", hk_started.elapsed().as_millis());\n            });\n        }\n\n        #[cfg(target_os = \"macos\")]\n        {\n            if bench_mode {\n                let _ = start_full_index_worker(app_handle.clone(), state.clone());\n            } else {\n                let (stored_event_id, index_complete) = db_connection(&state.db_path)\n                    .ok()\n                    .map(|c| {\n                        let eid = get_meta(&c, \"last_event_id\")\n                            .and_then(|v| v.parse::<u64>().ok());\n                        let complete = get_meta(&c, \"index_complete\")\n                            .map(|v| v == \"1\")\n                            .unwrap_or(false);\n                        (eid, complete)\n                    })\n                    .unwrap_or((None, false));\n\n                if stored_event_id.is_some() && index_complete {\n                    // Conditional startup: try watcher replay first, skip full scan if OK\n                    start_fsevent_watcher_worker(\n                        app_handle.clone(),\n                        state.clone(),\n                        stored_event_id,\n                        true,\n                    );\n                } else {\n                    if !index_complete {\n                        eprintln!(\"[mac] index incomplete; starting full index\");\n                    }\n                    let _ = start_full_index_worker(app_handle.clone(), state.clone());\n                    start_fsevent_watcher_worker(app_handle.clone(), state.clone(), None, false);\n                }\n            }\n        }\n\n        #[cfg(target_os = \"windows\")]\n        {\n            win::start_windows_indexing(app_handle.clone(), state.clone());\n        }\n\n        #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n        {\n            let _ = start_full_index_worker(app_handle.clone(), state.clone());\n        }\n\n        if bench_mode {\n            start_bench_runner(app_handle.clone(), state.clone());\n        }\n\n        #[cfg(not(target_os = \"windows\"))]\n        if !bench_mode {\n            let icon_cache = state.icon_cache.clone();\n            std::thread::spawn(move || {\n                let exts = [\n                    \"txt\", \"pdf\", \"png\", \"jpg\", \"md\", \"json\", \"swift\", \"rs\", \"js\", \"ts\", \"html\",\n                    \"css\", \"py\", \"zip\", \"dmg\", \"app\", \"doc\", \"xls\", \"ppt\", \"mov\",\n                ];\n                for ext in &exts {\n                    let key = ext.to_string();\n                    if icon_cache.lock().contains_key(&key) {\n                        continue;\n                    }\n                    if let Some(icon) = load_system_icon_png(ext) {\n                        icon_cache.lock().insert(key, icon);\n                    }\n                }\n            });\n        }\n    });\n\n    Ok(())\n}\n\n#[cfg_attr(mobile, tauri::mobile_entry_point)]\npub fn run() {\n    let _ = STARTUP_T0.set(Instant::now());\n    eprintln!(\"[startup +{}ms] run() entered\", startup_elapsed_ms());\n    #[cfg(target_os = \"windows\")]\n    if cfg!(debug_assertions) {\n        // Safety: called at program start before any threads are spawned.\n        // Will require `unsafe` block when migrating to Rust edition 2024.\n        std::env::set_var(\n            \"WEBVIEW2_ADDITIONAL_BROWSER_ARGUMENTS\",\n            \"--no-proxy-server --disable-http-cache --disk-cache-size=1 --media-cache-size=1\",\n        );\n        eprintln!(\n            \"[startup +{}ms] set REDACTED --disable-http-cache --disk-cache-size=1 --media-cache-size=1\",\n            startup_elapsed_ms()\n        );\n    }\n    let mut builder = tauri::Builder::default()\n        .plugin(tauri_plugin_decorum::init())\n        .plugin(tauri_plugin_drag::init())\n        .plugin(tauri_plugin_global_shortcut::Builder::new().build());\n\n    if !cfg!(debug_assertions) {\n        builder = builder.plugin(tauri_plugin_window_state::Builder::default().build());\n    } else {\n        eprintln!(\n            \"[startup +{}ms] debug mode: window-state plugin disabled for startup A/B test\",\n            startup_elapsed_ms()\n        );\n    }\n\n    builder\n        .on_page_load(|window, payload| {\n            eprintln!(\n                \"[startup/page +{}ms] on_page_load label={} event={:?} url={}\",\n                startup_elapsed_ms(),\n                window.label(),\n                payload.event(),\n                payload.url()\n            );\n        })\n        .setup(|app| {\n            setup_app(app).map_err(|e| {\n                Box::<dyn std::error::Error>::from(io::Error::new(io::ErrorKind::Other, e))\n            })\n        })\n        .invoke_handler(tauri::generate_handler![\n            get_index_status,\n            get_home_dir,\n            start_full_index,\n            reset_index,\n            search,\n            fd_search,\n            quick_look,\n            open,\n            open_with,\n            reveal_in_finder,\n            copy_paths,\n            copy_files,\n            move_to_trash,\n            rename,\n            get_file_icon,\n            get_platform,\n            show_context_menu,\n            set_native_theme,\n            frontend_log,\n            mark_frontend_ready\n        ])\n        .run(tauri::generate_context!())\n        .expect(\"error while running tauri application\");\n}\n\nfn main() {\n    run();\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::time::{SystemTime, UNIX_EPOCH};\n\n    fn mk_entry(path: &str, name: &str) -> EntryDto {\n        let parent = Path::new(path)\n            .parent()\n            .map(|p| p.to_string_lossy().to_string())\n            .unwrap_or_else(|| \"/\".to_string());\n        EntryDto {\n            path: path.to_string(),\n            name: name.to_string(),\n            dir: parent,\n            is_dir: false,\n            ext: None,\n            size: None,\n            mtime: None,\n        }\n    }\n\n    fn temp_case_dir(case: &str) -> PathBuf {\n        let stamp = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .map(|d| d.as_nanos())\n            .unwrap_or(0);\n        let base = if cfg!(target_os = \"windows\") {\n            std::env::current_dir()\n                .map(|dir| dir.join(\"tmp-test-dirs\"))\n                .unwrap_or_else(|_| std::env::temp_dir())\n        } else {\n            std::env::temp_dir()\n        };\n        base.join(format!(\n            \"everything_{case}_{}_{}\",\n            std::process::id(),\n            stamp\n        ))\n    }\n\n    fn test_state_for(db_path: PathBuf, home_dir: PathBuf, cwd: PathBuf) -> AppState {\n        AppState {\n            db_path,\n            home_dir: home_dir.clone(),\n            scan_root: home_dir.clone(),\n            cwd,\n            path_ignores: Arc::new(Vec::new()),\n            path_ignore_patterns: Arc::new(Vec::new()),\n            db_ready: Arc::new(AtomicBool::new(true)),\n            indexing_active: Arc::new(AtomicBool::new(false)),\n            status: Arc::new(Mutex::new(IndexStatus::default())),\n            recent_ops: Arc::new(Mutex::new(Vec::new())),\n            icon_cache: Arc::new(Mutex::new(HashMap::new())),\n            fd_search_cache: Arc::new(Mutex::new(None)),\n            negative_name_cache: Arc::new(Mutex::new(HashMap::new())),\n            ignore_cache: Arc::new(Mutex::new(None)),\n            gitignore: Arc::new(gitignore_filter::LazyGitignoreFilter::new(home_dir.clone())),\n            mem_index: Arc::new(RwLock::new(None)),\n            watcher_stop: Arc::new(AtomicBool::new(false)),\n            watcher_active: Arc::new(AtomicBool::new(false)),\n            frontend_ready: Arc::new(AtomicBool::new(true)),\n        }\n    }\n\n    #[test]\n    fn should_skip_path_for_ignored_descendant() {\n        let ignored = vec![PathBuf::from(\n            \"/Users/al02402336/Library/Developer/Xcode/DerivedData\",\n        )];\n        let target = Path::new(\n            \"REDACTED\",\n        );\n\n        assert!(should_skip_path(target, &ignored, &[]));\n    }\n\n    #[test]\n    fn filter_ignored_entries_removes_pathignore_matches() {\n        let ignored = vec![PathBuf::from(\n            \"/Users/al02402336/Library/Developer/Xcode/DerivedData\",\n        )];\n        let entries = vec![\n            mk_entry(\n                \"REDACTED\",\n                \"-Users-al02402336-a_desktop\",\n            ),\n            mk_entry(\"/Users/al02402336/a_desktop\", \"a_desktop\"),\n        ];\n\n        let filtered = filter_ignored_entries(entries, &ignored, &[]);\n\n        assert_eq!(filtered.len(), 1);\n        assert_eq!(filtered[0].path, \"/Users/al02402336/a_desktop\");\n    }\n\n    #[test]\n    fn should_skip_path_for_glob_any_segment_target() {\n        let patterns = vec![IgnorePattern::AnySegment(\"target\".to_string())];\n\n        assert!(should_skip_path(\n            Path::new(\"/Users/al02402336/work/rust/target\"),\n            &[],\n            &patterns\n        ));\n        assert!(should_skip_path(\n            Path::new(\"/Users/al02402336/work/rust/target/debug/deps/foo.o\"),\n            &[],\n            &patterns\n        ));\n        assert!(!should_skip_path(\n            Path::new(\"/Users/al02402336/work/rust/targets/debug/deps/foo.o\"),\n            &[],\n            &patterns\n        ));\n    }\n\n    #[test]\n    fn relevance_sort_prefers_shallow_exact_match() {\n        let mut entries = vec![\n            mk_entry(\"/Users/al02402336/work/a_desktop\", \"a_desktop\"),\n            mk_entry(\"/Users/al02402336/a_desktop\", \"a_desktop\"),\n            mk_entry(\n                \"/Users/al02402336/Library/Developer/Xcode/DerivedData/-Users-al02402336-a_desktop\",\n                \"-Users-al02402336-a_desktop\",\n            ),\n        ];\n\n        sort_entries_with_relevance(&mut entries, \"a_desktop\", \"name\", \"asc\");\n\n        assert_eq!(entries[0].path, \"/Users/al02402336/a_desktop\");\n    }\n\n    #[test]\n    fn resolved_dir_range_excludes_sibling_with_same_prefix() {\n        let dir_exact = \"/Users/user/Projects\";\n        let dir_prefix = format!(\"{}/\", dir_exact);\n        let dir_prefix_end = format!(\"{}0\", dir_exact);\n\n        let in_scope = |dir: &str| {\n            dir == dir_exact || (dir >= dir_prefix.as_str() && dir < dir_prefix_end.as_str())\n        };\n\n        assert!(in_scope(\"/Users/user/Projects\"));\n        assert!(in_scope(\"/Users/user/Projects/src\"));\n        assert!(in_scope(\"/Users/user/Projects/src/deeper\"));\n\n        assert!(!in_scope(\"/Users/user/Projects-archived\"));\n        assert!(!in_scope(\"/Users/user/Projects.archived\"));\n        assert!(!in_scope(\"/Users/user/Projects_archived\"));\n        assert!(!in_scope(\"/Users/user/Projectz\"));\n    }\n\n    #[test]\n    fn delete_paths_root_clears_all_entries() {\n        let root = temp_case_dir(\"delete_paths_root\");\n        let dir_a = root.join(\"alpha\");\n        let dir_b = root.join(\"beta\").join(\"nested\");\n        fs::create_dir_all(&dir_a).unwrap();\n        fs::create_dir_all(&dir_b).unwrap();\n\n        let db_path = root.join(\"index.db\");\n        init_db(&db_path).unwrap();\n        let mut conn = db_connection(&db_path).unwrap();\n        let now = now_epoch();\n\n        for (path, name, dir, ext) in [\n            (dir_a.join(\"a.txt\"), \"a.txt\", dir_a.clone(), \"txt\"),\n            (dir_b.join(\"b.rs\"), \"b.rs\", dir_b.clone(), \"rs\"),\n        ] {\n            conn.execute(\n                \"INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n                 VALUES(?1, ?2, ?3, 0, ?4, NULL, NULL, ?5, 1)\",\n                params![\n                    path.to_string_lossy().to_string(),\n                    name,\n                    dir.to_string_lossy().to_string(),\n                    ext,\n                    now\n                ],\n            )\n            .unwrap();\n        }\n\n        let deleted = delete_paths(&mut conn, &[\"/\".to_string()]).unwrap();\n        assert!(deleted >= 2);\n\n        let remaining: i64 = conn\n            .query_row(\"SELECT COUNT(*) FROM entries\", [], |row| row.get(0))\n            .unwrap();\n        assert_eq!(remaining, 0);\n\n        let _ = fs::remove_dir_all(root);\n    }\n\n    #[test]\n    fn execute_search_resolved_path_does_not_include_prefixed_sibling_dirs() {\n        let root = temp_case_dir(\"resolved_path_scope_execute\");\n        let projects_src = root.join(\"Projects\").join(\"src\");\n        let archived_src = root.join(\"Projects-archived\").join(\"src\");\n        fs::create_dir_all(&projects_src).unwrap();\n        fs::create_dir_all(&archived_src).unwrap();\n\n        let db_path = root.join(\"index.db\");\n        init_db(&db_path).unwrap();\n        let conn = db_connection(&db_path).unwrap();\n        let now = now_epoch();\n\n        let project_path = projects_src.join(\"main.rs\");\n        let archived_path = archived_src.join(\"legacy.rs\");\n\n        conn.execute(\n            \"INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n             VALUES(?1, ?2, ?3, 0, ?4, NULL, NULL, ?5, 1)\",\n            params![\n                project_path.to_string_lossy().to_string(),\n                \"main.rs\",\n                projects_src.to_string_lossy().to_string(),\n                \"rs\",\n                now\n            ],\n        )\n        .unwrap();\n\n        conn.execute(\n            \"INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n             VALUES(?1, ?2, ?3, 0, ?4, NULL, NULL, ?5, 1)\",\n            params![\n                archived_path.to_string_lossy().to_string(),\n                \"legacy.rs\",\n                archived_src.to_string_lossy().to_string(),\n                \"rs\",\n                now\n            ],\n        )\n        .unwrap();\n\n        let state = test_state_for(db_path.clone(), root.clone(), root.clone());\n        let result = execute_search(\n            &state,\n            \"Projects/ *.rs\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        assert!(result\n            .results\n            .iter()\n            .any(|entry| entry.path == project_path.to_string_lossy()));\n        assert!(result\n            .results\n            .iter()\n            .all(|entry| !entry.path.contains(\"Projects-archived\")));\n\n        let _ = fs::remove_dir_all(root);\n    }\n\n    #[test]\n    fn find_file_upward_locates_repo_level_pathignore() {\n        let root = temp_case_dir(\"pathignore_upward\");\n        let nested = root.join(\"src-tauri\").join(\"target\");\n        fs::create_dir_all(&nested).unwrap();\n        fs::write(root.join(\".pathignore\"), \"node_modules\\n\").unwrap();\n\n        let found = find_file_upward(&nested, \".pathignore\");\n        assert_eq!(found, Some(root.join(\".pathignore\")));\n\n        let _ = fs::remove_dir_all(root);\n    }\n\n    #[test]\n    fn find_git_root_works_from_nested_directory() {\n        let root = temp_case_dir(\"git_root\");\n        let nested = root.join(\"src-tauri\").join(\"target\");\n        fs::create_dir_all(&nested).unwrap();\n        fs::create_dir_all(root.join(\".git\")).unwrap();\n\n        let found = find_git_root(&nested);\n        assert_eq!(found, Some(root.clone()));\n\n        let _ = fs::remove_dir_all(root);\n    }\n\n    #[test]\n    fn extract_ext_from_like_rejects_multi_dot() {\n        assert_eq!(extract_ext_from_like(\"%.tar.gz\"), None);\n        assert_eq!(extract_ext_from_like(\"%.d.ts\"), None);\n        assert_eq!(extract_ext_from_like(\"%.rs\"), Some(\"rs\".to_string()));\n        assert_eq!(extract_ext_from_like(\"%.png\"), Some(\"png\".to_string()));\n    }\n\n    #[test]\n    fn negative_cache_fallback_removes_matched_key_not_query() {\n        let state = test_state_for(\n            PathBuf::from(\"/tmp/neg_cache_test.db\"),\n            PathBuf::from(\"/tmp\"),\n            PathBuf::from(\"/tmp\"),\n        );\n\n        remember_negative_name_query(&state, \"abc\");\n\n        let hit = negative_name_cache_lookup(&state, \"xabc\");\n        assert!(hit.is_some());\n        assert_eq!(hit.unwrap().query_lower, \"abc\");\n\n        remove_negative_name_query(&state, \"abc\");\n\n        let hit_after = negative_name_cache_lookup(&state, \"xabc\");\n        assert!(hit_after.is_none());\n    }\n\n    #[test]\n    fn dir_listing_deep_nested_path_without_time_budget() {\n        let root = temp_case_dir(\"dir_listing_deep\");\n        // Simulate: ~/Library/Containers/jp.naver.line.mac/Data/Library/Containers/jp.naver.line/log/\n        let deep_dir = root\n            .join(\"Library\")\n            .join(\"Containers\")\n            .join(\"jp.naver.line.mac\")\n            .join(\"Data\")\n            .join(\"Library\")\n            .join(\"Containers\")\n            .join(\"jp.naver.line\")\n            .join(\"log\");\n        let sub_dir = deep_dir.join(\"archive\");\n        fs::create_dir_all(&deep_dir).unwrap();\n        fs::create_dir_all(&sub_dir).unwrap();\n\n        let db_path = root.join(\"index.db\");\n        init_db(&db_path).unwrap();\n        let conn = db_connection(&db_path).unwrap();\n        let now = now_epoch();\n\n        let file1 = deep_dir.join(\"20260211_14.txt\");\n        let file2 = sub_dir.join(\"old.log\");\n        for (path, name, dir, ext) in [\n            (&file1, \"20260211_14.txt\", &deep_dir, \"txt\"),\n            (&file2, \"old.log\", &sub_dir, \"log\"),\n        ] {\n            conn.execute(\n                \"INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n                 VALUES(?1, ?2, ?3, 0, ?4, NULL, NULL, ?5, 1)\",\n                params![\n                    path.to_string_lossy().to_string(),\n                    name,\n                    dir.to_string_lossy().to_string(),\n                    ext,\n                    now\n                ],\n            )\n            .unwrap();\n        }\n\n        let state = test_state_for(db_path, root.clone(), root.clone());\n\n        // Query: \"jp.naver.line/log/\" - dir listing, name_like = \"%\"\n        let result = execute_search(\n            &state,\n            \"jp.naver.line/log/\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        assert_eq!(\n            result.results.len(),\n            2,\n            \"should find both files under log/ and log/archive/\"\n        );\n        let names: Vec<&str> = result.results.iter().map(|e| e.name.as_str()).collect();\n        assert!(names.contains(&\"20260211_14.txt\"));\n        assert!(names.contains(&\"old.log\"));\n\n        // Query with glob: \"jp.naver.line/log/ *\"\n        let result2 = execute_search(\n            &state,\n            \"jp.naver.line/log/ *\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        assert_eq!(\n            result2.results.len(),\n            2,\n            \"glob * should also list all files\"\n        );\n\n        // Query with trailing dot: \"jp.naver.line/log/ *.\" - name_like becomes \"%.\"\n        let result3 = execute_search(\n            &state,\n            \"jp.naver.line/log/ *.\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        // \"*.\" matches files ending with \".\" - none of our test files end with \".\"\n        // so this correctly returns 0 (this is expected, NOT a bug)\n        assert_eq!(\n            result3.results.len(),\n            0,\n            \"*. matches only files ending with dot\"\n        );\n\n        // But plain \"/\" at end should list all\n        let result4 = execute_search(\n            &state,\n            \"jp.naver.line/log/\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        assert_eq!(\n            result4.results.len(),\n            2,\n            \"trailing slash should list all files\"\n        );\n\n        let _ = fs::remove_dir_all(root);\n    }\n\n    #[test]\n    fn path_search_multi_dot_ext_uses_like_not_ext_shortcut() {\n        let root = temp_case_dir(\"multi_dot_ext\");\n        let proj_dir = root.join(\"Projects\");\n        fs::create_dir_all(&proj_dir).unwrap();\n\n        let db_path = root.join(\"index.db\");\n        init_db(&db_path).unwrap();\n        let conn = db_connection(&db_path).unwrap();\n        let now = now_epoch();\n\n        let file_path = proj_dir.join(\"archive.tar.gz\");\n        conn.execute(\n            \"INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n             VALUES(?1, ?2, ?3, 0, ?4, NULL, NULL, ?5, 1)\",\n            params![\n                file_path.to_string_lossy().to_string(),\n                \"archive.tar.gz\",\n                proj_dir.to_string_lossy().to_string(),\n                \"gz\",\n                now\n            ],\n        )\n        .unwrap();\n\n        let state = test_state_for(db_path, root.clone(), root.clone());\n        let result = execute_search(\n            &state,\n            \"Projects/ *.tar.gz\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        assert_eq!(result.results.len(), 1);\n        assert!(result.results[0].name == \"archive.tar.gz\");\n\n        let _ = fs::remove_dir_all(root);\n    }\n}\n","structuredPatch":[{"oldStart":2086,"oldLines":12,"newStart":2086,"newLines":16,"lines":["     // Fresh index: DB was empty, skip preload/stamp, single unlimited-depth pass","     let is_fresh = last_run_id == 0;"," ","+    // Fresh index has no secondary indexes to maintain, so we can use larger","+    // batches to reduce transaction overhead (fewer commits = faster).","+    let flush_batch_size = if is_fresh { BATCH_SIZE * 5 } else { BATCH_SIZE };","+","     let mut scanned: u64 = 0;","     let mut indexed: u64 = 0;","     let mut permission_errors: u64 = 0;","     let mut current_path = String::new();","-    let mut batch: Vec<IndexRow> = Vec::with_capacity(BATCH_SIZE);","-    let mut stamp_batch: Vec<String> = Vec::with_capacity(BATCH_SIZE);","+    let mut batch: Vec<IndexRow> = Vec::with_capacity(flush_batch_size);","+    let mut stamp_batch: Vec<String> = Vec::with_capacity(flush_batch_size);","     let mut last_emit = Instant::now();","     let mut last_perf_emit = Instant::now();"," "]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"0954ab97-68a4-4e61-8cad-76f773e1bad1"}
{"parentUuid":"c6f14f34-4d9b-4c10-ad2a-6d02d2fb1554","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01GoMA4FAHDLUAVHHDq9HMdt","type":"message","role":"assistant","content":[{"type":"text","text":"ì´ì œ ë°°ì¹˜ í¬ê¸° ë¹„êµì— `flush_batch_size` ë¥¼ ì‚¬ìš©í•˜ë„ë¡ êµì²´í•©ë‹ˆë‹¤."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":429,"cache_read_input_tokens":155876,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":429},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNirZEXjM7vL6Ub8hNyh","type":"assistant","uuid":"2a263b3b-66cc-485d-aed4-54beeffab3a6","timestamp":"2026-02-22T07:35:34.505Z"}
{"parentUuid":"2a263b3b-66cc-485d-aed4-54beeffab3a6","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01GoMA4FAHDLUAVHHDq9HMdt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0152L5xBtbzyCUx2wWGUD1B4","name":"Read","input":{"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","offset":2155,"limit":8},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":429,"cache_read_input_tokens":155876,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":429},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNirZEXjM7vL6Ub8hNyh","type":"assistant","uuid":"0ca27d4c-3c93-46b8-b57d-9f7f2b1a9fc2","timestamp":"2026-02-22T07:35:35.107Z"}
{"parentUuid":"0ca27d4c-3c93-46b8-b57d-9f7f2b1a9fc2","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_0152L5xBtbzyCUx2wWGUD1B4","toolUseID":"toolu_0152L5xBtbzyCUx2wWGUD1B4","timestamp":"2026-02-22T07:35:35.118Z","uuid":"f31ddb51-d384-4764-a05c-d6c5259bcbf8"}
{"parentUuid":"0ca27d4c-3c93-46b8-b57d-9f7f2b1a9fc2","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0152L5xBtbzyCUx2wWGUD1B4","type":"tool_result","content":"  2155â†’            if child_path.is_dir() {\n  2156â†’                if is_deferred_dir(&child_path, &state.scan_root) {\n  2157â†’                    deferred_roots.push(child_path);\n  2158â†’                } else {\n  2159â†’                    priority_roots.push(child_path);\n  2160â†’                }\n  2161â†’            }\n  2162â†’        }\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"11c3f98a-fe5a-4100-9d60-46cb33a9b8ab","timestamp":"2026-02-22T07:35:35.117Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src-tauri/src/main.rs","content":"            if child_path.is_dir() {\n                if is_deferred_dir(&child_path, &state.scan_root) {\n                    deferred_roots.push(child_path);\n                } else {\n                    priority_roots.push(child_path);\n                }\n            }\n        }","numLines":8,"startLine":2155,"totalLines":5786}},"sourceToolAssistantUUID":"0ca27d4c-3c93-46b8-b57d-9f7f2b1a9fc2"}
{"parentUuid":"11c3f98a-fe5a-4100-9d60-46cb33a9b8ab","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01TE1t4nDwPR1rt93SgimHJm","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TYpq8JT3H2qcHw4SuAyec2","name":"Read","input":{"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","offset":2163,"limit":6},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":341,"cache_read_input_tokens":156305,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":341},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNirmpKaMGeACVqaSrcF","type":"assistant","uuid":"1c0aed57-c889-4875-8eb9-a963472cc8ad","timestamp":"2026-02-22T07:35:37.246Z"}
{"parentUuid":"1c0aed57-c889-4875-8eb9-a963472cc8ad","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01TYpq8JT3H2qcHw4SuAyec2","toolUseID":"toolu_01TYpq8JT3H2qcHw4SuAyec2","timestamp":"2026-02-22T07:35:37.296Z","uuid":"6877515c-26b1-4657-83cf-bb7461e58172"}
{"parentUuid":"1c0aed57-c889-4875-8eb9-a963472cc8ad","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TYpq8JT3H2qcHw4SuAyec2","type":"tool_result","content":"  2163â†’    }\n  2164â†’\n  2165â†’\n  2166â†’    // Flush home-level stamp batch\n  2167â†’    if stamp_batch.len() >= BATCH_SIZE {\n  2168â†’        stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"05bc54e1-26cd-4195-a8b2-0ea764a5b120","timestamp":"2026-02-22T07:35:37.295Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src-tauri/src/main.rs","content":"    }\n\n\n    // Flush home-level stamp batch\n    if stamp_batch.len() >= BATCH_SIZE {\n        stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;","numLines":6,"startLine":2163,"totalLines":5786}},"sourceToolAssistantUUID":"1c0aed57-c889-4875-8eb9-a963472cc8ad"}
{"parentUuid":"05bc54e1-26cd-4195-a8b2-0ea764a5b120","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01FpsgYPFEyJMyw8ECVzvG1U","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011PzBKxy2on745S7zxvR2Jw","name":"Bash","input":{"command":"grep -n \"BATCH_SIZE\" /Users/al02402336/everything/src-tauri/src/main.rs | grep -v \"^42:\\|pub(crate)\"","description":"Find all BATCH_SIZE usages in the indexer"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":276,"cache_read_input_tokens":156646,"output_tokens":122,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":276,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYNirvhs89JJ8AgXYaPTy","type":"assistant","uuid":"51345c10-ee5a-405c-96e0-c4a3642300e6","timestamp":"2026-02-22T07:35:40.271Z"}
{"parentUuid":"51345c10-ee5a-405c-96e0-c4a3642300e6","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011PzBKxy2on745S7zxvR2Jw","type":"tool_result","content":"2091:    let flush_batch_size = if is_fresh { BATCH_SIZE * 5 } else { BATCH_SIZE };\n2167:    if stamp_batch.len() >= BATCH_SIZE {\n2282:                        if batch.len() >= BATCH_SIZE {\n2287:                        if stamp_batch.len() >= BATCH_SIZE {\n4309:            for chunk in rows.chunks(BATCH_SIZE) {","is_error":false}]},"uuid":"ccd21e16-6672-40b6-aadc-4b2300ae15f1","timestamp":"2026-02-22T07:35:40.386Z","toolUseResult":{"stdout":"2091:    let flush_batch_size = if is_fresh { BATCH_SIZE * 5 } else { BATCH_SIZE };\n2167:    if stamp_batch.len() >= BATCH_SIZE {\n2282:                        if batch.len() >= BATCH_SIZE {\n2287:                        if stamp_batch.len() >= BATCH_SIZE {\n4309:            for chunk in rows.chunks(BATCH_SIZE) {","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"51345c10-ee5a-405c-96e0-c4a3642300e6"}
{"parentUuid":"ccd21e16-6672-40b6-aadc-4b2300ae15f1","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_017AgTD1DANjyrtWJ2HsThfG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015QdaQam5dLEACz2omFCwuu","name":"Edit","input":{"replace_all":false,"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","old_string":"    // Flush home-level stamp batch\n    if stamp_batch.len() >= BATCH_SIZE {","new_string":"    // Flush home-level stamp batch\n    if stamp_batch.len() >= flush_batch_size {"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":238,"cache_read_input_tokens":156922,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":238},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNisACiTaJQL9afaZMdd","type":"assistant","uuid":"73e278b6-3e62-4ca6-af97-0bfa4899dcd4","timestamp":"2026-02-22T07:35:43.203Z"}
{"parentUuid":"73e278b6-3e62-4ca6-af97-0bfa4899dcd4","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>File has not been read yet. Read it first before writing to it.</tool_use_error>","is_error":true,"tool_use_id":"toolu_015QdaQam5dLEACz2omFCwuu"}]},"uuid":"03bfc4ec-8bd0-4ae7-a794-7a564e7bab9d","timestamp":"2026-02-22T07:35:43.204Z","toolUseResult":"Error: File has not been read yet. Read it first before writing to it.","sourceToolAssistantUUID":"73e278b6-3e62-4ca6-af97-0bfa4899dcd4"}
{"parentUuid":"03bfc4ec-8bd0-4ae7-a794-7a564e7bab9d","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_015wJJNNuKsopoegWwVgWvPm","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UT8T78ZXboMuhaRy8A2rnv","name":"Read","input":{"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","offset":2166,"limit":4},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":222,"cache_read_input_tokens":157160,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":222},"output_tokens":18,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNisNYd1DyWVtCe7a7hi","type":"assistant","uuid":"0b031319-37bc-4b15-a09d-ee2efe9b2058","timestamp":"2026-02-22T07:35:45.493Z"}
{"parentUuid":"0b031319-37bc-4b15-a09d-ee2efe9b2058","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01UT8T78ZXboMuhaRy8A2rnv","toolUseID":"toolu_01UT8T78ZXboMuhaRy8A2rnv","timestamp":"2026-02-22T07:35:45.502Z","uuid":"34eac55a-4b69-46a5-88a2-8a02cdd93f42"}
{"parentUuid":"0b031319-37bc-4b15-a09d-ee2efe9b2058","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UT8T78ZXboMuhaRy8A2rnv","type":"tool_result","content":"  2166â†’    // Flush home-level stamp batch\n  2167â†’    if stamp_batch.len() >= BATCH_SIZE {\n  2168â†’        stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n  2169â†’        stamp_batch.clear();\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"c62f44ec-20bd-4787-9d50-a5366515c5b5","timestamp":"2026-02-22T07:35:45.501Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src-tauri/src/main.rs","content":"    // Flush home-level stamp batch\n    if stamp_batch.len() >= BATCH_SIZE {\n        stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n        stamp_batch.clear();","numLines":4,"startLine":2166,"totalLines":5786}},"sourceToolAssistantUUID":"0b031319-37bc-4b15-a09d-ee2efe9b2058"}
{"parentUuid":"c62f44ec-20bd-4787-9d50-a5366515c5b5","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01KbXpWy9NU3CKGkd6inRFGg","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LJ6dJ1bw4kWS5wdhWCrBLr","name":"Edit","input":{"replace_all":false,"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","old_string":"    // Flush home-level stamp batch\n    if stamp_batch.len() >= BATCH_SIZE {\n        stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;","new_string":"    // Flush home-level stamp batch\n    if stamp_batch.len() >= flush_batch_size {\n        stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":271,"cache_read_input_tokens":157382,"output_tokens":222,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":271,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYNisYJWGFzLLQ3VWqxhN","type":"assistant","uuid":"08c5e6b0-d6d2-448e-9878-fbaa23c57109","timestamp":"2026-02-22T07:35:48.442Z"}
{"parentUuid":"08c5e6b0-d6d2-448e-9878-fbaa23c57109","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01LJ6dJ1bw4kWS5wdhWCrBLr","toolUseID":"toolu_01LJ6dJ1bw4kWS5wdhWCrBLr","timestamp":"2026-02-22T07:35:48.453Z","uuid":"18e56eca-8335-4429-8fd9-2452db23f16d"}
{"parentUuid":"08c5e6b0-d6d2-448e-9878-fbaa23c57109","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LJ6dJ1bw4kWS5wdhWCrBLr","type":"tool_result","content":"The file /Users/al02402336/everything/src-tauri/src/main.rs has been updated successfully."}]},"uuid":"22702c79-431d-4449-bdd7-e19a28634fdf","timestamp":"2026-02-22T07:35:48.452Z","toolUseResult":{"filePath":"/Users/al02402336/everything/src-tauri/src/main.rs","oldString":"    // Flush home-level stamp batch\n    if stamp_batch.len() >= BATCH_SIZE {\n        stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;","newString":"    // Flush home-level stamp batch\n    if stamp_batch.len() >= flush_batch_size {\n        stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;","originalFile":"#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\n\nuse std::{\n    cmp::Ordering,\n    collections::{HashMap, HashSet},\n    fs,\n    hash::{Hash, Hasher},\n    io::{self, BufRead, BufReader, Write},\n    path::{Path, PathBuf},\n    process::{Command, Stdio},\n    sync::{\n        atomic::{AtomicBool, Ordering as AtomicOrdering},\n        Arc, OnceLock,\n    },\n    time::{Duration, Instant, SystemTime, UNIX_EPOCH},\n};\n\nuse parking_lot::{Mutex, RwLock};\nuse rusqlite::{params, params_from_iter, types::Value as SqlValue, Connection};\nuse serde::Serialize;\nuse tauri::{AppHandle, Emitter, Manager, State};\n#[cfg(target_os = \"macos\")]\nuse tauri_plugin_global_shortcut::{Code, GlobalShortcutExt, Modifiers, Shortcut};\n#[cfg(target_os = \"windows\")]\nuse std::os::windows::process::CommandExt;\nuse walkdir::WalkDir;\n\nmod fd_search;\nmod gitignore_filter;\n#[cfg(target_os = \"macos\")]\nmod mac;\nmod mem_search;\nmod query;\n#[cfg(target_os = \"windows\")]\nmod win;\nuse fd_search::{FdSearchCache, FdSearchResultDto};\nuse query::{escape_like, parse_query, SearchMode};\n\nconst DEFAULT_LIMIT: u32 = 300;\nconst SHORT_QUERY_LIMIT: u32 = 100;\nconst MAX_LIMIT: u32 = 1000;\npub(crate) const BATCH_SIZE: usize = 10_000;\nconst RECENT_OP_TTL: Duration = Duration::from_secs(2);\npub(crate) const WATCH_DEBOUNCE: Duration = Duration::from_millis(300);\nconst NEGATIVE_CACHE_TTL: Duration = Duration::from_secs(60);\nconst NEGATIVE_CACHE_FALLBACK_WINDOW: Duration = Duration::from_millis(550);\nconst DB_VERSION: i32 = 4;\nconst DEFERRED_DIR_NAMES: &[&str] = &[\n    \"Library\", \".Trash\", \".Trashes\",\n    // Windows system directories (deferred when scan_root is C:\\)\n    \"Windows\", \"Program Files\", \"Program Files (x86)\",\n    \"$Recycle.Bin\", \"System Volume Information\", \"Recovery\", \"PerfLogs\",\n];\nconst SHALLOW_SCAN_DEPTH: usize = 6;\nfn jwalk_num_threads() -> usize {\n    std::thread::available_parallelism()\n        .map(|n| (n.get() / 2).max(4).min(16))\n        .unwrap_or(8)\n}\n\npub(crate) const BUILTIN_SKIP_NAMES: &[&str] = &[\n    \".git\",\n    \"node_modules\",\n    \".Trash\",\n    \".Trashes\",\n    \".npm\",\n    \".cache\",\n    \"CMakeFiles\",\n    \".qtc_clangd\",\n    \"__pycache__\",\n    \".gradle\",\n    \"DerivedData\",\n];\n\n/// Path segments whose name ends with one of these suffixes are skipped.\n/// e.g. \"*.build\" skips Xcode intermediate build directories like \"MyApp.build\".\npub(crate) const BUILTIN_SKIP_SUFFIXES: &[&str] = &[\n    \".build\", // Xcode intermediate build dir (MyApp.build, Objects-normal, etc.)\n];\n\npub(crate) const BUILTIN_SKIP_PATHS: &[&str] = &[\n    // macOS\n    \"Library/Caches\",\n    \"Library/Developer/CoreSimulator\",\n    \"Library/Logs\",\n    // Cross-platform\n    \".vscode/extensions\",\n    // Windows: noisy system directories under AppData\n    \"AppData/Local/Temp\",\n    \"AppData/Local/Microsoft\",\n    \"AppData/Local/Google\",\n    \"AppData/Local/Packages\",\n];\n\ntype AppResult<T> = Result<T, String>;\nstatic SEARCH_LOG_ENABLED: OnceLock<bool> = OnceLock::new();\nstatic PERF_LOG_ENABLED: OnceLock<bool> = OnceLock::new();\nstatic BENCH_MODE_ENABLED: OnceLock<bool> = OnceLock::new();\nstatic STARTUP_T0: OnceLock<Instant> = OnceLock::new();\n\nfn startup_elapsed_ms() -> u128 {\n    STARTUP_T0\n        .get()\n        .map(|started| started.elapsed().as_millis())\n        .unwrap_or(0)\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct EntryDto {\n    pub path: String,\n    pub name: String,\n    pub dir: String,\n    pub is_dir: bool,\n    pub ext: Option<String>,\n    pub size: Option<i64>,\n    pub mtime: Option<i64>,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct IndexStatusDto {\n    state: String,\n    entries_count: u64,\n    last_updated: Option<i64>,\n    permission_errors: u64,\n    message: Option<String>,\n    scanned: u64,\n    indexed: u64,\n    current_path: String,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct IndexProgressEvent {\n    scanned: u64,\n    indexed: u64,\n    current_path: String,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct IndexStateEvent {\n    state: String,\n    message: Option<String>,\n    is_catchup: bool,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct IndexUpdatedEvent {\n    entries_count: u64,\n    last_updated: i64,\n    permission_errors: u64,\n}\n\n#[derive(Debug, Clone)]\nstruct SearchExecution {\n    query: String,\n    sort_by: String,\n    sort_dir: String,\n    effective_limit: u32,\n    offset: u32,\n    mode_label: String,\n    results: Vec<EntryDto>,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct SearchResultDto {\n    entries: Vec<EntryDto>,\n    mode_label: String,\n    /// Total number of results matching the query (ignoring LIMIT/OFFSET).\n    total_count: u32,\n    /// True when total_count is exact. False means frontend should treat it as unknown.\n    total_known: bool,\n}\n\n#[allow(dead_code)]\n#[derive(Debug, Clone)]\nstruct BenchCase {\n    id: &'static str,\n    query: &'static str,\n    sort_by: &'static str,\n    sort_dir: &'static str,\n    limit: u32,\n    offset: u32,\n    expected_min_results: usize,\n}\n\n#[allow(dead_code)]\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct BenchCaseResult {\n    id: String,\n    query: String,\n    mode: String,\n    sort_by: String,\n    sort_dir: String,\n    limit: u32,\n    offset: u32,\n    elapsed_ms: f64,\n    result_count: usize,\n    expected_min_results: usize,\n    passed: bool,\n    top_results: Vec<String>,\n    error: Option<String>,\n}\n\n#[allow(dead_code)]\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct BenchReport {\n    run_label: String,\n    started_at: i64,\n    completed_at: i64,\n    home_dir: String,\n    db_path: String,\n    index_wait_ms: u128,\n    index_scanned: u64,\n    index_indexed: u64,\n    index_entries_count: u64,\n    index_permission_errors: u64,\n    index_message: Option<String>,\n    search_iterations: u32,\n    search_results: Vec<BenchCaseResult>,\n}\n\n#[derive(Debug, Clone)]\npub(crate) enum IndexState {\n    Ready,\n    Indexing,\n    Error,\n}\n\nimpl IndexState {\n    fn as_str(&self) -> &'static str {\n        match self {\n            Self::Ready => \"Ready\",\n            Self::Indexing => \"Indexing\",\n            Self::Error => \"Error\",\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct IndexStatus {\n    pub(crate) state: IndexState,\n    pub(crate) entries_count: u64,\n    pub(crate) last_updated: Option<i64>,\n    pub(crate) permission_errors: u64,\n    pub(crate) message: Option<String>,\n    pub(crate) scanned: u64,\n    pub(crate) indexed: u64,\n    pub(crate) current_path: String,\n}\n\nimpl Default for IndexStatus {\n    fn default() -> Self {\n        Self {\n            state: IndexState::Indexing,\n            entries_count: 0,\n            last_updated: None,\n            permission_errors: 0,\n            message: None,\n            scanned: 0,\n            indexed: 0,\n            current_path: String::new(),\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\n#[allow(dead_code)]\npub(crate) struct RecentOp {\n    old_path: Option<String>,\n    new_path: Option<String>,\n    op_type: &'static str,\n    at: Instant,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub(crate) enum IgnorePattern {\n    AnySegment(String),\n    Glob(String),\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct IgnoreRulesCache {\n    roots: Vec<PathBuf>,\n    patterns: Vec<IgnorePattern>,\n    pathignore_mtime: Option<SystemTime>,\n    gitignore_mtime: Option<SystemTime>,\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct AppState {\n    pub(crate) db_path: PathBuf,\n    pub(crate) home_dir: PathBuf,\n    pub(crate) scan_root: PathBuf,\n    pub(crate) cwd: PathBuf,\n    pub(crate) path_ignores: Arc<Vec<PathBuf>>,\n    pub(crate) path_ignore_patterns: Arc<Vec<IgnorePattern>>,\n    pub(crate) db_ready: Arc<AtomicBool>,\n    pub(crate) indexing_active: Arc<AtomicBool>,\n    pub(crate) status: Arc<Mutex<IndexStatus>>,\n    pub(crate) recent_ops: Arc<Mutex<Vec<RecentOp>>>,\n    pub(crate) icon_cache: Arc<Mutex<HashMap<String, Vec<u8>>>>,\n    pub(crate) fd_search_cache: Arc<Mutex<Option<FdSearchCache>>>,\n    pub(crate) negative_name_cache: Arc<Mutex<HashMap<String, NegativeNameEntry>>>,\n    pub(crate) ignore_cache: Arc<Mutex<Option<IgnoreRulesCache>>>,\n    pub(crate) gitignore: Arc<gitignore_filter::LazyGitignoreFilter>,\n    /// In-memory index for instant search while DB upsert runs in background.\n    /// Set by MFT scan, cleared after background DB upsert completes.\n    pub(crate) mem_index: Arc<RwLock<Option<Arc<mem_search::MemIndex>>>>,\n    /// Signal to stop the file watcher (RDCW / USN). Set to true on reset_index.\n    pub(crate) watcher_stop: Arc<AtomicBool>,\n    /// Set to true while a file watcher event loop is running.\n    pub(crate) watcher_active: Arc<AtomicBool>,\n    /// Set to true once frontend onMount has completed enough to accept user input.\n    pub(crate) frontend_ready: Arc<AtomicBool>,\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct NegativeNameEntry {\n    created_at: Instant,\n    fallback_checked: bool,\n}\n\n#[derive(Debug, Clone)]\nstruct NegativeCacheHit {\n    query_lower: String,\n    age: Duration,\n    fallback_checked: bool,\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct IndexRow {\n    pub(crate) path: String,\n    pub(crate) name: String,\n    pub(crate) dir: String,\n    pub(crate) is_dir: i64,\n    pub(crate) ext: Option<String>,\n    pub(crate) mtime: Option<i64>,\n    pub(crate) size: Option<i64>,\n    pub(crate) indexed_at: i64,\n    pub(crate) run_id: i64,\n}\n\npub(crate) fn now_epoch() -> i64 {\n    SystemTime::now()\n        .duration_since(UNIX_EPOCH)\n        .map(|d| d.as_secs() as i64)\n        .unwrap_or_default()\n}\n\nfn env_truthy(key: &str) -> bool {\n    std::env::var(key)\n        .ok()\n        .map(|value| {\n            matches!(\n                value.trim().to_ascii_lowercase().as_str(),\n                \"1\" | \"true\" | \"yes\" | \"on\"\n            )\n        })\n        .unwrap_or(false)\n}\n\nfn bench_mode_enabled() -> bool {\n    *BENCH_MODE_ENABLED.get_or_init(|| env_truthy(\"EVERYTHING_BENCH\"))\n}\n\nfn perf_log_enabled() -> bool {\n    *PERF_LOG_ENABLED.get_or_init(|| env_truthy(\"FASTFIND_PERF_LOG\") || bench_mode_enabled())\n}\n\npub(crate) fn perf_log(message: impl AsRef<str>) {\n    if perf_log_enabled() {\n        eprintln!(\"[perf] {}\", message.as_ref());\n    }\n}\n\nfn db_connection_with_timeout(db_path: &Path, busy_timeout_ms: u32) -> AppResult<Connection> {\n    let conn = Connection::open(db_path).map_err(|e| e.to_string())?;\n    conn.execute_batch(&format!(\n        r#\"\n        PRAGMA journal_mode=WAL;\n        PRAGMA synchronous=NORMAL;\n        PRAGMA temp_store=MEMORY;\n        PRAGMA busy_timeout={busy_timeout_ms};\n        \"#,\n    ))\n    .map_err(|e| e.to_string())?;\n    Ok(conn)\n}\n\npub(crate) fn db_connection(db_path: &Path) -> AppResult<Connection> {\n    db_connection_with_timeout(db_path, 3000)\n}\n\nfn db_connection_for_search(db_path: &Path) -> AppResult<Connection> {\n    let conn = db_connection_with_timeout(db_path, 500)?;\n    conn.execute_batch(\n        \"PRAGMA cache_size = -32768;\n         PRAGMA mmap_size = 268435456;\",\n    )\n    .map_err(|e| e.to_string())?;\n    Ok(conn)\n}\n\npub(crate) fn set_indexing_pragmas(conn: &Connection) -> AppResult<()> {\n    conn.execute_batch(\n        r#\"\n        PRAGMA synchronous = OFF;\n        PRAGMA cache_size = -131072;\n        PRAGMA mmap_size = 536870912;\n        PRAGMA wal_autocheckpoint = 0;\n        \"#,\n    )\n    .map_err(|e| e.to_string())\n}\n\npub(crate) fn restore_normal_pragmas(conn: &Connection) -> AppResult<()> {\n    conn.execute_batch(\n        r#\"\n        PRAGMA synchronous = NORMAL;\n        PRAGMA cache_size = -16384;\n        PRAGMA mmap_size = 268435456;\n        PRAGMA wal_autocheckpoint = 1000;\n        \"#,\n    )\n    .map_err(|e| e.to_string())?;\n    conn.execute_batch(\"PRAGMA wal_checkpoint(TRUNCATE);\")\n        .map_err(|e| e.to_string())?;\n    Ok(())\n}\n\nfn init_db(db_path: &Path) -> AppResult<()> {\n    let t = Instant::now();\n    let conn = db_connection(db_path)?;\n    eprintln!(\"[init_db] +{}ms db_connection opened\", t.elapsed().as_millis());\n\n    let current_version: i32 = conn\n        .query_row(\"PRAGMA user_version\", [], |row| row.get(0))\n        .unwrap_or(0);\n    if current_version != DB_VERSION {\n        conn.execute_batch(\n            r#\"\n            DROP TRIGGER IF EXISTS entries_ai;\n            DROP TRIGGER IF EXISTS entries_ad;\n            DROP TRIGGER IF EXISTS entries_au;\n            DROP TABLE IF EXISTS entries_fts;\n            DROP TABLE IF EXISTS entries;\n            \"#,\n        )\n        .map_err(|e| e.to_string())?;\n        conn.execute_batch(&format!(\"PRAGMA user_version = {};\", DB_VERSION))\n            .map_err(|e| e.to_string())?;\n    }\n    eprintln!(\"[init_db] +{}ms version check done (v={})\", t.elapsed().as_millis(), current_version);\n\n    conn.execute_batch(\n        r#\"\n        CREATE TABLE IF NOT EXISTS entries (\n          id INTEGER PRIMARY KEY,\n          path TEXT NOT NULL UNIQUE,\n          name TEXT NOT NULL,\n          dir TEXT NOT NULL,\n          is_dir INTEGER NOT NULL,\n          ext TEXT,\n          mtime INTEGER,\n          size INTEGER,\n          indexed_at INTEGER NOT NULL,\n          run_id INTEGER NOT NULL DEFAULT 0\n        );\n\n        CREATE INDEX IF NOT EXISTS idx_entries_dir_ext_name_nocase ON entries(dir, ext, name COLLATE NOCASE);\n        CREATE INDEX IF NOT EXISTS idx_entries_mtime ON entries(mtime);\n        CREATE INDEX IF NOT EXISTS idx_entries_name_nocase ON entries(name COLLATE NOCASE);\n        CREATE INDEX IF NOT EXISTS idx_entries_ext_name ON entries(ext, name COLLATE NOCASE);\n\n        CREATE TABLE IF NOT EXISTS meta (\n          key TEXT PRIMARY KEY,\n          value TEXT NOT NULL\n        );\n        \"#,\n    )\n    .map_err(|e| e.to_string())?;\n    eprintln!(\"[init_db] +{}ms schema ensured\", t.elapsed().as_millis());\n\n    let legacy_index_migration_key = \"migration_drop_idx_entries_dir_name_nocase_v1\";\n    let migrated = get_meta(&conn, legacy_index_migration_key)\n        .map(|v| v == \"1\")\n        .unwrap_or(false);\n    if !migrated {\n        conn.execute_batch(\"DROP INDEX IF EXISTS idx_entries_dir_name_nocase;\")\n            .map_err(|e| e.to_string())?;\n        set_meta(&conn, legacy_index_migration_key, \"1\")?;\n    }\n    eprintln!(\"[init_db] +{}ms total\", t.elapsed().as_millis());\n\n    Ok(())\n}\n\npub(crate) fn get_meta(conn: &Connection, key: &str) -> Option<String> {\n    conn.query_row(\n        \"SELECT value FROM meta WHERE key = ?1\",\n        params![key],\n        |row| row.get(0),\n    )\n    .ok()\n}\n\npub(crate) fn set_meta(conn: &Connection, key: &str, value: &str) -> AppResult<()> {\n    conn.execute(\n        \"INSERT OR REPLACE INTO meta(key, value) VALUES(?1, ?2)\",\n        params![key, value],\n    )\n    .map_err(|e| e.to_string())?;\n    Ok(())\n}\n\nfn update_counts(state: &AppState) -> AppResult<(u64, Option<i64>)> {\n    let conn = db_connection(&state.db_path)?;\n\n    let entries_count = conn\n        .query_row(\"SELECT COUNT(*) FROM entries\", [], |row| {\n            row.get::<_, i64>(0)\n        })\n        .map_err(|e| e.to_string())?\n        .max(0) as u64;\n\n    let last_updated = conn\n        .query_row(\"SELECT MAX(indexed_at) FROM entries\", [], |row| {\n            row.get::<_, Option<i64>>(0)\n        })\n        .map_err(|e| e.to_string())?;\n\n    Ok((entries_count, last_updated))\n}\n\npub(crate) fn update_status_counts(state: &AppState) -> AppResult<(u64, Option<i64>)> {\n    let (entries_count, last_updated) = update_counts(state)?;\n    let mut status = state.status.lock();\n    status.entries_count = entries_count;\n    status.last_updated = last_updated;\n    Ok((entries_count, last_updated))\n}\n\npub(crate) fn invalidate_search_caches(state: &AppState) {\n    state.fd_search_cache.lock().take();\n    state.negative_name_cache.lock().clear();\n}\n\nfn prune_negative_name_cache(cache: &mut HashMap<String, NegativeNameEntry>) {\n    let now = Instant::now();\n    cache.retain(|_, entry| now.duration_since(entry.created_at) <= NEGATIVE_CACHE_TTL);\n}\n\nfn negative_name_cache_lookup(state: &AppState, query: &str) -> Option<NegativeCacheHit> {\n    if query.is_empty() {\n        return None;\n    }\n    let q = query.to_lowercase();\n    let now = Instant::now();\n    let mut cache = state.negative_name_cache.lock();\n    prune_negative_name_cache(&mut cache);\n    cache\n        .iter()\n        .filter(|(key, _)| q.contains(key.as_str()))\n        .max_by_key(|(key, _)| key.len())\n        .map(|(key, entry)| NegativeCacheHit {\n            query_lower: key.clone(),\n            age: now.duration_since(entry.created_at),\n            fallback_checked: entry.fallback_checked,\n        })\n}\n\nfn remember_negative_name_query(state: &AppState, query: &str) {\n    if query.is_empty() {\n        return;\n    }\n    let normalized = query.to_lowercase();\n    let mut cache = state.negative_name_cache.lock();\n    prune_negative_name_cache(&mut cache);\n\n    if cache.contains_key(&normalized) {\n        return;\n    }\n\n    cache.insert(\n        normalized,\n        NegativeNameEntry {\n            created_at: Instant::now(),\n            fallback_checked: false,\n        },\n    );\n    const MAX_NEGATIVE_CACHE: usize = 512;\n    if cache.len() > MAX_NEGATIVE_CACHE {\n        let mut entries: Vec<_> =\n            cache.iter().map(|(k, v)| (k.clone(), v.created_at)).collect();\n        entries.sort_by_key(|(_, t)| *t);\n        let drop_count = cache.len() - MAX_NEGATIVE_CACHE;\n        for (key, _) in entries.into_iter().take(drop_count) {\n            cache.remove(&key);\n        }\n    }\n}\n\nfn remove_negative_name_query(state: &AppState, query: &str) {\n    if query.is_empty() {\n        return;\n    }\n    let normalized = query.to_lowercase();\n    state.negative_name_cache.lock().remove(&normalized);\n}\n\nfn mark_negative_name_fallback_checked(state: &AppState, query_lower: &str) {\n    let mut cache = state.negative_name_cache.lock();\n    if let Some(entry) = cache.get_mut(query_lower) {\n        entry.fallback_checked = true;\n    }\n}\n\nfn sort_clause(sort_by: &str, sort_dir: &str, prefix: &str) -> String {\n    match (sort_by, sort_dir) {\n        (\"name\", \"desc\") => {\n            format!(\"{prefix}name COLLATE NOCASE DESC, {prefix}path COLLATE NOCASE DESC\")\n        }\n        (\"mtime\", \"asc\") => {\n            format!(\"COALESCE({prefix}mtime, 0) ASC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        (\"mtime\", \"desc\") => {\n            format!(\"COALESCE({prefix}mtime, 0) DESC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        (\"dir\", \"asc\") => {\n            format!(\"{prefix}dir COLLATE NOCASE ASC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        (\"dir\", \"desc\") => {\n            format!(\"{prefix}dir COLLATE NOCASE DESC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        (\"size\", \"asc\") => {\n            format!(\"{prefix}size IS NULL ASC, {prefix}size ASC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        (\"size\", \"desc\") => {\n            format!(\"{prefix}size IS NULL ASC, {prefix}size DESC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        _ => format!(\"{prefix}name COLLATE NOCASE ASC, {prefix}path COLLATE NOCASE ASC\"),\n    }\n}\n\nfn contains_glob_meta(s: &str) -> bool {\n    s.contains('*') || s.contains('?')\n}\n\n/// Detect if a LIKE pattern is a pure extension filter (e.g. `%.rs`).\n/// Returns the lowercase extension if matched, None otherwise.\nfn extract_ext_from_like(like_pattern: &str) -> Option<String> {\n    let rest = like_pattern.strip_prefix('%')?;\n    let ext = rest.strip_prefix('.')?;\n    if ext.is_empty()\n        || ext.contains('%')\n        || ext.contains('_')\n        || ext.contains('\\\\')\n        || ext.contains('/')\n        || ext.contains('.')\n    {\n        return None;\n    }\n    Some(ext.to_lowercase())\n}\n\nfn normalize_hint_to_native(dir_hint: &str) -> (String, bool) {\n    let native = dir_hint.replace('/', &std::path::MAIN_SEPARATOR.to_string());\n    let is_abs = Path::new(&native).is_absolute();\n    (native, is_abs)\n}\n\nfn last_segment(dir_hint: &str) -> &str {\n    dir_hint\n        .rsplit(|c| c == '/' || c == '\\\\')\n        .find(|seg| !seg.is_empty())\n        .unwrap_or(dir_hint)\n}\n\nfn resolve_dir_hint(home_dir: &Path, dir_hint: &str) -> Option<PathBuf> {\n    if dir_hint.is_empty() || contains_glob_meta(dir_hint) {\n        return None;\n    }\n\n    let candidate = if dir_hint == \"~\" {\n        home_dir.to_path_buf()\n    } else if let Some(rest) = dir_hint.strip_prefix(\"~/\") {\n        home_dir.join(rest)\n    } else {\n        let (native_hint, is_absolute) = normalize_hint_to_native(dir_hint);\n        if is_absolute {\n            PathBuf::from(native_hint)\n        } else {\n            home_dir.join(native_hint)\n        }\n    };\n\n    if candidate.is_dir() {\n        Some(candidate)\n    } else {\n        None\n    }\n}\n\nconst RESOLVE_DIRS_MAX: usize = 20;\n\nfn resolve_dirs_from_db(conn: &Connection, dir_hint: &str) -> Vec<String> {\n    if dir_hint.is_empty() || contains_glob_meta(dir_hint) {\n        return Vec::new();\n    }\n    let last_seg = last_segment(dir_hint);\n    let sep = std::path::MAIN_SEPARATOR;\n    let (native_hint, is_absolute) = normalize_hint_to_native(dir_hint);\n    let sep_str = sep.to_string();\n    let escaped_sep = escape_like(&sep_str);\n    let path_pattern = if is_absolute {\n        format!(\"%{}\", escape_like(&native_hint))\n    } else {\n        format!(\"%{escaped_sep}{}\", escape_like(&native_hint))\n    };\n    let fetch_limit = (RESOLVE_DIRS_MAX + 1) as i64;\n    let mut stmt = match conn.prepare(\n        \"SELECT path FROM entries WHERE name = ?1 COLLATE NOCASE AND is_dir = 1 AND path LIKE ?2 ESCAPE '\\\\' LIMIT ?3\",\n    ) {\n        Ok(s) => s,\n        Err(_) => return Vec::new(),\n    };\n    let rows = match stmt.query_map(params![last_seg, path_pattern, fetch_limit], |row| {\n        row.get::<_, String>(0)\n    }) {\n        Ok(r) => r,\n        Err(_) => return Vec::new(),\n    };\n    let dirs: Vec<String> = rows.filter_map(|r| r.ok()).collect();\n    if dirs.len() > RESOLVE_DIRS_MAX {\n        return Vec::new();\n    }\n    dirs\n}\n\nfn normalize_slashes(s: String) -> String {\n    s.replace('\\\\', \"/\")\n}\n\nfn resolve_ignore_path(raw: &str, base_dir: &Path, home_dir: &Path) -> Option<PathBuf> {\n    let trimmed = raw.trim();\n    if trimmed.is_empty() || trimmed.starts_with('#') || trimmed.starts_with('!') {\n        return None;\n    }\n\n    let mut path = if trimmed == \"~\" {\n        home_dir.to_path_buf()\n    } else if let Some(rest) = trimmed.strip_prefix(\"~/\") {\n        home_dir.join(rest)\n    } else {\n        PathBuf::from(trimmed)\n    };\n\n    if !path.is_absolute() {\n        path = base_dir.join(path);\n    }\n\n    Some(fs::canonicalize(&path).unwrap_or(path))\n}\n\nfn normalize_ignore_pattern(raw: &str, base_dir: &Path, home_dir: &Path) -> String {\n    let trimmed = raw.trim().trim_end_matches('/').to_string();\n    if trimmed == \"~\" {\n        return normalize_slashes(home_dir.to_string_lossy().to_string());\n    }\n    if let Some(rest) = trimmed.strip_prefix(\"~/\") {\n        return normalize_slashes(home_dir.join(rest).to_string_lossy().to_string());\n    }\n    if trimmed.starts_with('/') || trimmed.starts_with(\"**/\") {\n        return trimmed;\n    }\n    normalize_slashes(base_dir.join(&trimmed).to_string_lossy().to_string())\n}\n\nfn parse_ignore_pattern(raw: &str, base_dir: &Path, home_dir: &Path) -> Option<IgnorePattern> {\n    let trimmed = raw.trim().trim_end_matches('/');\n    if trimmed.is_empty() {\n        return None;\n    }\n\n    if let Some(segment) = trimmed.strip_prefix(\"**/\") {\n        if !segment.is_empty() && !segment.contains('/') && !contains_glob_meta(segment) {\n            return Some(IgnorePattern::AnySegment(segment.to_string()));\n        }\n    }\n\n    Some(IgnorePattern::Glob(normalize_ignore_pattern(\n        trimmed, base_dir, home_dir,\n    )))\n}\n\nfn ignore_pattern_key(pattern: &IgnorePattern) -> String {\n    match pattern {\n        IgnorePattern::AnySegment(segment) => format!(\"seg:{segment}\"),\n        IgnorePattern::Glob(glob) => format!(\"glob:{glob}\"),\n    }\n}\n\nfn find_file_upward(start: &Path, file_name: &str) -> Option<PathBuf> {\n    let mut current = Some(start);\n    while let Some(dir) = current {\n        let candidate = dir.join(file_name);\n        if candidate.is_file() {\n            return Some(candidate);\n        }\n        current = dir.parent();\n    }\n    None\n}\n\nfn find_git_root(start: &Path) -> Option<PathBuf> {\n    let mut current = Some(start);\n    while let Some(dir) = current {\n        let marker = dir.join(\".git\");\n        if marker.is_dir() || marker.is_file() {\n            return Some(dir.to_path_buf());\n        }\n        current = dir.parent();\n    }\n    None\n}\n\nfn load_pathignore_rules(home_dir: &Path, cwd: &Path) -> (Vec<PathBuf>, Vec<IgnorePattern>) {\n    let mut files = Vec::new();\n    if let Some(file) = find_file_upward(cwd, \".pathignore\") {\n        files.push(file);\n    } else {\n        files.push(cwd.join(\".pathignore\"));\n    }\n    let home_file = home_dir.join(\".pathignore\");\n    if !files.iter().any(|p| p == &home_file) {\n        files.push(home_file);\n    }\n\n    let mut roots = Vec::new();\n    let mut patterns = Vec::new();\n    let mut seen_roots = HashSet::new();\n    let mut seen_patterns = HashSet::new();\n\n    for file in files {\n        let Ok(contents) = fs::read_to_string(&file) else {\n            continue;\n        };\n        let base_dir = file.parent().unwrap_or_else(|| Path::new(\"/\"));\n        for line in contents.lines() {\n            let trimmed = line.trim();\n            if trimmed.is_empty() || trimmed.starts_with('#') || trimmed.starts_with('!') {\n                continue;\n            }\n\n            if contains_glob_meta(trimmed) {\n                let Some(pattern) = parse_ignore_pattern(trimmed, base_dir, home_dir) else {\n                    continue;\n                };\n                let key = ignore_pattern_key(&pattern);\n                if seen_patterns.insert(key) {\n                    patterns.push(pattern);\n                }\n                continue;\n            }\n\n            let Some(path) = resolve_ignore_path(trimmed, base_dir, home_dir) else {\n                continue;\n            };\n\n            let key = path.to_string_lossy().to_string();\n            if seen_roots.insert(key) {\n                roots.push(path);\n            }\n        }\n    }\n\n    (roots, patterns)\n}\n\nfn load_gitignore_roots(home_dir: &Path, cwd: &Path) -> Vec<PathBuf> {\n    let gitignore = if let Some(root) = find_git_root(cwd) {\n        root.join(\".gitignore\")\n    } else if let Some(file) = find_file_upward(&cwd, \".gitignore\") {\n        file\n    } else {\n        return Vec::new();\n    };\n    let contents = match fs::read_to_string(&gitignore) {\n        Ok(contents) => contents,\n        Err(_) => return Vec::new(),\n    };\n\n    let mut roots = Vec::new();\n    let mut seen = HashSet::new();\n\n    for line in contents.lines() {\n        let trimmed = line.trim();\n        if trimmed.is_empty() || trimmed.starts_with('#') || trimmed.starts_with('!') {\n            continue;\n        }\n        if contains_glob_meta(trimmed) || trimmed.contains('[') {\n            continue;\n        }\n\n        let normalized = trimmed.trim_start_matches('/').trim_end_matches('/');\n        if normalized.is_empty() {\n            continue;\n        }\n\n        let Some(path) = resolve_ignore_path(normalized, &cwd, home_dir) else {\n            continue;\n        };\n\n        let key = path.to_string_lossy().to_string();\n        if seen.insert(key) {\n            roots.push(path);\n        }\n    }\n\n    roots\n}\n\n#[cfg(target_os = \"macos\")]\nfn macos_tcc_ignore_roots(home_dir: &Path) -> Vec<PathBuf> {\n    let library = home_dir.join(\"Library\");\n    let app_support = library.join(\"Application Support\");\n    let caches = library.join(\"Caches\");\n\n    let dirs: Vec<PathBuf> = vec![\n        home_dir.join(\".Trash\"),\n        library.join(\"Accounts\"),\n        library.join(\"AppleMediaServices\"),\n        library.join(\"Assistant\").join(\"SiriVocabulary\"),\n        library.join(\"Autosave Information\"),\n        library.join(\"Biome\"),\n        library.join(\"Calendars\"),\n        library.join(\"com.apple.aiml.instrumentation\"),\n        library.join(\"ContainerManager\"),\n        library.join(\"Cookies\"),\n        library.join(\"CoreFollowUp\"),\n        library.join(\"Daemon Containers\"),\n        library.join(\"DoNotDisturb\"),\n        library.join(\"DuetExpertCenter\"),\n        library.join(\"Group Containers\"),\n        library.join(\"HomeKit\"),\n        library.join(\"Developer\").join(\"Xcode\").join(\"DerivedData\"),\n        library.join(\"IdentityServices\"),\n        library.join(\"IntelligencePlatform\"),\n        library.join(\"Mail\"),\n        library.join(\"Messages\"),\n        library.join(\"Metadata\").join(\"CoreSpotlight\"),\n        library.join(\"PersonalizationPortrait\"),\n        library.join(\"Reminders\"),\n        library.join(\"Safari\"),\n        library.join(\"Sharing\"),\n        library.join(\"Shortcuts\"),\n        library.join(\"StatusKit\"),\n        library.join(\"Suggestions\"),\n        library.join(\"Trial\"),\n        library.join(\"Weather\"),\n        app_support.join(\"AddressBook\"),\n        app_support.join(\"CallHistoryDB\"),\n        app_support.join(\"CallHistoryTransactions\"),\n        app_support.join(\"CloudDocs\"),\n        app_support.join(\"com.apple.avfoundation\"),\n        app_support.join(\"com.apple.sharedfilelist\"),\n        app_support.join(\"com.apple.TCC\"),\n        app_support.join(\"DifferentialPrivacy\"),\n        app_support.join(\"FaceTime\"),\n        app_support.join(\"FileProvider\"),\n        app_support.join(\"Knowledge\"),\n        caches.join(\"CloudKit\"),\n        caches.join(\"com.apple.ap.adprivacyd\"),\n        caches.join(\"com.apple.containermanagerd\"),\n        caches.join(\"com.apple.findmy.fmfcore\"),\n        caches.join(\"com.apple.findmy.fmipcore\"),\n        caches.join(\"com.apple.homed\"),\n        caches.join(\"com.apple.HomeKit\"),\n        caches.join(\"com.apple.Safari\"),\n        caches.join(\"FamilyCircle\"),\n    ];\n\n    dirs.into_iter().filter(|p| p.exists()).collect()\n}\n\n#[cfg(not(target_os = \"macos\"))]\nfn macos_tcc_ignore_roots(_home_dir: &Path) -> Vec<PathBuf> {\n    Vec::new()\n}\n\n/// Directories under home that generate heavy background I/O on Windows\n/// (browser caches, Windows Update temp files, UWP package state, etc.).\n/// Pruning these from the MFT subtree eliminates noisy USN records.\n#[cfg(target_os = \"windows\")]\nfn windows_noisy_roots(home_dir: &Path) -> Vec<PathBuf> {\n    let local = home_dir.join(\"AppData\").join(\"Local\");\n    let dirs = vec![\n        local.join(\"Temp\"),\n        local.join(\"Microsoft\"),\n        local.join(\"Google\"),\n        local.join(\"Packages\"),\n        // C:\\ system directories (Windows is deferred, not excluded)\n        PathBuf::from(\"C:\\\\$Recycle.Bin\"),\n        PathBuf::from(\"C:\\\\System Volume Information\"),\n        PathBuf::from(\"C:\\\\Recovery\"),\n        PathBuf::from(\"C:\\\\PerfLogs\"),\n    ];\n    dirs.into_iter().filter(|p| p.exists()).collect()\n}\n\n#[cfg(not(target_os = \"windows\"))]\nfn windows_noisy_roots(_home_dir: &Path) -> Vec<PathBuf> {\n    Vec::new()\n}\n\npub(crate) fn effective_ignore_rules(\n    home_dir: &Path,\n    cwd: &Path,\n    base_roots: &[PathBuf],\n    base_patterns: &[IgnorePattern],\n) -> (Vec<PathBuf>, Vec<IgnorePattern>) {\n    let mut roots = base_roots.to_vec();\n    let mut patterns = base_patterns.to_vec();\n    let mut seen: HashSet<String> = roots\n        .iter()\n        .map(|p| p.to_string_lossy().to_string())\n        .collect();\n    let mut seen_patterns: HashSet<String> = patterns.iter().map(ignore_pattern_key).collect();\n\n    let (pathignore_roots, pathignore_patterns) = load_pathignore_rules(home_dir, cwd);\n    for root in pathignore_roots\n        .into_iter()\n        .chain(load_gitignore_roots(home_dir, cwd).into_iter())\n        .chain(macos_tcc_ignore_roots(home_dir).into_iter())\n        .chain(windows_noisy_roots(home_dir).into_iter())\n    {\n        let key = root.to_string_lossy().to_string();\n        if seen.insert(key) {\n            roots.push(root);\n        }\n    }\n\n    for pattern in pathignore_patterns\n        .into_iter()\n        .chain(builtin_ignore_patterns(home_dir))\n    {\n        let key = ignore_pattern_key(&pattern);\n        if seen_patterns.insert(key) {\n            patterns.push(pattern);\n        }\n    }\n\n    (roots, patterns)\n}\n\nfn builtin_ignore_patterns(home_dir: &Path) -> Vec<IgnorePattern> {\n    let home = normalize_slashes(home_dir.to_string_lossy().to_string());\n    vec![\n        // ~/Library/Application Support/*/Cache*\n        IgnorePattern::Glob(format!(\"{home}/Library/Application Support/*/Cache*\")),\n        // ~/Library/Application Support/*/Code Cache\n        IgnorePattern::Glob(format!(\"{home}/Library/Application Support/*/Code Cache\")),\n        // ~/.rustup/toolchains/*/share/doc\n        IgnorePattern::Glob(format!(\"{home}/.rustup/toolchains/*/share/doc\")),\n        // ~/.pyenv/versions/*/lib\n        IgnorePattern::Glob(format!(\"{home}/.pyenv/versions/*/lib\")),\n    ]\n}\n\npub(crate) fn cached_effective_ignore_rules(state: &AppState) -> (Vec<PathBuf>, Vec<IgnorePattern>) {\n    let home_dir = &state.home_dir;\n    let cwd = &state.cwd;\n\n    let pathignore_mtime = find_file_upward(cwd, \".pathignore\")\n        .or_else(|| Some(home_dir.join(\".pathignore\")))\n        .and_then(|p| fs::metadata(&p).ok())\n        .and_then(|m| m.modified().ok());\n\n    let gitignore_mtime = find_git_root(cwd)\n        .map(|root| root.join(\".gitignore\"))\n        .or_else(|| find_file_upward(cwd, \".gitignore\"))\n        .and_then(|p| fs::metadata(&p).ok())\n        .and_then(|m| m.modified().ok());\n\n    let mut cache = state.ignore_cache.lock();\n    if let Some(ref cached) = *cache {\n        if cached.pathignore_mtime == pathignore_mtime && cached.gitignore_mtime == gitignore_mtime\n        {\n            return (cached.roots.clone(), cached.patterns.clone());\n        }\n    }\n\n    let (roots, patterns) = effective_ignore_rules(\n        home_dir,\n        cwd,\n        state.path_ignores.as_ref(),\n        state.path_ignore_patterns.as_ref(),\n    );\n\n    *cache = Some(IgnoreRulesCache {\n        roots: roots.clone(),\n        patterns: patterns.clone(),\n        pathignore_mtime,\n        gitignore_mtime,\n    });\n\n    (roots, patterns)\n}\n\nfn ignore_rules_fingerprint(roots: &[PathBuf], patterns: &[IgnorePattern]) -> u64 {\n    let mut hasher = std::collections::hash_map::DefaultHasher::new();\n    for root in roots {\n        normalize_slashes(root.to_string_lossy().to_string()).hash(&mut hasher);\n    }\n    for pattern in patterns {\n        ignore_pattern_key(pattern).hash(&mut hasher);\n    }\n    hasher.finish()\n}\n\nfn purge_ignored_entries(db_path: &Path, ignored_roots: &[PathBuf]) -> AppResult<()> {\n    if ignored_roots.is_empty() {\n        return Ok(());\n    }\n\n    let conn = db_connection(db_path)?;\n    for root in ignored_roots {\n        let root_str = root.to_string_lossy().to_string();\n        if root_str.is_empty() {\n            continue;\n        }\n\n        if root_str == \"/\" {\n            conn.execute(\"DELETE FROM entries\", [])\n                .map_err(|e| e.to_string())?;\n            break;\n        }\n\n        let prefix = root_str.trim_end_matches('/');\n        let descendant_like = format!(\"{}%\", escape_like(&format!(\"{prefix}/\")));\n        conn.execute(\n            \"DELETE FROM entries WHERE path = ?1 OR path LIKE ?2 ESCAPE '\\\\'\",\n            params![prefix, descendant_like],\n        )\n        .map_err(|e| e.to_string())?;\n    }\n\n    Ok(())\n}\n\nfn glob_match_path(pattern: &str, text: &str) -> bool {\n    let pat = pattern.as_bytes();\n    let txt = text.as_bytes();\n    let (pn, tn) = (pat.len(), txt.len());\n\n    let mut px = 0usize;\n    let mut tx = 0usize;\n    let mut star_px = usize::MAX;\n    let mut star_tx = 0usize;\n    let mut star_is_double = false;\n\n    while tx < tn {\n        if px < pn && px + 1 < pn && pat[px] == b'*' && pat[px + 1] == b'*' {\n            star_px = px;\n            star_tx = tx;\n            star_is_double = true;\n            px += 2;\n        } else if px < pn && pat[px] == b'*' {\n            star_px = px;\n            star_tx = tx;\n            star_is_double = false;\n            px += 1;\n        } else if px < pn && (pat[px] == b'?' && txt[tx] != b'/') {\n            px += 1;\n            tx += 1;\n        } else if px < pn && pat[px] == txt[tx] {\n            px += 1;\n            tx += 1;\n        } else if star_px != usize::MAX {\n            star_tx += 1;\n            if !star_is_double && txt[star_tx - 1] == b'/' {\n                return false;\n            }\n            px = if star_is_double {\n                star_px + 2\n            } else {\n                star_px + 1\n            };\n            tx = star_tx;\n        } else {\n            return false;\n        }\n    }\n\n    while px < pn && pat[px] == b'*' {\n        px += 1;\n    }\n\n    px == pn\n}\n\npub(crate) fn matches_ignore_pattern(path: &str, pattern: &IgnorePattern) -> bool {\n    match pattern {\n        IgnorePattern::AnySegment(segment) => {\n            let suffix = format!(\"/{segment}\");\n            let infix = format!(\"/{segment}/\");\n            path.ends_with(&suffix) || path.contains(&infix)\n        }\n        IgnorePattern::Glob(glob) => {\n            let mut cur = path;\n            loop {\n                if glob_match_path(glob, cur) {\n                    return true;\n                }\n\n                if cur == \"/\" {\n                    break;\n                }\n\n                let Some(pos) = cur.rfind('/') else {\n                    break;\n                };\n\n                cur = if pos == 0 { \"/\" } else { &cur[..pos] };\n            }\n            false\n        }\n    }\n}\n\npub(crate) fn should_skip_path(\n    path: &Path,\n    ignored_roots: &[PathBuf],\n    ignored_patterns: &[IgnorePattern],\n) -> bool {\n    should_skip_path_ext(path, ignored_roots, ignored_patterns, None, None)\n}\n\npub(crate) fn should_skip_path_ext(\n    path: &Path,\n    ignored_roots: &[PathBuf],\n    ignored_patterns: &[IgnorePattern],\n    gitignore: Option<&gitignore_filter::GitignoreFilter>,\n    is_dir_hint: Option<bool>,\n) -> bool {\n    let s = normalize_slashes(path.to_string_lossy().to_string());\n\n    // Single-component builtin names: check path segments\n    if s.split('/').any(|seg| {\n        BUILTIN_SKIP_NAMES.contains(&seg)\n            || BUILTIN_SKIP_SUFFIXES.iter().any(|suf| seg.ends_with(suf))\n    }) {\n        return true;\n    }\n\n    // Multi-component builtin paths\n    if BUILTIN_SKIP_PATHS.iter().any(|pat| {\n        let infix = format!(\"/{pat}/\");\n        let suffix = format!(\"/{pat}\");\n        s.contains(&infix) || s.ends_with(&suffix)\n    }) {\n        return true;\n    }\n\n    if ignored_roots\n        .iter()\n        .any(|root| path == root || path.starts_with(root))\n    {\n        return true;\n    }\n    if ignored_patterns\n        .iter()\n        .any(|pattern| matches_ignore_pattern(&s, pattern))\n    {\n        return true;\n    }\n    if let Some(gi) = gitignore {\n        let is_dir = is_dir_hint.unwrap_or_else(|| path.is_dir());\n        if gi.is_ignored(path, is_dir) {\n            return true;\n        }\n    }\n    false\n}\n\nfn extension_for(path: &Path, is_dir: bool) -> Option<String> {\n    if is_dir {\n        return None;\n    }\n\n    path.extension()\n        .and_then(|ext| ext.to_str())\n        .map(|ext| ext.to_lowercase())\n}\n\npub(crate) fn index_row_from_path_and_metadata(path: &Path, metadata: &fs::Metadata) -> Option<IndexRow> {\n    let is_dir = metadata.is_dir();\n\n    let name = path\n        .file_name()\n        .map(|v| v.to_string_lossy().to_string())\n        .or_else(|| {\n            if path == Path::new(\"/\") {\n                Some(\"/\".to_string())\n            } else {\n                None\n            }\n        })?;\n\n    let dir = path\n        .parent()\n        .map(|p| p.to_string_lossy().to_string())\n        .unwrap_or_else(|| \"/\".to_string());\n\n    let mtime = metadata\n        .modified()\n        .ok()\n        .and_then(|m| m.duration_since(UNIX_EPOCH).ok())\n        .map(|d| d.as_secs() as i64);\n\n    let size = if metadata.is_file() {\n        Some(metadata.len() as i64)\n    } else {\n        None\n    };\n\n    Some(IndexRow {\n        path: path.to_string_lossy().to_string(),\n        name,\n        dir,\n        is_dir: if is_dir { 1 } else { 0 },\n        ext: extension_for(path, is_dir),\n        mtime,\n        size,\n        indexed_at: now_epoch(),\n        run_id: 0,\n    })\n}\n\nfn index_row_from_path(path: &Path) -> Option<IndexRow> {\n    let metadata = fs::symlink_metadata(path).ok()?;\n    index_row_from_path_and_metadata(path, &metadata)\n}\n\nfn index_row_from_walkdir_entry(entry: &walkdir::DirEntry) -> Option<IndexRow> {\n    let metadata = entry.metadata().ok()?;\n    index_row_from_path_and_metadata(entry.path(), &metadata)\n}\n\nfn index_row_from_jwalk_entry(entry: &jwalk::DirEntry<((), ())>) -> Option<IndexRow> {\n    let metadata = entry.metadata().ok()?;\n    index_row_from_path_and_metadata(&entry.path(), &metadata)\n}\n\nfn collect_rows_recursive(\n    root: &Path,\n    ignored_roots: &[PathBuf],\n    ignored_patterns: &[IgnorePattern],\n) -> Vec<IndexRow> {\n    let mut rows = Vec::new();\n\n    let iter = WalkDir::new(root)\n        .follow_links(false)\n        .into_iter()\n        .filter_entry(|entry| !should_skip_path(entry.path(), ignored_roots, ignored_patterns));\n\n    for entry in iter.flatten() {\n        if let Some(row) = index_row_from_walkdir_entry(&entry) {\n            rows.push(row);\n        }\n    }\n\n    rows\n}\n\nfn entry_from_index_row(row: IndexRow) -> EntryDto {\n    EntryDto {\n        path: row.path,\n        name: row.name,\n        dir: row.dir,\n        is_dir: row.is_dir == 1,\n        ext: row.ext,\n        size: row.size,\n        mtime: row.mtime,\n    }\n}\n\npub fn entry_from_path(path: &Path) -> Option<EntryDto> {\n    index_row_from_path(path).map(entry_from_index_row)\n}\n\nfn entry_cmp(a: &EntryDto, b: &EntryDto, sort_by: &str, sort_dir: &str) -> Ordering {\n    match sort_by {\n        \"mtime\" => {\n            let lhs = a.mtime.unwrap_or(0);\n            let rhs = b.mtime.unwrap_or(0);\n            let primary = if sort_dir == \"desc\" {\n                rhs.cmp(&lhs)\n            } else {\n                lhs.cmp(&rhs)\n            };\n\n            if primary != Ordering::Equal {\n                return primary;\n            }\n\n            a.name\n                .to_lowercase()\n                .cmp(&b.name.to_lowercase())\n                .then(a.path.to_lowercase().cmp(&b.path.to_lowercase()))\n        }\n        \"dir\" => {\n            let lhs = a.dir.to_lowercase();\n            let rhs = b.dir.to_lowercase();\n            let primary = if sort_dir == \"desc\" {\n                rhs.cmp(&lhs)\n            } else {\n                lhs.cmp(&rhs)\n            };\n            if primary != Ordering::Equal {\n                return primary;\n            }\n            a.name.to_lowercase().cmp(&b.name.to_lowercase())\n        }\n        \"size\" => {\n            let lhs = a.size.unwrap_or(0);\n            let rhs = b.size.unwrap_or(0);\n            let primary = if sort_dir == \"desc\" {\n                rhs.cmp(&lhs)\n            } else {\n                lhs.cmp(&rhs)\n            };\n            if primary != Ordering::Equal {\n                return primary;\n            }\n            a.name\n                .to_lowercase()\n                .cmp(&b.name.to_lowercase())\n                .then(a.path.to_lowercase().cmp(&b.path.to_lowercase()))\n        }\n        _ => {\n            let lhs_name = a.name.to_lowercase();\n            let rhs_name = b.name.to_lowercase();\n            let primary = if sort_dir == \"desc\" {\n                rhs_name.cmp(&lhs_name)\n            } else {\n                lhs_name.cmp(&rhs_name)\n            };\n\n            if primary != Ordering::Equal {\n                return primary;\n            }\n\n            let lhs_path = a.path.to_lowercase();\n            let rhs_path = b.path.to_lowercase();\n            if sort_dir == \"desc\" {\n                rhs_path.cmp(&lhs_path)\n            } else {\n                lhs_path.cmp(&rhs_path)\n            }\n        }\n    }\n}\n\nfn relevance_rank(entry: &EntryDto, query_lower: &str, path_suffix: &str) -> u8 {\n    if query_lower.is_empty() {\n        return 255;\n    }\n\n    let name = entry.name.to_lowercase();\n    let path = entry.path.to_lowercase();\n\n    if name == query_lower {\n        return 0;\n    }\n    if name.starts_with(query_lower) {\n        return 1;\n    }\n    if name.contains(query_lower) {\n        return 2;\n    }\n    if path.ends_with(path_suffix) {\n        return 3;\n    }\n    if path.contains(query_lower) {\n        return 4;\n    }\n\n    5\n}\n\nfn path_depth(path: &str) -> usize {\n    Path::new(path).components().count()\n}\n\npub fn sort_entries(entries: &mut Vec<EntryDto>, sort_by: &str, sort_dir: &str) {\n    entries.sort_by(|a, b| entry_cmp(a, b, sort_by, sort_dir));\n}\n\nfn sort_entries_with_relevance(\n    entries: &mut Vec<EntryDto>,\n    query: &str,\n    sort_by: &str,\n    sort_dir: &str,\n) {\n    let query_lower = query.trim().to_lowercase();\n    if query_lower.is_empty() {\n        sort_entries(entries, sort_by, sort_dir);\n        return;\n    }\n    let path_suffix = format!(\"/{query_lower}\");\n\n    entries.sort_by(|a, b| {\n        let ra = relevance_rank(a, &query_lower, &path_suffix);\n        let rb = relevance_rank(b, &query_lower, &path_suffix);\n        if ra != rb {\n            return ra.cmp(&rb);\n        }\n\n        // For highly-relevant matches, prefer shallower paths first\n        // so `~/name` ranks above deep descendants with the same name.\n        if ra <= 3 {\n            let da = path_depth(&a.path);\n            let db = path_depth(&b.path);\n            if da != db {\n                return da.cmp(&db);\n            }\n        }\n\n        entry_cmp(a, b, sort_by, sort_dir)\n    });\n}\n\nfn filter_ignored_entries(\n    entries: Vec<EntryDto>,\n    ignored_roots: &[PathBuf],\n    ignored_patterns: &[IgnorePattern],\n) -> Vec<EntryDto> {\n    entries\n        .into_iter()\n        .filter(|entry| !should_skip_path(Path::new(&entry.path), ignored_roots, ignored_patterns))\n        .collect()\n}\n\nfn find_search(\n    home_dir: &Path,\n    ignored_roots: &[PathBuf],\n    ignored_patterns: &[IgnorePattern],\n    query: &str,\n    limit: usize,\n    sort_by: &str,\n    sort_dir: &str,\n) -> Vec<EntryDto> {\n    let trimmed = query.trim();\n    if trimmed.is_empty() || limit == 0 {\n        return Vec::new();\n    }\n\n    let mut search_root = home_dir.to_path_buf();\n    let mut dir_filter_pattern: Option<String> = None;\n    let mut name_filter_pattern: Option<String> = None;\n    let mut name_filter_glob = false;\n\n    if trimmed.contains('/') {\n        let last_slash = trimmed.rfind('/').unwrap();\n        let dir_part = trimmed[..last_slash].trim();\n        let name_part = trimmed[last_slash + 1..].trim();\n\n        if !dir_part.is_empty() {\n            let mut hinted = if dir_part == \"~\" {\n                Some(home_dir.to_path_buf())\n            } else if let Some(rest) = dir_part.strip_prefix(\"~/\") {\n                Some(home_dir.join(rest))\n            } else {\n                let p = PathBuf::from(dir_part);\n                if p.is_absolute() {\n                    Some(p)\n                } else if !dir_part.contains('*')\n                    && !dir_part.contains('?')\n                    && !dir_part.contains('[')\n                {\n                    Some(home_dir.join(dir_part))\n                } else {\n                    None\n                }\n            };\n\n            if let Some(path) = hinted.take() {\n                if path.exists() && path.is_dir() {\n                    search_root = path;\n                } else {\n                    dir_filter_pattern = Some(format!(\"*{}/*\", dir_part));\n                }\n            } else {\n                dir_filter_pattern = Some(format!(\"*{}/*\", dir_part));\n            }\n        }\n\n        if !name_part.is_empty() {\n            if name_part.contains('*') || name_part.contains('?') {\n                name_filter_pattern = Some(name_part.to_string());\n                name_filter_glob = true;\n            } else {\n                name_filter_pattern = Some(format!(\"*{}*\", name_part));\n            }\n        }\n    } else if trimmed.contains('*') || trimmed.contains('?') {\n        name_filter_pattern = Some(trimmed.to_string());\n        name_filter_glob = true;\n    } else {\n        name_filter_pattern = Some(format!(\"*{}*\", trimmed));\n    }\n\n    let mut cmd = Command::new(\"find\");\n    cmd.arg(&search_root);\n\n    if search_root == home_dir {\n        cmd.args([\"-maxdepth\", \"8\"]);\n    }\n\n    if let Some(dir_pattern) = dir_filter_pattern.as_deref() {\n        cmd.args([\"-ipath\", dir_pattern]);\n    }\n    if let Some(name_pattern) = name_filter_pattern.as_deref() {\n        cmd.args([\"-iname\", name_pattern]);\n    }\n    if name_filter_glob {\n        cmd.args([\"-type\", \"f\"]);\n    }\n\n    cmd.args([\"!\", \"-path\", \"*/.git/*\"])\n        .args([\"!\", \"-path\", \"*/node_modules/*\"])\n        .args([\"!\", \"-path\", \"*/.Trash/*\"])\n        .args([\"!\", \"-path\", \"*/.Trashes/*\"])\n        .args([\"!\", \"-path\", \"*/Library/Caches/*\"])\n        .stdout(Stdio::piped())\n        .stderr(Stdio::null());\n\n    let mut child = match cmd.spawn() {\n        Ok(c) => c,\n        Err(_) => return Vec::new(),\n    };\n\n    let stdout = match child.stdout.take() {\n        Some(s) => s,\n        None => return Vec::new(),\n    };\n\n    let reader = BufReader::new(stdout);\n    let mut entries = Vec::with_capacity(limit);\n\n    for line in reader.lines() {\n        let Ok(line) = line else { continue };\n        let path = PathBuf::from(&line);\n        if should_skip_path(&path, ignored_roots, ignored_patterns) {\n            continue;\n        }\n\n        if let Some(entry) = entry_from_path(&path) {\n            entries.push(entry);\n            if entries.len() >= limit {\n                break;\n            }\n        }\n    }\n\n    let _ = child.kill();\n    let _ = child.wait();\n\n    sort_entries_with_relevance(&mut entries, trimmed, sort_by, sort_dir);\n    entries\n}\n\npub(crate) fn upsert_rows(conn: &mut Connection, rows: &[IndexRow]) -> AppResult<usize> {\n    if rows.is_empty() {\n        return Ok(0);\n    }\n\n    let tx = conn.transaction().map_err(|e| e.to_string())?;\n    {\n        let mut stmt = tx\n            .prepare(\n                r#\"\n                INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n                VALUES(?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)\n                ON CONFLICT(path) DO UPDATE SET\n                  name = excluded.name,\n                  dir = excluded.dir,\n                  is_dir = excluded.is_dir,\n                  ext = excluded.ext,\n                  mtime = excluded.mtime,\n                  size = excluded.size,\n                  indexed_at = excluded.indexed_at,\n                  run_id = excluded.run_id\n                \"#,\n            )\n            .map_err(|e| e.to_string())?;\n\n        for row in rows {\n            stmt.execute(params![\n                row.path,\n                row.name,\n                row.dir,\n                row.is_dir,\n                row.ext,\n                row.mtime,\n                row.size,\n                row.indexed_at,\n                row.run_id\n            ])\n            .map_err(|e| e.to_string())?;\n        }\n    }\n    tx.commit().map_err(|e| e.to_string())?;\n    Ok(rows.len())\n}\n\npub(crate) fn delete_paths(conn: &mut Connection, raw_paths: &[String]) -> AppResult<usize> {\n    if raw_paths.is_empty() {\n        return Ok(0);\n    }\n\n    let tx = conn.transaction().map_err(|e| e.to_string())?;\n    let mut deleted = 0;\n\n    {\n        let mut stmt_exact = tx\n            .prepare(\"DELETE FROM entries WHERE path = ?1\")\n            .map_err(|e| e.to_string())?;\n        let mut stmt_children = tx\n            .prepare(\"DELETE FROM entries WHERE path >= ?1 AND path < ?2\")\n            .map_err(|e| e.to_string())?;\n\n        for path in raw_paths {\n            let is_root = path == \"/\" || path == \"\\\\\";\n            let normalized = if is_root {\n                path.clone()\n            } else {\n                path.trim_end_matches(&['/', '\\\\'][..]).to_string()\n            };\n\n            if normalized.is_empty() {\n                continue;\n            }\n\n            if is_root {\n                deleted += tx\n                    .execute(\"DELETE FROM entries\", [])\n                    .map_err(|e| e.to_string())?;\n                continue;\n            }\n\n            deleted += stmt_exact\n                .execute(params![&normalized])\n                .map_err(|e| e.to_string())?;\n\n            // Delete children using B-tree range scan: path >= \"{normalized}{sep}\" AND path < \"{normalized}\\x7F\"\n            // \\x7F (127) is higher than both '/' (47) and '\\' (92), so this captures all children.\n            let sep = std::path::MAIN_SEPARATOR;\n            let range_start = format!(\"{normalized}{sep}\");\n            let range_end = format!(\"{normalized}\\x7F\");\n            deleted += stmt_children\n                .execute(params![&range_start, &range_end])\n                .map_err(|e| e.to_string())?;\n        }\n    }\n\n    tx.commit().map_err(|e| e.to_string())?;\n    Ok(deleted)\n}\n\npub(crate) fn emit_index_state(app: &AppHandle, state: &str, message: Option<String>) {\n    let is_catchup = message.as_ref().map_or(false, |m| m.starts_with(\"Catchup:\"));\n    let _ = app.emit(\n        \"index_state\",\n        IndexStateEvent {\n            state: state.to_string(),\n            message,\n            is_catchup,\n        },\n    );\n}\n\npub(crate) fn emit_index_updated(\n    app: &AppHandle,\n    entries_count: u64,\n    last_updated: i64,\n    permission_errors: u64,\n) {\n    let _ = app.emit(\n        \"index_updated\",\n        IndexUpdatedEvent {\n            entries_count,\n            last_updated,\n            permission_errors,\n        },\n    );\n}\n\npub(crate) fn emit_index_progress(app: &AppHandle, scanned: u64, indexed: u64, current_path: String) {\n    let _ = app.emit(\n        \"index_progress\",\n        IndexProgressEvent {\n            scanned,\n            indexed,\n            current_path,\n        },\n    );\n}\n\npub(crate) fn set_state(state: &AppState, next: IndexState, message: Option<String>) {\n    let mut status = state.status.lock();\n    status.state = next;\n    status.message = message;\n}\n\npub(crate) fn set_progress(state: &AppState, scanned: u64, indexed: u64, current_path: &str) {\n    let mut status = state.status.lock();\n    status.scanned = scanned;\n    status.indexed = indexed;\n    status.current_path = current_path.to_string();\n}\n\nfn emit_status_counts(app: &AppHandle, state: &AppState) {\n    let status = state.status.lock();\n    emit_index_updated(\n        app,\n        status.entries_count,\n        status.last_updated.unwrap_or_else(now_epoch),\n        status.permission_errors,\n    );\n}\n\npub(crate) fn refresh_and_emit_status_counts(app: &AppHandle, state: &AppState) -> AppResult<()> {\n    let (entries_count, last_updated) = update_status_counts(state)?;\n    // Persist cached counts so next startup can read them instantly\n    if let Ok(conn) = db_connection(&state.db_path) {\n        let _ = set_meta(&conn, \"cached_entries_count\", &entries_count.to_string());\n        if let Some(lu) = last_updated {\n            let _ = set_meta(&conn, \"cached_last_updated\", &lu.to_string());\n        }\n    }\n    emit_status_counts(app, state);\n    Ok(())\n}\n\n/// Load cached entries count from meta table (instant) and emit Ready state + counts.\n/// Used on Windows startup paths where the index is already complete from a prior run.\n#[cfg(target_os = \"windows\")]\npub(crate) fn set_ready_with_cached_counts(app: &AppHandle, state: &AppState) {\n    let (count, last_updated) = db_connection(&state.db_path)\n        .ok()\n        .map(|conn| {\n            let c = get_meta(&conn, \"cached_entries_count\")\n                .and_then(|v| v.parse::<u64>().ok())\n                .unwrap_or(0);\n            let lu = get_meta(&conn, \"cached_last_updated\")\n                .and_then(|v| v.parse::<i64>().ok());\n            (c, lu)\n        })\n        .unwrap_or((0, None));\n\n    {\n        let mut status = state.status.lock();\n        status.state = IndexState::Ready;\n        status.entries_count = count;\n        status.last_updated = last_updated;\n    }\n\n    emit_index_state(app, \"Ready\", None);\n    emit_index_updated(app, count, last_updated.unwrap_or_else(now_epoch), 0);\n}\n\n#[cfg(target_os = \"macos\")]\nfn touch_status_updated(state: &AppState) {\n    state.status.lock().last_updated = Some(now_epoch());\n}\n\n#[cfg(not(target_os = \"windows\"))]\npub(crate) fn start_full_index_worker(app: AppHandle, state: AppState) -> AppResult<()> {\n    start_full_index_worker_inner(app, state, false)\n}\n\n#[cfg(target_os = \"windows\")]\npub(crate) fn start_full_index_worker_silent(app: AppHandle, state: AppState) -> AppResult<()> {\n    start_full_index_worker_inner(app, state, true)\n}\n\nfn start_full_index_worker_inner(app: AppHandle, state: AppState, silent: bool) -> AppResult<()> {\n    if state\n        .indexing_active\n        .compare_exchange(false, true, AtomicOrdering::AcqRel, AtomicOrdering::Acquire)\n        .is_err()\n    {\n        perf_log(\"index_start_skipped already_active=true\");\n        return Ok(());\n    }\n\n    // Mark index as incomplete -- cleared when run_incremental_index succeeds\n    if let Ok(c) = db_connection(&state.db_path) {\n        let _ = set_meta(&c, \"index_complete\", \"0\");\n    }\n\n    if !silent {\n        {\n            let mut status = state.status.lock();\n            status.state = IndexState::Indexing;\n            status.message = None;\n            status.scanned = 0;\n            status.indexed = 0;\n            status.current_path.clear();\n        }\n\n        emit_index_state(&app, \"Indexing\", None);\n        perf_log(\"index_state=Indexing\");\n    } else {\n        perf_log(\"index_start silent=true (background reindex)\");\n    }\n\n    std::thread::spawn(move || {\n        let result = run_incremental_index(&app, &state);\n        if let Err(ref err) = result {\n            eprintln!(\"[index] run_incremental_index failed: {err}\");\n            if !silent {\n                set_state(&state, IndexState::Error, Some(err.clone()));\n                emit_index_state(&app, \"Error\", Some(err.clone()));\n            }\n            // Silent mode: keep Ready state, just log the error\n        }\n        state.indexing_active.store(false, AtomicOrdering::Release);\n    });\n\n    Ok(())\n}\n\nfn is_deferred_dir(path: &Path, home_dir: &Path) -> bool {\n    path.parent() == Some(home_dir)\n        && path\n            .file_name()\n            .and_then(|n| n.to_str())\n            .map(|name| DEFERRED_DIR_NAMES.contains(&name))\n            .unwrap_or(false)\n}\n\nfn preload_existing_entries(\n    conn: &Connection,\n    dir_prefix: &str,\n) -> HashMap<String, (Option<i64>, Option<i64>)> {\n    let like_pattern = format!(\"{}/%\", escape_like(dir_prefix));\n    let mut stmt = match conn.prepare(\n        \"SELECT path, mtime, size FROM entries WHERE path LIKE ?1 ESCAPE '\\\\' OR path = ?2\",\n    ) {\n        Ok(s) => s,\n        Err(_) => return HashMap::new(),\n    };\n\n    let mut map = HashMap::new();\n    let rows = match stmt.query_map(params![like_pattern, dir_prefix], |row| {\n        Ok((\n            row.get::<_, String>(0)?,\n            row.get::<_, Option<i64>>(1)?,\n            row.get::<_, Option<i64>>(2)?,\n        ))\n    }) {\n        Ok(r) => r,\n        Err(_) => return map,\n    };\n\n    for row in rows.flatten() {\n        map.insert(row.0, (row.1, row.2));\n    }\n    map\n}\n\nfn stamp_run_id_batch(conn: &mut Connection, paths: &[String], run_id: i64) -> AppResult<()> {\n    if paths.is_empty() {\n        return Ok(());\n    }\n\n    let tx = conn.transaction().map_err(|e| e.to_string())?;\n    {\n        let mut stmt = tx\n            .prepare(\"UPDATE entries SET run_id = ?1 WHERE path = ?2\")\n            .map_err(|e| e.to_string())?;\n        for path in paths {\n            stmt.execute(params![run_id, path])\n                .map_err(|e| e.to_string())?;\n        }\n    }\n    tx.commit().map_err(|e| e.to_string())?;\n    Ok(())\n}\n\nfn run_incremental_index(app: &AppHandle, state: &AppState) -> AppResult<()> {\n    let started = Instant::now();\n    perf_log(format!(\n        \"index_run_start home={} db={}\",\n        state.home_dir.to_string_lossy(),\n        state.db_path.to_string_lossy(),\n    ));\n\n    let mut conn = db_connection(&state.db_path)?;\n    set_indexing_pragmas(&conn)?;\n\n    // For fresh index (empty DB), drop secondary indexes before bulk insert and\n    // recreate them after. This avoids per-row BTREE maintenance on every insert,\n    // which can be 3-5x faster when loading hundreds of thousands of rows.\n    let is_fresh_run: bool = get_meta(&conn, \"last_run_id\")\n        .and_then(|v| v.parse::<i64>().ok())\n        .unwrap_or(0)\n        == 0;\n    if is_fresh_run {\n        let _ = conn.execute_batch(\n            \"DROP INDEX IF EXISTS idx_entries_dir_ext_name_nocase;\n             DROP INDEX IF EXISTS idx_entries_mtime;\n             DROP INDEX IF EXISTS idx_entries_name_nocase;\n             DROP INDEX IF EXISTS idx_entries_ext_name;\",\n        );\n    }\n\n    let result = run_incremental_index_inner(app, state, &mut conn);\n\n    if is_fresh_run {\n        let _ = conn.execute_batch(\n            \"CREATE INDEX IF NOT EXISTS idx_entries_dir_ext_name_nocase ON entries(dir, ext, name COLLATE NOCASE);\n             CREATE INDEX IF NOT EXISTS idx_entries_mtime ON entries(mtime);\n             CREATE INDEX IF NOT EXISTS idx_entries_name_nocase ON entries(name COLLATE NOCASE);\n             CREATE INDEX IF NOT EXISTS idx_entries_ext_name ON entries(ext, name COLLATE NOCASE);\",\n        );\n    }\n\n    let _ = conn.execute_batch(\"ANALYZE\");\n    let _ = restore_normal_pragmas(&conn);\n\n    match &result {\n        Ok(_) => {\n            let _ = set_meta(&conn, \"index_complete\", \"1\");\n            let snapshot = state.status.lock().clone();\n            perf_log(format!(\n                \"index_run_done elapsed_ms={} scanned={} indexed={} entries={} permission_errors={} message={:?}\",\n                started.elapsed().as_millis(),\n                snapshot.scanned,\n                snapshot.indexed,\n                snapshot.entries_count,\n                snapshot.permission_errors,\n                snapshot.message,\n            ));\n        }\n        Err(err) => {\n            perf_log(format!(\n                \"index_run_error elapsed_ms={} err={}\",\n                started.elapsed().as_millis(),\n                err,\n            ));\n        }\n    }\n\n    result\n}\n\nfn run_incremental_index_inner(\n    app: &AppHandle,\n    state: &AppState,\n    conn: &mut Connection,\n) -> AppResult<()> {\n\n    let (runtime_ignored_roots, runtime_ignored_patterns) = effective_ignore_rules(\n        &state.home_dir,\n        &state.cwd,\n        state.path_ignores.as_ref(),\n        state.path_ignore_patterns.as_ref(),\n    );\n    let gi_filter = state.gitignore.get();\n\n    let last_run_id: i64 = get_meta(conn, \"last_run_id\")\n        .and_then(|v| v.parse().ok())\n        .unwrap_or(0);\n    let current_run_id = last_run_id + 1;\n    // Fresh index: DB was empty, skip preload/stamp, single unlimited-depth pass\n    let is_fresh = last_run_id == 0;\n\n    // Fresh index has no secondary indexes to maintain, so we can use larger\n    // batches to reduce transaction overhead (fewer commits = faster).\n    let flush_batch_size = if is_fresh { BATCH_SIZE * 5 } else { BATCH_SIZE };\n\n    let mut scanned: u64 = 0;\n    let mut indexed: u64 = 0;\n    let mut permission_errors: u64 = 0;\n    let mut current_path = String::new();\n    let mut batch: Vec<IndexRow> = Vec::with_capacity(flush_batch_size);\n    let mut stamp_batch: Vec<String> = Vec::with_capacity(flush_batch_size);\n    let mut last_emit = Instant::now();\n    let mut last_perf_emit = Instant::now();\n\n    // Preload scan_root-level entries (direct children only, not recursive)\n    let scan_str = state.scan_root.to_string_lossy().to_string();\n    let root_existing = preload_existing_entries(conn, &scan_str);\n\n    // Index scan_root itself\n    if let Some(mut row) = index_row_from_path(&state.scan_root) {\n        scanned += 1;\n        row.run_id = current_run_id;\n        if let Some((old_mtime, old_size)) = root_existing.get(&row.path) {\n            if *old_mtime == row.mtime && *old_size == row.size {\n                stamp_batch.push(row.path);\n            } else {\n                batch.push(row);\n            }\n        } else {\n            batch.push(row);\n        }\n    }\n\n    // Partition direct children into priority vs deferred\n    let mut priority_roots: Vec<PathBuf> = Vec::new();\n    let mut deferred_roots: Vec<PathBuf> = Vec::new();\n\n    if let Ok(entries) = fs::read_dir(&state.scan_root) {\n        for dir_entry in entries.flatten() {\n            let child_path = dir_entry.path();\n\n            if should_skip_path_ext(\n                &child_path,\n                &runtime_ignored_roots,\n                &runtime_ignored_patterns,\n                Some(&gi_filter),\n                None,\n            ) {\n                continue;\n            }\n\n            scanned += 1;\n            current_path = child_path.to_string_lossy().to_string();\n\n            if let Some(mut row) = index_row_from_path(&child_path) {\n                row.run_id = current_run_id;\n                if let Some((old_mtime, old_size)) = root_existing.get(&row.path) {\n                    if *old_mtime == row.mtime && *old_size == row.size {\n                        stamp_batch.push(row.path);\n                    } else {\n                        batch.push(row);\n                    }\n                } else {\n                    batch.push(row);\n                }\n            }\n\n            if child_path.is_dir() {\n                if is_deferred_dir(&child_path, &state.scan_root) {\n                    deferred_roots.push(child_path);\n                } else {\n                    priority_roots.push(child_path);\n                }\n            }\n        }\n    }\n\n\n    // Flush home-level stamp batch\n    if stamp_batch.len() >= BATCH_SIZE {\n        stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n        stamp_batch.clear();\n    }\n\n    priority_roots.sort();\n    deferred_roots.sort();\n\n    let roots: Vec<PathBuf> = priority_roots.into_iter().chain(deferred_roots).collect();\n    perf_log(format!(\n        \"index_scan_roots total={} priority+deferred\",\n        roots.len()\n    ));\n\n    // 2-pass indexing: shallow first (depth <= SHALLOW_SCAN_DEPTH), then deep\n    // Both passes use jwalk for parallel scanning\n    let arc_ignored_roots = Arc::new(runtime_ignored_roots.clone());\n    let arc_ignored_patterns = Arc::new(runtime_ignored_patterns.clone());\n\n\n    for pass in 0..2u8 {\n        // Fresh index: single unlimited-depth pass -- avoids double filesystem traversal\n        if pass == 1 && is_fresh {\n            break;\n        }\n        let pass_label = if pass == 0 { \"shallow\" } else { \"deep\" };\n        let pass_started = Instant::now();\n        let mut pass_scanned = 0u64;\n        let mut pass_indexed = 0u64;\n\n        for root in &roots {\n            let root_started = Instant::now();\n            let mut root_scanned = 0u64;\n            let mut root_indexed = 0u64;\n            let mut root_permission_errors = 0u64;\n            let root_str = root.to_string_lossy().to_string();\n\n            // Fresh index: DB is empty, preload is unnecessary\n            let existing = if is_fresh {\n                HashMap::new()\n            } else {\n                let e = preload_existing_entries(conn, &root_str);\n                e\n            };\n\n            let gi_ref = gi_filter.clone();\n            let skip_roots = arc_ignored_roots.clone();\n            let skip_patterns = arc_ignored_patterns.clone();\n\n            let mut builder = jwalk::WalkDir::new(root)\n                .follow_links(false)\n                .skip_hidden(false)\n                .parallelism(jwalk::Parallelism::RayonNewPool(jwalk_num_threads()));\n            // Fresh index: no depth limit -- walk everything in one pass\n            if pass == 0 && !is_fresh {\n                builder = builder.max_depth(SHALLOW_SCAN_DEPTH);\n            }\n            let walker = builder.process_read_dir(move |_depth, path, _state, children| {\n                children.retain(|entry_result| {\n                    entry_result\n                        .as_ref()\n                        .map(|entry| {\n                            let full_path = path.join(&entry.file_name);\n                            let is_dir = Some(entry.file_type.is_dir());\n                            !should_skip_path_ext(\n                                &full_path,\n                                &skip_roots,\n                                &skip_patterns,\n                                Some(&gi_ref),\n                                is_dir,\n                            )\n                        })\n                        .unwrap_or(false)\n                });\n            });\n\n            for result in walker {\n                match result {\n                    Ok(entry) => {\n                        let path = entry.path();\n                        if path == root.as_path() {\n                            continue;\n                        }\n\n                        // Pass 1 (incremental only): skip shallow entries already indexed in pass 0\n                        if pass == 1 && entry.depth <= SHALLOW_SCAN_DEPTH {\n                            continue;\n                        }\n\n                        scanned += 1;\n                        root_scanned += 1;\n                        current_path = path.to_string_lossy().to_string();\n\n                        if let Some(mut row) = index_row_from_jwalk_entry(&entry) {\n                            row.run_id = current_run_id;\n                            if is_fresh {\n                                // Fresh index: all entries are new, skip existing check\n                                indexed += 1;\n                                root_indexed += 1;\n                                batch.push(row);\n                            } else if let Some((old_mtime, old_size)) = existing.get(&row.path) {\n                                if *old_mtime == row.mtime && *old_size == row.size {\n                                    stamp_batch.push(row.path);\n                                } else {\n                                    indexed += 1;\n                                    root_indexed += 1;\n                                    batch.push(row);\n                                }\n                            } else {\n                                indexed += 1;\n                                root_indexed += 1;\n                                batch.push(row);\n                            }\n                        }\n\n                        if batch.len() >= BATCH_SIZE {\n                            upsert_rows(conn, &batch)?;\n                            batch.clear();\n                        }\n\n                        if stamp_batch.len() >= BATCH_SIZE {\n                            stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n                            stamp_batch.clear();\n                        }\n\n                        if last_emit.elapsed() >= Duration::from_millis(200) {\n                            set_progress(state, scanned, indexed, &current_path);\n                            emit_index_progress(app, scanned, indexed, current_path.clone());\n                            last_emit = Instant::now();\n                        }\n                        if perf_log_enabled() && last_perf_emit.elapsed() >= Duration::from_secs(1)\n                        {\n                            perf_log(format!(\n                                \"index_progress pass={} scanned={} indexed={} current_path={}\",\n                                pass_label, scanned, indexed, current_path\n                            ));\n                            last_perf_emit = Instant::now();\n                        }\n                    }\n                    Err(err) => {\n                        scanned += 1;\n                        root_scanned += 1;\n                        permission_errors += 1;\n                        root_permission_errors += 1;\n                        if permission_errors <= 20 || perf_log_enabled() {\n                            eprintln!(\"[index] permission error: {}\", err);\n                        }\n                    }\n                }\n            }\n\n            pass_scanned += root_scanned;\n            pass_indexed += root_indexed;\n\n            eprintln!(\"[timing]   walk_{} {} {}ms scanned={} indexed={} err={}\",\n                pass_label, root_str, root_started.elapsed().as_millis(),\n                root_scanned, root_indexed, root_permission_errors);\n            perf_log(format!(\n                \"index_root_done pass={} root={} elapsed_ms={} scanned={} indexed={} permission_errors={}\",\n                pass_label,\n                root.to_string_lossy(),\n                root_started.elapsed().as_millis(),\n                root_scanned,\n                root_indexed,\n                root_permission_errors,\n            ));\n        }\n\n        // Flush between passes\n        if !batch.is_empty() {\n            upsert_rows(conn, &batch)?;\n            batch.clear();\n        }\n        if !stamp_batch.is_empty() {\n            stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n            stamp_batch.clear();\n        }\n\n        perf_log(format!(\n            \"index_pass_done pass={} elapsed_ms={} scanned={} indexed={}\",\n            pass_label,\n            pass_started.elapsed().as_millis(),\n            pass_scanned,\n            pass_indexed,\n        ));\n\n        // After shallow pass (incremental only), emit progress so UI shows searchable state early\n        // Fresh index uses per-root emit above instead.\n        if pass == 0 && !is_fresh {\n            let _ = refresh_and_emit_status_counts(app, state);\n            let _ = app.emit(\n                \"index_updated\",\n                IndexUpdatedEvent {\n                    entries_count: state.status.lock().entries_count,\n                    last_updated: now_epoch(),\n                    permission_errors,\n                },\n            );\n        }\n    }\n\n    if !batch.is_empty() {\n        upsert_rows(conn, &batch)?;\n    }\n\n    if !stamp_batch.is_empty() {\n        stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n    }\n\n    set_progress(state, scanned, indexed, &current_path);\n    emit_index_progress(app, scanned, indexed, current_path.clone());\n\n    // Remove entries not seen in this run (deleted files)\n    // Fresh index: DB was empty before this run, no stale entries possible\n    let deleted_count: i64 = if is_fresh {\n        0\n    } else {\n        let count = conn\n            .query_row(\n                \"SELECT COUNT(*) FROM entries WHERE run_id < ?1\",\n                params![current_run_id],\n                |row| row.get(0),\n            )\n            .unwrap_or(0);\n        conn.execute(\n            \"DELETE FROM entries WHERE run_id < ?1\",\n            params![current_run_id],\n        )\n        .map_err(|e| e.to_string())?;\n        count\n    };\n\n    set_meta(conn, \"last_run_id\", &current_run_id.to_string())?;\n\n    if deleted_count > 0 || indexed > 0 {\n        invalidate_search_caches(state);\n    }\n\n    let (entries_count, last_updated) = update_status_counts(state)?;\n    // Persist cached counts for instant startup next time\n    let _ = set_meta(conn, \"cached_entries_count\", &entries_count.to_string());\n    if let Some(lu) = last_updated {\n        let _ = set_meta(conn, \"cached_last_updated\", &lu.to_string());\n    }\n    let updated_at = last_updated.unwrap_or_else(now_epoch);\n\n    {\n        let mut status = state.status.lock();\n        status.state = IndexState::Ready;\n        status.permission_errors = permission_errors;\n        status.scanned = scanned;\n        status.indexed = indexed;\n        status.current_path = current_path.clone();\n        status.message = if permission_errors > 0 {\n            Some(format!(\n                \"{} permission/access error(s) occurred.\",\n                permission_errors\n            ))\n        } else {\n            None\n        };\n    }\n    emit_index_progress(app, scanned, indexed, current_path);\n    emit_index_updated(app, entries_count, updated_at, permission_errors);\n    emit_index_state(\n        app,\n        \"Ready\",\n        if permission_errors > 0 {\n            Some(format!(\"{} permission/access error(s)\", permission_errors))\n        } else {\n            None\n        },\n    );\n    perf_log(format!(\n        \"index_state=Ready scanned={} indexed={} deleted={} entries={} permission_errors={}\",\n        scanned, indexed, deleted_count, entries_count, permission_errors\n    ));\n\n    Ok(())\n}\n\nfn trim_recent_ops(ops: &mut Vec<RecentOp>) {\n    let now = Instant::now();\n    ops.retain(|op| now.duration_since(op.at) <= RECENT_OP_TTL);\n}\n\nfn remember_op(\n    state: &AppState,\n    op_type: &'static str,\n    old_path: Option<String>,\n    new_path: Option<String>,\n) {\n    let mut ops = state.recent_ops.lock();\n    trim_recent_ops(&mut ops);\n    ops.push(RecentOp {\n        old_path,\n        new_path,\n        op_type,\n        at: Instant::now(),\n    });\n}\n\n#[cfg(any(target_os = \"macos\", target_os = \"windows\"))]\npub(crate) fn is_recently_touched(state: &AppState, path: &str) -> bool {\n    let mut ops = state.recent_ops.lock();\n    trim_recent_ops(&mut ops);\n\n    ops.iter().any(|op| match op.op_type {\n        \"rename\" | \"trash\" => {\n            op.old_path\n                .as_deref()\n                .map(|old| old == path)\n                .unwrap_or(false)\n                || op\n                    .new_path\n                    .as_deref()\n                    .map(|new| new == path)\n                    .unwrap_or(false)\n        }\n        _ => false,\n    })\n}\n\n#[cfg(target_os = \"macos\")]\nfn apply_path_changes(state: &AppState, paths: &[PathBuf]) -> AppResult<usize> {\n    let (ignored_roots, ignored_patterns) = cached_effective_ignore_rules(state);\n    let mut to_upsert_map: HashMap<String, IndexRow> = HashMap::new();\n    let mut to_delete = Vec::new();\n\n    for path in paths {\n        if should_skip_path(path, &ignored_roots, &ignored_patterns) {\n            continue;\n        }\n\n        let path_str = path.to_string_lossy().to_string();\n        if path_str.is_empty() {\n            continue;\n        }\n\n        if is_recently_touched(state, &path_str) {\n            continue;\n        }\n\n        match fs::symlink_metadata(path) {\n            Ok(metadata) => {\n                if let Some(row) = index_row_from_path_and_metadata(path, &metadata) {\n                    to_upsert_map.insert(row.path.clone(), row);\n                }\n            }\n            Err(_) => {\n                to_delete.push(path_str);\n            }\n        }\n    }\n\n    let to_upsert = to_upsert_map.into_values().collect::<Vec<_>>();\n\n    if to_upsert.is_empty() && to_delete.is_empty() {\n        return Ok(0);\n    }\n\n    let op_start = std::time::Instant::now();\n    let mut conn = db_connection(&state.db_path).map_err(|e| {\n        eprintln!(\n            \"[watcher] db_connection FAILED after {}ms: {} (upsert={} delete={} indexing_active={})\",\n            op_start.elapsed().as_millis(),\n            e,\n            to_upsert.len(),\n            to_delete.len(),\n            state.indexing_active.load(AtomicOrdering::Acquire)\n        );\n        e\n    })?;\n    let mut changed = 0;\n\n    changed += upsert_rows(&mut conn, &to_upsert)?;\n    changed += delete_paths(&mut conn, &to_delete)?;\n\n    Ok(changed)\n}\n\n#[cfg(target_os = \"macos\")]\nconst STATUS_EMIT_MIN_INTERVAL: Duration = Duration::from_secs(2);\n\n#[cfg(target_os = \"macos\")]\nconst DB_BUSY_RETRY_DELAY: Duration = Duration::from_secs(3);\n\n#[cfg(target_os = \"macos\")]\nfn process_watcher_paths(\n    app: &AppHandle,\n    state: &AppState,\n    pending: &mut HashSet<PathBuf>,\n    deadline: &mut Option<Instant>,\n    last_status_emit: &mut Instant,\n    pending_status_emit: &mut bool,\n) {\n    if pending.is_empty() {\n        return;\n    }\n\n    if state.indexing_active.load(AtomicOrdering::Acquire) {\n        return;\n    }\n\n    let mut batch: Vec<PathBuf> = pending.drain().collect();\n    batch.sort();\n\n    match apply_path_changes(state, &batch) {\n        Ok(changed) => {\n            *deadline = None;\n            if changed > 0 {\n                invalidate_search_caches(state);\n                touch_status_updated(state);\n                if last_status_emit.elapsed() >= STATUS_EMIT_MIN_INTERVAL {\n                    let _ = refresh_and_emit_status_counts(app, state);\n                    *last_status_emit = Instant::now();\n                    *pending_status_emit = false;\n                } else {\n                    *pending_status_emit = true;\n                }\n            }\n        }\n        Err(err) => {\n            let is_busy = err.contains(\"locked\") || err.contains(\"busy\");\n            if is_busy {\n                eprintln!(\n                    \"[watcher] DB busy, will retry in {}s: {} | batch_size={}\",\n                    DB_BUSY_RETRY_DELAY.as_secs(),\n                    err,\n                    batch.len()\n                );\n                for path in batch {\n                    pending.insert(path);\n                }\n                *deadline = Some(Instant::now() + DB_BUSY_RETRY_DELAY);\n                return;\n            }\n            eprintln!(\n                \"[watcher] process_watcher_paths ERROR: {} | batch_size={} indexing_active={}\",\n                err,\n                batch.len(),\n                state.indexing_active.load(AtomicOrdering::Acquire)\n            );\n            *deadline = None;\n            if state.indexing_active.load(AtomicOrdering::Acquire) {\n                return;\n            }\n            let mut status = state.status.lock();\n            if !matches!(status.state, IndexState::Indexing) {\n                status.state = IndexState::Error;\n            }\n            status.message = Some(format!(\"Watcher update failed: {err}\"));\n            drop(status);\n            emit_index_state(app, \"Error\", Some(format!(\"Watcher update failed: {err}\")));\n        }\n    }\n}\n\n#[cfg(target_os = \"macos\")]\nconst EVENT_ID_FLUSH_INTERVAL: Duration = Duration::from_secs(30);\n\n#[cfg(target_os = \"macos\")]\nfn persist_event_id(db_path: &Path, event_id: u64) -> AppResult<()> {\n    let conn = db_connection(db_path)?;\n    set_meta(&conn, \"last_event_id\", &event_id.to_string())\n}\n\n#[cfg(target_os = \"macos\")]\nconst MUST_SCAN_THRESHOLD: usize = 10;\n\n#[cfg(target_os = \"macos\")]\nfn start_fsevent_watcher_worker(\n    app: AppHandle,\n    state: AppState,\n    since_event_id: Option<u64>,\n    conditional: bool,\n) {\n    use std::sync::mpsc::{self, RecvTimeoutError};\n    std::thread::spawn(move || {\n        let (tx, rx) = mpsc::channel();\n\n        let mut watcher =\n            match mac::fsevent_watcher::FsEventWatcher::new(&state.home_dir, since_event_id, tx) {\n                Ok(w) => w,\n                Err(err) => {\n                    set_state(\n                        &state,\n                        IndexState::Error,\n                        Some(format!(\"FSEvents watcher initialization failed: {err}\")),\n                    );\n                    emit_index_state(\n                        &app,\n                        \"Error\",\n                        Some(format!(\"FSEvents watcher initialization failed: {err}\")),\n                    );\n                    return;\n                }\n            };\n\n        if conditional {\n            perf_log(\"conditional_startup: watcher started, awaiting history replay\");\n            set_state(&state, IndexState::Ready, None);\n            emit_index_state(&app, \"Ready\", None);\n        }\n\n        let mut pending_paths: HashSet<PathBuf> = HashSet::new();\n        let mut deadline: Option<Instant> = None;\n        let mut last_flush = Instant::now();\n        let mut last_status_emit = Instant::now();\n        let mut pending_status_emit = false;\n        let mut last_count_refresh = Instant::now();\n        let mut must_scan_count: usize = 0;\n        let mut replay_phase = conditional;\n        let mut full_scan_triggered = false;\n\n        loop {\n            let wait = match deadline {\n                Some(due) => {\n                    let now = Instant::now();\n                    if now >= due {\n                        Duration::from_millis(0)\n                    } else {\n                        due - now\n                    }\n                }\n                None => Duration::from_secs(1),\n            };\n            match rx.recv_timeout(wait) {\n                Ok(mac::fsevent_watcher::FsEvent::Paths(paths)) => {\n                    let (ignored_roots, ignored_patterns) = cached_effective_ignore_rules(&state);\n                    let prev_len = pending_paths.len();\n                    for path in paths {\n                        if !should_skip_path(&path, &ignored_roots, &ignored_patterns) {\n                            pending_paths.insert(path);\n                        }\n                    }\n                    if pending_paths.len() > prev_len {\n                        deadline = Some(Instant::now() + WATCH_DEBOUNCE);\n                    }\n                }\n                Ok(mac::fsevent_watcher::FsEvent::MustScanSubDirs(path)) => {\n                    must_scan_count += 1;\n                    if replay_phase\n                        && must_scan_count >= MUST_SCAN_THRESHOLD\n                        && !full_scan_triggered\n                    {\n                        perf_log(format!(\n                            \"conditional_startup: MustScanSubDirs={} >= threshold, triggering full scan\",\n                            must_scan_count\n                        ));\n                        full_scan_triggered = true;\n                        let _ = start_full_index_worker(app.clone(), state.clone());\n                    }\n                    if !state.indexing_active.load(AtomicOrdering::Acquire) {\n                        let (ignored_roots, ignored_patterns) =\n                            cached_effective_ignore_rules(&state);\n                        let rows = collect_rows_recursive(&path, &ignored_roots, &ignored_patterns);\n                        if !rows.is_empty() {\n                            eprintln!(\n                                \"[watcher] MustScanSubDirs DB write: rows={} path={}\",\n                                rows.len(),\n                                path.display()\n                            );\n                            if let Ok(mut conn) = db_connection(&state.db_path) {\n                                if upsert_rows(&mut conn, &rows).is_ok() {\n                                    invalidate_search_caches(&state);\n                                    touch_status_updated(&state);\n                                    if last_status_emit.elapsed() >= STATUS_EMIT_MIN_INTERVAL {\n                                        let _ = refresh_and_emit_status_counts(&app, &state);\n                                        last_status_emit = Instant::now();\n                                        pending_status_emit = false;\n                                    } else {\n                                        pending_status_emit = true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                Ok(mac::fsevent_watcher::FsEvent::HistoryDone) => {\n                    eprintln!(\n                        \"[watcher] HistoryDone: pending_paths={} indexing_active={}\",\n                        pending_paths.len(),\n                        state.indexing_active.load(AtomicOrdering::Acquire)\n                    );\n                    process_watcher_paths(\n                        &app,\n                        &state,\n                        &mut pending_paths,\n                        &mut deadline,\n                        &mut last_status_emit,\n                        &mut pending_status_emit,\n                    );\n                    if replay_phase {\n                        replay_phase = false;\n                        if !full_scan_triggered {\n                            perf_log(format!(\n                                \"conditional_startup: HistoryDone, MustScanSubDirs={}, skipping full scan\",\n                                must_scan_count\n                            ));\n                            let _ = refresh_and_emit_status_counts(&app, &state);\n                            last_status_emit = Instant::now();\n                            pending_status_emit = false;\n                        }\n                    }\n                }\n                Err(RecvTimeoutError::Timeout) => {}\n                Err(RecvTimeoutError::Disconnected) => break,\n            }\n\n            if let Some(due) = deadline {\n                if Instant::now() >= due {\n                    process_watcher_paths(\n                        &app,\n                        &state,\n                        &mut pending_paths,\n                        &mut deadline,\n                        &mut last_status_emit,\n                        &mut pending_status_emit,\n                    );\n                }\n            }\n\n            if pending_status_emit && last_status_emit.elapsed() >= STATUS_EMIT_MIN_INTERVAL {\n                let _ = refresh_and_emit_status_counts(&app, &state);\n                last_status_emit = Instant::now();\n                pending_status_emit = false;\n            }\n\n            // Periodic event_id flush\n            if last_flush.elapsed() >= EVENT_ID_FLUSH_INTERVAL {\n                let eid = watcher.last_event_id();\n                let _ = persist_event_id(&state.db_path, eid);\n                last_flush = Instant::now();\n            }\n\n            // Periodic count refresh to keep in-memory counts accurate\n            if last_count_refresh.elapsed() >= EVENT_ID_FLUSH_INTERVAL {\n                let _ = update_status_counts(&state);\n                last_count_refresh = Instant::now();\n            }\n        }\n\n        // Final flush on shutdown\n        let eid = watcher.last_event_id();\n        let _ = persist_event_id(&state.db_path, eid);\n        watcher.stop();\n    });\n}\n\nfn validate_new_name(new_name: &str) -> AppResult<String> {\n    let trimmed = new_name.trim();\n\n    if trimmed.is_empty() {\n        return Err(\"New name cannot be empty.\".to_string());\n    }\n    if trimmed.contains('/') {\n        return Err(\"New name cannot contain '/'.\".to_string());\n    }\n    if trimmed == \".\" || trimmed == \"..\" {\n        return Err(\"Invalid name.\".to_string());\n    }\n\n    Ok(trimmed.to_string())\n}\n\nfn row_to_entry(row: &rusqlite::Row<'_>) -> rusqlite::Result<EntryDto> {\n    Ok(EntryDto {\n        path: row.get(0)?,\n        name: row.get(1)?,\n        dir: row.get(2)?,\n        is_dir: row.get::<_, i64>(3)? == 1,\n        ext: row.get(4)?,\n        size: row.get(5)?,\n        mtime: row.get(6)?,\n    })\n}\n\n#[cfg(target_os = \"macos\")]\nfn safe_file_type(ext: &str) -> String {\n    if ext.eq_ignore_ascii_case(\"folder\") {\n        return \"public.folder\".to_string();\n    }\n\n    let filtered: String = ext\n        .chars()\n        .filter(|c| c.is_ascii_alphanumeric())\n        .collect::<String>()\n        .to_lowercase();\n\n    if filtered.is_empty() {\n        \"public.data\".to_string()\n    } else {\n        filtered\n    }\n}\n\n#[cfg(target_os = \"macos\")]\nfn load_system_icon_png(ext: &str) -> Option<Vec<u8>> {\n    let file_type = safe_file_type(ext);\n    let script = format!(\n        r#\"import AppKit\nimport Foundation\nlet image = NSWorkspace.shared.icon(forFileType: \"{file_type}\")\nimage.size = NSSize(width: 16, height: 16)\nif let tiff = image.tiffRepresentation,\n   let rep = NSBitmapImageRep(data: tiff),\n   let png = rep.representation(using: .png, properties: [:]) {{\n  FileHandle.standardOutput.write(png)\n}} else {{\n  exit(1)\n}}\n\"#\n    );\n\n    let output = Command::new(\"swift\").arg(\"-e\").arg(script).output().ok()?;\n    if output.status.success() && !output.stdout.is_empty() {\n        Some(output.stdout)\n    } else {\n        None\n    }\n}\n\n#[cfg(target_os = \"windows\")]\nfn load_system_icon_png(ext: &str) -> Option<Vec<u8>> {\n    win::icon::load_icon_png_by_ext(ext)\n}\n\n#[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\nfn load_system_icon_png(_ext: &str) -> Option<Vec<u8>> {\n    None\n}\n\n#[cfg(target_os = \"windows\")]\nfn is_per_file_icon_ext(ext: &str) -> bool {\n    matches!(ext, \"exe\" | \"lnk\" | \"ico\" | \"url\" | \"scr\" | \"appx\")\n}\n\n#[tauri::command]\nfn get_index_status(state: State<'_, AppState>) -> IndexStatusDto {\n    let started = Instant::now();\n    let snapshot = state.status.lock().clone();\n    let snapshot_state = snapshot.state.as_str().to_string();\n    let db_ready = state.db_ready.load(AtomicOrdering::Acquire);\n    let indexing_active = state.indexing_active.load(AtomicOrdering::Acquire);\n    let state_label = if matches!(snapshot.state, IndexState::Error) {\n        snapshot.state.as_str().to_string()\n    } else if matches!(snapshot.state, IndexState::Ready) {\n        \"Ready\".to_string()\n    } else if indexing_active || !db_ready {\n        \"Indexing\".to_string()\n    } else {\n        snapshot.state.as_str().to_string()\n    };\n    let dto = IndexStatusDto {\n        state: state_label,\n        entries_count: snapshot.entries_count,\n        last_updated: snapshot.last_updated,\n        permission_errors: snapshot.permission_errors,\n        message: snapshot.message,\n        scanned: snapshot.scanned,\n        indexed: snapshot.indexed,\n        current_path: snapshot.current_path,\n    };\n    if cfg!(debug_assertions) {\n        eprintln!(\n            \"[rpc/get_index_status] elapsed={}ms state={} snapshot_state={} db_ready={} indexing_active={} entries={} scanned={} indexed={}\",\n            started.elapsed().as_millis(),\n            dto.state,\n            snapshot_state,\n            db_ready,\n            indexing_active,\n            dto.entries_count,\n            dto.scanned,\n            dto.indexed,\n        );\n    }\n    dto\n}\n\n#[tauri::command]\nfn get_home_dir(state: State<'_, AppState>) -> String {\n    state.home_dir.to_string_lossy().to_string()\n}\n\n#[tauri::command]\nfn start_full_index(app: AppHandle, state: State<'_, AppState>) -> AppResult<()> {\n    #[cfg(target_os = \"windows\")]\n    {\n        win::start_windows_indexing(app, state.inner().clone());\n        Ok(())\n    }\n    #[cfg(not(target_os = \"windows\"))]\n    {\n        start_full_index_worker(app, state.inner().clone())\n    }\n}\n\n#[tauri::command]\nasync fn reset_index(app: AppHandle, state: State<'_, AppState>) -> AppResult<()> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        if state.indexing_active.load(AtomicOrdering::Acquire) {\n            return Err(\"Cannot reset while indexing is in progress.\".to_string());\n        }\n\n        // Stop existing file watcher and wait for it to fully exit\n        state.watcher_stop.store(true, AtomicOrdering::Release);\n        let deadline = std::time::Instant::now() + std::time::Duration::from_secs(5);\n        while state.watcher_active.load(AtomicOrdering::Acquire) {\n            if std::time::Instant::now() >= deadline {\n                eprintln!(\"[reset] watcher did not stop within 5s, proceeding anyway\");\n                break;\n            }\n            std::thread::sleep(std::time::Duration::from_millis(50));\n        }\n\n        let conn = db_connection(&state.db_path)?;\n        // Use synchronous=OFF + large cache to make the bulk DELETE fast\n        let _ = conn.execute_batch(\n            \"PRAGMA synchronous=OFF; PRAGMA cache_size=-131072;\",\n        );\n        conn.execute(\"DELETE FROM entries\", [])\n            .map_err(|e| e.to_string())?;\n        conn.execute(\"DELETE FROM meta\", [])\n            .map_err(|e| e.to_string())?;\n\n        {\n            let mut status = state.status.lock();\n            status.state = IndexState::Indexing;\n            status.entries_count = 0;\n            status.last_updated = None;\n            status.permission_errors = 0;\n            status.message = None;\n            status.scanned = 0;\n            status.indexed = 0;\n            status.current_path.clear();\n        }\n\n        invalidate_search_caches(&state);\n\n        emit_index_state(&app, \"Indexing\", None);\n        emit_index_updated(&app, 0, now_epoch(), 0);\n\n        // Allow new watcher to start\n        state.watcher_stop.store(false, AtomicOrdering::Release);\n\n        #[cfg(target_os = \"windows\")]\n        {\n            win::start_windows_indexing(app, state);\n            Ok(())\n        }\n        #[cfg(not(target_os = \"windows\"))]\n        {\n            start_full_index_worker(app, state)\n        }\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\nfn log_search(db_path: &Path, query: &str, mode: &str, results: &[EntryDto]) {\n    if !search_log_enabled() {\n        return;\n    }\n\n    let log_path = db_path.with_file_name(\"search.log\");\n    let Ok(mut f) = fs::OpenOptions::new()\n        .create(true)\n        .append(true)\n        .open(&log_path)\n    else {\n        return;\n    };\n    let top: Vec<&str> = results.iter().take(10).map(|e| e.name.as_str()).collect();\n    let _ = writeln!(\n        f,\n        \"[{}] Q={:?} MODE={} COUNT={} TOP={:?}\",\n        now_epoch(),\n        query,\n        mode,\n        results.len(),\n        top,\n    );\n}\n\nfn search_log_enabled() -> bool {\n    *SEARCH_LOG_ENABLED.get_or_init(|| env_truthy(\"FASTFIND_SEARCH_LOG\"))\n}\n\n/// Returns the total number of entries matching `query` without LIMIT/OFFSET.\n/// Returns `None` when the total is unknown or intentionally skipped.\nfn compute_total_count(\n    db_path: &Path,\n    home_dir: &Path,\n    execution: &SearchExecution,\n) -> Option<u32> {\n    // When fewer results than the limit were returned the total is exact.\n    if (execution.results.len() as u32) < execution.effective_limit {\n        return Some(\n            execution\n                .offset\n                .saturating_add(execution.results.len() as u32),\n        );\n    }\n    // For paginated pages after the first we leave total tracking to the frontend.\n    if execution.offset > 0 {\n        return None;\n    }\n    // Non-SQL fast paths already return all matching entries.\n    if execution.mode_label.starts_with(\"mem_\")\n        || execution.mode_label == \"spotlight\"\n        || execution.mode_label == \"spotlight_timeout\"\n        || execution.mode_label == \"find_fallback\"\n        || execution.mode_label == \"name_neg_cache\"\n    {\n        return Some(execution.results.len() as u32);\n    }\n    let Ok(conn) = db_connection_for_search(db_path) else {\n        return None;\n    };\n    let mode = parse_query(&execution.query);\n    let total = match mode {\n        SearchMode::Empty => conn\n            .query_row(\"SELECT COUNT(*) FROM entries\", [], |r| r.get(0))\n            .unwrap_or(0),\n        SearchMode::NameSearch { name_like } => {\n            let escaped = escape_like(&execution.query);\n            let prefix_like = format!(\"{}%\", escaped);\n            let prefix_count: u32 = conn\n                .query_row(\n                    \"SELECT COUNT(*) FROM entries WHERE name LIKE ?1 ESCAPE '\\\\'\",\n                    params![prefix_like],\n                    |r| r.get(0),\n                )\n                .unwrap_or(0);\n            if prefix_count > 0 {\n                prefix_count\n            } else {\n                // Phase-2 contains fallback was used.\n                conn.query_row(\n                    \"SELECT COUNT(*) FROM entries WHERE name LIKE ?1 ESCAPE '\\\\'\",\n                    params![name_like],\n                    |r| r.get(0),\n                )\n                .unwrap_or(0)\n            }\n        }\n        SearchMode::GlobName { name_like } => conn\n            .query_row(\n                \"SELECT COUNT(*) FROM entries WHERE name LIKE ?1 ESCAPE '\\\\'\",\n                params![name_like],\n                |r| r.get(0),\n            )\n            .unwrap_or(0),\n        SearchMode::ExtSearch { ext, .. } => conn\n            .query_row(\n                \"SELECT COUNT(*) FROM entries WHERE ext = ?1\",\n                params![ext],\n                |r| r.get(0),\n            )\n            .unwrap_or(0),\n        SearchMode::PathSearch {\n            name_like,\n            dir_hint,\n            ..\n        } => {\n            let resolved_dirs = resolve_dir_hint(home_dir, &dir_hint)\n                .map(|p| vec![p.to_string_lossy().to_string()])\n                .unwrap_or_default();\n            let resolved_dirs = if resolved_dirs.is_empty() {\n                resolve_dirs_from_db(&conn, &dir_hint)\n            } else {\n                resolved_dirs\n            };\n\n            if !resolved_dirs.is_empty() {\n                let mut sql_params: Vec<SqlValue> = Vec::new();\n                let mut dir_conditions = Vec::new();\n                let sep = std::path::MAIN_SEPARATOR;\n                for d in &resolved_dirs {\n                    let i = sql_params.len();\n                    let pfx = format!(\"{d}{sep}\");\n                    let pfx_end = format!(\"{d}\\x7F\");\n                    sql_params.push(SqlValue::Text(d.clone()));\n                    sql_params.push(SqlValue::Text(pfx));\n                    sql_params.push(SqlValue::Text(pfx_end));\n                    dir_conditions.push(format!(\n                        \"(e.dir = ?{} OR (e.dir >= ?{} AND e.dir < ?{}))\",\n                        i + 1,\n                        i + 2,\n                        i + 3\n                    ));\n                }\n                let dir_where = dir_conditions.join(\" OR \");\n                let name_filter = if name_like == \"%\" {\n                    String::new()\n                } else {\n                    let ext_shortcut = extract_ext_from_like(&name_like);\n                    if let Some(ext_val) = ext_shortcut {\n                        let i = sql_params.len();\n                        sql_params.push(SqlValue::Text(ext_val));\n                        format!(\" AND e.ext = ?{}\", i + 1)\n                    } else {\n                        let i = sql_params.len();\n                        sql_params.push(SqlValue::Text(name_like.clone()));\n                        format!(\" AND e.name LIKE ?{} ESCAPE '\\\\'\", i + 1)\n                    }\n                };\n                let sql =\n                    format!(\"SELECT COUNT(*) FROM entries e WHERE ({dir_where}){name_filter}\");\n                conn.query_row(&sql, params_from_iter(sql_params.iter()), |r| r.get(0))\n                    .unwrap_or(0)\n            } else {\n                let sep = std::path::MAIN_SEPARATOR;\n                let native_hint = dir_hint.replace('/', &sep.to_string());\n                let escaped_sep = escape_like(&sep.to_string());\n                let dir_suffix = escape_like(&native_hint);\n                let dir_like_exact = format!(\"%{escaped_sep}{dir_suffix}\");\n                let dir_like_sub = format!(\"%{escaped_sep}{dir_suffix}{escaped_sep}%\");\n                let ext_shortcut = extract_ext_from_like(&name_like);\n                if let Some(ext_val) = ext_shortcut {\n                    conn.query_row(\n                        \"SELECT COUNT(*) FROM entries e WHERE e.ext = ?1 AND (e.dir LIKE ?2 ESCAPE '\\\\' OR e.dir LIKE ?3 ESCAPE '\\\\')\",\n                        params![ext_val, dir_like_exact, dir_like_sub],\n                        |r| r.get(0),\n                    )\n                    .unwrap_or(0)\n                } else if name_like == \"%\" {\n                    conn.query_row(\n                        \"SELECT COUNT(*) FROM entries e WHERE e.dir LIKE ?1 ESCAPE '\\\\' OR e.dir LIKE ?2 ESCAPE '\\\\'\",\n                        params![dir_like_exact, dir_like_sub],\n                        |r| r.get(0),\n                    )\n                    .unwrap_or(0)\n                } else {\n                    conn.query_row(\n                        \"SELECT COUNT(*) FROM entries e WHERE (e.dir LIKE ?1 ESCAPE '\\\\' OR e.dir LIKE ?2 ESCAPE '\\\\') AND e.name LIKE ?3 ESCAPE '\\\\'\",\n                        params![dir_like_exact, dir_like_sub, name_like],\n                        |r| r.get(0),\n                    )\n                    .unwrap_or(0)\n                }\n            }\n        }\n    };\n\n    Some(total)\n}\n\nfn execute_search(\n    state: &AppState,\n    query: String,\n    limit: Option<u32>,\n    offset: Option<u32>,\n    sort_by: Option<String>,\n    sort_dir: Option<String>,\n) -> AppResult<SearchExecution> {\n    let query = query.trim().to_string();\n    let base_limit = limit.unwrap_or(DEFAULT_LIMIT).clamp(1, MAX_LIMIT);\n    let effective_limit = if !query.is_empty() && query.chars().count() <= 1 {\n        base_limit.min(SHORT_QUERY_LIMIT)\n    } else {\n        base_limit\n    };\n    let offset = offset.unwrap_or(0);\n\n    let sort_by = sort_by.unwrap_or_else(|| \"name\".to_string());\n    let sort_dir = sort_dir.unwrap_or_else(|| \"asc\".to_string());\n    let (runtime_ignored_roots, runtime_ignored_patterns) = cached_effective_ignore_rules(state);\n\n    #[cfg(target_os = \"macos\")]\n    if !state.db_ready.load(AtomicOrdering::Acquire) {\n        let spotlight = mac::spotlight_search::search_spotlight(&state.home_dir, &query);\n        let mode_label = if spotlight.entries.is_empty() {\n            \"db_not_ready\".to_string()\n        } else if spotlight.timed_out {\n            \"spotlight_timeout\".to_string()\n        } else {\n            \"spotlight\".to_string()\n        };\n        perf_log(format!(\n            \"spotlight_fallback db_not_ready query={:?} results={} timed_out={}\",\n            query,\n            spotlight.entries.len(),\n            spotlight.timed_out\n        ));\n        return Ok(SearchExecution {\n            query,\n            sort_by,\n            sort_dir,\n            effective_limit,\n            offset,\n            mode_label,\n            results: spotlight.entries,\n        });\n    }\n\n    let is_indexing = matches!(state.status.lock().state, IndexState::Indexing);\n    let order_by = sort_clause(&sort_by, &sort_dir, \"e.\");\n\n    let mut results = Vec::with_capacity(effective_limit as usize);\n    let mode = parse_query(&query);\n    let is_name_mode = matches!(&mode, SearchMode::NameSearch { .. });\n    let allow_find_fallback = !is_indexing\n        && matches!(\n            &mode,\n            SearchMode::GlobName { .. } | SearchMode::ExtSearch { .. }\n        );\n    let mut mode_label = match &mode {\n        SearchMode::Empty => \"empty\",\n        SearchMode::NameSearch { .. } => \"name\",\n        SearchMode::GlobName { .. } => \"glob\",\n        SearchMode::ExtSearch { .. } => \"ext\",\n        SearchMode::PathSearch { .. } => \"path\",\n    }\n    .to_string();\n\n    // Fast path: search in-memory index if available (DB upsert still in progress)\n    {\n        let guard = state.mem_index.read();\n        if let Some(ref mi) = *guard {\n            let mem_results = mem_search::search_mem_index(\n                mi, &query, &mode, effective_limit, offset, &sort_by, &sort_dir,\n            );\n            mode_label = format!(\"mem_{mode_label}\");\n            return Ok(SearchExecution {\n                query,\n                sort_by,\n                sort_dir,\n                effective_limit,\n                offset,\n                mode_label,\n                results: mem_results,\n            });\n        }\n    }\n\n    if is_name_mode && !is_indexing && offset == 0 {\n        if let Some(cache_hit) = negative_name_cache_lookup(state, &query) {\n            if cache_hit.age >= WATCH_DEBOUNCE\n                && cache_hit.age <= NEGATIVE_CACHE_FALLBACK_WINDOW\n                && !cache_hit.fallback_checked\n            {\n                let fallback_results = find_search(\n                    &state.home_dir,\n                    &runtime_ignored_roots,\n                    &runtime_ignored_patterns,\n                    &query,\n                    effective_limit as usize,\n                    &sort_by,\n                    &sort_dir,\n                );\n                if !fallback_results.is_empty() {\n                    remove_negative_name_query(state, &cache_hit.query_lower);\n                    perf_log(format!(\n                        \"search_negative_cache_fallback_hit query={:?} age_ms={} results={}\",\n                        query,\n                        cache_hit.age.as_millis(),\n                        fallback_results.len()\n                    ));\n                    return Ok(SearchExecution {\n                        query,\n                        sort_by,\n                        sort_dir,\n                        effective_limit,\n                        offset,\n                        mode_label: \"find_fallback\".to_string(),\n                        results: fallback_results,\n                    });\n                }\n                mark_negative_name_fallback_checked(state, &cache_hit.query_lower);\n            }\n\n            perf_log(format!(\n                \"search_negative_cache_hit query={:?} age_ms={}\",\n                query,\n                cache_hit.age.as_millis()\n            ));\n            return Ok(SearchExecution {\n                query,\n                sort_by,\n                sort_dir,\n                effective_limit,\n                offset,\n                mode_label: \"name_neg_cache\".to_string(),\n                results: Vec::new(),\n            });\n        }\n    }\n\n    #[cfg(target_os = \"macos\")]\n    let db_unavailable;\n    match db_connection_for_search(&state.db_path) {\n        Ok(conn) => {\n            #[cfg(target_os = \"macos\")]\n            { db_unavailable = false; }\n            match &mode {\n                SearchMode::Empty => {\n                    let sql = format!(\n                        r#\"\n                        SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                        FROM entries e\n                        ORDER BY {order_by}\n                        LIMIT ?1 OFFSET ?2\n                        \"#,\n                    );\n                    let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                    let rows = stmt\n                        .query_map(params![effective_limit, offset], row_to_entry)\n                        .map_err(|e| e.to_string())?;\n                    for row in rows {\n                        results.push(row.map_err(|e| e.to_string())?);\n                    }\n                }\n\n                SearchMode::NameSearch { name_like } => {\n                    let escaped_query = escape_like(&query);\n                    let exact_query = query.clone();\n                    let prefix_like = format!(\"{}%\", escaped_query);\n                    let bare_order = sort_clause(&sort_by, &sort_dir, \"\");\n\n                    if offset == 0 {\n                        let exact_sql = format!(\n                            r#\"\n                            SELECT path, name, dir, is_dir, ext, size, mtime\n                            FROM entries\n                            WHERE name COLLATE NOCASE = ?1\n                            ORDER BY {bare_order}\n                            LIMIT ?2\n                            \"#,\n                        );\n                        let mut stmt = conn.prepare(&exact_sql).map_err(|e| e.to_string())?;\n                        let rows = stmt\n                            .query_map(params![exact_query, effective_limit], row_to_entry)\n                            .map_err(|e| e.to_string())?;\n                        for row in rows {\n                            results.push(row.map_err(|e| e.to_string())?);\n                        }\n                    }\n\n                    if (results.len() as u32) < effective_limit {\n                        let remaining = effective_limit - results.len() as u32;\n                        let adj_offset = if offset > 0 {\n                            offset.saturating_sub(results.len() as u32)\n                        } else {\n                            0\n                        };\n\n                        // Try indexed prefix search first; fall back to unindexed if\n                        // the index is temporarily unavailable (during background DB\n                        // rebuild the index may be dropped then recreated).\n                        let prefix_sql_indexed = format!(\n                            r#\"\n                            SELECT path, name, dir, is_dir, ext, size, mtime\n                            FROM entries INDEXED BY idx_entries_name_nocase\n                            WHERE name LIKE ?1 ESCAPE '\\'\n                              AND name COLLATE NOCASE != ?2\n                            ORDER BY {bare_order}\n                            LIMIT ?3 OFFSET ?4\n                            \"#,\n                        );\n                        let prefix_sql_fallback = format!(\n                            r#\"\n                            SELECT path, name, dir, is_dir, ext, size, mtime\n                            FROM entries\n                            WHERE name LIKE ?1 ESCAPE '\\'\n                              AND name COLLATE NOCASE != ?2\n                            ORDER BY {bare_order}\n                            LIMIT ?3 OFFSET ?4\n                            \"#,\n                        );\n                        let mut stmt = match conn.prepare(&prefix_sql_indexed) {\n                            Ok(s) => s,\n                            Err(_) => {\n                                eprintln!(\"[search] idx_entries_name_nocase unavailable, using fallback\");\n                                conn.prepare(&prefix_sql_fallback).map_err(|e| e.to_string())?\n                            }\n                        };\n                        let rows = stmt\n                            .query_map(\n                                params![prefix_like, exact_query, remaining, adj_offset],\n                                row_to_entry,\n                            )\n                            .map_err(|e| e.to_string())?;\n                        for row in rows {\n                            results.push(row.map_err(|e| e.to_string())?);\n                        }\n                    }\n\n                    if results.is_empty() && offset == 0 {\n                        // Phase 2: contains-match (LIKE '%q%') with tight time budget.\n                        // Combines probe + fetch in one pass to avoid double scan overhead.\n                        let phase2_start = Instant::now();\n                        conn.progress_handler(\n                            2_000,\n                            Some(move || phase2_start.elapsed().as_millis() > 5),\n                        );\n\n                        {\n\n                            let phase2_sql = format!(\n                                r#\"\n                                SELECT path, name, dir, is_dir, ext, size, mtime\n                                FROM entries\n                                WHERE name LIKE ?1 ESCAPE '\\'\n                                  AND name COLLATE NOCASE != ?2\n                                  AND name NOT LIKE ?3 ESCAPE '\\'\n                                ORDER BY {bare_order}\n                                LIMIT ?4\n                                \"#,\n                            );\n                            if let Ok(mut stmt2) = conn.prepare(&phase2_sql) {\n                                if let Ok(rows2) = stmt2.query_map(\n                                    params![name_like, exact_query, prefix_like, effective_limit],\n                                    row_to_entry,\n                                ) {\n                                    for row in rows2 {\n                                        match row {\n                                            Ok(entry) => results.push(entry),\n                                            Err(_) => break,\n                                        }\n                                    }\n                                }\n                            }\n                        }\n\n                        conn.progress_handler(0, None::<fn() -> bool>);\n                    }\n                }\n\n                SearchMode::GlobName { name_like } => {\n                    let sql = format!(\n                        r#\"\n                        SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                        FROM entries e\n                        WHERE e.name LIKE ?1 ESCAPE '\\'\n                        ORDER BY {order_by}\n                        LIMIT ?2 OFFSET ?3\n                        \"#,\n                    );\n                    let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                    let rows = stmt\n                        .query_map(params![name_like, effective_limit, offset], row_to_entry)\n                        .map_err(|e| e.to_string())?;\n                    for row in rows {\n                        results.push(row.map_err(|e| e.to_string())?);\n                    }\n                }\n\n                SearchMode::ExtSearch { ext, name_like: _ } => {\n                    let sql = format!(\n                        r#\"\n                        SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                        FROM entries e\n                        WHERE e.ext = ?1\n                        ORDER BY {order_by}\n                        LIMIT ?2 OFFSET ?3\n                        \"#,\n                    );\n                    let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                    let rows = stmt\n                        .query_map(params![ext, effective_limit, offset], row_to_entry)\n                        .map_err(|e| e.to_string())?;\n                    for row in rows {\n                        results.push(row.map_err(|e| e.to_string())?);\n                    }\n                }\n\n                SearchMode::PathSearch {\n                    path_like: _,\n                    name_like,\n                    dir_hint,\n                } => {\n                    let resolved_dirs: Vec<String> = resolve_dir_hint(&state.home_dir, dir_hint)\n                        .map(|p| vec![p.to_string_lossy().to_string()])\n                        .unwrap_or_default();\n                    let resolved_dirs = if resolved_dirs.is_empty() {\n                        resolve_dirs_from_db(&conn, dir_hint)\n                    } else {\n                        resolved_dirs\n                    };\n\n                    if !resolved_dirs.is_empty() {\n                        let ext_shortcut = extract_ext_from_like(name_like);\n                        let mut sql_params: Vec<SqlValue> = Vec::new();\n                        let mut dir_conditions = Vec::new();\n                        let sep = std::path::MAIN_SEPARATOR;\n\n                        for d in &resolved_dirs {\n                            let i = sql_params.len();\n                            let pfx = format!(\"{d}{sep}\");\n                            let pfx_end = format!(\"{d}\\x7F\");\n                            sql_params.push(SqlValue::Text(d.clone()));\n                            sql_params.push(SqlValue::Text(pfx));\n                            sql_params.push(SqlValue::Text(pfx_end));\n                            dir_conditions.push(format!(\n                                \"(e.dir = ?{} OR (e.dir >= ?{} AND e.dir < ?{}))\",\n                                i + 1,\n                                i + 2,\n                                i + 3\n                            ));\n                        }\n                        let dir_where = dir_conditions.join(\" OR \");\n\n                        let name_filter = if name_like == \"%\" {\n                            String::new()\n                        } else if let Some(ref ext_val) = ext_shortcut {\n                            let i = sql_params.len();\n                            sql_params.push(SqlValue::Text(ext_val.clone()));\n                            format!(\" AND e.ext = ?{}\", i + 1)\n                        } else {\n                            let i = sql_params.len();\n                            sql_params.push(SqlValue::Text(name_like.clone()));\n                            format!(\" AND e.name LIKE ?{} ESCAPE '\\\\'\", i + 1)\n                        };\n\n                        let limit_idx = sql_params.len() + 1;\n                        let offset_idx = sql_params.len() + 2;\n                        sql_params.push(SqlValue::Integer(effective_limit as i64));\n                        sql_params.push(SqlValue::Integer(offset as i64));\n\n                        let sql = format!(\n                            r#\"\n                            SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                            FROM entries e\n                            WHERE ({dir_where}){name_filter}\n                            ORDER BY {order_by}\n                            LIMIT ?{limit_idx} OFFSET ?{offset_idx}\n                            \"#,\n                        );\n                        let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                        let rows = stmt\n                            .query_map(params_from_iter(sql_params.iter()), row_to_entry)\n                            .map_err(|e| e.to_string())?;\n                        for row in rows {\n                            results.push(row.map_err(|e| e.to_string())?);\n                        }\n                    } else {\n                        let sep = std::path::MAIN_SEPARATOR;\n                        let sep_str = sep.to_string();\n                        let escaped_sep = escape_like(&sep_str);\n                        let (native_hint, is_absolute) = normalize_hint_to_native(dir_hint);\n                        let dir_suffix = escape_like(&native_hint);\n                        let dir_prefix = if is_absolute {\n                            String::new()\n                        } else {\n                            escaped_sep.clone()\n                        };\n                        let dir_like_exact = format!(\"%{dir_prefix}{dir_suffix}\");\n                        let dir_like_sub = format!(\"%{dir_prefix}{dir_suffix}{escaped_sep}%\");\n                        let ext_shortcut = extract_ext_from_like(name_like);\n\n                        if let Some(ext_val) = ext_shortcut {\n                            let sql = format!(\n                                r#\"\n                                SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                                FROM entries e\n                                WHERE e.ext = ?1\n                                  AND (e.dir LIKE ?2 ESCAPE '\\' OR e.dir LIKE ?3 ESCAPE '\\')\n                                ORDER BY {order_by}\n                                LIMIT ?4 OFFSET ?5\n                                \"#,\n                            );\n                            let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                            let rows = stmt\n                                .query_map(\n                                    params![\n                                        ext_val,\n                                        dir_like_exact,\n                                        dir_like_sub,\n                                        effective_limit,\n                                        offset\n                                    ],\n                                    row_to_entry,\n                                )\n                                .map_err(|e| e.to_string())?;\n                            for row in rows {\n                                results.push(row.map_err(|e| e.to_string())?);\n                            }\n                        } else if name_like == \"%\" {\n                            // Directory listing: no name filter needed, no time budget\n                            let sql = format!(\n                                r#\"\n                                SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                                FROM entries e\n                                WHERE e.dir LIKE ?1 ESCAPE '\\' OR e.dir LIKE ?2 ESCAPE '\\'\n                                ORDER BY {order_by}\n                                LIMIT ?3 OFFSET ?4\n                                \"#,\n                            );\n                            let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                            let rows = stmt\n                                .query_map(\n                                    params![dir_like_exact, dir_like_sub, effective_limit, offset],\n                                    row_to_entry,\n                                )\n                                .map_err(|e| e.to_string())?;\n                            for row in rows {\n                                results.push(row.map_err(|e| e.to_string())?);\n                            }\n                        } else {\n                            // Phase A: fast prefix search via name index\n                            // \"%main%\" -> strip leading '%' -> \"main%\" can use idx_entries_name_nocase\n                            let prefix_like = if name_like.starts_with('%') {\n                                let rest = &name_like[1..];\n                                if !rest.is_empty() && !rest.starts_with('%') {\n                                    Some(rest.to_string())\n                                } else {\n                                    None\n                                }\n                            } else {\n                                // Already a prefix pattern (e.g. \"test%\"), use as-is\n                                Some(name_like.clone())\n                            };\n\n                            if offset == 0 {\n                                if let Some(ref pfx) = prefix_like {\n                                    let sql = format!(\n                                        r#\"\n                                        SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                                        FROM entries e INDEXED BY idx_entries_name_nocase\n                                        WHERE e.name LIKE ?1 ESCAPE '\\'\n                                          AND (e.dir LIKE ?2 ESCAPE '\\' OR e.dir LIKE ?3 ESCAPE '\\')\n                                        ORDER BY {order_by}\n                                        LIMIT ?4\n                                        \"#,\n                                    );\n                                    if let Ok(mut stmt) = conn.prepare(&sql) {\n                                        if let Ok(rows) = stmt.query_map(\n                                            params![\n                                                pfx,\n                                                dir_like_exact,\n                                                dir_like_sub,\n                                                effective_limit\n                                            ],\n                                            row_to_entry,\n                                        ) {\n                                            for row in rows {\n                                                match row {\n                                                    Ok(entry) => results.push(entry),\n                                                    Err(_) => break,\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n\n                            // Phase B: time-budgeted contains fallback if prefix found too few\n                            if results.len() < effective_limit as usize {\n                                let path_start = Instant::now();\n                                conn.progress_handler(\n                                    2_000,\n                                    Some(move || path_start.elapsed().as_millis() > 5),\n                                );\n\n                                let sql = format!(\n                                    r#\"\n                                    SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                                    FROM entries e\n                                    WHERE (e.dir LIKE ?1 ESCAPE '\\' OR e.dir LIKE ?2 ESCAPE '\\')\n                                      AND e.name LIKE ?3 ESCAPE '\\'\n                                    ORDER BY {order_by}\n                                    LIMIT ?4 OFFSET ?5\n                                    \"#,\n                                );\n                                if let Ok(mut stmt) = conn.prepare(&sql) {\n                                    if let Ok(rows) = stmt.query_map(\n                                        params![\n                                            dir_like_exact,\n                                            dir_like_sub,\n                                            name_like,\n                                            effective_limit,\n                                            offset\n                                        ],\n                                        row_to_entry,\n                                    ) {\n                                        for row in rows {\n                                            match row {\n                                                Ok(entry) => results.push(entry),\n                                                Err(_) => break,\n                                            }\n                                        }\n                                    }\n                                }\n\n                                conn.progress_handler(0, None::<fn() -> bool>);\n\n                                // Deduplicate (Phase A prefix results overlap with Phase B contains)\n                                let mut seen = std::collections::HashSet::new();\n                                results.retain(|e| seen.insert(e.path.clone()));\n                                results.truncate(effective_limit as usize);\n                            }\n                        }\n                    }\n                }\n            }\n\n            if results.is_empty() && !query.is_empty() && offset == 0 && allow_find_fallback {\n                results = find_search(\n                    &state.home_dir,\n                    &runtime_ignored_roots,\n                    &runtime_ignored_patterns,\n                    &query,\n                    effective_limit as usize,\n                    &sort_by,\n                    &sort_dir,\n                );\n                mode_label = \"find_fallback\".to_string();\n            }\n        }\n        Err(_) => {\n            #[cfg(target_os = \"macos\")]\n            { db_unavailable = true; }\n            perf_log(format!(\"search_db_unavailable query={:?}\", query));\n        }\n    }\n\n    #[cfg(target_os = \"macos\")]\n    if !query.is_empty() && offset == 0 {\n        let should_spotlight = if results.is_empty() {\n            true\n        } else if results.len() >= effective_limit as usize {\n            false\n        } else {\n            is_indexing || db_unavailable\n        };\n        if should_spotlight {\n            let spotlight = mac::spotlight_search::search_spotlight(&state.home_dir, &query);\n            if !spotlight.entries.is_empty() {\n                if results.is_empty() {\n                    perf_log(format!(\n                        \"spotlight_fallback empty_results query={:?} results={} timed_out={}\",\n                        query,\n                        spotlight.entries.len(),\n                        spotlight.timed_out\n                    ));\n                    results = spotlight.entries;\n                    mode_label = if spotlight.timed_out {\n                        \"spotlight_timeout\".to_string()\n                    } else {\n                        \"spotlight\".to_string()\n                    };\n                } else {\n                    let existing_paths: std::collections::HashSet<String> =\n                        results.iter().map(|e| e.path.clone()).collect();\n                    let mut merged_count = 0usize;\n                    for entry in spotlight.entries {\n                        if !existing_paths.contains(&entry.path) {\n                            results.push(entry);\n                            merged_count += 1;\n                        }\n                    }\n                    if merged_count > 0 {\n                        perf_log(format!(\n                            \"spotlight_merge indexing query={:?} merged={} timed_out={}\",\n                            query, merged_count, spotlight.timed_out\n                        ));\n                        mode_label = format!(\"{}_+spotlight\", mode_label);\n                    }\n                }\n            }\n        }\n    }\n\n    results = filter_ignored_entries(results, &runtime_ignored_roots, &runtime_ignored_patterns);\n    results.truncate(effective_limit as usize);\n    if offset == 0 {\n        if sort_by == \"name\" {\n            sort_entries_with_relevance(&mut results, &query, &sort_by, &sort_dir);\n        } else {\n            sort_entries(&mut results, &sort_by, &sort_dir);\n        }\n    }\n    if is_name_mode && !is_indexing && offset == 0 && results.is_empty() && !query.is_empty() {\n        remember_negative_name_query(state, &query);\n    }\n\n    Ok(SearchExecution {\n        query,\n        sort_by,\n        sort_dir,\n        effective_limit,\n        offset,\n        mode_label,\n        results,\n    })\n}\n\n#[tauri::command]\nasync fn search(\n    _app: AppHandle,\n    query: String,\n    limit: Option<u32>,\n    offset: Option<u32>,\n    sort_by: Option<String>,\n    sort_dir: Option<String>,\n    include_total: Option<bool>,\n    state: State<'_, AppState>,\n) -> AppResult<SearchResultDto> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        let rpc_started = Instant::now();\n        let execute_started = Instant::now();\n        let execution = execute_search(&state, query, limit, offset, sort_by, sort_dir)?;\n        let execute_elapsed_ms = execute_started.elapsed().as_secs_f64() * 1000.0;\n\n        log_search(\n            &state.db_path,\n            &execution.query,\n            &execution.mode_label,\n            &execution.results,\n        );\n\n        if perf_log_enabled() {\n            let top: Vec<&str> = execution\n                .results\n                .iter()\n                .take(5)\n                .map(|entry| entry.name.as_str())\n                .collect();\n            perf_log(format!(\n                \"search query={:?} mode={} sort={}/{} limit={} offset={} results={} elapsed_ms={:.3} top={:?}\",\n                execution.query,\n                execution.mode_label,\n                execution.sort_by,\n                execution.sort_dir,\n                execution.effective_limit,\n                execution.offset,\n                execution.results.len(),\n                execute_elapsed_ms,\n                top,\n            ));\n        }\n\n        let include_total = include_total.unwrap_or(true);\n        let count_started = Instant::now();\n        let (total_count, total_known) = if include_total {\n            match compute_total_count(&state.db_path, &state.home_dir, &execution) {\n                Some(v) => (v, true),\n                None => (0, false),\n            }\n        } else {\n            (0, false)\n        };\n        let count_elapsed_ms = if include_total {\n            count_started.elapsed().as_secs_f64() * 1000.0\n        } else {\n            0.0\n        };\n\n        let rpc_elapsed_ms = rpc_started.elapsed().as_secs_f64() * 1000.0;\n        if cfg!(debug_assertions) {\n            let db_ready = state.db_ready.load(AtomicOrdering::Acquire);\n            let indexing_active = state.indexing_active.load(AtomicOrdering::Acquire);\n            eprintln!(\n                \"[rpc/search] total={:.3}ms execute={:.3}ms total_count={:.3}ms include_total={} query={:?} mode={} sort={}/{} limit={} offset={} results={} total_count={} total_known={} db_ready={} indexing_active={}\",\n                rpc_elapsed_ms,\n                execute_elapsed_ms,\n                count_elapsed_ms,\n                include_total,\n                execution.query,\n                execution.mode_label,\n                execution.sort_by,\n                execution.sort_dir,\n                execution.effective_limit,\n                execution.offset,\n                execution.results.len(),\n                total_count,\n                total_known,\n                db_ready,\n                indexing_active,\n            );\n        }\n        Ok(SearchResultDto {\n            entries: execution.results,\n            mode_label: execution.mode_label,\n            total_count,\n            total_known,\n        })\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nasync fn quick_look(path: String) -> AppResult<()> {\n    tauri::async_runtime::spawn_blocking(move || {\n        #[cfg(target_os = \"macos\")]\n        {\n            Command::new(\"qlmanage\")\n                .args([\"-p\", &path])\n                .stdout(std::process::Stdio::null())\n                .stderr(std::process::Stdio::null())\n                .spawn()\n                .map_err(|e| e.to_string())?;\n        }\n        #[cfg(target_os = \"windows\")]\n        {\n            Command::new(\"explorer\")\n                .arg(&path)\n                .spawn()\n                .map_err(|e| e.to_string())?;\n        }\n        #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n        {\n            Command::new(\"xdg-open\")\n                .arg(&path)\n                .spawn()\n                .map_err(|e| e.to_string())?;\n        }\n        Ok(())\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nasync fn open(paths: Vec<String>) -> AppResult<()> {\n    tauri::async_runtime::spawn_blocking(move || {\n        for path in &paths {\n            #[cfg(target_os = \"macos\")]\n            {\n                let output = Command::new(\"open\")\n                    .arg(path)\n                    .output()\n                    .map_err(|e| e.to_string())?;\n\n                if !output.status.success() && Path::new(path).is_dir() {\n                    let fallback = Command::new(\"open\")\n                        .args([\"-R\", path])\n                        .status()\n                        .map_err(|e| e.to_string())?;\n\n                    if !fallback.success() {\n                        return Err(format!(\"Failed to open: {path}\"));\n                    }\n                } else if !output.status.success() {\n                    let stderr = String::from_utf8_lossy(&output.stderr);\n                    return Err(format!(\"Failed to open: {path} ({stderr})\",));\n                }\n            }\n            #[cfg(target_os = \"windows\")]\n            {\n                let mut cmd = Command::new(\"cmd\");\n                cmd.raw_arg(format!(\"/C start \\\"\\\" \\\"{}\\\"\", path.replace('\"', \"\")));\n                let status = cmd.status().map_err(|e| e.to_string())?;\n                if !status.success() {\n                    return Err(format!(\"Failed to open: {path}\"));\n                }\n            }\n            #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n            {\n                let status = Command::new(\"xdg-open\")\n                    .arg(path)\n                    .status()\n                    .map_err(|e| e.to_string())?;\n                if !status.success() {\n                    return Err(format!(\"Failed to open: {path}\"));\n                }\n            }\n        }\n\n        Ok(())\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\nfn reveal_in_finder_impl(paths: Vec<String>) -> AppResult<()> {\n    if paths.is_empty() {\n        return Ok(());\n    }\n\n    #[cfg(target_os = \"macos\")]\n    {\n        if paths.len() == 1 {\n            let status = Command::new(\"open\")\n                .arg(\"-R\")\n                .arg(&paths[0])\n                .status()\n                .map_err(|e| e.to_string())?;\n\n            if !status.success() {\n                return Err(format!(\"Failed to reveal in Finder: {}\", paths[0]));\n            }\n\n            return Ok(());\n        }\n\n        let mut unique_parents: HashSet<PathBuf> = HashSet::new();\n        for path in &paths {\n            let p = PathBuf::from(path);\n            if let Some(parent) = p.parent() {\n                unique_parents.insert(parent.to_path_buf());\n            }\n        }\n\n        for parent in unique_parents {\n            let status = Command::new(\"open\")\n                .arg(&parent)\n                .status()\n                .map_err(|e| e.to_string())?;\n\n            if !status.success() {\n                return Err(format!(\n                    \"Failed to open in Finder: {}\",\n                    parent.to_string_lossy()\n                ));\n            }\n        }\n    }\n\n    #[cfg(target_os = \"windows\")]\n    {\n        for path in &paths {\n            let mut cmd = Command::new(\"explorer\");\n            cmd.raw_arg(format!(\"/select,\\\"{}\\\"\", path.replace('\"', \"\")));\n            let _ = cmd.status();\n        }\n    }\n\n    #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n    {\n        for path in &paths {\n            let target = Path::new(path);\n            let dir = if target.is_dir() {\n                path.as_str()\n            } else {\n                target\n                    .parent()\n                    .map(|p| p.to_str().unwrap_or(\"/\"))\n                    .unwrap_or(\"/\")\n            };\n            let _ = Command::new(\"xdg-open\").arg(dir).status();\n        }\n    }\n\n    Ok(())\n}\n\nfn copy_with_command(program: &str, args: &[&str], text: &str) -> AppResult<()> {\n    let mut child = Command::new(program)\n        .args(args)\n        .stdin(Stdio::piped())\n        .spawn()\n        .map_err(|e| format!(\"Failed to run {program}: {e}\"))?;\n\n    if let Some(mut stdin) = child.stdin.take() {\n        stdin\n            .write_all(text.as_bytes())\n            .map_err(|e| format!(\"Failed to write to clipboard: {e}\"))?;\n    } else {\n        return Err(\"Cannot open clipboard input stream.\".to_string());\n    }\n\n    let status = child\n        .wait()\n        .map_err(|e| format!(\"Failed to wait for {program}: {e}\"))?;\n\n    if status.success() {\n        Ok(())\n    } else {\n        Err(format!(\"{program} execution failed.\"))\n    }\n}\n\n#[cfg(target_os = \"macos\")]\nfn copy_text_to_clipboard(text: &str) -> AppResult<()> {\n    copy_with_command(\"pbcopy\", &[], text)\n}\n\n#[cfg(target_os = \"windows\")]\nfn copy_text_to_clipboard(text: &str) -> AppResult<()> {\n    copy_with_command(\"cmd\", &[\"/C\", \"clip\"], text)\n}\n\n#[cfg(all(unix, not(target_os = \"macos\")))]\nfn copy_text_to_clipboard(text: &str) -> AppResult<()> {\n    let mut last_error = None;\n\n    match copy_with_command(\"wl-copy\", &[], text) {\n        Ok(()) => return Ok(()),\n        Err(err) => last_error = Some(err),\n    }\n    match copy_with_command(\"xclip\", &[\"-selection\", \"clipboard\"], text) {\n        Ok(()) => return Ok(()),\n        Err(err) => last_error = Some(err),\n    }\n    match copy_with_command(\"xsel\", &[\"--clipboard\", \"--input\"], text) {\n        Ok(()) => return Ok(()),\n        Err(err) => last_error = Some(err),\n    }\n\n    Err(last_error.unwrap_or_else(|| {\n        \"No supported clipboard tool found. Please install wl-copy, xclip, or xsel.\".to_string()\n    }))\n}\n\n#[tauri::command]\nasync fn open_with(path: String) -> AppResult<()> {\n    tauri::async_runtime::spawn_blocking(move || reveal_in_finder_impl(vec![path]))\n        .await\n        .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nasync fn reveal_in_finder(paths: Vec<String>) -> AppResult<()> {\n    tauri::async_runtime::spawn_blocking(move || reveal_in_finder_impl(paths))\n        .await\n        .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nfn copy_paths(paths: Vec<String>) -> AppResult<()> {\n    copy_text_to_clipboard(&paths.join(\"\\n\"))\n}\n\n#[cfg(target_os = \"macos\")]\nfn copy_files_to_clipboard(paths: &[String]) -> AppResult<()> {\n    if paths.is_empty() {\n        return Ok(());\n    }\n    let file_exprs: Vec<String> = paths\n        .iter()\n        .map(|p| {\n            let escaped = p.replace('\\\\', \"\\\\\\\\\").replace('\"', \"\\\\\\\"\");\n            format!(\"POSIX file \\\"{}\\\"\", escaped)\n        })\n        .collect();\n    let script = if file_exprs.len() == 1 {\n        format!(\"set the clipboard to {}\", file_exprs[0])\n    } else {\n        format!(\"set the clipboard to {{{}}}\", file_exprs.join(\", \"))\n    };\n    let status = Command::new(\"osascript\")\n        .arg(\"-e\")\n        .arg(&script)\n        .status()\n        .map_err(|e| e.to_string())?;\n    if !status.success() {\n        return Err(\"Failed to copy files to clipboard\".to_string());\n    }\n    Ok(())\n}\n\n#[cfg(target_os = \"macos\")]\n#[tauri::command]\nfn copy_files(paths: Vec<String>) -> AppResult<()> {\n    copy_files_to_clipboard(&paths)\n}\n\n#[cfg(not(target_os = \"macos\"))]\n#[tauri::command]\nfn copy_files(_paths: Vec<String>) -> AppResult<()> {\n    Err(\"copy_files is only supported on macOS\".to_string())\n}\n\n#[tauri::command]\nasync fn move_to_trash(\n    paths: Vec<String>,\n    app: AppHandle,\n    state: State<'_, AppState>,\n) -> AppResult<()> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        let mut deleted_targets = Vec::new();\n\n        for path in &paths {\n            trash::delete(path).map_err(|e| e.to_string())?;\n            remember_op(&state, \"trash\", Some(path.clone()), None);\n            deleted_targets.push(path.clone());\n        }\n\n        let mut conn = db_connection(&state.db_path)?;\n        let _ = delete_paths(&mut conn, &deleted_targets)?;\n        invalidate_search_caches(&state);\n\n        refresh_and_emit_status_counts(&app, &state)?;\n        Ok(())\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nasync fn rename(\n    path: String,\n    new_name: String,\n    app: AppHandle,\n    state: State<'_, AppState>,\n) -> AppResult<EntryDto> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        let validated_name = validate_new_name(&new_name)?;\n        let old_path = PathBuf::from(&path);\n\n        if !old_path.exists() {\n            return Err(\"Source file does not exist.\".to_string());\n        }\n\n        let parent = old_path\n            .parent()\n            .ok_or_else(|| \"Parent directory not found.\".to_string())?;\n\n        let new_path = parent.join(&validated_name);\n        if new_path == old_path {\n            let meta = fs::symlink_metadata(&old_path).ok();\n            return Ok(EntryDto {\n                path: path.clone(),\n                name: old_path\n                    .file_name()\n                    .map(|v| v.to_string_lossy().to_string())\n                    .unwrap_or_else(|| validated_name.clone()),\n                dir: parent.to_string_lossy().to_string(),\n                is_dir: old_path.is_dir(),\n                ext: extension_for(&old_path, old_path.is_dir()),\n                size: meta\n                    .as_ref()\n                    .filter(|m| m.is_file())\n                    .map(|m| m.len() as i64),\n                mtime: meta\n                    .and_then(|m| m.modified().ok())\n                    .and_then(|m| m.duration_since(UNIX_EPOCH).ok())\n                    .map(|d| d.as_secs() as i64),\n            });\n        }\n\n        if new_path.exists() {\n            return Err(\"A file/folder with the same name already exists.\".to_string());\n        }\n\n        let original_is_dir = old_path.is_dir();\n        fs::rename(&old_path, &new_path).map_err(|e| e.to_string())?;\n\n        let mut conn = db_connection(&state.db_path)?;\n        let _ = delete_paths(&mut conn, &[path.clone()])?;\n\n        if original_is_dir {\n            let rows =\n                collect_rows_recursive(&new_path, &state.path_ignores, &state.path_ignore_patterns);\n            for chunk in rows.chunks(BATCH_SIZE) {\n                let _ = upsert_rows(&mut conn, chunk)?;\n            }\n        } else {\n            let row = index_row_from_path(&new_path)\n                .ok_or_else(|| \"Cannot read renamed file info.\".to_string())?;\n            let _ = upsert_rows(&mut conn, &[row])?;\n        }\n\n        invalidate_search_caches(&state);\n\n        remember_op(\n            &state,\n            \"rename\",\n            Some(old_path.to_string_lossy().to_string()),\n            Some(new_path.to_string_lossy().to_string()),\n        );\n\n        refresh_and_emit_status_counts(&app, &state)?;\n\n        let new_meta = fs::symlink_metadata(&new_path).ok();\n        Ok(EntryDto {\n            path: new_path.to_string_lossy().to_string(),\n            name: validated_name,\n            dir: parent.to_string_lossy().to_string(),\n            is_dir: original_is_dir,\n            ext: extension_for(&new_path, original_is_dir),\n            size: new_meta\n                .as_ref()\n                .filter(|m| m.is_file())\n                .map(|m| m.len() as i64),\n            mtime: new_meta\n                .and_then(|m| m.modified().ok())\n                .and_then(|m| m.duration_since(UNIX_EPOCH).ok())\n                .map(|d| d.as_secs() as i64),\n        })\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nasync fn fd_search(\n    query: String,\n    limit: Option<u32>,\n    offset: Option<u32>,\n    sort_by: Option<String>,\n    sort_dir: Option<String>,\n    state: State<'_, AppState>,\n) -> AppResult<FdSearchResultDto> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        let query = query.trim().to_string();\n        let limit = limit.unwrap_or(500).clamp(1, 5000) as usize;\n        let offset = offset.unwrap_or(0) as usize;\n        let sort_by = sort_by.unwrap_or_else(|| \"name\".to_string());\n        let sort_dir = sort_dir.unwrap_or_else(|| \"asc\".to_string());\n        let (runtime_ignored_roots, runtime_ignored_patterns) =\n            cached_effective_ignore_rules(&state);\n        let ignore_fingerprint =\n            ignore_rules_fingerprint(&runtime_ignored_roots, &runtime_ignored_patterns);\n\n        if query.is_empty() {\n            return Ok(FdSearchResultDto {\n                entries: Vec::new(),\n                total: 0,\n                timed_out: false,\n            });\n        }\n\n        {\n            let cache = state.fd_search_cache.lock();\n            if let Some(cached) = cache.as_ref() {\n                let cache_hit = cached.query == query\n                    && cached.sort_by == sort_by\n                    && cached.sort_dir == sort_dir\n                    && cached.ignore_fingerprint == ignore_fingerprint;\n                if cache_hit {\n                    let total = cached.entries.len() as u64;\n                    let end = (offset + limit).min(cached.entries.len());\n                    let page = if offset < cached.entries.len() {\n                        cached.entries[offset..end].to_vec()\n                    } else {\n                        Vec::new()\n                    };\n                    return Ok(FdSearchResultDto {\n                        entries: page,\n                        total,\n                        timed_out: false,\n                    });\n                }\n            }\n        }\n\n        let result = fd_search::run_fd_search(\n            &state.scan_root,\n            &runtime_ignored_roots,\n            &runtime_ignored_patterns,\n            &query,\n            &sort_by,\n            &sort_dir,\n        );\n        let total = result.entries.len() as u64;\n        let end = (offset + limit).min(result.entries.len());\n        let page = if offset < result.entries.len() {\n            result.entries[offset..end].to_vec()\n        } else {\n            Vec::new()\n        };\n\n        {\n            let mut cache = state.fd_search_cache.lock();\n            *cache = Some(FdSearchCache {\n                query: query.clone(),\n                sort_by: sort_by.clone(),\n                sort_dir: sort_dir.clone(),\n                ignore_fingerprint,\n                entries: result.entries,\n            });\n        }\n\n        Ok(FdSearchResultDto {\n            entries: page,\n            total,\n            timed_out: result.timed_out,\n        })\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nfn frontend_log(msg: String) {\n    eprintln!(\"{msg}\");\n}\n\n#[tauri::command]\nfn mark_frontend_ready(state: State<'_, AppState>) {\n    state.frontend_ready.store(true, AtomicOrdering::Release);\n    if cfg!(debug_assertions) {\n        eprintln!(\"[startup] frontend_ready=true\");\n    }\n}\n\n#[tauri::command]\nfn get_platform() -> String {\n    if cfg!(target_os = \"windows\") {\n        \"windows\".to_string()\n    } else if cfg!(target_os = \"macos\") {\n        \"macos\".to_string()\n    } else {\n        \"linux\".to_string()\n    }\n}\n\n#[cfg(target_os = \"windows\")]\n#[tauri::command]\nasync fn show_context_menu(\n    paths: Vec<String>,\n    x: f64,\n    y: f64,\n    _single_selection: bool,\n    app: AppHandle,\n) -> AppResult<()> {\n    let window = app\n        .get_webview_window(\"main\")\n        .ok_or_else(|| \"Main window not found\".to_string())?;\n\n    let scale = window.scale_factor().map_err(|e| e.to_string())?;\n    let win_pos = window.inner_position().map_err(|e| e.to_string())?;\n    let screen_x = win_pos.x + (x * scale) as i32;\n    let screen_y = win_pos.y + (y * scale) as i32;\n\n    let hwnd_raw = window.hwnd().map_err(|e| e.to_string())?.0 as isize;\n\n    // TrackPopupMenu must run on the thread that owns the HWND (main UI thread).\n    // Use a channel to relay the result back to the async context.\n    let (tx, rx) = std::sync::mpsc::sync_channel::<Result<(), String>>(1);\n\n    app.run_on_main_thread(move || {\n        let result = win::context_menu::show(hwnd_raw, &paths, screen_x, screen_y);\n        let _ = tx.send(result);\n    })\n    .map_err(|e| e.to_string())?;\n\n    tauri::async_runtime::spawn_blocking(move || {\n        rx.recv().map_err(|e| format!(\"context menu channel: {e}\"))?\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[cfg(target_os = \"macos\")]\n#[tauri::command]\nasync fn show_context_menu(\n    _paths: Vec<String>,\n    x: f64,\n    y: f64,\n    single_selection: bool,\n    app: AppHandle,\n) -> AppResult<()> {\n    use tauri::menu::{IsMenuItem, Menu, MenuItem, PredefinedMenuItem};\n\n    let window = app\n        .get_webview_window(\"main\")\n        .ok_or_else(|| \"Main window not found\".to_string())?;\n\n    let (tx, rx) = std::sync::mpsc::sync_channel::<Result<(), String>>(1);\n\n    let app_clone = app.clone();\n    app.run_on_main_thread(move || {\n        let app = app_clone;\n        let result = (|| -> Result<(), tauri::Error> {\n            let open = MenuItem::with_id(&app, \"ctx_open\", \"Open\", true, None::<&str>)?;\n            let quick_look =\n                MenuItem::with_id(&app, \"ctx_quick_look\", \"Quick Look\", true, None::<&str>)?;\n            let open_with =\n                MenuItem::with_id(&app, \"ctx_open_with\", \"Open With...\", true, None::<&str>)?;\n            let sep1 = PredefinedMenuItem::separator(&app)?;\n            let reveal = MenuItem::with_id(\n                &app,\n                \"ctx_reveal\",\n                \"Reveal in Finder\",\n                true,\n                None::<&str>,\n            )?;\n            let sep2 = PredefinedMenuItem::separator(&app)?;\n            let copy_files =\n                MenuItem::with_id(&app, \"ctx_copy_files\", \"Copy\", true, None::<&str>)?;\n            let copy_path =\n                MenuItem::with_id(&app, \"ctx_copy_path\", \"Copy Path\", true, None::<&str>)?;\n            let sep3 = PredefinedMenuItem::separator(&app)?;\n            let trash = MenuItem::with_id(\n                &app,\n                \"ctx_trash\",\n                \"Move to Trash\",\n                true,\n                None::<&str>,\n            )?;\n            let rename =\n                MenuItem::with_id(&app, \"ctx_rename\", \"Rename\", true, None::<&str>)?;\n\n            let mut items: Vec<&dyn IsMenuItem<tauri::Wry>> = vec![\n                &open, &quick_look, &open_with, &sep1, &reveal, &sep2, &copy_files, &copy_path, &sep3, &trash,\n            ];\n            if single_selection {\n                items.push(&rename);\n            }\n\n            let menu = Menu::with_items(&app, &items)?;\n            // Position is window-relative logical pixels, matching clientX/clientY.\n            window.popup_menu_at(&menu, tauri::LogicalPosition::new(x, y))?;\n            Ok(())\n        })();\n        let _ = tx.send(result.map_err(|e| e.to_string()));\n    })\n    .map_err(|e| e.to_string())?;\n\n    tauri::async_runtime::spawn_blocking(move || {\n        rx.recv().map_err(|e| format!(\"context menu channel: {e}\"))?\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[cfg(not(any(target_os = \"windows\", target_os = \"macos\")))]\n#[tauri::command]\nasync fn show_context_menu(\n    _paths: Vec<String>,\n    _x: f64,\n    _y: f64,\n    _single_selection: bool,\n    _app: AppHandle,\n) -> AppResult<()> {\n    Err(\"Native context menu is only supported on Windows and macOS\".to_string())\n}\n\n#[tauri::command]\nasync fn set_native_theme(theme: String, app: AppHandle) -> AppResult<()> {\n    let window = app\n        .get_webview_window(\"main\")\n        .ok_or_else(|| \"Main window not found\".to_string())?;\n    let t = if theme == \"light\" {\n        tauri::Theme::Light\n    } else {\n        tauri::Theme::Dark\n    };\n    window.set_theme(Some(t)).map_err(|e| e.to_string())\n}\n\n#[tauri::command]\nasync fn get_file_icon(\n    path: Option<String>,\n    ext: String,\n    state: State<'_, AppState>,\n) -> AppResult<Vec<u8>> {\n    let state = state.inner().clone();\n    Ok(tauri::async_runtime::spawn_blocking(move || {\n        let ext_lower = if ext.trim().is_empty() {\n            \"__default__\".to_string()\n        } else {\n            ext.to_lowercase()\n        };\n\n        #[cfg(target_os = \"windows\")]\n        let cache_key = {\n            if is_per_file_icon_ext(&ext_lower) {\n                path.as_deref().unwrap_or(&ext_lower).to_string()\n            } else {\n                ext_lower.clone()\n            }\n        };\n        #[cfg(not(target_os = \"windows\"))]\n        let cache_key = ext_lower.clone();\n\n        if let Some(cached) = state.icon_cache.lock().get(&cache_key).cloned() {\n            return cached;\n        }\n\n        #[cfg(target_os = \"windows\")]\n        let icon = {\n            let from_path = path\n                .as_deref()\n                .filter(|p| !p.is_empty())\n                .and_then(win::icon::load_icon_png);\n            from_path.or_else(|| load_system_icon_png(&ext_lower))\n        };\n        #[cfg(not(target_os = \"windows\"))]\n        let icon = {\n            let _ = path;\n            load_system_icon_png(&ext_lower)\n        };\n\n        let icon = icon.unwrap_or_default();\n        state.icon_cache.lock().insert(cache_key, icon.clone());\n        icon\n    })\n    .await\n    .unwrap_or_default())\n}\n\nfn default_bench_cases() -> Vec<BenchCase> {\n    vec![\n        BenchCase {\n            id: \"TC01_exact_name\",\n            query: \"report_00042\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC02_prefix_name\",\n            query: \"report_00\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 10,\n        },\n        BenchCase {\n            id: \"TC03_contains_name\",\n            query: \"invoice\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC04_ext_md\",\n            query: \"*.md\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC05_path_glob_png\",\n            query: \"Desktop/ *.png\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC06_path_term\",\n            query: \"Projects/rust\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC07_path_ext_rs\",\n            query: \"Projects/ *.rs\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC08_no_match\",\n            query: \"zzzz_not_exists_12345\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 0,\n        },\n    ]\n}\n\nfn bench_iterations() -> u32 {\n    std::env::var(\"EVERYTHING_BENCH_ITERATIONS\")\n        .ok()\n        .and_then(|v| v.parse::<u32>().ok())\n        .map(|v| v.clamp(1, 50))\n        .unwrap_or(5)\n}\n\nfn bench_wait_timeout() -> Duration {\n    let seconds = std::env::var(\"EVERYTHING_BENCH_WAIT_SEC\")\n        .ok()\n        .and_then(|v| v.parse::<u64>().ok())\n        .map(|v| v.clamp(10, 7200))\n        .unwrap_or(1800);\n    Duration::from_secs(seconds)\n}\n\nfn bench_run_label() -> String {\n    std::env::var(\"EVERYTHING_BENCH_RUN_LABEL\")\n        .ok()\n        .filter(|v| !v.trim().is_empty())\n        .unwrap_or_else(|| format!(\"run-{}\", now_epoch()))\n}\n\nfn bench_output_path(db_path: &Path, run_label: &str) -> PathBuf {\n    std::env::var(\"EVERYTHING_BENCH_OUTPUT\")\n        .ok()\n        .filter(|v| !v.trim().is_empty())\n        .map(PathBuf::from)\n        .unwrap_or_else(|| db_path.with_file_name(format!(\"bench-report-{run_label}.json\")))\n}\n\nfn write_bench_report(path: &Path, report: &BenchReport) -> AppResult<()> {\n    let json = serde_json::to_string_pretty(report).map_err(|e| e.to_string())?;\n    fs::write(path, json).map_err(|e| e.to_string())\n}\n\nfn start_bench_runner(app_handle: AppHandle, state: AppState) {\n    std::thread::spawn(move || {\n        let run_label = bench_run_label();\n        let output_path = bench_output_path(&state.db_path, &run_label);\n        let iterations = bench_iterations();\n        let wait_timeout = bench_wait_timeout();\n        let started_at = now_epoch();\n\n        perf_log(format!(\n            \"bench_start run_label={} output={} iterations={} wait_timeout_s={}\",\n            run_label,\n            output_path.to_string_lossy(),\n            iterations,\n            wait_timeout.as_secs(),\n        ));\n\n        let wait_started = Instant::now();\n        let mut saw_indexing = false;\n        let index_snapshot: IndexStatus;\n        loop {\n            let snapshot = state.status.lock().clone();\n            let active = state.indexing_active.load(AtomicOrdering::Acquire)\n                || matches!(snapshot.state, IndexState::Indexing);\n\n            if active {\n                saw_indexing = true;\n            }\n\n            if state.db_ready.load(AtomicOrdering::Acquire) && saw_indexing && !active {\n                index_snapshot = snapshot;\n                break;\n            }\n\n            if wait_started.elapsed() >= wait_timeout {\n                let report = BenchReport {\n                    run_label: run_label.clone(),\n                    started_at,\n                    completed_at: now_epoch(),\n                    home_dir: state.home_dir.to_string_lossy().to_string(),\n                    db_path: state.db_path.to_string_lossy().to_string(),\n                    index_wait_ms: wait_started.elapsed().as_millis(),\n                    index_scanned: snapshot.scanned,\n                    index_indexed: snapshot.indexed,\n                    index_entries_count: snapshot.entries_count,\n                    index_permission_errors: snapshot.permission_errors,\n                    index_message: Some(\"Timed out waiting for index ready\".to_string()),\n                    search_iterations: iterations,\n                    search_results: Vec::new(),\n                };\n                let _ = write_bench_report(&output_path, &report);\n                perf_log(format!(\n                    \"bench_timeout run_label={} waited_ms={}\",\n                    run_label,\n                    wait_started.elapsed().as_millis()\n                ));\n                if env_truthy(\"EVERYTHING_BENCH_EXIT\") {\n                    app_handle.exit(2);\n                }\n                return;\n            }\n\n            std::thread::sleep(Duration::from_millis(200));\n        }\n\n        let index_wait_ms = wait_started.elapsed().as_millis();\n        perf_log(format!(\n            \"bench_index_ready run_label={} waited_ms={} scanned={} indexed={} entries={} permission_errors={}\",\n            run_label,\n            index_wait_ms,\n            index_snapshot.scanned,\n            index_snapshot.indexed,\n            index_snapshot.entries_count,\n            index_snapshot.permission_errors,\n        ));\n\n        let mut search_results = Vec::new();\n        for case in default_bench_cases() {\n            let mut elapsed_sum = 0.0f64;\n            let mut success_count = 0u32;\n            let mut result_count = 0usize;\n            let mut mode = String::new();\n            let mut top_results = Vec::new();\n            let mut case_error = None;\n\n            for iter in 1..=iterations {\n                let started = Instant::now();\n                match execute_search(\n                    &state,\n                    case.query.to_string(),\n                    Some(case.limit),\n                    Some(case.offset),\n                    Some(case.sort_by.to_string()),\n                    Some(case.sort_dir.to_string()),\n                ) {\n                    Ok(execution) => {\n                        let elapsed_ms = started.elapsed().as_secs_f64() * 1000.0;\n                        elapsed_sum += elapsed_ms;\n                        success_count += 1;\n                        result_count = execution.results.len();\n                        mode = execution.mode_label;\n                        top_results = execution\n                            .results\n                            .iter()\n                            .take(5)\n                            .map(|entry| entry.path.clone())\n                            .collect();\n\n                        perf_log(format!(\n                            \"bench_query run_label={} case={} iter={}/{} query={:?} mode={} results={} elapsed_ms={:.3}\",\n                            run_label,\n                            case.id,\n                            iter,\n                            iterations,\n                            case.query,\n                            mode,\n                            result_count,\n                            elapsed_ms\n                        ));\n                    }\n                    Err(err) => {\n                        case_error = Some(err);\n                        break;\n                    }\n                }\n            }\n\n            let elapsed_ms = if success_count > 0 {\n                elapsed_sum / success_count as f64\n            } else {\n                0.0\n            };\n            let passed = case_error.is_none() && result_count >= case.expected_min_results;\n\n            search_results.push(BenchCaseResult {\n                id: case.id.to_string(),\n                query: case.query.to_string(),\n                mode,\n                sort_by: case.sort_by.to_string(),\n                sort_dir: case.sort_dir.to_string(),\n                limit: case.limit,\n                offset: case.offset,\n                elapsed_ms,\n                result_count,\n                expected_min_results: case.expected_min_results,\n                passed,\n                top_results,\n                error: case_error,\n            });\n        }\n\n        let report = BenchReport {\n            run_label: run_label.clone(),\n            started_at,\n            completed_at: now_epoch(),\n            home_dir: state.home_dir.to_string_lossy().to_string(),\n            db_path: state.db_path.to_string_lossy().to_string(),\n            index_wait_ms,\n            index_scanned: index_snapshot.scanned,\n            index_indexed: index_snapshot.indexed,\n            index_entries_count: index_snapshot.entries_count,\n            index_permission_errors: index_snapshot.permission_errors,\n            index_message: index_snapshot.message.clone(),\n            search_iterations: iterations,\n            search_results,\n        };\n\n        match write_bench_report(&output_path, &report) {\n            Ok(()) => perf_log(format!(\n                \"bench_report_written run_label={} path={}\",\n                run_label,\n                output_path.to_string_lossy()\n            )),\n            Err(err) => perf_log(format!(\n                \"bench_report_write_error run_label={} path={} err={}\",\n                run_label,\n                output_path.to_string_lossy(),\n                err\n            )),\n        }\n\n        if env_truthy(\"EVERYTHING_BENCH_EXIT\") {\n            app_handle.exit(0);\n        }\n    });\n}\n\n#[cfg(target_os = \"macos\")]\nfn register_global_shortcut(app: &AppHandle) -> AppResult<()> {\n    let shortcut = Shortcut::new(Some(Modifiers::SUPER | Modifiers::SHIFT), Code::Space);\n\n    app.global_shortcut()\n        .on_shortcut(shortcut, move |app_handle, _, _| {\n            if let Some(window) = app_handle.get_webview_window(\"main\") {\n                let _ = window.show();\n                let _ = window.unminimize();\n                let _ = window.set_focus();\n            }\n            let _ = app_handle.emit(\"focus_search\", ());\n        })\n        .map_err(|e| format!(\"Failed to register global shortcut: {e}\"))\n}\n\n#[cfg(not(target_os = \"macos\"))]\nfn register_global_shortcut(_app: &AppHandle) -> AppResult<()> {\n    Ok(())\n}\n\nfn setup_app(app: &mut tauri::App) -> AppResult<()> {\n    let setup_started = std::time::Instant::now();\n    eprintln!(\"[startup] setup_app() entered\");\n    let bench_mode = bench_mode_enabled();\n\n    #[cfg(target_os = \"macos\")]\n    if let Some(window) = app.get_webview_window(\"main\") {\n        use tauri::window::Color;\n        let is_dark = window\n            .theme()\n            .map(|t| t == tauri::Theme::Dark)\n            .unwrap_or(false);\n        let bg = if is_dark {\n            Color(0x1f, 0x1f, 0x1f, 0xff)\n        } else {\n            Color(0xf4, 0xf5, 0xf7, 0xff)\n        };\n        let _ = window.set_background_color(Some(bg));\n        let _ = window.show();\n    }\n\n    #[cfg(target_os = \"windows\")]\n    if let Some(window) = app.get_webview_window(\"main\") {\n        eprintln!(\"[startup +{}ms] windows setup: before window.show()\", startup_elapsed_ms());\n        use tauri::window::Color;\n        let is_dark = window.theme().map(|t| t == tauri::Theme::Dark).unwrap_or(false);\n        let bg = if is_dark {\n            Color(0x1f, 0x1f, 0x1f, 0xff)\n        } else {\n            Color(0xf4, 0xf5, 0xf7, 0xff)\n        };\n        let _ = window.set_background_color(Some(bg));\n        if let Err(e) = window.set_decorations(false) {\n            eprintln!(\n                \"[startup +{}ms] windows setup: set_decorations(false) failed: {}\",\n                startup_elapsed_ms(),\n                e\n            );\n        }\n        let _ = window.show();\n        eprintln!(\"[startup +{}ms] windows setup: window.show() returned\", startup_elapsed_ms());\n    }\n\n    let app_data_dir = app\n        .path()\n        .app_data_dir()\n        .map_err(|e| format!(\"Failed to get app data dir: {e}\"))?;\n    fs::create_dir_all(&app_data_dir).map_err(|e| e.to_string())?;\n\n    let db_path = app_data_dir.join(\"index.db\");\n    let home_dir = PathBuf::from(\n        std::env::var(\"HOME\")\n            .or_else(|_| std::env::var(\"USERPROFILE\"))\n            .unwrap_or_else(|_| if cfg!(windows) { \"C:\\\\\".to_string() } else { \"/\".to_string() }),\n    );\n    let scan_root = if cfg!(windows) {\n        PathBuf::from(\"C:\\\\\")\n    } else {\n        home_dir.clone()\n    };\n    let cwd = std::env::current_dir().unwrap_or_else(|_| home_dir.clone());\n    eprintln!(\"[startup] +{}ms loading pathignore rules...\", setup_started.elapsed().as_millis());\n    let (mut path_ignores, path_ignore_patterns) = load_pathignore_rules(&home_dir, &cwd);\n    if !path_ignores.iter().any(|r| r == &app_data_dir) {\n        path_ignores.push(app_data_dir.clone());\n    }\n    for root in load_gitignore_roots(&home_dir, &cwd) {\n        if !path_ignores.iter().any(|r| r == &root) {\n            path_ignores.push(root);\n        }\n    }\n    eprintln!(\"[startup] +{}ms pathignore done\", setup_started.elapsed().as_millis());\n\n    let gitignore = Arc::new(gitignore_filter::LazyGitignoreFilter::new(home_dir.clone()));\n\n    let state = AppState {\n        db_path,\n        home_dir,\n        scan_root,\n        cwd,\n        path_ignores: Arc::new(path_ignores),\n        path_ignore_patterns: Arc::new(path_ignore_patterns),\n        db_ready: Arc::new(AtomicBool::new(false)),\n        indexing_active: Arc::new(AtomicBool::new(false)),\n        status: Arc::new(Mutex::new(IndexStatus::default())),\n        recent_ops: Arc::new(Mutex::new(Vec::new())),\n        icon_cache: Arc::new(Mutex::new(HashMap::new())),\n        fd_search_cache: Arc::new(Mutex::new(None)),\n        negative_name_cache: Arc::new(Mutex::new(HashMap::new())),\n        ignore_cache: Arc::new(Mutex::new(None)),\n        gitignore,\n        mem_index: Arc::new(RwLock::new(None)),\n        watcher_stop: Arc::new(AtomicBool::new(false)),\n        watcher_active: Arc::new(AtomicBool::new(false)),\n        frontend_ready: Arc::new(AtomicBool::new(false)),\n    };\n\n    eprintln!(\"[startup] +{}ms AppState created\", setup_started.elapsed().as_millis());\n    app.manage(state.clone());\n    if !bench_mode {\n        register_global_shortcut(&app.handle())?;\n    }\n    // Context menu item IDs use the \"ctx_\" prefix by convention.\n    // All matching IDs are forwarded as \"context_menu_action\" events to the frontend.\n    #[cfg(target_os = \"macos\")]\n    {\n        app.handle().on_menu_event(|app, event| {\n            let action = match event.id().as_ref() {\n                \"ctx_open\" => \"open\",\n                \"ctx_quick_look\" => \"quick_look\",\n                \"ctx_open_with\" => \"open_with\",\n                \"ctx_reveal\" => \"reveal\",\n                \"ctx_copy_files\" => \"copy_files\",\n                \"ctx_copy_path\" => \"copy_path\",\n                \"ctx_trash\" => \"trash\",\n                \"ctx_rename\" => \"rename\",\n                _ => return,\n            };\n            let _ = app.emit(\"context_menu_action\", action);\n        });\n    }\n    eprintln!(\"[startup] +{}ms global shortcut registered\", setup_started.elapsed().as_millis());\n    if bench_mode {\n        if let Some(window) = app.get_webview_window(\"main\") {\n            let _ = window.hide();\n        }\n    }\n\n    eprintln!(\"[startup] +{}ms setup_app() done, spawning init thread\", setup_started.elapsed().as_millis());\n\n    let app_handle = app.handle().clone();\n    std::thread::spawn(move || {\n        let thread_started = std::time::Instant::now();\n        eprintln!(\"[startup/thread] init thread started\");\n\n        eprintln!(\"[startup/thread] +{}ms calling init_db...\", thread_started.elapsed().as_millis());\n        if let Err(err) = init_db(&state.db_path) {\n            set_state(&state, IndexState::Error, Some(err.clone()));\n            emit_index_state(&app_handle, \"Error\", Some(err));\n            return;\n        }\n        eprintln!(\"[startup/thread] +{}ms init_db done\", thread_started.elapsed().as_millis());\n\n        state.db_ready.store(true, AtomicOrdering::Release);\n        eprintln!(\"[startup/thread] +{}ms db_ready=true -- launching indexing immediately\", thread_started.elapsed().as_millis());\n\n        // Deferred housekeeping -- purge + status counts run in background\n        {\n            let hk_app = app_handle.clone();\n            let hk_state = state.clone();\n            std::thread::spawn(move || {\n                // Brief pause so indexing thread can start first\n                std::thread::sleep(std::time::Duration::from_millis(500));\n                let hk_started = std::time::Instant::now();\n                let _ = refresh_and_emit_status_counts(&hk_app, &hk_state);\n                eprintln!(\"[startup/housekeeping] refresh_and_emit_status_counts done in {}ms\", hk_started.elapsed().as_millis());\n                // Wait for frontend readiness so initial paint and first input are not contended by purge I/O.\n                const FRONTEND_READY_TIMEOUT: Duration = Duration::from_secs(180);\n                const POST_READY_GRACE: Duration = Duration::from_secs(2);\n                let wait_started = std::time::Instant::now();\n                while !hk_state.frontend_ready.load(AtomicOrdering::Acquire)\n                    && wait_started.elapsed() < FRONTEND_READY_TIMEOUT\n                {\n                    std::thread::sleep(Duration::from_millis(50));\n                }\n                if hk_state.frontend_ready.load(AtomicOrdering::Acquire) {\n                    eprintln!(\n                        \"[startup/housekeeping] frontend_ready observed after {}ms; purging in {}ms\",\n                        wait_started.elapsed().as_millis(),\n                        POST_READY_GRACE.as_millis()\n                    );\n                } else {\n                    eprintln!(\n                        \"[startup/housekeeping] frontend_ready wait timed out after {}ms; proceeding with purge\",\n                        FRONTEND_READY_TIMEOUT.as_millis()\n                    );\n                }\n                std::thread::sleep(POST_READY_GRACE);\n                let purge_started = std::time::Instant::now();\n                if let Err(err) = purge_ignored_entries(&hk_state.db_path, &hk_state.path_ignores) {\n                    eprintln!(\"[startup/housekeeping] purge_ignored_entries failed: {err}\");\n                } else {\n                    eprintln!(\n                        \"[startup/housekeeping] purge_ignored_entries done in {}ms\",\n                        purge_started.elapsed().as_millis()\n                    );\n                }\n                eprintln!(\"[startup/housekeeping] all done in {}ms\", hk_started.elapsed().as_millis());\n            });\n        }\n\n        #[cfg(target_os = \"macos\")]\n        {\n            if bench_mode {\n                let _ = start_full_index_worker(app_handle.clone(), state.clone());\n            } else {\n                let (stored_event_id, index_complete) = db_connection(&state.db_path)\n                    .ok()\n                    .map(|c| {\n                        let eid = get_meta(&c, \"last_event_id\")\n                            .and_then(|v| v.parse::<u64>().ok());\n                        let complete = get_meta(&c, \"index_complete\")\n                            .map(|v| v == \"1\")\n                            .unwrap_or(false);\n                        (eid, complete)\n                    })\n                    .unwrap_or((None, false));\n\n                if stored_event_id.is_some() && index_complete {\n                    // Conditional startup: try watcher replay first, skip full scan if OK\n                    start_fsevent_watcher_worker(\n                        app_handle.clone(),\n                        state.clone(),\n                        stored_event_id,\n                        true,\n                    );\n                } else {\n                    if !index_complete {\n                        eprintln!(\"[mac] index incomplete; starting full index\");\n                    }\n                    let _ = start_full_index_worker(app_handle.clone(), state.clone());\n                    start_fsevent_watcher_worker(app_handle.clone(), state.clone(), None, false);\n                }\n            }\n        }\n\n        #[cfg(target_os = \"windows\")]\n        {\n            win::start_windows_indexing(app_handle.clone(), state.clone());\n        }\n\n        #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n        {\n            let _ = start_full_index_worker(app_handle.clone(), state.clone());\n        }\n\n        if bench_mode {\n            start_bench_runner(app_handle.clone(), state.clone());\n        }\n\n        #[cfg(not(target_os = \"windows\"))]\n        if !bench_mode {\n            let icon_cache = state.icon_cache.clone();\n            std::thread::spawn(move || {\n                let exts = [\n                    \"txt\", \"pdf\", \"png\", \"jpg\", \"md\", \"json\", \"swift\", \"rs\", \"js\", \"ts\", \"html\",\n                    \"css\", \"py\", \"zip\", \"dmg\", \"app\", \"doc\", \"xls\", \"ppt\", \"mov\",\n                ];\n                for ext in &exts {\n                    let key = ext.to_string();\n                    if icon_cache.lock().contains_key(&key) {\n                        continue;\n                    }\n                    if let Some(icon) = load_system_icon_png(ext) {\n                        icon_cache.lock().insert(key, icon);\n                    }\n                }\n            });\n        }\n    });\n\n    Ok(())\n}\n\n#[cfg_attr(mobile, tauri::mobile_entry_point)]\npub fn run() {\n    let _ = STARTUP_T0.set(Instant::now());\n    eprintln!(\"[startup +{}ms] run() entered\", startup_elapsed_ms());\n    #[cfg(target_os = \"windows\")]\n    if cfg!(debug_assertions) {\n        // Safety: called at program start before any threads are spawned.\n        // Will require `unsafe` block when migrating to Rust edition 2024.\n        std::env::set_var(\n            \"WEBVIEW2_ADDITIONAL_BROWSER_ARGUMENTS\",\n            \"--no-proxy-server --disable-http-cache --disk-cache-size=1 --media-cache-size=1\",\n        );\n        eprintln!(\n            \"[startup +{}ms] set REDACTED --disable-http-cache --disk-cache-size=1 --media-cache-size=1\",\n            startup_elapsed_ms()\n        );\n    }\n    let mut builder = tauri::Builder::default()\n        .plugin(tauri_plugin_decorum::init())\n        .plugin(tauri_plugin_drag::init())\n        .plugin(tauri_plugin_global_shortcut::Builder::new().build());\n\n    if !cfg!(debug_assertions) {\n        builder = builder.plugin(tauri_plugin_window_state::Builder::default().build());\n    } else {\n        eprintln!(\n            \"[startup +{}ms] debug mode: window-state plugin disabled for startup A/B test\",\n            startup_elapsed_ms()\n        );\n    }\n\n    builder\n        .on_page_load(|window, payload| {\n            eprintln!(\n                \"[startup/page +{}ms] on_page_load label={} event={:?} url={}\",\n                startup_elapsed_ms(),\n                window.label(),\n                payload.event(),\n                payload.url()\n            );\n        })\n        .setup(|app| {\n            setup_app(app).map_err(|e| {\n                Box::<dyn std::error::Error>::from(io::Error::new(io::ErrorKind::Other, e))\n            })\n        })\n        .invoke_handler(tauri::generate_handler![\n            get_index_status,\n            get_home_dir,\n            start_full_index,\n            reset_index,\n            search,\n            fd_search,\n            quick_look,\n            open,\n            open_with,\n            reveal_in_finder,\n            copy_paths,\n            copy_files,\n            move_to_trash,\n            rename,\n            get_file_icon,\n            get_platform,\n            show_context_menu,\n            set_native_theme,\n            frontend_log,\n            mark_frontend_ready\n        ])\n        .run(tauri::generate_context!())\n        .expect(\"error while running tauri application\");\n}\n\nfn main() {\n    run();\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::time::{SystemTime, UNIX_EPOCH};\n\n    fn mk_entry(path: &str, name: &str) -> EntryDto {\n        let parent = Path::new(path)\n            .parent()\n            .map(|p| p.to_string_lossy().to_string())\n            .unwrap_or_else(|| \"/\".to_string());\n        EntryDto {\n            path: path.to_string(),\n            name: name.to_string(),\n            dir: parent,\n            is_dir: false,\n            ext: None,\n            size: None,\n            mtime: None,\n        }\n    }\n\n    fn temp_case_dir(case: &str) -> PathBuf {\n        let stamp = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .map(|d| d.as_nanos())\n            .unwrap_or(0);\n        let base = if cfg!(target_os = \"windows\") {\n            std::env::current_dir()\n                .map(|dir| dir.join(\"tmp-test-dirs\"))\n                .unwrap_or_else(|_| std::env::temp_dir())\n        } else {\n            std::env::temp_dir()\n        };\n        base.join(format!(\n            \"everything_{case}_{}_{}\",\n            std::process::id(),\n            stamp\n        ))\n    }\n\n    fn test_state_for(db_path: PathBuf, home_dir: PathBuf, cwd: PathBuf) -> AppState {\n        AppState {\n            db_path,\n            home_dir: home_dir.clone(),\n            scan_root: home_dir.clone(),\n            cwd,\n            path_ignores: Arc::new(Vec::new()),\n            path_ignore_patterns: Arc::new(Vec::new()),\n            db_ready: Arc::new(AtomicBool::new(true)),\n            indexing_active: Arc::new(AtomicBool::new(false)),\n            status: Arc::new(Mutex::new(IndexStatus::default())),\n            recent_ops: Arc::new(Mutex::new(Vec::new())),\n            icon_cache: Arc::new(Mutex::new(HashMap::new())),\n            fd_search_cache: Arc::new(Mutex::new(None)),\n            negative_name_cache: Arc::new(Mutex::new(HashMap::new())),\n            ignore_cache: Arc::new(Mutex::new(None)),\n            gitignore: Arc::new(gitignore_filter::LazyGitignoreFilter::new(home_dir.clone())),\n            mem_index: Arc::new(RwLock::new(None)),\n            watcher_stop: Arc::new(AtomicBool::new(false)),\n            watcher_active: Arc::new(AtomicBool::new(false)),\n            frontend_ready: Arc::new(AtomicBool::new(true)),\n        }\n    }\n\n    #[test]\n    fn should_skip_path_for_ignored_descendant() {\n        let ignored = vec![PathBuf::from(\n            \"/Users/al02402336/Library/Developer/Xcode/DerivedData\",\n        )];\n        let target = Path::new(\n            \"REDACTED\",\n        );\n\n        assert!(should_skip_path(target, &ignored, &[]));\n    }\n\n    #[test]\n    fn filter_ignored_entries_removes_pathignore_matches() {\n        let ignored = vec![PathBuf::from(\n            \"/Users/al02402336/Library/Developer/Xcode/DerivedData\",\n        )];\n        let entries = vec![\n            mk_entry(\n                \"REDACTED\",\n                \"-Users-al02402336-a_desktop\",\n            ),\n            mk_entry(\"/Users/al02402336/a_desktop\", \"a_desktop\"),\n        ];\n\n        let filtered = filter_ignored_entries(entries, &ignored, &[]);\n\n        assert_eq!(filtered.len(), 1);\n        assert_eq!(filtered[0].path, \"/Users/al02402336/a_desktop\");\n    }\n\n    #[test]\n    fn should_skip_path_for_glob_any_segment_target() {\n        let patterns = vec![IgnorePattern::AnySegment(\"target\".to_string())];\n\n        assert!(should_skip_path(\n            Path::new(\"/Users/al02402336/work/rust/target\"),\n            &[],\n            &patterns\n        ));\n        assert!(should_skip_path(\n            Path::new(\"/Users/al02402336/work/rust/target/debug/deps/foo.o\"),\n            &[],\n            &patterns\n        ));\n        assert!(!should_skip_path(\n            Path::new(\"/Users/al02402336/work/rust/targets/debug/deps/foo.o\"),\n            &[],\n            &patterns\n        ));\n    }\n\n    #[test]\n    fn relevance_sort_prefers_shallow_exact_match() {\n        let mut entries = vec![\n            mk_entry(\"/Users/al02402336/work/a_desktop\", \"a_desktop\"),\n            mk_entry(\"/Users/al02402336/a_desktop\", \"a_desktop\"),\n            mk_entry(\n                \"/Users/al02402336/Library/Developer/Xcode/DerivedData/-Users-al02402336-a_desktop\",\n                \"-Users-al02402336-a_desktop\",\n            ),\n        ];\n\n        sort_entries_with_relevance(&mut entries, \"a_desktop\", \"name\", \"asc\");\n\n        assert_eq!(entries[0].path, \"/Users/al02402336/a_desktop\");\n    }\n\n    #[test]\n    fn resolved_dir_range_excludes_sibling_with_same_prefix() {\n        let dir_exact = \"/Users/user/Projects\";\n        let dir_prefix = format!(\"{}/\", dir_exact);\n        let dir_prefix_end = format!(\"{}0\", dir_exact);\n\n        let in_scope = |dir: &str| {\n            dir == dir_exact || (dir >= dir_prefix.as_str() && dir < dir_prefix_end.as_str())\n        };\n\n        assert!(in_scope(\"/Users/user/Projects\"));\n        assert!(in_scope(\"/Users/user/Projects/src\"));\n        assert!(in_scope(\"/Users/user/Projects/src/deeper\"));\n\n        assert!(!in_scope(\"/Users/user/Projects-archived\"));\n        assert!(!in_scope(\"/Users/user/Projects.archived\"));\n        assert!(!in_scope(\"/Users/user/Projects_archived\"));\n        assert!(!in_scope(\"/Users/user/Projectz\"));\n    }\n\n    #[test]\n    fn delete_paths_root_clears_all_entries() {\n        let root = temp_case_dir(\"delete_paths_root\");\n        let dir_a = root.join(\"alpha\");\n        let dir_b = root.join(\"beta\").join(\"nested\");\n        fs::create_dir_all(&dir_a).unwrap();\n        fs::create_dir_all(&dir_b).unwrap();\n\n        let db_path = root.join(\"index.db\");\n        init_db(&db_path).unwrap();\n        let mut conn = db_connection(&db_path).unwrap();\n        let now = now_epoch();\n\n        for (path, name, dir, ext) in [\n            (dir_a.join(\"a.txt\"), \"a.txt\", dir_a.clone(), \"txt\"),\n            (dir_b.join(\"b.rs\"), \"b.rs\", dir_b.clone(), \"rs\"),\n        ] {\n            conn.execute(\n                \"INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n                 VALUES(?1, ?2, ?3, 0, ?4, NULL, NULL, ?5, 1)\",\n                params![\n                    path.to_string_lossy().to_string(),\n                    name,\n                    dir.to_string_lossy().to_string(),\n                    ext,\n                    now\n                ],\n            )\n            .unwrap();\n        }\n\n        let deleted = delete_paths(&mut conn, &[\"/\".to_string()]).unwrap();\n        assert!(deleted >= 2);\n\n        let remaining: i64 = conn\n            .query_row(\"SELECT COUNT(*) FROM entries\", [], |row| row.get(0))\n            .unwrap();\n        assert_eq!(remaining, 0);\n\n        let _ = fs::remove_dir_all(root);\n    }\n\n    #[test]\n    fn execute_search_resolved_path_does_not_include_prefixed_sibling_dirs() {\n        let root = temp_case_dir(\"resolved_path_scope_execute\");\n        let projects_src = root.join(\"Projects\").join(\"src\");\n        let archived_src = root.join(\"Projects-archived\").join(\"src\");\n        fs::create_dir_all(&projects_src).unwrap();\n        fs::create_dir_all(&archived_src).unwrap();\n\n        let db_path = root.join(\"index.db\");\n        init_db(&db_path).unwrap();\n        let conn = db_connection(&db_path).unwrap();\n        let now = now_epoch();\n\n        let project_path = projects_src.join(\"main.rs\");\n        let archived_path = archived_src.join(\"legacy.rs\");\n\n        conn.execute(\n            \"INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n             VALUES(?1, ?2, ?3, 0, ?4, NULL, NULL, ?5, 1)\",\n            params![\n                project_path.to_string_lossy().to_string(),\n                \"main.rs\",\n                projects_src.to_string_lossy().to_string(),\n                \"rs\",\n                now\n            ],\n        )\n        .unwrap();\n\n        conn.execute(\n            \"INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n             VALUES(?1, ?2, ?3, 0, ?4, NULL, NULL, ?5, 1)\",\n            params![\n                archived_path.to_string_lossy().to_string(),\n                \"legacy.rs\",\n                archived_src.to_string_lossy().to_string(),\n                \"rs\",\n                now\n            ],\n        )\n        .unwrap();\n\n        let state = test_state_for(db_path.clone(), root.clone(), root.clone());\n        let result = execute_search(\n            &state,\n            \"Projects/ *.rs\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        assert!(result\n            .results\n            .iter()\n            .any(|entry| entry.path == project_path.to_string_lossy()));\n        assert!(result\n            .results\n            .iter()\n            .all(|entry| !entry.path.contains(\"Projects-archived\")));\n\n        let _ = fs::remove_dir_all(root);\n    }\n\n    #[test]\n    fn find_file_upward_locates_repo_level_pathignore() {\n        let root = temp_case_dir(\"pathignore_upward\");\n        let nested = root.join(\"src-tauri\").join(\"target\");\n        fs::create_dir_all(&nested).unwrap();\n        fs::write(root.join(\".pathignore\"), \"node_modules\\n\").unwrap();\n\n        let found = find_file_upward(&nested, \".pathignore\");\n        assert_eq!(found, Some(root.join(\".pathignore\")));\n\n        let _ = fs::remove_dir_all(root);\n    }\n\n    #[test]\n    fn find_git_root_works_from_nested_directory() {\n        let root = temp_case_dir(\"git_root\");\n        let nested = root.join(\"src-tauri\").join(\"target\");\n        fs::create_dir_all(&nested).unwrap();\n        fs::create_dir_all(root.join(\".git\")).unwrap();\n\n        let found = find_git_root(&nested);\n        assert_eq!(found, Some(root.clone()));\n\n        let _ = fs::remove_dir_all(root);\n    }\n\n    #[test]\n    fn extract_ext_from_like_rejects_multi_dot() {\n        assert_eq!(extract_ext_from_like(\"%.tar.gz\"), None);\n        assert_eq!(extract_ext_from_like(\"%.d.ts\"), None);\n        assert_eq!(extract_ext_from_like(\"%.rs\"), Some(\"rs\".to_string()));\n        assert_eq!(extract_ext_from_like(\"%.png\"), Some(\"png\".to_string()));\n    }\n\n    #[test]\n    fn negative_cache_fallback_removes_matched_key_not_query() {\n        let state = test_state_for(\n            PathBuf::from(\"/tmp/neg_cache_test.db\"),\n            PathBuf::from(\"/tmp\"),\n            PathBuf::from(\"/tmp\"),\n        );\n\n        remember_negative_name_query(&state, \"abc\");\n\n        let hit = negative_name_cache_lookup(&state, \"xabc\");\n        assert!(hit.is_some());\n        assert_eq!(hit.unwrap().query_lower, \"abc\");\n\n        remove_negative_name_query(&state, \"abc\");\n\n        let hit_after = negative_name_cache_lookup(&state, \"xabc\");\n        assert!(hit_after.is_none());\n    }\n\n    #[test]\n    fn dir_listing_deep_nested_path_without_time_budget() {\n        let root = temp_case_dir(\"dir_listing_deep\");\n        // Simulate: ~/Library/Containers/jp.naver.line.mac/Data/Library/Containers/jp.naver.line/log/\n        let deep_dir = root\n            .join(\"Library\")\n            .join(\"Containers\")\n            .join(\"jp.naver.line.mac\")\n            .join(\"Data\")\n            .join(\"Library\")\n            .join(\"Containers\")\n            .join(\"jp.naver.line\")\n            .join(\"log\");\n        let sub_dir = deep_dir.join(\"archive\");\n        fs::create_dir_all(&deep_dir).unwrap();\n        fs::create_dir_all(&sub_dir).unwrap();\n\n        let db_path = root.join(\"index.db\");\n        init_db(&db_path).unwrap();\n        let conn = db_connection(&db_path).unwrap();\n        let now = now_epoch();\n\n        let file1 = deep_dir.join(\"20260211_14.txt\");\n        let file2 = sub_dir.join(\"old.log\");\n        for (path, name, dir, ext) in [\n            (&file1, \"20260211_14.txt\", &deep_dir, \"txt\"),\n            (&file2, \"old.log\", &sub_dir, \"log\"),\n        ] {\n            conn.execute(\n                \"INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n                 VALUES(?1, ?2, ?3, 0, ?4, NULL, NULL, ?5, 1)\",\n                params![\n                    path.to_string_lossy().to_string(),\n                    name,\n                    dir.to_string_lossy().to_string(),\n                    ext,\n                    now\n                ],\n            )\n            .unwrap();\n        }\n\n        let state = test_state_for(db_path, root.clone(), root.clone());\n\n        // Query: \"jp.naver.line/log/\" - dir listing, name_like = \"%\"\n        let result = execute_search(\n            &state,\n            \"jp.naver.line/log/\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        assert_eq!(\n            result.results.len(),\n            2,\n            \"should find both files under log/ and log/archive/\"\n        );\n        let names: Vec<&str> = result.results.iter().map(|e| e.name.as_str()).collect();\n        assert!(names.contains(&\"20260211_14.txt\"));\n        assert!(names.contains(&\"old.log\"));\n\n        // Query with glob: \"jp.naver.line/log/ *\"\n        let result2 = execute_search(\n            &state,\n            \"jp.naver.line/log/ *\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        assert_eq!(\n            result2.results.len(),\n            2,\n            \"glob * should also list all files\"\n        );\n\n        // Query with trailing dot: \"jp.naver.line/log/ *.\" - name_like becomes \"%.\"\n        let result3 = execute_search(\n            &state,\n            \"jp.naver.line/log/ *.\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        // \"*.\" matches files ending with \".\" - none of our test files end with \".\"\n        // so this correctly returns 0 (this is expected, NOT a bug)\n        assert_eq!(\n            result3.results.len(),\n            0,\n            \"*. matches only files ending with dot\"\n        );\n\n        // But plain \"/\" at end should list all\n        let result4 = execute_search(\n            &state,\n            \"jp.naver.line/log/\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        assert_eq!(\n            result4.results.len(),\n            2,\n            \"trailing slash should list all files\"\n        );\n\n        let _ = fs::remove_dir_all(root);\n    }\n\n    #[test]\n    fn path_search_multi_dot_ext_uses_like_not_ext_shortcut() {\n        let root = temp_case_dir(\"multi_dot_ext\");\n        let proj_dir = root.join(\"Projects\");\n        fs::create_dir_all(&proj_dir).unwrap();\n\n        let db_path = root.join(\"index.db\");\n        init_db(&db_path).unwrap();\n        let conn = db_connection(&db_path).unwrap();\n        let now = now_epoch();\n\n        let file_path = proj_dir.join(\"archive.tar.gz\");\n        conn.execute(\n            \"INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n             VALUES(?1, ?2, ?3, 0, ?4, NULL, NULL, ?5, 1)\",\n            params![\n                file_path.to_string_lossy().to_string(),\n                \"archive.tar.gz\",\n                proj_dir.to_string_lossy().to_string(),\n                \"gz\",\n                now\n            ],\n        )\n        .unwrap();\n\n        let state = test_state_for(db_path, root.clone(), root.clone());\n        let result = execute_search(\n            &state,\n            \"Projects/ *.tar.gz\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        assert_eq!(result.results.len(), 1);\n        assert!(result.results[0].name == \"archive.tar.gz\");\n\n        let _ = fs::remove_dir_all(root);\n    }\n}\n","structuredPatch":[{"oldStart":2164,"oldLines":7,"newStart":2164,"newLines":7,"lines":[" "," ","     // Flush home-level stamp batch","-    if stamp_batch.len() >= BATCH_SIZE {","+    if stamp_batch.len() >= flush_batch_size {","         stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;","         stamp_batch.clear();","     }"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"08c5e6b0-d6d2-448e-9878-fbaa23c57109"}
{"parentUuid":"22702c79-431d-4449-bdd7-e19a28634fdf","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01GjR2qtkQ9Pr32M1KVgyGD7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DjzbY7NS2zgbrT922ef7s7","name":"Read","input":{"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","offset":2280,"limit":12},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":260,"cache_read_input_tokens":157653,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":260},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNiskPGvVJPNGY9iAerU","type":"assistant","uuid":"95ba9aeb-db27-40ab-ac32-6197089ce3ab","timestamp":"2026-02-22T07:35:50.540Z"}
{"parentUuid":"95ba9aeb-db27-40ab-ac32-6197089ce3ab","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01DjzbY7NS2zgbrT922ef7s7","toolUseID":"toolu_01DjzbY7NS2zgbrT922ef7s7","timestamp":"2026-02-22T07:35:50.583Z","uuid":"e9d99836-791b-482b-98fe-0865d7a29487"}
{"parentUuid":"95ba9aeb-db27-40ab-ac32-6197089ce3ab","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DjzbY7NS2zgbrT922ef7s7","type":"tool_result","content":"  2280â†’                        }\n  2281â†’\n  2282â†’                        if batch.len() >= BATCH_SIZE {\n  2283â†’                            upsert_rows(conn, &batch)?;\n  2284â†’                            batch.clear();\n  2285â†’                        }\n  2286â†’\n  2287â†’                        if stamp_batch.len() >= BATCH_SIZE {\n  2288â†’                            stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n  2289â†’                            stamp_batch.clear();\n  2290â†’                        }\n  2291â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"450c619b-26b8-4252-b394-76c2f8d2f542","timestamp":"2026-02-22T07:35:50.582Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src-tauri/src/main.rs","content":"                        }\n\n                        if batch.len() >= BATCH_SIZE {\n                            upsert_rows(conn, &batch)?;\n                            batch.clear();\n                        }\n\n                        if stamp_batch.len() >= BATCH_SIZE {\n                            stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n                            stamp_batch.clear();\n                        }\n","numLines":12,"startLine":2280,"totalLines":5786}},"sourceToolAssistantUUID":"95ba9aeb-db27-40ab-ac32-6197089ce3ab"}
{"parentUuid":"450c619b-26b8-4252-b394-76c2f8d2f542","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01PthY4xtRYy8htD4Kqp5zuu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01T4NK6EVP9sN3RMHKhd5tUB","name":"Edit","input":{"replace_all":false,"file_path":"/Users/al02402336/everything/src-tauri/src/main.rs","old_string":"                        if batch.len() >= BATCH_SIZE {\n                            upsert_rows(conn, &batch)?;\n                            batch.clear();\n                        }\n\n                        if stamp_batch.len() >= BATCH_SIZE {\n                            stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n                            stamp_batch.clear();\n                        }","new_string":"                        if batch.len() >= flush_batch_size {\n                            upsert_rows(conn, &batch)?;\n                            batch.clear();\n                        }\n\n                        if stamp_batch.len() >= flush_batch_size {\n                            stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n                            stamp_batch.clear();\n                        }"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":455,"cache_read_input_tokens":157913,"output_tokens":315,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":455,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYNisvMJnshhCc3HGmSeW","type":"assistant","uuid":"d1341dd3-7ae8-4e22-a473-867a738d385f","timestamp":"2026-02-22T07:35:54.354Z"}
{"parentUuid":"d1341dd3-7ae8-4e22-a473-867a738d385f","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01T4NK6EVP9sN3RMHKhd5tUB","toolUseID":"toolu_01T4NK6EVP9sN3RMHKhd5tUB","timestamp":"2026-02-22T07:35:54.363Z","uuid":"dfb95482-d64c-43b3-85f5-49c413f8460d"}
{"parentUuid":"d1341dd3-7ae8-4e22-a473-867a738d385f","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01T4NK6EVP9sN3RMHKhd5tUB","type":"tool_result","content":"The file /Users/al02402336/everything/src-tauri/src/main.rs has been updated successfully."}]},"uuid":"35bbfb4c-927e-471a-bcb9-47acc323d94f","timestamp":"2026-02-22T07:35:54.362Z","toolUseResult":{"filePath":"/Users/al02402336/everything/src-tauri/src/main.rs","oldString":"                        if batch.len() >= BATCH_SIZE {\n                            upsert_rows(conn, &batch)?;\n                            batch.clear();\n                        }\n\n                        if stamp_batch.len() >= BATCH_SIZE {\n                            stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n                            stamp_batch.clear();\n                        }","newString":"                        if batch.len() >= flush_batch_size {\n                            upsert_rows(conn, &batch)?;\n                            batch.clear();\n                        }\n\n                        if stamp_batch.len() >= flush_batch_size {\n                            stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n                            stamp_batch.clear();\n                        }","originalFile":"#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\n\nuse std::{\n    cmp::Ordering,\n    collections::{HashMap, HashSet},\n    fs,\n    hash::{Hash, Hasher},\n    io::{self, BufRead, BufReader, Write},\n    path::{Path, PathBuf},\n    process::{Command, Stdio},\n    sync::{\n        atomic::{AtomicBool, Ordering as AtomicOrdering},\n        Arc, OnceLock,\n    },\n    time::{Duration, Instant, SystemTime, UNIX_EPOCH},\n};\n\nuse parking_lot::{Mutex, RwLock};\nuse rusqlite::{params, params_from_iter, types::Value as SqlValue, Connection};\nuse serde::Serialize;\nuse tauri::{AppHandle, Emitter, Manager, State};\n#[cfg(target_os = \"macos\")]\nuse tauri_plugin_global_shortcut::{Code, GlobalShortcutExt, Modifiers, Shortcut};\n#[cfg(target_os = \"windows\")]\nuse std::os::windows::process::CommandExt;\nuse walkdir::WalkDir;\n\nmod fd_search;\nmod gitignore_filter;\n#[cfg(target_os = \"macos\")]\nmod mac;\nmod mem_search;\nmod query;\n#[cfg(target_os = \"windows\")]\nmod win;\nuse fd_search::{FdSearchCache, FdSearchResultDto};\nuse query::{escape_like, parse_query, SearchMode};\n\nconst DEFAULT_LIMIT: u32 = 300;\nconst SHORT_QUERY_LIMIT: u32 = 100;\nconst MAX_LIMIT: u32 = 1000;\npub(crate) const BATCH_SIZE: usize = 10_000;\nconst RECENT_OP_TTL: Duration = Duration::from_secs(2);\npub(crate) const WATCH_DEBOUNCE: Duration = Duration::from_millis(300);\nconst NEGATIVE_CACHE_TTL: Duration = Duration::from_secs(60);\nconst NEGATIVE_CACHE_FALLBACK_WINDOW: Duration = Duration::from_millis(550);\nconst DB_VERSION: i32 = 4;\nconst DEFERRED_DIR_NAMES: &[&str] = &[\n    \"Library\", \".Trash\", \".Trashes\",\n    // Windows system directories (deferred when scan_root is C:\\)\n    \"Windows\", \"Program Files\", \"Program Files (x86)\",\n    \"$Recycle.Bin\", \"System Volume Information\", \"Recovery\", \"PerfLogs\",\n];\nconst SHALLOW_SCAN_DEPTH: usize = 6;\nfn jwalk_num_threads() -> usize {\n    std::thread::available_parallelism()\n        .map(|n| (n.get() / 2).max(4).min(16))\n        .unwrap_or(8)\n}\n\npub(crate) const BUILTIN_SKIP_NAMES: &[&str] = &[\n    \".git\",\n    \"node_modules\",\n    \".Trash\",\n    \".Trashes\",\n    \".npm\",\n    \".cache\",\n    \"CMakeFiles\",\n    \".qtc_clangd\",\n    \"__pycache__\",\n    \".gradle\",\n    \"DerivedData\",\n];\n\n/// Path segments whose name ends with one of these suffixes are skipped.\n/// e.g. \"*.build\" skips Xcode intermediate build directories like \"MyApp.build\".\npub(crate) const BUILTIN_SKIP_SUFFIXES: &[&str] = &[\n    \".build\", // Xcode intermediate build dir (MyApp.build, Objects-normal, etc.)\n];\n\npub(crate) const BUILTIN_SKIP_PATHS: &[&str] = &[\n    // macOS\n    \"Library/Caches\",\n    \"Library/Developer/CoreSimulator\",\n    \"Library/Logs\",\n    // Cross-platform\n    \".vscode/extensions\",\n    // Windows: noisy system directories under AppData\n    \"AppData/Local/Temp\",\n    \"AppData/Local/Microsoft\",\n    \"AppData/Local/Google\",\n    \"AppData/Local/Packages\",\n];\n\ntype AppResult<T> = Result<T, String>;\nstatic SEARCH_LOG_ENABLED: OnceLock<bool> = OnceLock::new();\nstatic PERF_LOG_ENABLED: OnceLock<bool> = OnceLock::new();\nstatic BENCH_MODE_ENABLED: OnceLock<bool> = OnceLock::new();\nstatic STARTUP_T0: OnceLock<Instant> = OnceLock::new();\n\nfn startup_elapsed_ms() -> u128 {\n    STARTUP_T0\n        .get()\n        .map(|started| started.elapsed().as_millis())\n        .unwrap_or(0)\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct EntryDto {\n    pub path: String,\n    pub name: String,\n    pub dir: String,\n    pub is_dir: bool,\n    pub ext: Option<String>,\n    pub size: Option<i64>,\n    pub mtime: Option<i64>,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct IndexStatusDto {\n    state: String,\n    entries_count: u64,\n    last_updated: Option<i64>,\n    permission_errors: u64,\n    message: Option<String>,\n    scanned: u64,\n    indexed: u64,\n    current_path: String,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct IndexProgressEvent {\n    scanned: u64,\n    indexed: u64,\n    current_path: String,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct IndexStateEvent {\n    state: String,\n    message: Option<String>,\n    is_catchup: bool,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct IndexUpdatedEvent {\n    entries_count: u64,\n    last_updated: i64,\n    permission_errors: u64,\n}\n\n#[derive(Debug, Clone)]\nstruct SearchExecution {\n    query: String,\n    sort_by: String,\n    sort_dir: String,\n    effective_limit: u32,\n    offset: u32,\n    mode_label: String,\n    results: Vec<EntryDto>,\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct SearchResultDto {\n    entries: Vec<EntryDto>,\n    mode_label: String,\n    /// Total number of results matching the query (ignoring LIMIT/OFFSET).\n    total_count: u32,\n    /// True when total_count is exact. False means frontend should treat it as unknown.\n    total_known: bool,\n}\n\n#[allow(dead_code)]\n#[derive(Debug, Clone)]\nstruct BenchCase {\n    id: &'static str,\n    query: &'static str,\n    sort_by: &'static str,\n    sort_dir: &'static str,\n    limit: u32,\n    offset: u32,\n    expected_min_results: usize,\n}\n\n#[allow(dead_code)]\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct BenchCaseResult {\n    id: String,\n    query: String,\n    mode: String,\n    sort_by: String,\n    sort_dir: String,\n    limit: u32,\n    offset: u32,\n    elapsed_ms: f64,\n    result_count: usize,\n    expected_min_results: usize,\n    passed: bool,\n    top_results: Vec<String>,\n    error: Option<String>,\n}\n\n#[allow(dead_code)]\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct BenchReport {\n    run_label: String,\n    started_at: i64,\n    completed_at: i64,\n    home_dir: String,\n    db_path: String,\n    index_wait_ms: u128,\n    index_scanned: u64,\n    index_indexed: u64,\n    index_entries_count: u64,\n    index_permission_errors: u64,\n    index_message: Option<String>,\n    search_iterations: u32,\n    search_results: Vec<BenchCaseResult>,\n}\n\n#[derive(Debug, Clone)]\npub(crate) enum IndexState {\n    Ready,\n    Indexing,\n    Error,\n}\n\nimpl IndexState {\n    fn as_str(&self) -> &'static str {\n        match self {\n            Self::Ready => \"Ready\",\n            Self::Indexing => \"Indexing\",\n            Self::Error => \"Error\",\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct IndexStatus {\n    pub(crate) state: IndexState,\n    pub(crate) entries_count: u64,\n    pub(crate) last_updated: Option<i64>,\n    pub(crate) permission_errors: u64,\n    pub(crate) message: Option<String>,\n    pub(crate) scanned: u64,\n    pub(crate) indexed: u64,\n    pub(crate) current_path: String,\n}\n\nimpl Default for IndexStatus {\n    fn default() -> Self {\n        Self {\n            state: IndexState::Indexing,\n            entries_count: 0,\n            last_updated: None,\n            permission_errors: 0,\n            message: None,\n            scanned: 0,\n            indexed: 0,\n            current_path: String::new(),\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\n#[allow(dead_code)]\npub(crate) struct RecentOp {\n    old_path: Option<String>,\n    new_path: Option<String>,\n    op_type: &'static str,\n    at: Instant,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub(crate) enum IgnorePattern {\n    AnySegment(String),\n    Glob(String),\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct IgnoreRulesCache {\n    roots: Vec<PathBuf>,\n    patterns: Vec<IgnorePattern>,\n    pathignore_mtime: Option<SystemTime>,\n    gitignore_mtime: Option<SystemTime>,\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct AppState {\n    pub(crate) db_path: PathBuf,\n    pub(crate) home_dir: PathBuf,\n    pub(crate) scan_root: PathBuf,\n    pub(crate) cwd: PathBuf,\n    pub(crate) path_ignores: Arc<Vec<PathBuf>>,\n    pub(crate) path_ignore_patterns: Arc<Vec<IgnorePattern>>,\n    pub(crate) db_ready: Arc<AtomicBool>,\n    pub(crate) indexing_active: Arc<AtomicBool>,\n    pub(crate) status: Arc<Mutex<IndexStatus>>,\n    pub(crate) recent_ops: Arc<Mutex<Vec<RecentOp>>>,\n    pub(crate) icon_cache: Arc<Mutex<HashMap<String, Vec<u8>>>>,\n    pub(crate) fd_search_cache: Arc<Mutex<Option<FdSearchCache>>>,\n    pub(crate) negative_name_cache: Arc<Mutex<HashMap<String, NegativeNameEntry>>>,\n    pub(crate) ignore_cache: Arc<Mutex<Option<IgnoreRulesCache>>>,\n    pub(crate) gitignore: Arc<gitignore_filter::LazyGitignoreFilter>,\n    /// In-memory index for instant search while DB upsert runs in background.\n    /// Set by MFT scan, cleared after background DB upsert completes.\n    pub(crate) mem_index: Arc<RwLock<Option<Arc<mem_search::MemIndex>>>>,\n    /// Signal to stop the file watcher (RDCW / USN). Set to true on reset_index.\n    pub(crate) watcher_stop: Arc<AtomicBool>,\n    /// Set to true while a file watcher event loop is running.\n    pub(crate) watcher_active: Arc<AtomicBool>,\n    /// Set to true once frontend onMount has completed enough to accept user input.\n    pub(crate) frontend_ready: Arc<AtomicBool>,\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct NegativeNameEntry {\n    created_at: Instant,\n    fallback_checked: bool,\n}\n\n#[derive(Debug, Clone)]\nstruct NegativeCacheHit {\n    query_lower: String,\n    age: Duration,\n    fallback_checked: bool,\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct IndexRow {\n    pub(crate) path: String,\n    pub(crate) name: String,\n    pub(crate) dir: String,\n    pub(crate) is_dir: i64,\n    pub(crate) ext: Option<String>,\n    pub(crate) mtime: Option<i64>,\n    pub(crate) size: Option<i64>,\n    pub(crate) indexed_at: i64,\n    pub(crate) run_id: i64,\n}\n\npub(crate) fn now_epoch() -> i64 {\n    SystemTime::now()\n        .duration_since(UNIX_EPOCH)\n        .map(|d| d.as_secs() as i64)\n        .unwrap_or_default()\n}\n\nfn env_truthy(key: &str) -> bool {\n    std::env::var(key)\n        .ok()\n        .map(|value| {\n            matches!(\n                value.trim().to_ascii_lowercase().as_str(),\n                \"1\" | \"true\" | \"yes\" | \"on\"\n            )\n        })\n        .unwrap_or(false)\n}\n\nfn bench_mode_enabled() -> bool {\n    *BENCH_MODE_ENABLED.get_or_init(|| env_truthy(\"EVERYTHING_BENCH\"))\n}\n\nfn perf_log_enabled() -> bool {\n    *PERF_LOG_ENABLED.get_or_init(|| env_truthy(\"FASTFIND_PERF_LOG\") || bench_mode_enabled())\n}\n\npub(crate) fn perf_log(message: impl AsRef<str>) {\n    if perf_log_enabled() {\n        eprintln!(\"[perf] {}\", message.as_ref());\n    }\n}\n\nfn db_connection_with_timeout(db_path: &Path, busy_timeout_ms: u32) -> AppResult<Connection> {\n    let conn = Connection::open(db_path).map_err(|e| e.to_string())?;\n    conn.execute_batch(&format!(\n        r#\"\n        PRAGMA journal_mode=WAL;\n        PRAGMA synchronous=NORMAL;\n        PRAGMA temp_store=MEMORY;\n        PRAGMA busy_timeout={busy_timeout_ms};\n        \"#,\n    ))\n    .map_err(|e| e.to_string())?;\n    Ok(conn)\n}\n\npub(crate) fn db_connection(db_path: &Path) -> AppResult<Connection> {\n    db_connection_with_timeout(db_path, 3000)\n}\n\nfn db_connection_for_search(db_path: &Path) -> AppResult<Connection> {\n    let conn = db_connection_with_timeout(db_path, 500)?;\n    conn.execute_batch(\n        \"PRAGMA cache_size = -32768;\n         PRAGMA mmap_size = 268435456;\",\n    )\n    .map_err(|e| e.to_string())?;\n    Ok(conn)\n}\n\npub(crate) fn set_indexing_pragmas(conn: &Connection) -> AppResult<()> {\n    conn.execute_batch(\n        r#\"\n        PRAGMA synchronous = OFF;\n        PRAGMA cache_size = -131072;\n        PRAGMA mmap_size = 536870912;\n        PRAGMA wal_autocheckpoint = 0;\n        \"#,\n    )\n    .map_err(|e| e.to_string())\n}\n\npub(crate) fn restore_normal_pragmas(conn: &Connection) -> AppResult<()> {\n    conn.execute_batch(\n        r#\"\n        PRAGMA synchronous = NORMAL;\n        PRAGMA cache_size = -16384;\n        PRAGMA mmap_size = 268435456;\n        PRAGMA wal_autocheckpoint = 1000;\n        \"#,\n    )\n    .map_err(|e| e.to_string())?;\n    conn.execute_batch(\"PRAGMA wal_checkpoint(TRUNCATE);\")\n        .map_err(|e| e.to_string())?;\n    Ok(())\n}\n\nfn init_db(db_path: &Path) -> AppResult<()> {\n    let t = Instant::now();\n    let conn = db_connection(db_path)?;\n    eprintln!(\"[init_db] +{}ms db_connection opened\", t.elapsed().as_millis());\n\n    let current_version: i32 = conn\n        .query_row(\"PRAGMA user_version\", [], |row| row.get(0))\n        .unwrap_or(0);\n    if current_version != DB_VERSION {\n        conn.execute_batch(\n            r#\"\n            DROP TRIGGER IF EXISTS entries_ai;\n            DROP TRIGGER IF EXISTS entries_ad;\n            DROP TRIGGER IF EXISTS entries_au;\n            DROP TABLE IF EXISTS entries_fts;\n            DROP TABLE IF EXISTS entries;\n            \"#,\n        )\n        .map_err(|e| e.to_string())?;\n        conn.execute_batch(&format!(\"PRAGMA user_version = {};\", DB_VERSION))\n            .map_err(|e| e.to_string())?;\n    }\n    eprintln!(\"[init_db] +{}ms version check done (v={})\", t.elapsed().as_millis(), current_version);\n\n    conn.execute_batch(\n        r#\"\n        CREATE TABLE IF NOT EXISTS entries (\n          id INTEGER PRIMARY KEY,\n          path TEXT NOT NULL UNIQUE,\n          name TEXT NOT NULL,\n          dir TEXT NOT NULL,\n          is_dir INTEGER NOT NULL,\n          ext TEXT,\n          mtime INTEGER,\n          size INTEGER,\n          indexed_at INTEGER NOT NULL,\n          run_id INTEGER NOT NULL DEFAULT 0\n        );\n\n        CREATE INDEX IF NOT EXISTS idx_entries_dir_ext_name_nocase ON entries(dir, ext, name COLLATE NOCASE);\n        CREATE INDEX IF NOT EXISTS idx_entries_mtime ON entries(mtime);\n        CREATE INDEX IF NOT EXISTS idx_entries_name_nocase ON entries(name COLLATE NOCASE);\n        CREATE INDEX IF NOT EXISTS idx_entries_ext_name ON entries(ext, name COLLATE NOCASE);\n\n        CREATE TABLE IF NOT EXISTS meta (\n          key TEXT PRIMARY KEY,\n          value TEXT NOT NULL\n        );\n        \"#,\n    )\n    .map_err(|e| e.to_string())?;\n    eprintln!(\"[init_db] +{}ms schema ensured\", t.elapsed().as_millis());\n\n    let legacy_index_migration_key = \"migration_drop_idx_entries_dir_name_nocase_v1\";\n    let migrated = get_meta(&conn, legacy_index_migration_key)\n        .map(|v| v == \"1\")\n        .unwrap_or(false);\n    if !migrated {\n        conn.execute_batch(\"DROP INDEX IF EXISTS idx_entries_dir_name_nocase;\")\n            .map_err(|e| e.to_string())?;\n        set_meta(&conn, legacy_index_migration_key, \"1\")?;\n    }\n    eprintln!(\"[init_db] +{}ms total\", t.elapsed().as_millis());\n\n    Ok(())\n}\n\npub(crate) fn get_meta(conn: &Connection, key: &str) -> Option<String> {\n    conn.query_row(\n        \"SELECT value FROM meta WHERE key = ?1\",\n        params![key],\n        |row| row.get(0),\n    )\n    .ok()\n}\n\npub(crate) fn set_meta(conn: &Connection, key: &str, value: &str) -> AppResult<()> {\n    conn.execute(\n        \"INSERT OR REPLACE INTO meta(key, value) VALUES(?1, ?2)\",\n        params![key, value],\n    )\n    .map_err(|e| e.to_string())?;\n    Ok(())\n}\n\nfn update_counts(state: &AppState) -> AppResult<(u64, Option<i64>)> {\n    let conn = db_connection(&state.db_path)?;\n\n    let entries_count = conn\n        .query_row(\"SELECT COUNT(*) FROM entries\", [], |row| {\n            row.get::<_, i64>(0)\n        })\n        .map_err(|e| e.to_string())?\n        .max(0) as u64;\n\n    let last_updated = conn\n        .query_row(\"SELECT MAX(indexed_at) FROM entries\", [], |row| {\n            row.get::<_, Option<i64>>(0)\n        })\n        .map_err(|e| e.to_string())?;\n\n    Ok((entries_count, last_updated))\n}\n\npub(crate) fn update_status_counts(state: &AppState) -> AppResult<(u64, Option<i64>)> {\n    let (entries_count, last_updated) = update_counts(state)?;\n    let mut status = state.status.lock();\n    status.entries_count = entries_count;\n    status.last_updated = last_updated;\n    Ok((entries_count, last_updated))\n}\n\npub(crate) fn invalidate_search_caches(state: &AppState) {\n    state.fd_search_cache.lock().take();\n    state.negative_name_cache.lock().clear();\n}\n\nfn prune_negative_name_cache(cache: &mut HashMap<String, NegativeNameEntry>) {\n    let now = Instant::now();\n    cache.retain(|_, entry| now.duration_since(entry.created_at) <= NEGATIVE_CACHE_TTL);\n}\n\nfn negative_name_cache_lookup(state: &AppState, query: &str) -> Option<NegativeCacheHit> {\n    if query.is_empty() {\n        return None;\n    }\n    let q = query.to_lowercase();\n    let now = Instant::now();\n    let mut cache = state.negative_name_cache.lock();\n    prune_negative_name_cache(&mut cache);\n    cache\n        .iter()\n        .filter(|(key, _)| q.contains(key.as_str()))\n        .max_by_key(|(key, _)| key.len())\n        .map(|(key, entry)| NegativeCacheHit {\n            query_lower: key.clone(),\n            age: now.duration_since(entry.created_at),\n            fallback_checked: entry.fallback_checked,\n        })\n}\n\nfn remember_negative_name_query(state: &AppState, query: &str) {\n    if query.is_empty() {\n        return;\n    }\n    let normalized = query.to_lowercase();\n    let mut cache = state.negative_name_cache.lock();\n    prune_negative_name_cache(&mut cache);\n\n    if cache.contains_key(&normalized) {\n        return;\n    }\n\n    cache.insert(\n        normalized,\n        NegativeNameEntry {\n            created_at: Instant::now(),\n            fallback_checked: false,\n        },\n    );\n    const MAX_NEGATIVE_CACHE: usize = 512;\n    if cache.len() > MAX_NEGATIVE_CACHE {\n        let mut entries: Vec<_> =\n            cache.iter().map(|(k, v)| (k.clone(), v.created_at)).collect();\n        entries.sort_by_key(|(_, t)| *t);\n        let drop_count = cache.len() - MAX_NEGATIVE_CACHE;\n        for (key, _) in entries.into_iter().take(drop_count) {\n            cache.remove(&key);\n        }\n    }\n}\n\nfn remove_negative_name_query(state: &AppState, query: &str) {\n    if query.is_empty() {\n        return;\n    }\n    let normalized = query.to_lowercase();\n    state.negative_name_cache.lock().remove(&normalized);\n}\n\nfn mark_negative_name_fallback_checked(state: &AppState, query_lower: &str) {\n    let mut cache = state.negative_name_cache.lock();\n    if let Some(entry) = cache.get_mut(query_lower) {\n        entry.fallback_checked = true;\n    }\n}\n\nfn sort_clause(sort_by: &str, sort_dir: &str, prefix: &str) -> String {\n    match (sort_by, sort_dir) {\n        (\"name\", \"desc\") => {\n            format!(\"{prefix}name COLLATE NOCASE DESC, {prefix}path COLLATE NOCASE DESC\")\n        }\n        (\"mtime\", \"asc\") => {\n            format!(\"COALESCE({prefix}mtime, 0) ASC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        (\"mtime\", \"desc\") => {\n            format!(\"COALESCE({prefix}mtime, 0) DESC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        (\"dir\", \"asc\") => {\n            format!(\"{prefix}dir COLLATE NOCASE ASC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        (\"dir\", \"desc\") => {\n            format!(\"{prefix}dir COLLATE NOCASE DESC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        (\"size\", \"asc\") => {\n            format!(\"{prefix}size IS NULL ASC, {prefix}size ASC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        (\"size\", \"desc\") => {\n            format!(\"{prefix}size IS NULL ASC, {prefix}size DESC, {prefix}name COLLATE NOCASE ASC\")\n        }\n        _ => format!(\"{prefix}name COLLATE NOCASE ASC, {prefix}path COLLATE NOCASE ASC\"),\n    }\n}\n\nfn contains_glob_meta(s: &str) -> bool {\n    s.contains('*') || s.contains('?')\n}\n\n/// Detect if a LIKE pattern is a pure extension filter (e.g. `%.rs`).\n/// Returns the lowercase extension if matched, None otherwise.\nfn extract_ext_from_like(like_pattern: &str) -> Option<String> {\n    let rest = like_pattern.strip_prefix('%')?;\n    let ext = rest.strip_prefix('.')?;\n    if ext.is_empty()\n        || ext.contains('%')\n        || ext.contains('_')\n        || ext.contains('\\\\')\n        || ext.contains('/')\n        || ext.contains('.')\n    {\n        return None;\n    }\n    Some(ext.to_lowercase())\n}\n\nfn normalize_hint_to_native(dir_hint: &str) -> (String, bool) {\n    let native = dir_hint.replace('/', &std::path::MAIN_SEPARATOR.to_string());\n    let is_abs = Path::new(&native).is_absolute();\n    (native, is_abs)\n}\n\nfn last_segment(dir_hint: &str) -> &str {\n    dir_hint\n        .rsplit(|c| c == '/' || c == '\\\\')\n        .find(|seg| !seg.is_empty())\n        .unwrap_or(dir_hint)\n}\n\nfn resolve_dir_hint(home_dir: &Path, dir_hint: &str) -> Option<PathBuf> {\n    if dir_hint.is_empty() || contains_glob_meta(dir_hint) {\n        return None;\n    }\n\n    let candidate = if dir_hint == \"~\" {\n        home_dir.to_path_buf()\n    } else if let Some(rest) = dir_hint.strip_prefix(\"~/\") {\n        home_dir.join(rest)\n    } else {\n        let (native_hint, is_absolute) = normalize_hint_to_native(dir_hint);\n        if is_absolute {\n            PathBuf::from(native_hint)\n        } else {\n            home_dir.join(native_hint)\n        }\n    };\n\n    if candidate.is_dir() {\n        Some(candidate)\n    } else {\n        None\n    }\n}\n\nconst RESOLVE_DIRS_MAX: usize = 20;\n\nfn resolve_dirs_from_db(conn: &Connection, dir_hint: &str) -> Vec<String> {\n    if dir_hint.is_empty() || contains_glob_meta(dir_hint) {\n        return Vec::new();\n    }\n    let last_seg = last_segment(dir_hint);\n    let sep = std::path::MAIN_SEPARATOR;\n    let (native_hint, is_absolute) = normalize_hint_to_native(dir_hint);\n    let sep_str = sep.to_string();\n    let escaped_sep = escape_like(&sep_str);\n    let path_pattern = if is_absolute {\n        format!(\"%{}\", escape_like(&native_hint))\n    } else {\n        format!(\"%{escaped_sep}{}\", escape_like(&native_hint))\n    };\n    let fetch_limit = (RESOLVE_DIRS_MAX + 1) as i64;\n    let mut stmt = match conn.prepare(\n        \"SELECT path FROM entries WHERE name = ?1 COLLATE NOCASE AND is_dir = 1 AND path LIKE ?2 ESCAPE '\\\\' LIMIT ?3\",\n    ) {\n        Ok(s) => s,\n        Err(_) => return Vec::new(),\n    };\n    let rows = match stmt.query_map(params![last_seg, path_pattern, fetch_limit], |row| {\n        row.get::<_, String>(0)\n    }) {\n        Ok(r) => r,\n        Err(_) => return Vec::new(),\n    };\n    let dirs: Vec<String> = rows.filter_map(|r| r.ok()).collect();\n    if dirs.len() > RESOLVE_DIRS_MAX {\n        return Vec::new();\n    }\n    dirs\n}\n\nfn normalize_slashes(s: String) -> String {\n    s.replace('\\\\', \"/\")\n}\n\nfn resolve_ignore_path(raw: &str, base_dir: &Path, home_dir: &Path) -> Option<PathBuf> {\n    let trimmed = raw.trim();\n    if trimmed.is_empty() || trimmed.starts_with('#') || trimmed.starts_with('!') {\n        return None;\n    }\n\n    let mut path = if trimmed == \"~\" {\n        home_dir.to_path_buf()\n    } else if let Some(rest) = trimmed.strip_prefix(\"~/\") {\n        home_dir.join(rest)\n    } else {\n        PathBuf::from(trimmed)\n    };\n\n    if !path.is_absolute() {\n        path = base_dir.join(path);\n    }\n\n    Some(fs::canonicalize(&path).unwrap_or(path))\n}\n\nfn normalize_ignore_pattern(raw: &str, base_dir: &Path, home_dir: &Path) -> String {\n    let trimmed = raw.trim().trim_end_matches('/').to_string();\n    if trimmed == \"~\" {\n        return normalize_slashes(home_dir.to_string_lossy().to_string());\n    }\n    if let Some(rest) = trimmed.strip_prefix(\"~/\") {\n        return normalize_slashes(home_dir.join(rest).to_string_lossy().to_string());\n    }\n    if trimmed.starts_with('/') || trimmed.starts_with(\"**/\") {\n        return trimmed;\n    }\n    normalize_slashes(base_dir.join(&trimmed).to_string_lossy().to_string())\n}\n\nfn parse_ignore_pattern(raw: &str, base_dir: &Path, home_dir: &Path) -> Option<IgnorePattern> {\n    let trimmed = raw.trim().trim_end_matches('/');\n    if trimmed.is_empty() {\n        return None;\n    }\n\n    if let Some(segment) = trimmed.strip_prefix(\"**/\") {\n        if !segment.is_empty() && !segment.contains('/') && !contains_glob_meta(segment) {\n            return Some(IgnorePattern::AnySegment(segment.to_string()));\n        }\n    }\n\n    Some(IgnorePattern::Glob(normalize_ignore_pattern(\n        trimmed, base_dir, home_dir,\n    )))\n}\n\nfn ignore_pattern_key(pattern: &IgnorePattern) -> String {\n    match pattern {\n        IgnorePattern::AnySegment(segment) => format!(\"seg:{segment}\"),\n        IgnorePattern::Glob(glob) => format!(\"glob:{glob}\"),\n    }\n}\n\nfn find_file_upward(start: &Path, file_name: &str) -> Option<PathBuf> {\n    let mut current = Some(start);\n    while let Some(dir) = current {\n        let candidate = dir.join(file_name);\n        if candidate.is_file() {\n            return Some(candidate);\n        }\n        current = dir.parent();\n    }\n    None\n}\n\nfn find_git_root(start: &Path) -> Option<PathBuf> {\n    let mut current = Some(start);\n    while let Some(dir) = current {\n        let marker = dir.join(\".git\");\n        if marker.is_dir() || marker.is_file() {\n            return Some(dir.to_path_buf());\n        }\n        current = dir.parent();\n    }\n    None\n}\n\nfn load_pathignore_rules(home_dir: &Path, cwd: &Path) -> (Vec<PathBuf>, Vec<IgnorePattern>) {\n    let mut files = Vec::new();\n    if let Some(file) = find_file_upward(cwd, \".pathignore\") {\n        files.push(file);\n    } else {\n        files.push(cwd.join(\".pathignore\"));\n    }\n    let home_file = home_dir.join(\".pathignore\");\n    if !files.iter().any(|p| p == &home_file) {\n        files.push(home_file);\n    }\n\n    let mut roots = Vec::new();\n    let mut patterns = Vec::new();\n    let mut seen_roots = HashSet::new();\n    let mut seen_patterns = HashSet::new();\n\n    for file in files {\n        let Ok(contents) = fs::read_to_string(&file) else {\n            continue;\n        };\n        let base_dir = file.parent().unwrap_or_else(|| Path::new(\"/\"));\n        for line in contents.lines() {\n            let trimmed = line.trim();\n            if trimmed.is_empty() || trimmed.starts_with('#') || trimmed.starts_with('!') {\n                continue;\n            }\n\n            if contains_glob_meta(trimmed) {\n                let Some(pattern) = parse_ignore_pattern(trimmed, base_dir, home_dir) else {\n                    continue;\n                };\n                let key = ignore_pattern_key(&pattern);\n                if seen_patterns.insert(key) {\n                    patterns.push(pattern);\n                }\n                continue;\n            }\n\n            let Some(path) = resolve_ignore_path(trimmed, base_dir, home_dir) else {\n                continue;\n            };\n\n            let key = path.to_string_lossy().to_string();\n            if seen_roots.insert(key) {\n                roots.push(path);\n            }\n        }\n    }\n\n    (roots, patterns)\n}\n\nfn load_gitignore_roots(home_dir: &Path, cwd: &Path) -> Vec<PathBuf> {\n    let gitignore = if let Some(root) = find_git_root(cwd) {\n        root.join(\".gitignore\")\n    } else if let Some(file) = find_file_upward(&cwd, \".gitignore\") {\n        file\n    } else {\n        return Vec::new();\n    };\n    let contents = match fs::read_to_string(&gitignore) {\n        Ok(contents) => contents,\n        Err(_) => return Vec::new(),\n    };\n\n    let mut roots = Vec::new();\n    let mut seen = HashSet::new();\n\n    for line in contents.lines() {\n        let trimmed = line.trim();\n        if trimmed.is_empty() || trimmed.starts_with('#') || trimmed.starts_with('!') {\n            continue;\n        }\n        if contains_glob_meta(trimmed) || trimmed.contains('[') {\n            continue;\n        }\n\n        let normalized = trimmed.trim_start_matches('/').trim_end_matches('/');\n        if normalized.is_empty() {\n            continue;\n        }\n\n        let Some(path) = resolve_ignore_path(normalized, &cwd, home_dir) else {\n            continue;\n        };\n\n        let key = path.to_string_lossy().to_string();\n        if seen.insert(key) {\n            roots.push(path);\n        }\n    }\n\n    roots\n}\n\n#[cfg(target_os = \"macos\")]\nfn macos_tcc_ignore_roots(home_dir: &Path) -> Vec<PathBuf> {\n    let library = home_dir.join(\"Library\");\n    let app_support = library.join(\"Application Support\");\n    let caches = library.join(\"Caches\");\n\n    let dirs: Vec<PathBuf> = vec![\n        home_dir.join(\".Trash\"),\n        library.join(\"Accounts\"),\n        library.join(\"AppleMediaServices\"),\n        library.join(\"Assistant\").join(\"SiriVocabulary\"),\n        library.join(\"Autosave Information\"),\n        library.join(\"Biome\"),\n        library.join(\"Calendars\"),\n        library.join(\"com.apple.aiml.instrumentation\"),\n        library.join(\"ContainerManager\"),\n        library.join(\"Cookies\"),\n        library.join(\"CoreFollowUp\"),\n        library.join(\"Daemon Containers\"),\n        library.join(\"DoNotDisturb\"),\n        library.join(\"DuetExpertCenter\"),\n        library.join(\"Group Containers\"),\n        library.join(\"HomeKit\"),\n        library.join(\"Developer\").join(\"Xcode\").join(\"DerivedData\"),\n        library.join(\"IdentityServices\"),\n        library.join(\"IntelligencePlatform\"),\n        library.join(\"Mail\"),\n        library.join(\"Messages\"),\n        library.join(\"Metadata\").join(\"CoreSpotlight\"),\n        library.join(\"PersonalizationPortrait\"),\n        library.join(\"Reminders\"),\n        library.join(\"Safari\"),\n        library.join(\"Sharing\"),\n        library.join(\"Shortcuts\"),\n        library.join(\"StatusKit\"),\n        library.join(\"Suggestions\"),\n        library.join(\"Trial\"),\n        library.join(\"Weather\"),\n        app_support.join(\"AddressBook\"),\n        app_support.join(\"CallHistoryDB\"),\n        app_support.join(\"CallHistoryTransactions\"),\n        app_support.join(\"CloudDocs\"),\n        app_support.join(\"com.apple.avfoundation\"),\n        app_support.join(\"com.apple.sharedfilelist\"),\n        app_support.join(\"com.apple.TCC\"),\n        app_support.join(\"DifferentialPrivacy\"),\n        app_support.join(\"FaceTime\"),\n        app_support.join(\"FileProvider\"),\n        app_support.join(\"Knowledge\"),\n        caches.join(\"CloudKit\"),\n        caches.join(\"com.apple.ap.adprivacyd\"),\n        caches.join(\"com.apple.containermanagerd\"),\n        caches.join(\"com.apple.findmy.fmfcore\"),\n        caches.join(\"com.apple.findmy.fmipcore\"),\n        caches.join(\"com.apple.homed\"),\n        caches.join(\"com.apple.HomeKit\"),\n        caches.join(\"com.apple.Safari\"),\n        caches.join(\"FamilyCircle\"),\n    ];\n\n    dirs.into_iter().filter(|p| p.exists()).collect()\n}\n\n#[cfg(not(target_os = \"macos\"))]\nfn macos_tcc_ignore_roots(_home_dir: &Path) -> Vec<PathBuf> {\n    Vec::new()\n}\n\n/// Directories under home that generate heavy background I/O on Windows\n/// (browser caches, Windows Update temp files, UWP package state, etc.).\n/// Pruning these from the MFT subtree eliminates noisy USN records.\n#[cfg(target_os = \"windows\")]\nfn windows_noisy_roots(home_dir: &Path) -> Vec<PathBuf> {\n    let local = home_dir.join(\"AppData\").join(\"Local\");\n    let dirs = vec![\n        local.join(\"Temp\"),\n        local.join(\"Microsoft\"),\n        local.join(\"Google\"),\n        local.join(\"Packages\"),\n        // C:\\ system directories (Windows is deferred, not excluded)\n        PathBuf::from(\"C:\\\\$Recycle.Bin\"),\n        PathBuf::from(\"C:\\\\System Volume Information\"),\n        PathBuf::from(\"C:\\\\Recovery\"),\n        PathBuf::from(\"C:\\\\PerfLogs\"),\n    ];\n    dirs.into_iter().filter(|p| p.exists()).collect()\n}\n\n#[cfg(not(target_os = \"windows\"))]\nfn windows_noisy_roots(_home_dir: &Path) -> Vec<PathBuf> {\n    Vec::new()\n}\n\npub(crate) fn effective_ignore_rules(\n    home_dir: &Path,\n    cwd: &Path,\n    base_roots: &[PathBuf],\n    base_patterns: &[IgnorePattern],\n) -> (Vec<PathBuf>, Vec<IgnorePattern>) {\n    let mut roots = base_roots.to_vec();\n    let mut patterns = base_patterns.to_vec();\n    let mut seen: HashSet<String> = roots\n        .iter()\n        .map(|p| p.to_string_lossy().to_string())\n        .collect();\n    let mut seen_patterns: HashSet<String> = patterns.iter().map(ignore_pattern_key).collect();\n\n    let (pathignore_roots, pathignore_patterns) = load_pathignore_rules(home_dir, cwd);\n    for root in pathignore_roots\n        .into_iter()\n        .chain(load_gitignore_roots(home_dir, cwd).into_iter())\n        .chain(macos_tcc_ignore_roots(home_dir).into_iter())\n        .chain(windows_noisy_roots(home_dir).into_iter())\n    {\n        let key = root.to_string_lossy().to_string();\n        if seen.insert(key) {\n            roots.push(root);\n        }\n    }\n\n    for pattern in pathignore_patterns\n        .into_iter()\n        .chain(builtin_ignore_patterns(home_dir))\n    {\n        let key = ignore_pattern_key(&pattern);\n        if seen_patterns.insert(key) {\n            patterns.push(pattern);\n        }\n    }\n\n    (roots, patterns)\n}\n\nfn builtin_ignore_patterns(home_dir: &Path) -> Vec<IgnorePattern> {\n    let home = normalize_slashes(home_dir.to_string_lossy().to_string());\n    vec![\n        // ~/Library/Application Support/*/Cache*\n        IgnorePattern::Glob(format!(\"{home}/Library/Application Support/*/Cache*\")),\n        // ~/Library/Application Support/*/Code Cache\n        IgnorePattern::Glob(format!(\"{home}/Library/Application Support/*/Code Cache\")),\n        // ~/.rustup/toolchains/*/share/doc\n        IgnorePattern::Glob(format!(\"{home}/.rustup/toolchains/*/share/doc\")),\n        // ~/.pyenv/versions/*/lib\n        IgnorePattern::Glob(format!(\"{home}/.pyenv/versions/*/lib\")),\n    ]\n}\n\npub(crate) fn cached_effective_ignore_rules(state: &AppState) -> (Vec<PathBuf>, Vec<IgnorePattern>) {\n    let home_dir = &state.home_dir;\n    let cwd = &state.cwd;\n\n    let pathignore_mtime = find_file_upward(cwd, \".pathignore\")\n        .or_else(|| Some(home_dir.join(\".pathignore\")))\n        .and_then(|p| fs::metadata(&p).ok())\n        .and_then(|m| m.modified().ok());\n\n    let gitignore_mtime = find_git_root(cwd)\n        .map(|root| root.join(\".gitignore\"))\n        .or_else(|| find_file_upward(cwd, \".gitignore\"))\n        .and_then(|p| fs::metadata(&p).ok())\n        .and_then(|m| m.modified().ok());\n\n    let mut cache = state.ignore_cache.lock();\n    if let Some(ref cached) = *cache {\n        if cached.pathignore_mtime == pathignore_mtime && cached.gitignore_mtime == gitignore_mtime\n        {\n            return (cached.roots.clone(), cached.patterns.clone());\n        }\n    }\n\n    let (roots, patterns) = effective_ignore_rules(\n        home_dir,\n        cwd,\n        state.path_ignores.as_ref(),\n        state.path_ignore_patterns.as_ref(),\n    );\n\n    *cache = Some(IgnoreRulesCache {\n        roots: roots.clone(),\n        patterns: patterns.clone(),\n        pathignore_mtime,\n        gitignore_mtime,\n    });\n\n    (roots, patterns)\n}\n\nfn ignore_rules_fingerprint(roots: &[PathBuf], patterns: &[IgnorePattern]) -> u64 {\n    let mut hasher = std::collections::hash_map::DefaultHasher::new();\n    for root in roots {\n        normalize_slashes(root.to_string_lossy().to_string()).hash(&mut hasher);\n    }\n    for pattern in patterns {\n        ignore_pattern_key(pattern).hash(&mut hasher);\n    }\n    hasher.finish()\n}\n\nfn purge_ignored_entries(db_path: &Path, ignored_roots: &[PathBuf]) -> AppResult<()> {\n    if ignored_roots.is_empty() {\n        return Ok(());\n    }\n\n    let conn = db_connection(db_path)?;\n    for root in ignored_roots {\n        let root_str = root.to_string_lossy().to_string();\n        if root_str.is_empty() {\n            continue;\n        }\n\n        if root_str == \"/\" {\n            conn.execute(\"DELETE FROM entries\", [])\n                .map_err(|e| e.to_string())?;\n            break;\n        }\n\n        let prefix = root_str.trim_end_matches('/');\n        let descendant_like = format!(\"{}%\", escape_like(&format!(\"{prefix}/\")));\n        conn.execute(\n            \"DELETE FROM entries WHERE path = ?1 OR path LIKE ?2 ESCAPE '\\\\'\",\n            params![prefix, descendant_like],\n        )\n        .map_err(|e| e.to_string())?;\n    }\n\n    Ok(())\n}\n\nfn glob_match_path(pattern: &str, text: &str) -> bool {\n    let pat = pattern.as_bytes();\n    let txt = text.as_bytes();\n    let (pn, tn) = (pat.len(), txt.len());\n\n    let mut px = 0usize;\n    let mut tx = 0usize;\n    let mut star_px = usize::MAX;\n    let mut star_tx = 0usize;\n    let mut star_is_double = false;\n\n    while tx < tn {\n        if px < pn && px + 1 < pn && pat[px] == b'*' && pat[px + 1] == b'*' {\n            star_px = px;\n            star_tx = tx;\n            star_is_double = true;\n            px += 2;\n        } else if px < pn && pat[px] == b'*' {\n            star_px = px;\n            star_tx = tx;\n            star_is_double = false;\n            px += 1;\n        } else if px < pn && (pat[px] == b'?' && txt[tx] != b'/') {\n            px += 1;\n            tx += 1;\n        } else if px < pn && pat[px] == txt[tx] {\n            px += 1;\n            tx += 1;\n        } else if star_px != usize::MAX {\n            star_tx += 1;\n            if !star_is_double && txt[star_tx - 1] == b'/' {\n                return false;\n            }\n            px = if star_is_double {\n                star_px + 2\n            } else {\n                star_px + 1\n            };\n            tx = star_tx;\n        } else {\n            return false;\n        }\n    }\n\n    while px < pn && pat[px] == b'*' {\n        px += 1;\n    }\n\n    px == pn\n}\n\npub(crate) fn matches_ignore_pattern(path: &str, pattern: &IgnorePattern) -> bool {\n    match pattern {\n        IgnorePattern::AnySegment(segment) => {\n            let suffix = format!(\"/{segment}\");\n            let infix = format!(\"/{segment}/\");\n            path.ends_with(&suffix) || path.contains(&infix)\n        }\n        IgnorePattern::Glob(glob) => {\n            let mut cur = path;\n            loop {\n                if glob_match_path(glob, cur) {\n                    return true;\n                }\n\n                if cur == \"/\" {\n                    break;\n                }\n\n                let Some(pos) = cur.rfind('/') else {\n                    break;\n                };\n\n                cur = if pos == 0 { \"/\" } else { &cur[..pos] };\n            }\n            false\n        }\n    }\n}\n\npub(crate) fn should_skip_path(\n    path: &Path,\n    ignored_roots: &[PathBuf],\n    ignored_patterns: &[IgnorePattern],\n) -> bool {\n    should_skip_path_ext(path, ignored_roots, ignored_patterns, None, None)\n}\n\npub(crate) fn should_skip_path_ext(\n    path: &Path,\n    ignored_roots: &[PathBuf],\n    ignored_patterns: &[IgnorePattern],\n    gitignore: Option<&gitignore_filter::GitignoreFilter>,\n    is_dir_hint: Option<bool>,\n) -> bool {\n    let s = normalize_slashes(path.to_string_lossy().to_string());\n\n    // Single-component builtin names: check path segments\n    if s.split('/').any(|seg| {\n        BUILTIN_SKIP_NAMES.contains(&seg)\n            || BUILTIN_SKIP_SUFFIXES.iter().any(|suf| seg.ends_with(suf))\n    }) {\n        return true;\n    }\n\n    // Multi-component builtin paths\n    if BUILTIN_SKIP_PATHS.iter().any(|pat| {\n        let infix = format!(\"/{pat}/\");\n        let suffix = format!(\"/{pat}\");\n        s.contains(&infix) || s.ends_with(&suffix)\n    }) {\n        return true;\n    }\n\n    if ignored_roots\n        .iter()\n        .any(|root| path == root || path.starts_with(root))\n    {\n        return true;\n    }\n    if ignored_patterns\n        .iter()\n        .any(|pattern| matches_ignore_pattern(&s, pattern))\n    {\n        return true;\n    }\n    if let Some(gi) = gitignore {\n        let is_dir = is_dir_hint.unwrap_or_else(|| path.is_dir());\n        if gi.is_ignored(path, is_dir) {\n            return true;\n        }\n    }\n    false\n}\n\nfn extension_for(path: &Path, is_dir: bool) -> Option<String> {\n    if is_dir {\n        return None;\n    }\n\n    path.extension()\n        .and_then(|ext| ext.to_str())\n        .map(|ext| ext.to_lowercase())\n}\n\npub(crate) fn index_row_from_path_and_metadata(path: &Path, metadata: &fs::Metadata) -> Option<IndexRow> {\n    let is_dir = metadata.is_dir();\n\n    let name = path\n        .file_name()\n        .map(|v| v.to_string_lossy().to_string())\n        .or_else(|| {\n            if path == Path::new(\"/\") {\n                Some(\"/\".to_string())\n            } else {\n                None\n            }\n        })?;\n\n    let dir = path\n        .parent()\n        .map(|p| p.to_string_lossy().to_string())\n        .unwrap_or_else(|| \"/\".to_string());\n\n    let mtime = metadata\n        .modified()\n        .ok()\n        .and_then(|m| m.duration_since(UNIX_EPOCH).ok())\n        .map(|d| d.as_secs() as i64);\n\n    let size = if metadata.is_file() {\n        Some(metadata.len() as i64)\n    } else {\n        None\n    };\n\n    Some(IndexRow {\n        path: path.to_string_lossy().to_string(),\n        name,\n        dir,\n        is_dir: if is_dir { 1 } else { 0 },\n        ext: extension_for(path, is_dir),\n        mtime,\n        size,\n        indexed_at: now_epoch(),\n        run_id: 0,\n    })\n}\n\nfn index_row_from_path(path: &Path) -> Option<IndexRow> {\n    let metadata = fs::symlink_metadata(path).ok()?;\n    index_row_from_path_and_metadata(path, &metadata)\n}\n\nfn index_row_from_walkdir_entry(entry: &walkdir::DirEntry) -> Option<IndexRow> {\n    let metadata = entry.metadata().ok()?;\n    index_row_from_path_and_metadata(entry.path(), &metadata)\n}\n\nfn index_row_from_jwalk_entry(entry: &jwalk::DirEntry<((), ())>) -> Option<IndexRow> {\n    let metadata = entry.metadata().ok()?;\n    index_row_from_path_and_metadata(&entry.path(), &metadata)\n}\n\nfn collect_rows_recursive(\n    root: &Path,\n    ignored_roots: &[PathBuf],\n    ignored_patterns: &[IgnorePattern],\n) -> Vec<IndexRow> {\n    let mut rows = Vec::new();\n\n    let iter = WalkDir::new(root)\n        .follow_links(false)\n        .into_iter()\n        .filter_entry(|entry| !should_skip_path(entry.path(), ignored_roots, ignored_patterns));\n\n    for entry in iter.flatten() {\n        if let Some(row) = index_row_from_walkdir_entry(&entry) {\n            rows.push(row);\n        }\n    }\n\n    rows\n}\n\nfn entry_from_index_row(row: IndexRow) -> EntryDto {\n    EntryDto {\n        path: row.path,\n        name: row.name,\n        dir: row.dir,\n        is_dir: row.is_dir == 1,\n        ext: row.ext,\n        size: row.size,\n        mtime: row.mtime,\n    }\n}\n\npub fn entry_from_path(path: &Path) -> Option<EntryDto> {\n    index_row_from_path(path).map(entry_from_index_row)\n}\n\nfn entry_cmp(a: &EntryDto, b: &EntryDto, sort_by: &str, sort_dir: &str) -> Ordering {\n    match sort_by {\n        \"mtime\" => {\n            let lhs = a.mtime.unwrap_or(0);\n            let rhs = b.mtime.unwrap_or(0);\n            let primary = if sort_dir == \"desc\" {\n                rhs.cmp(&lhs)\n            } else {\n                lhs.cmp(&rhs)\n            };\n\n            if primary != Ordering::Equal {\n                return primary;\n            }\n\n            a.name\n                .to_lowercase()\n                .cmp(&b.name.to_lowercase())\n                .then(a.path.to_lowercase().cmp(&b.path.to_lowercase()))\n        }\n        \"dir\" => {\n            let lhs = a.dir.to_lowercase();\n            let rhs = b.dir.to_lowercase();\n            let primary = if sort_dir == \"desc\" {\n                rhs.cmp(&lhs)\n            } else {\n                lhs.cmp(&rhs)\n            };\n            if primary != Ordering::Equal {\n                return primary;\n            }\n            a.name.to_lowercase().cmp(&b.name.to_lowercase())\n        }\n        \"size\" => {\n            let lhs = a.size.unwrap_or(0);\n            let rhs = b.size.unwrap_or(0);\n            let primary = if sort_dir == \"desc\" {\n                rhs.cmp(&lhs)\n            } else {\n                lhs.cmp(&rhs)\n            };\n            if primary != Ordering::Equal {\n                return primary;\n            }\n            a.name\n                .to_lowercase()\n                .cmp(&b.name.to_lowercase())\n                .then(a.path.to_lowercase().cmp(&b.path.to_lowercase()))\n        }\n        _ => {\n            let lhs_name = a.name.to_lowercase();\n            let rhs_name = b.name.to_lowercase();\n            let primary = if sort_dir == \"desc\" {\n                rhs_name.cmp(&lhs_name)\n            } else {\n                lhs_name.cmp(&rhs_name)\n            };\n\n            if primary != Ordering::Equal {\n                return primary;\n            }\n\n            let lhs_path = a.path.to_lowercase();\n            let rhs_path = b.path.to_lowercase();\n            if sort_dir == \"desc\" {\n                rhs_path.cmp(&lhs_path)\n            } else {\n                lhs_path.cmp(&rhs_path)\n            }\n        }\n    }\n}\n\nfn relevance_rank(entry: &EntryDto, query_lower: &str, path_suffix: &str) -> u8 {\n    if query_lower.is_empty() {\n        return 255;\n    }\n\n    let name = entry.name.to_lowercase();\n    let path = entry.path.to_lowercase();\n\n    if name == query_lower {\n        return 0;\n    }\n    if name.starts_with(query_lower) {\n        return 1;\n    }\n    if name.contains(query_lower) {\n        return 2;\n    }\n    if path.ends_with(path_suffix) {\n        return 3;\n    }\n    if path.contains(query_lower) {\n        return 4;\n    }\n\n    5\n}\n\nfn path_depth(path: &str) -> usize {\n    Path::new(path).components().count()\n}\n\npub fn sort_entries(entries: &mut Vec<EntryDto>, sort_by: &str, sort_dir: &str) {\n    entries.sort_by(|a, b| entry_cmp(a, b, sort_by, sort_dir));\n}\n\nfn sort_entries_with_relevance(\n    entries: &mut Vec<EntryDto>,\n    query: &str,\n    sort_by: &str,\n    sort_dir: &str,\n) {\n    let query_lower = query.trim().to_lowercase();\n    if query_lower.is_empty() {\n        sort_entries(entries, sort_by, sort_dir);\n        return;\n    }\n    let path_suffix = format!(\"/{query_lower}\");\n\n    entries.sort_by(|a, b| {\n        let ra = relevance_rank(a, &query_lower, &path_suffix);\n        let rb = relevance_rank(b, &query_lower, &path_suffix);\n        if ra != rb {\n            return ra.cmp(&rb);\n        }\n\n        // For highly-relevant matches, prefer shallower paths first\n        // so `~/name` ranks above deep descendants with the same name.\n        if ra <= 3 {\n            let da = path_depth(&a.path);\n            let db = path_depth(&b.path);\n            if da != db {\n                return da.cmp(&db);\n            }\n        }\n\n        entry_cmp(a, b, sort_by, sort_dir)\n    });\n}\n\nfn filter_ignored_entries(\n    entries: Vec<EntryDto>,\n    ignored_roots: &[PathBuf],\n    ignored_patterns: &[IgnorePattern],\n) -> Vec<EntryDto> {\n    entries\n        .into_iter()\n        .filter(|entry| !should_skip_path(Path::new(&entry.path), ignored_roots, ignored_patterns))\n        .collect()\n}\n\nfn find_search(\n    home_dir: &Path,\n    ignored_roots: &[PathBuf],\n    ignored_patterns: &[IgnorePattern],\n    query: &str,\n    limit: usize,\n    sort_by: &str,\n    sort_dir: &str,\n) -> Vec<EntryDto> {\n    let trimmed = query.trim();\n    if trimmed.is_empty() || limit == 0 {\n        return Vec::new();\n    }\n\n    let mut search_root = home_dir.to_path_buf();\n    let mut dir_filter_pattern: Option<String> = None;\n    let mut name_filter_pattern: Option<String> = None;\n    let mut name_filter_glob = false;\n\n    if trimmed.contains('/') {\n        let last_slash = trimmed.rfind('/').unwrap();\n        let dir_part = trimmed[..last_slash].trim();\n        let name_part = trimmed[last_slash + 1..].trim();\n\n        if !dir_part.is_empty() {\n            let mut hinted = if dir_part == \"~\" {\n                Some(home_dir.to_path_buf())\n            } else if let Some(rest) = dir_part.strip_prefix(\"~/\") {\n                Some(home_dir.join(rest))\n            } else {\n                let p = PathBuf::from(dir_part);\n                if p.is_absolute() {\n                    Some(p)\n                } else if !dir_part.contains('*')\n                    && !dir_part.contains('?')\n                    && !dir_part.contains('[')\n                {\n                    Some(home_dir.join(dir_part))\n                } else {\n                    None\n                }\n            };\n\n            if let Some(path) = hinted.take() {\n                if path.exists() && path.is_dir() {\n                    search_root = path;\n                } else {\n                    dir_filter_pattern = Some(format!(\"*{}/*\", dir_part));\n                }\n            } else {\n                dir_filter_pattern = Some(format!(\"*{}/*\", dir_part));\n            }\n        }\n\n        if !name_part.is_empty() {\n            if name_part.contains('*') || name_part.contains('?') {\n                name_filter_pattern = Some(name_part.to_string());\n                name_filter_glob = true;\n            } else {\n                name_filter_pattern = Some(format!(\"*{}*\", name_part));\n            }\n        }\n    } else if trimmed.contains('*') || trimmed.contains('?') {\n        name_filter_pattern = Some(trimmed.to_string());\n        name_filter_glob = true;\n    } else {\n        name_filter_pattern = Some(format!(\"*{}*\", trimmed));\n    }\n\n    let mut cmd = Command::new(\"find\");\n    cmd.arg(&search_root);\n\n    if search_root == home_dir {\n        cmd.args([\"-maxdepth\", \"8\"]);\n    }\n\n    if let Some(dir_pattern) = dir_filter_pattern.as_deref() {\n        cmd.args([\"-ipath\", dir_pattern]);\n    }\n    if let Some(name_pattern) = name_filter_pattern.as_deref() {\n        cmd.args([\"-iname\", name_pattern]);\n    }\n    if name_filter_glob {\n        cmd.args([\"-type\", \"f\"]);\n    }\n\n    cmd.args([\"!\", \"-path\", \"*/.git/*\"])\n        .args([\"!\", \"-path\", \"*/node_modules/*\"])\n        .args([\"!\", \"-path\", \"*/.Trash/*\"])\n        .args([\"!\", \"-path\", \"*/.Trashes/*\"])\n        .args([\"!\", \"-path\", \"*/Library/Caches/*\"])\n        .stdout(Stdio::piped())\n        .stderr(Stdio::null());\n\n    let mut child = match cmd.spawn() {\n        Ok(c) => c,\n        Err(_) => return Vec::new(),\n    };\n\n    let stdout = match child.stdout.take() {\n        Some(s) => s,\n        None => return Vec::new(),\n    };\n\n    let reader = BufReader::new(stdout);\n    let mut entries = Vec::with_capacity(limit);\n\n    for line in reader.lines() {\n        let Ok(line) = line else { continue };\n        let path = PathBuf::from(&line);\n        if should_skip_path(&path, ignored_roots, ignored_patterns) {\n            continue;\n        }\n\n        if let Some(entry) = entry_from_path(&path) {\n            entries.push(entry);\n            if entries.len() >= limit {\n                break;\n            }\n        }\n    }\n\n    let _ = child.kill();\n    let _ = child.wait();\n\n    sort_entries_with_relevance(&mut entries, trimmed, sort_by, sort_dir);\n    entries\n}\n\npub(crate) fn upsert_rows(conn: &mut Connection, rows: &[IndexRow]) -> AppResult<usize> {\n    if rows.is_empty() {\n        return Ok(0);\n    }\n\n    let tx = conn.transaction().map_err(|e| e.to_string())?;\n    {\n        let mut stmt = tx\n            .prepare(\n                r#\"\n                INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n                VALUES(?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)\n                ON CONFLICT(path) DO UPDATE SET\n                  name = excluded.name,\n                  dir = excluded.dir,\n                  is_dir = excluded.is_dir,\n                  ext = excluded.ext,\n                  mtime = excluded.mtime,\n                  size = excluded.size,\n                  indexed_at = excluded.indexed_at,\n                  run_id = excluded.run_id\n                \"#,\n            )\n            .map_err(|e| e.to_string())?;\n\n        for row in rows {\n            stmt.execute(params![\n                row.path,\n                row.name,\n                row.dir,\n                row.is_dir,\n                row.ext,\n                row.mtime,\n                row.size,\n                row.indexed_at,\n                row.run_id\n            ])\n            .map_err(|e| e.to_string())?;\n        }\n    }\n    tx.commit().map_err(|e| e.to_string())?;\n    Ok(rows.len())\n}\n\npub(crate) fn delete_paths(conn: &mut Connection, raw_paths: &[String]) -> AppResult<usize> {\n    if raw_paths.is_empty() {\n        return Ok(0);\n    }\n\n    let tx = conn.transaction().map_err(|e| e.to_string())?;\n    let mut deleted = 0;\n\n    {\n        let mut stmt_exact = tx\n            .prepare(\"DELETE FROM entries WHERE path = ?1\")\n            .map_err(|e| e.to_string())?;\n        let mut stmt_children = tx\n            .prepare(\"DELETE FROM entries WHERE path >= ?1 AND path < ?2\")\n            .map_err(|e| e.to_string())?;\n\n        for path in raw_paths {\n            let is_root = path == \"/\" || path == \"\\\\\";\n            let normalized = if is_root {\n                path.clone()\n            } else {\n                path.trim_end_matches(&['/', '\\\\'][..]).to_string()\n            };\n\n            if normalized.is_empty() {\n                continue;\n            }\n\n            if is_root {\n                deleted += tx\n                    .execute(\"DELETE FROM entries\", [])\n                    .map_err(|e| e.to_string())?;\n                continue;\n            }\n\n            deleted += stmt_exact\n                .execute(params![&normalized])\n                .map_err(|e| e.to_string())?;\n\n            // Delete children using B-tree range scan: path >= \"{normalized}{sep}\" AND path < \"{normalized}\\x7F\"\n            // \\x7F (127) is higher than both '/' (47) and '\\' (92), so this captures all children.\n            let sep = std::path::MAIN_SEPARATOR;\n            let range_start = format!(\"{normalized}{sep}\");\n            let range_end = format!(\"{normalized}\\x7F\");\n            deleted += stmt_children\n                .execute(params![&range_start, &range_end])\n                .map_err(|e| e.to_string())?;\n        }\n    }\n\n    tx.commit().map_err(|e| e.to_string())?;\n    Ok(deleted)\n}\n\npub(crate) fn emit_index_state(app: &AppHandle, state: &str, message: Option<String>) {\n    let is_catchup = message.as_ref().map_or(false, |m| m.starts_with(\"Catchup:\"));\n    let _ = app.emit(\n        \"index_state\",\n        IndexStateEvent {\n            state: state.to_string(),\n            message,\n            is_catchup,\n        },\n    );\n}\n\npub(crate) fn emit_index_updated(\n    app: &AppHandle,\n    entries_count: u64,\n    last_updated: i64,\n    permission_errors: u64,\n) {\n    let _ = app.emit(\n        \"index_updated\",\n        IndexUpdatedEvent {\n            entries_count,\n            last_updated,\n            permission_errors,\n        },\n    );\n}\n\npub(crate) fn emit_index_progress(app: &AppHandle, scanned: u64, indexed: u64, current_path: String) {\n    let _ = app.emit(\n        \"index_progress\",\n        IndexProgressEvent {\n            scanned,\n            indexed,\n            current_path,\n        },\n    );\n}\n\npub(crate) fn set_state(state: &AppState, next: IndexState, message: Option<String>) {\n    let mut status = state.status.lock();\n    status.state = next;\n    status.message = message;\n}\n\npub(crate) fn set_progress(state: &AppState, scanned: u64, indexed: u64, current_path: &str) {\n    let mut status = state.status.lock();\n    status.scanned = scanned;\n    status.indexed = indexed;\n    status.current_path = current_path.to_string();\n}\n\nfn emit_status_counts(app: &AppHandle, state: &AppState) {\n    let status = state.status.lock();\n    emit_index_updated(\n        app,\n        status.entries_count,\n        status.last_updated.unwrap_or_else(now_epoch),\n        status.permission_errors,\n    );\n}\n\npub(crate) fn refresh_and_emit_status_counts(app: &AppHandle, state: &AppState) -> AppResult<()> {\n    let (entries_count, last_updated) = update_status_counts(state)?;\n    // Persist cached counts so next startup can read them instantly\n    if let Ok(conn) = db_connection(&state.db_path) {\n        let _ = set_meta(&conn, \"cached_entries_count\", &entries_count.to_string());\n        if let Some(lu) = last_updated {\n            let _ = set_meta(&conn, \"cached_last_updated\", &lu.to_string());\n        }\n    }\n    emit_status_counts(app, state);\n    Ok(())\n}\n\n/// Load cached entries count from meta table (instant) and emit Ready state + counts.\n/// Used on Windows startup paths where the index is already complete from a prior run.\n#[cfg(target_os = \"windows\")]\npub(crate) fn set_ready_with_cached_counts(app: &AppHandle, state: &AppState) {\n    let (count, last_updated) = db_connection(&state.db_path)\n        .ok()\n        .map(|conn| {\n            let c = get_meta(&conn, \"cached_entries_count\")\n                .and_then(|v| v.parse::<u64>().ok())\n                .unwrap_or(0);\n            let lu = get_meta(&conn, \"cached_last_updated\")\n                .and_then(|v| v.parse::<i64>().ok());\n            (c, lu)\n        })\n        .unwrap_or((0, None));\n\n    {\n        let mut status = state.status.lock();\n        status.state = IndexState::Ready;\n        status.entries_count = count;\n        status.last_updated = last_updated;\n    }\n\n    emit_index_state(app, \"Ready\", None);\n    emit_index_updated(app, count, last_updated.unwrap_or_else(now_epoch), 0);\n}\n\n#[cfg(target_os = \"macos\")]\nfn touch_status_updated(state: &AppState) {\n    state.status.lock().last_updated = Some(now_epoch());\n}\n\n#[cfg(not(target_os = \"windows\"))]\npub(crate) fn start_full_index_worker(app: AppHandle, state: AppState) -> AppResult<()> {\n    start_full_index_worker_inner(app, state, false)\n}\n\n#[cfg(target_os = \"windows\")]\npub(crate) fn start_full_index_worker_silent(app: AppHandle, state: AppState) -> AppResult<()> {\n    start_full_index_worker_inner(app, state, true)\n}\n\nfn start_full_index_worker_inner(app: AppHandle, state: AppState, silent: bool) -> AppResult<()> {\n    if state\n        .indexing_active\n        .compare_exchange(false, true, AtomicOrdering::AcqRel, AtomicOrdering::Acquire)\n        .is_err()\n    {\n        perf_log(\"index_start_skipped already_active=true\");\n        return Ok(());\n    }\n\n    // Mark index as incomplete -- cleared when run_incremental_index succeeds\n    if let Ok(c) = db_connection(&state.db_path) {\n        let _ = set_meta(&c, \"index_complete\", \"0\");\n    }\n\n    if !silent {\n        {\n            let mut status = state.status.lock();\n            status.state = IndexState::Indexing;\n            status.message = None;\n            status.scanned = 0;\n            status.indexed = 0;\n            status.current_path.clear();\n        }\n\n        emit_index_state(&app, \"Indexing\", None);\n        perf_log(\"index_state=Indexing\");\n    } else {\n        perf_log(\"index_start silent=true (background reindex)\");\n    }\n\n    std::thread::spawn(move || {\n        let result = run_incremental_index(&app, &state);\n        if let Err(ref err) = result {\n            eprintln!(\"[index] run_incremental_index failed: {err}\");\n            if !silent {\n                set_state(&state, IndexState::Error, Some(err.clone()));\n                emit_index_state(&app, \"Error\", Some(err.clone()));\n            }\n            // Silent mode: keep Ready state, just log the error\n        }\n        state.indexing_active.store(false, AtomicOrdering::Release);\n    });\n\n    Ok(())\n}\n\nfn is_deferred_dir(path: &Path, home_dir: &Path) -> bool {\n    path.parent() == Some(home_dir)\n        && path\n            .file_name()\n            .and_then(|n| n.to_str())\n            .map(|name| DEFERRED_DIR_NAMES.contains(&name))\n            .unwrap_or(false)\n}\n\nfn preload_existing_entries(\n    conn: &Connection,\n    dir_prefix: &str,\n) -> HashMap<String, (Option<i64>, Option<i64>)> {\n    let like_pattern = format!(\"{}/%\", escape_like(dir_prefix));\n    let mut stmt = match conn.prepare(\n        \"SELECT path, mtime, size FROM entries WHERE path LIKE ?1 ESCAPE '\\\\' OR path = ?2\",\n    ) {\n        Ok(s) => s,\n        Err(_) => return HashMap::new(),\n    };\n\n    let mut map = HashMap::new();\n    let rows = match stmt.query_map(params![like_pattern, dir_prefix], |row| {\n        Ok((\n            row.get::<_, String>(0)?,\n            row.get::<_, Option<i64>>(1)?,\n            row.get::<_, Option<i64>>(2)?,\n        ))\n    }) {\n        Ok(r) => r,\n        Err(_) => return map,\n    };\n\n    for row in rows.flatten() {\n        map.insert(row.0, (row.1, row.2));\n    }\n    map\n}\n\nfn stamp_run_id_batch(conn: &mut Connection, paths: &[String], run_id: i64) -> AppResult<()> {\n    if paths.is_empty() {\n        return Ok(());\n    }\n\n    let tx = conn.transaction().map_err(|e| e.to_string())?;\n    {\n        let mut stmt = tx\n            .prepare(\"UPDATE entries SET run_id = ?1 WHERE path = ?2\")\n            .map_err(|e| e.to_string())?;\n        for path in paths {\n            stmt.execute(params![run_id, path])\n                .map_err(|e| e.to_string())?;\n        }\n    }\n    tx.commit().map_err(|e| e.to_string())?;\n    Ok(())\n}\n\nfn run_incremental_index(app: &AppHandle, state: &AppState) -> AppResult<()> {\n    let started = Instant::now();\n    perf_log(format!(\n        \"index_run_start home={} db={}\",\n        state.home_dir.to_string_lossy(),\n        state.db_path.to_string_lossy(),\n    ));\n\n    let mut conn = db_connection(&state.db_path)?;\n    set_indexing_pragmas(&conn)?;\n\n    // For fresh index (empty DB), drop secondary indexes before bulk insert and\n    // recreate them after. This avoids per-row BTREE maintenance on every insert,\n    // which can be 3-5x faster when loading hundreds of thousands of rows.\n    let is_fresh_run: bool = get_meta(&conn, \"last_run_id\")\n        .and_then(|v| v.parse::<i64>().ok())\n        .unwrap_or(0)\n        == 0;\n    if is_fresh_run {\n        let _ = conn.execute_batch(\n            \"DROP INDEX IF EXISTS idx_entries_dir_ext_name_nocase;\n             DROP INDEX IF EXISTS idx_entries_mtime;\n             DROP INDEX IF EXISTS idx_entries_name_nocase;\n             DROP INDEX IF EXISTS idx_entries_ext_name;\",\n        );\n    }\n\n    let result = run_incremental_index_inner(app, state, &mut conn);\n\n    if is_fresh_run {\n        let _ = conn.execute_batch(\n            \"CREATE INDEX IF NOT EXISTS idx_entries_dir_ext_name_nocase ON entries(dir, ext, name COLLATE NOCASE);\n             CREATE INDEX IF NOT EXISTS idx_entries_mtime ON entries(mtime);\n             CREATE INDEX IF NOT EXISTS idx_entries_name_nocase ON entries(name COLLATE NOCASE);\n             CREATE INDEX IF NOT EXISTS idx_entries_ext_name ON entries(ext, name COLLATE NOCASE);\",\n        );\n    }\n\n    let _ = conn.execute_batch(\"ANALYZE\");\n    let _ = restore_normal_pragmas(&conn);\n\n    match &result {\n        Ok(_) => {\n            let _ = set_meta(&conn, \"index_complete\", \"1\");\n            let snapshot = state.status.lock().clone();\n            perf_log(format!(\n                \"index_run_done elapsed_ms={} scanned={} indexed={} entries={} permission_errors={} message={:?}\",\n                started.elapsed().as_millis(),\n                snapshot.scanned,\n                snapshot.indexed,\n                snapshot.entries_count,\n                snapshot.permission_errors,\n                snapshot.message,\n            ));\n        }\n        Err(err) => {\n            perf_log(format!(\n                \"index_run_error elapsed_ms={} err={}\",\n                started.elapsed().as_millis(),\n                err,\n            ));\n        }\n    }\n\n    result\n}\n\nfn run_incremental_index_inner(\n    app: &AppHandle,\n    state: &AppState,\n    conn: &mut Connection,\n) -> AppResult<()> {\n\n    let (runtime_ignored_roots, runtime_ignored_patterns) = effective_ignore_rules(\n        &state.home_dir,\n        &state.cwd,\n        state.path_ignores.as_ref(),\n        state.path_ignore_patterns.as_ref(),\n    );\n    let gi_filter = state.gitignore.get();\n\n    let last_run_id: i64 = get_meta(conn, \"last_run_id\")\n        .and_then(|v| v.parse().ok())\n        .unwrap_or(0);\n    let current_run_id = last_run_id + 1;\n    // Fresh index: DB was empty, skip preload/stamp, single unlimited-depth pass\n    let is_fresh = last_run_id == 0;\n\n    // Fresh index has no secondary indexes to maintain, so we can use larger\n    // batches to reduce transaction overhead (fewer commits = faster).\n    let flush_batch_size = if is_fresh { BATCH_SIZE * 5 } else { BATCH_SIZE };\n\n    let mut scanned: u64 = 0;\n    let mut indexed: u64 = 0;\n    let mut permission_errors: u64 = 0;\n    let mut current_path = String::new();\n    let mut batch: Vec<IndexRow> = Vec::with_capacity(flush_batch_size);\n    let mut stamp_batch: Vec<String> = Vec::with_capacity(flush_batch_size);\n    let mut last_emit = Instant::now();\n    let mut last_perf_emit = Instant::now();\n\n    // Preload scan_root-level entries (direct children only, not recursive)\n    let scan_str = state.scan_root.to_string_lossy().to_string();\n    let root_existing = preload_existing_entries(conn, &scan_str);\n\n    // Index scan_root itself\n    if let Some(mut row) = index_row_from_path(&state.scan_root) {\n        scanned += 1;\n        row.run_id = current_run_id;\n        if let Some((old_mtime, old_size)) = root_existing.get(&row.path) {\n            if *old_mtime == row.mtime && *old_size == row.size {\n                stamp_batch.push(row.path);\n            } else {\n                batch.push(row);\n            }\n        } else {\n            batch.push(row);\n        }\n    }\n\n    // Partition direct children into priority vs deferred\n    let mut priority_roots: Vec<PathBuf> = Vec::new();\n    let mut deferred_roots: Vec<PathBuf> = Vec::new();\n\n    if let Ok(entries) = fs::read_dir(&state.scan_root) {\n        for dir_entry in entries.flatten() {\n            let child_path = dir_entry.path();\n\n            if should_skip_path_ext(\n                &child_path,\n                &runtime_ignored_roots,\n                &runtime_ignored_patterns,\n                Some(&gi_filter),\n                None,\n            ) {\n                continue;\n            }\n\n            scanned += 1;\n            current_path = child_path.to_string_lossy().to_string();\n\n            if let Some(mut row) = index_row_from_path(&child_path) {\n                row.run_id = current_run_id;\n                if let Some((old_mtime, old_size)) = root_existing.get(&row.path) {\n                    if *old_mtime == row.mtime && *old_size == row.size {\n                        stamp_batch.push(row.path);\n                    } else {\n                        batch.push(row);\n                    }\n                } else {\n                    batch.push(row);\n                }\n            }\n\n            if child_path.is_dir() {\n                if is_deferred_dir(&child_path, &state.scan_root) {\n                    deferred_roots.push(child_path);\n                } else {\n                    priority_roots.push(child_path);\n                }\n            }\n        }\n    }\n\n\n    // Flush home-level stamp batch\n    if stamp_batch.len() >= flush_batch_size {\n        stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n        stamp_batch.clear();\n    }\n\n    priority_roots.sort();\n    deferred_roots.sort();\n\n    let roots: Vec<PathBuf> = priority_roots.into_iter().chain(deferred_roots).collect();\n    perf_log(format!(\n        \"index_scan_roots total={} priority+deferred\",\n        roots.len()\n    ));\n\n    // 2-pass indexing: shallow first (depth <= SHALLOW_SCAN_DEPTH), then deep\n    // Both passes use jwalk for parallel scanning\n    let arc_ignored_roots = Arc::new(runtime_ignored_roots.clone());\n    let arc_ignored_patterns = Arc::new(runtime_ignored_patterns.clone());\n\n\n    for pass in 0..2u8 {\n        // Fresh index: single unlimited-depth pass -- avoids double filesystem traversal\n        if pass == 1 && is_fresh {\n            break;\n        }\n        let pass_label = if pass == 0 { \"shallow\" } else { \"deep\" };\n        let pass_started = Instant::now();\n        let mut pass_scanned = 0u64;\n        let mut pass_indexed = 0u64;\n\n        for root in &roots {\n            let root_started = Instant::now();\n            let mut root_scanned = 0u64;\n            let mut root_indexed = 0u64;\n            let mut root_permission_errors = 0u64;\n            let root_str = root.to_string_lossy().to_string();\n\n            // Fresh index: DB is empty, preload is unnecessary\n            let existing = if is_fresh {\n                HashMap::new()\n            } else {\n                let e = preload_existing_entries(conn, &root_str);\n                e\n            };\n\n            let gi_ref = gi_filter.clone();\n            let skip_roots = arc_ignored_roots.clone();\n            let skip_patterns = arc_ignored_patterns.clone();\n\n            let mut builder = jwalk::WalkDir::new(root)\n                .follow_links(false)\n                .skip_hidden(false)\n                .parallelism(jwalk::Parallelism::RayonNewPool(jwalk_num_threads()));\n            // Fresh index: no depth limit -- walk everything in one pass\n            if pass == 0 && !is_fresh {\n                builder = builder.max_depth(SHALLOW_SCAN_DEPTH);\n            }\n            let walker = builder.process_read_dir(move |_depth, path, _state, children| {\n                children.retain(|entry_result| {\n                    entry_result\n                        .as_ref()\n                        .map(|entry| {\n                            let full_path = path.join(&entry.file_name);\n                            let is_dir = Some(entry.file_type.is_dir());\n                            !should_skip_path_ext(\n                                &full_path,\n                                &skip_roots,\n                                &skip_patterns,\n                                Some(&gi_ref),\n                                is_dir,\n                            )\n                        })\n                        .unwrap_or(false)\n                });\n            });\n\n            for result in walker {\n                match result {\n                    Ok(entry) => {\n                        let path = entry.path();\n                        if path == root.as_path() {\n                            continue;\n                        }\n\n                        // Pass 1 (incremental only): skip shallow entries already indexed in pass 0\n                        if pass == 1 && entry.depth <= SHALLOW_SCAN_DEPTH {\n                            continue;\n                        }\n\n                        scanned += 1;\n                        root_scanned += 1;\n                        current_path = path.to_string_lossy().to_string();\n\n                        if let Some(mut row) = index_row_from_jwalk_entry(&entry) {\n                            row.run_id = current_run_id;\n                            if is_fresh {\n                                // Fresh index: all entries are new, skip existing check\n                                indexed += 1;\n                                root_indexed += 1;\n                                batch.push(row);\n                            } else if let Some((old_mtime, old_size)) = existing.get(&row.path) {\n                                if *old_mtime == row.mtime && *old_size == row.size {\n                                    stamp_batch.push(row.path);\n                                } else {\n                                    indexed += 1;\n                                    root_indexed += 1;\n                                    batch.push(row);\n                                }\n                            } else {\n                                indexed += 1;\n                                root_indexed += 1;\n                                batch.push(row);\n                            }\n                        }\n\n                        if batch.len() >= BATCH_SIZE {\n                            upsert_rows(conn, &batch)?;\n                            batch.clear();\n                        }\n\n                        if stamp_batch.len() >= BATCH_SIZE {\n                            stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n                            stamp_batch.clear();\n                        }\n\n                        if last_emit.elapsed() >= Duration::from_millis(200) {\n                            set_progress(state, scanned, indexed, &current_path);\n                            emit_index_progress(app, scanned, indexed, current_path.clone());\n                            last_emit = Instant::now();\n                        }\n                        if perf_log_enabled() && last_perf_emit.elapsed() >= Duration::from_secs(1)\n                        {\n                            perf_log(format!(\n                                \"index_progress pass={} scanned={} indexed={} current_path={}\",\n                                pass_label, scanned, indexed, current_path\n                            ));\n                            last_perf_emit = Instant::now();\n                        }\n                    }\n                    Err(err) => {\n                        scanned += 1;\n                        root_scanned += 1;\n                        permission_errors += 1;\n                        root_permission_errors += 1;\n                        if permission_errors <= 20 || perf_log_enabled() {\n                            eprintln!(\"[index] permission error: {}\", err);\n                        }\n                    }\n                }\n            }\n\n            pass_scanned += root_scanned;\n            pass_indexed += root_indexed;\n\n            eprintln!(\"[timing]   walk_{} {} {}ms scanned={} indexed={} err={}\",\n                pass_label, root_str, root_started.elapsed().as_millis(),\n                root_scanned, root_indexed, root_permission_errors);\n            perf_log(format!(\n                \"index_root_done pass={} root={} elapsed_ms={} scanned={} indexed={} permission_errors={}\",\n                pass_label,\n                root.to_string_lossy(),\n                root_started.elapsed().as_millis(),\n                root_scanned,\n                root_indexed,\n                root_permission_errors,\n            ));\n        }\n\n        // Flush between passes\n        if !batch.is_empty() {\n            upsert_rows(conn, &batch)?;\n            batch.clear();\n        }\n        if !stamp_batch.is_empty() {\n            stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n            stamp_batch.clear();\n        }\n\n        perf_log(format!(\n            \"index_pass_done pass={} elapsed_ms={} scanned={} indexed={}\",\n            pass_label,\n            pass_started.elapsed().as_millis(),\n            pass_scanned,\n            pass_indexed,\n        ));\n\n        // After shallow pass (incremental only), emit progress so UI shows searchable state early\n        // Fresh index uses per-root emit above instead.\n        if pass == 0 && !is_fresh {\n            let _ = refresh_and_emit_status_counts(app, state);\n            let _ = app.emit(\n                \"index_updated\",\n                IndexUpdatedEvent {\n                    entries_count: state.status.lock().entries_count,\n                    last_updated: now_epoch(),\n                    permission_errors,\n                },\n            );\n        }\n    }\n\n    if !batch.is_empty() {\n        upsert_rows(conn, &batch)?;\n    }\n\n    if !stamp_batch.is_empty() {\n        stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;\n    }\n\n    set_progress(state, scanned, indexed, &current_path);\n    emit_index_progress(app, scanned, indexed, current_path.clone());\n\n    // Remove entries not seen in this run (deleted files)\n    // Fresh index: DB was empty before this run, no stale entries possible\n    let deleted_count: i64 = if is_fresh {\n        0\n    } else {\n        let count = conn\n            .query_row(\n                \"SELECT COUNT(*) FROM entries WHERE run_id < ?1\",\n                params![current_run_id],\n                |row| row.get(0),\n            )\n            .unwrap_or(0);\n        conn.execute(\n            \"DELETE FROM entries WHERE run_id < ?1\",\n            params![current_run_id],\n        )\n        .map_err(|e| e.to_string())?;\n        count\n    };\n\n    set_meta(conn, \"last_run_id\", &current_run_id.to_string())?;\n\n    if deleted_count > 0 || indexed > 0 {\n        invalidate_search_caches(state);\n    }\n\n    let (entries_count, last_updated) = update_status_counts(state)?;\n    // Persist cached counts for instant startup next time\n    let _ = set_meta(conn, \"cached_entries_count\", &entries_count.to_string());\n    if let Some(lu) = last_updated {\n        let _ = set_meta(conn, \"cached_last_updated\", &lu.to_string());\n    }\n    let updated_at = last_updated.unwrap_or_else(now_epoch);\n\n    {\n        let mut status = state.status.lock();\n        status.state = IndexState::Ready;\n        status.permission_errors = permission_errors;\n        status.scanned = scanned;\n        status.indexed = indexed;\n        status.current_path = current_path.clone();\n        status.message = if permission_errors > 0 {\n            Some(format!(\n                \"{} permission/access error(s) occurred.\",\n                permission_errors\n            ))\n        } else {\n            None\n        };\n    }\n    emit_index_progress(app, scanned, indexed, current_path);\n    emit_index_updated(app, entries_count, updated_at, permission_errors);\n    emit_index_state(\n        app,\n        \"Ready\",\n        if permission_errors > 0 {\n            Some(format!(\"{} permission/access error(s)\", permission_errors))\n        } else {\n            None\n        },\n    );\n    perf_log(format!(\n        \"index_state=Ready scanned={} indexed={} deleted={} entries={} permission_errors={}\",\n        scanned, indexed, deleted_count, entries_count, permission_errors\n    ));\n\n    Ok(())\n}\n\nfn trim_recent_ops(ops: &mut Vec<RecentOp>) {\n    let now = Instant::now();\n    ops.retain(|op| now.duration_since(op.at) <= RECENT_OP_TTL);\n}\n\nfn remember_op(\n    state: &AppState,\n    op_type: &'static str,\n    old_path: Option<String>,\n    new_path: Option<String>,\n) {\n    let mut ops = state.recent_ops.lock();\n    trim_recent_ops(&mut ops);\n    ops.push(RecentOp {\n        old_path,\n        new_path,\n        op_type,\n        at: Instant::now(),\n    });\n}\n\n#[cfg(any(target_os = \"macos\", target_os = \"windows\"))]\npub(crate) fn is_recently_touched(state: &AppState, path: &str) -> bool {\n    let mut ops = state.recent_ops.lock();\n    trim_recent_ops(&mut ops);\n\n    ops.iter().any(|op| match op.op_type {\n        \"rename\" | \"trash\" => {\n            op.old_path\n                .as_deref()\n                .map(|old| old == path)\n                .unwrap_or(false)\n                || op\n                    .new_path\n                    .as_deref()\n                    .map(|new| new == path)\n                    .unwrap_or(false)\n        }\n        _ => false,\n    })\n}\n\n#[cfg(target_os = \"macos\")]\nfn apply_path_changes(state: &AppState, paths: &[PathBuf]) -> AppResult<usize> {\n    let (ignored_roots, ignored_patterns) = cached_effective_ignore_rules(state);\n    let mut to_upsert_map: HashMap<String, IndexRow> = HashMap::new();\n    let mut to_delete = Vec::new();\n\n    for path in paths {\n        if should_skip_path(path, &ignored_roots, &ignored_patterns) {\n            continue;\n        }\n\n        let path_str = path.to_string_lossy().to_string();\n        if path_str.is_empty() {\n            continue;\n        }\n\n        if is_recently_touched(state, &path_str) {\n            continue;\n        }\n\n        match fs::symlink_metadata(path) {\n            Ok(metadata) => {\n                if let Some(row) = index_row_from_path_and_metadata(path, &metadata) {\n                    to_upsert_map.insert(row.path.clone(), row);\n                }\n            }\n            Err(_) => {\n                to_delete.push(path_str);\n            }\n        }\n    }\n\n    let to_upsert = to_upsert_map.into_values().collect::<Vec<_>>();\n\n    if to_upsert.is_empty() && to_delete.is_empty() {\n        return Ok(0);\n    }\n\n    let op_start = std::time::Instant::now();\n    let mut conn = db_connection(&state.db_path).map_err(|e| {\n        eprintln!(\n            \"[watcher] db_connection FAILED after {}ms: {} (upsert={} delete={} indexing_active={})\",\n            op_start.elapsed().as_millis(),\n            e,\n            to_upsert.len(),\n            to_delete.len(),\n            state.indexing_active.load(AtomicOrdering::Acquire)\n        );\n        e\n    })?;\n    let mut changed = 0;\n\n    changed += upsert_rows(&mut conn, &to_upsert)?;\n    changed += delete_paths(&mut conn, &to_delete)?;\n\n    Ok(changed)\n}\n\n#[cfg(target_os = \"macos\")]\nconst STATUS_EMIT_MIN_INTERVAL: Duration = Duration::from_secs(2);\n\n#[cfg(target_os = \"macos\")]\nconst DB_BUSY_RETRY_DELAY: Duration = Duration::from_secs(3);\n\n#[cfg(target_os = \"macos\")]\nfn process_watcher_paths(\n    app: &AppHandle,\n    state: &AppState,\n    pending: &mut HashSet<PathBuf>,\n    deadline: &mut Option<Instant>,\n    last_status_emit: &mut Instant,\n    pending_status_emit: &mut bool,\n) {\n    if pending.is_empty() {\n        return;\n    }\n\n    if state.indexing_active.load(AtomicOrdering::Acquire) {\n        return;\n    }\n\n    let mut batch: Vec<PathBuf> = pending.drain().collect();\n    batch.sort();\n\n    match apply_path_changes(state, &batch) {\n        Ok(changed) => {\n            *deadline = None;\n            if changed > 0 {\n                invalidate_search_caches(state);\n                touch_status_updated(state);\n                if last_status_emit.elapsed() >= STATUS_EMIT_MIN_INTERVAL {\n                    let _ = refresh_and_emit_status_counts(app, state);\n                    *last_status_emit = Instant::now();\n                    *pending_status_emit = false;\n                } else {\n                    *pending_status_emit = true;\n                }\n            }\n        }\n        Err(err) => {\n            let is_busy = err.contains(\"locked\") || err.contains(\"busy\");\n            if is_busy {\n                eprintln!(\n                    \"[watcher] DB busy, will retry in {}s: {} | batch_size={}\",\n                    DB_BUSY_RETRY_DELAY.as_secs(),\n                    err,\n                    batch.len()\n                );\n                for path in batch {\n                    pending.insert(path);\n                }\n                *deadline = Some(Instant::now() + DB_BUSY_RETRY_DELAY);\n                return;\n            }\n            eprintln!(\n                \"[watcher] process_watcher_paths ERROR: {} | batch_size={} indexing_active={}\",\n                err,\n                batch.len(),\n                state.indexing_active.load(AtomicOrdering::Acquire)\n            );\n            *deadline = None;\n            if state.indexing_active.load(AtomicOrdering::Acquire) {\n                return;\n            }\n            let mut status = state.status.lock();\n            if !matches!(status.state, IndexState::Indexing) {\n                status.state = IndexState::Error;\n            }\n            status.message = Some(format!(\"Watcher update failed: {err}\"));\n            drop(status);\n            emit_index_state(app, \"Error\", Some(format!(\"Watcher update failed: {err}\")));\n        }\n    }\n}\n\n#[cfg(target_os = \"macos\")]\nconst EVENT_ID_FLUSH_INTERVAL: Duration = Duration::from_secs(30);\n\n#[cfg(target_os = \"macos\")]\nfn persist_event_id(db_path: &Path, event_id: u64) -> AppResult<()> {\n    let conn = db_connection(db_path)?;\n    set_meta(&conn, \"last_event_id\", &event_id.to_string())\n}\n\n#[cfg(target_os = \"macos\")]\nconst MUST_SCAN_THRESHOLD: usize = 10;\n\n#[cfg(target_os = \"macos\")]\nfn start_fsevent_watcher_worker(\n    app: AppHandle,\n    state: AppState,\n    since_event_id: Option<u64>,\n    conditional: bool,\n) {\n    use std::sync::mpsc::{self, RecvTimeoutError};\n    std::thread::spawn(move || {\n        let (tx, rx) = mpsc::channel();\n\n        let mut watcher =\n            match mac::fsevent_watcher::FsEventWatcher::new(&state.home_dir, since_event_id, tx) {\n                Ok(w) => w,\n                Err(err) => {\n                    set_state(\n                        &state,\n                        IndexState::Error,\n                        Some(format!(\"FSEvents watcher initialization failed: {err}\")),\n                    );\n                    emit_index_state(\n                        &app,\n                        \"Error\",\n                        Some(format!(\"FSEvents watcher initialization failed: {err}\")),\n                    );\n                    return;\n                }\n            };\n\n        if conditional {\n            perf_log(\"conditional_startup: watcher started, awaiting history replay\");\n            set_state(&state, IndexState::Ready, None);\n            emit_index_state(&app, \"Ready\", None);\n        }\n\n        let mut pending_paths: HashSet<PathBuf> = HashSet::new();\n        let mut deadline: Option<Instant> = None;\n        let mut last_flush = Instant::now();\n        let mut last_status_emit = Instant::now();\n        let mut pending_status_emit = false;\n        let mut last_count_refresh = Instant::now();\n        let mut must_scan_count: usize = 0;\n        let mut replay_phase = conditional;\n        let mut full_scan_triggered = false;\n\n        loop {\n            let wait = match deadline {\n                Some(due) => {\n                    let now = Instant::now();\n                    if now >= due {\n                        Duration::from_millis(0)\n                    } else {\n                        due - now\n                    }\n                }\n                None => Duration::from_secs(1),\n            };\n            match rx.recv_timeout(wait) {\n                Ok(mac::fsevent_watcher::FsEvent::Paths(paths)) => {\n                    let (ignored_roots, ignored_patterns) = cached_effective_ignore_rules(&state);\n                    let prev_len = pending_paths.len();\n                    for path in paths {\n                        if !should_skip_path(&path, &ignored_roots, &ignored_patterns) {\n                            pending_paths.insert(path);\n                        }\n                    }\n                    if pending_paths.len() > prev_len {\n                        deadline = Some(Instant::now() + WATCH_DEBOUNCE);\n                    }\n                }\n                Ok(mac::fsevent_watcher::FsEvent::MustScanSubDirs(path)) => {\n                    must_scan_count += 1;\n                    if replay_phase\n                        && must_scan_count >= MUST_SCAN_THRESHOLD\n                        && !full_scan_triggered\n                    {\n                        perf_log(format!(\n                            \"conditional_startup: MustScanSubDirs={} >= threshold, triggering full scan\",\n                            must_scan_count\n                        ));\n                        full_scan_triggered = true;\n                        let _ = start_full_index_worker(app.clone(), state.clone());\n                    }\n                    if !state.indexing_active.load(AtomicOrdering::Acquire) {\n                        let (ignored_roots, ignored_patterns) =\n                            cached_effective_ignore_rules(&state);\n                        let rows = collect_rows_recursive(&path, &ignored_roots, &ignored_patterns);\n                        if !rows.is_empty() {\n                            eprintln!(\n                                \"[watcher] MustScanSubDirs DB write: rows={} path={}\",\n                                rows.len(),\n                                path.display()\n                            );\n                            if let Ok(mut conn) = db_connection(&state.db_path) {\n                                if upsert_rows(&mut conn, &rows).is_ok() {\n                                    invalidate_search_caches(&state);\n                                    touch_status_updated(&state);\n                                    if last_status_emit.elapsed() >= STATUS_EMIT_MIN_INTERVAL {\n                                        let _ = refresh_and_emit_status_counts(&app, &state);\n                                        last_status_emit = Instant::now();\n                                        pending_status_emit = false;\n                                    } else {\n                                        pending_status_emit = true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                Ok(mac::fsevent_watcher::FsEvent::HistoryDone) => {\n                    eprintln!(\n                        \"[watcher] HistoryDone: pending_paths={} indexing_active={}\",\n                        pending_paths.len(),\n                        state.indexing_active.load(AtomicOrdering::Acquire)\n                    );\n                    process_watcher_paths(\n                        &app,\n                        &state,\n                        &mut pending_paths,\n                        &mut deadline,\n                        &mut last_status_emit,\n                        &mut pending_status_emit,\n                    );\n                    if replay_phase {\n                        replay_phase = false;\n                        if !full_scan_triggered {\n                            perf_log(format!(\n                                \"conditional_startup: HistoryDone, MustScanSubDirs={}, skipping full scan\",\n                                must_scan_count\n                            ));\n                            let _ = refresh_and_emit_status_counts(&app, &state);\n                            last_status_emit = Instant::now();\n                            pending_status_emit = false;\n                        }\n                    }\n                }\n                Err(RecvTimeoutError::Timeout) => {}\n                Err(RecvTimeoutError::Disconnected) => break,\n            }\n\n            if let Some(due) = deadline {\n                if Instant::now() >= due {\n                    process_watcher_paths(\n                        &app,\n                        &state,\n                        &mut pending_paths,\n                        &mut deadline,\n                        &mut last_status_emit,\n                        &mut pending_status_emit,\n                    );\n                }\n            }\n\n            if pending_status_emit && last_status_emit.elapsed() >= STATUS_EMIT_MIN_INTERVAL {\n                let _ = refresh_and_emit_status_counts(&app, &state);\n                last_status_emit = Instant::now();\n                pending_status_emit = false;\n            }\n\n            // Periodic event_id flush\n            if last_flush.elapsed() >= EVENT_ID_FLUSH_INTERVAL {\n                let eid = watcher.last_event_id();\n                let _ = persist_event_id(&state.db_path, eid);\n                last_flush = Instant::now();\n            }\n\n            // Periodic count refresh to keep in-memory counts accurate\n            if last_count_refresh.elapsed() >= EVENT_ID_FLUSH_INTERVAL {\n                let _ = update_status_counts(&state);\n                last_count_refresh = Instant::now();\n            }\n        }\n\n        // Final flush on shutdown\n        let eid = watcher.last_event_id();\n        let _ = persist_event_id(&state.db_path, eid);\n        watcher.stop();\n    });\n}\n\nfn validate_new_name(new_name: &str) -> AppResult<String> {\n    let trimmed = new_name.trim();\n\n    if trimmed.is_empty() {\n        return Err(\"New name cannot be empty.\".to_string());\n    }\n    if trimmed.contains('/') {\n        return Err(\"New name cannot contain '/'.\".to_string());\n    }\n    if trimmed == \".\" || trimmed == \"..\" {\n        return Err(\"Invalid name.\".to_string());\n    }\n\n    Ok(trimmed.to_string())\n}\n\nfn row_to_entry(row: &rusqlite::Row<'_>) -> rusqlite::Result<EntryDto> {\n    Ok(EntryDto {\n        path: row.get(0)?,\n        name: row.get(1)?,\n        dir: row.get(2)?,\n        is_dir: row.get::<_, i64>(3)? == 1,\n        ext: row.get(4)?,\n        size: row.get(5)?,\n        mtime: row.get(6)?,\n    })\n}\n\n#[cfg(target_os = \"macos\")]\nfn safe_file_type(ext: &str) -> String {\n    if ext.eq_ignore_ascii_case(\"folder\") {\n        return \"public.folder\".to_string();\n    }\n\n    let filtered: String = ext\n        .chars()\n        .filter(|c| c.is_ascii_alphanumeric())\n        .collect::<String>()\n        .to_lowercase();\n\n    if filtered.is_empty() {\n        \"public.data\".to_string()\n    } else {\n        filtered\n    }\n}\n\n#[cfg(target_os = \"macos\")]\nfn load_system_icon_png(ext: &str) -> Option<Vec<u8>> {\n    let file_type = safe_file_type(ext);\n    let script = format!(\n        r#\"import AppKit\nimport Foundation\nlet image = NSWorkspace.shared.icon(forFileType: \"{file_type}\")\nimage.size = NSSize(width: 16, height: 16)\nif let tiff = image.tiffRepresentation,\n   let rep = NSBitmapImageRep(data: tiff),\n   let png = rep.representation(using: .png, properties: [:]) {{\n  FileHandle.standardOutput.write(png)\n}} else {{\n  exit(1)\n}}\n\"#\n    );\n\n    let output = Command::new(\"swift\").arg(\"-e\").arg(script).output().ok()?;\n    if output.status.success() && !output.stdout.is_empty() {\n        Some(output.stdout)\n    } else {\n        None\n    }\n}\n\n#[cfg(target_os = \"windows\")]\nfn load_system_icon_png(ext: &str) -> Option<Vec<u8>> {\n    win::icon::load_icon_png_by_ext(ext)\n}\n\n#[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\nfn load_system_icon_png(_ext: &str) -> Option<Vec<u8>> {\n    None\n}\n\n#[cfg(target_os = \"windows\")]\nfn is_per_file_icon_ext(ext: &str) -> bool {\n    matches!(ext, \"exe\" | \"lnk\" | \"ico\" | \"url\" | \"scr\" | \"appx\")\n}\n\n#[tauri::command]\nfn get_index_status(state: State<'_, AppState>) -> IndexStatusDto {\n    let started = Instant::now();\n    let snapshot = state.status.lock().clone();\n    let snapshot_state = snapshot.state.as_str().to_string();\n    let db_ready = state.db_ready.load(AtomicOrdering::Acquire);\n    let indexing_active = state.indexing_active.load(AtomicOrdering::Acquire);\n    let state_label = if matches!(snapshot.state, IndexState::Error) {\n        snapshot.state.as_str().to_string()\n    } else if matches!(snapshot.state, IndexState::Ready) {\n        \"Ready\".to_string()\n    } else if indexing_active || !db_ready {\n        \"Indexing\".to_string()\n    } else {\n        snapshot.state.as_str().to_string()\n    };\n    let dto = IndexStatusDto {\n        state: state_label,\n        entries_count: snapshot.entries_count,\n        last_updated: snapshot.last_updated,\n        permission_errors: snapshot.permission_errors,\n        message: snapshot.message,\n        scanned: snapshot.scanned,\n        indexed: snapshot.indexed,\n        current_path: snapshot.current_path,\n    };\n    if cfg!(debug_assertions) {\n        eprintln!(\n            \"[rpc/get_index_status] elapsed={}ms state={} snapshot_state={} db_ready={} indexing_active={} entries={} scanned={} indexed={}\",\n            started.elapsed().as_millis(),\n            dto.state,\n            snapshot_state,\n            db_ready,\n            indexing_active,\n            dto.entries_count,\n            dto.scanned,\n            dto.indexed,\n        );\n    }\n    dto\n}\n\n#[tauri::command]\nfn get_home_dir(state: State<'_, AppState>) -> String {\n    state.home_dir.to_string_lossy().to_string()\n}\n\n#[tauri::command]\nfn start_full_index(app: AppHandle, state: State<'_, AppState>) -> AppResult<()> {\n    #[cfg(target_os = \"windows\")]\n    {\n        win::start_windows_indexing(app, state.inner().clone());\n        Ok(())\n    }\n    #[cfg(not(target_os = \"windows\"))]\n    {\n        start_full_index_worker(app, state.inner().clone())\n    }\n}\n\n#[tauri::command]\nasync fn reset_index(app: AppHandle, state: State<'_, AppState>) -> AppResult<()> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        if state.indexing_active.load(AtomicOrdering::Acquire) {\n            return Err(\"Cannot reset while indexing is in progress.\".to_string());\n        }\n\n        // Stop existing file watcher and wait for it to fully exit\n        state.watcher_stop.store(true, AtomicOrdering::Release);\n        let deadline = std::time::Instant::now() + std::time::Duration::from_secs(5);\n        while state.watcher_active.load(AtomicOrdering::Acquire) {\n            if std::time::Instant::now() >= deadline {\n                eprintln!(\"[reset] watcher did not stop within 5s, proceeding anyway\");\n                break;\n            }\n            std::thread::sleep(std::time::Duration::from_millis(50));\n        }\n\n        let conn = db_connection(&state.db_path)?;\n        // Use synchronous=OFF + large cache to make the bulk DELETE fast\n        let _ = conn.execute_batch(\n            \"PRAGMA synchronous=OFF; PRAGMA cache_size=-131072;\",\n        );\n        conn.execute(\"DELETE FROM entries\", [])\n            .map_err(|e| e.to_string())?;\n        conn.execute(\"DELETE FROM meta\", [])\n            .map_err(|e| e.to_string())?;\n\n        {\n            let mut status = state.status.lock();\n            status.state = IndexState::Indexing;\n            status.entries_count = 0;\n            status.last_updated = None;\n            status.permission_errors = 0;\n            status.message = None;\n            status.scanned = 0;\n            status.indexed = 0;\n            status.current_path.clear();\n        }\n\n        invalidate_search_caches(&state);\n\n        emit_index_state(&app, \"Indexing\", None);\n        emit_index_updated(&app, 0, now_epoch(), 0);\n\n        // Allow new watcher to start\n        state.watcher_stop.store(false, AtomicOrdering::Release);\n\n        #[cfg(target_os = \"windows\")]\n        {\n            win::start_windows_indexing(app, state);\n            Ok(())\n        }\n        #[cfg(not(target_os = \"windows\"))]\n        {\n            start_full_index_worker(app, state)\n        }\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\nfn log_search(db_path: &Path, query: &str, mode: &str, results: &[EntryDto]) {\n    if !search_log_enabled() {\n        return;\n    }\n\n    let log_path = db_path.with_file_name(\"search.log\");\n    let Ok(mut f) = fs::OpenOptions::new()\n        .create(true)\n        .append(true)\n        .open(&log_path)\n    else {\n        return;\n    };\n    let top: Vec<&str> = results.iter().take(10).map(|e| e.name.as_str()).collect();\n    let _ = writeln!(\n        f,\n        \"[{}] Q={:?} MODE={} COUNT={} TOP={:?}\",\n        now_epoch(),\n        query,\n        mode,\n        results.len(),\n        top,\n    );\n}\n\nfn search_log_enabled() -> bool {\n    *SEARCH_LOG_ENABLED.get_or_init(|| env_truthy(\"FASTFIND_SEARCH_LOG\"))\n}\n\n/// Returns the total number of entries matching `query` without LIMIT/OFFSET.\n/// Returns `None` when the total is unknown or intentionally skipped.\nfn compute_total_count(\n    db_path: &Path,\n    home_dir: &Path,\n    execution: &SearchExecution,\n) -> Option<u32> {\n    // When fewer results than the limit were returned the total is exact.\n    if (execution.results.len() as u32) < execution.effective_limit {\n        return Some(\n            execution\n                .offset\n                .saturating_add(execution.results.len() as u32),\n        );\n    }\n    // For paginated pages after the first we leave total tracking to the frontend.\n    if execution.offset > 0 {\n        return None;\n    }\n    // Non-SQL fast paths already return all matching entries.\n    if execution.mode_label.starts_with(\"mem_\")\n        || execution.mode_label == \"spotlight\"\n        || execution.mode_label == \"spotlight_timeout\"\n        || execution.mode_label == \"find_fallback\"\n        || execution.mode_label == \"name_neg_cache\"\n    {\n        return Some(execution.results.len() as u32);\n    }\n    let Ok(conn) = db_connection_for_search(db_path) else {\n        return None;\n    };\n    let mode = parse_query(&execution.query);\n    let total = match mode {\n        SearchMode::Empty => conn\n            .query_row(\"SELECT COUNT(*) FROM entries\", [], |r| r.get(0))\n            .unwrap_or(0),\n        SearchMode::NameSearch { name_like } => {\n            let escaped = escape_like(&execution.query);\n            let prefix_like = format!(\"{}%\", escaped);\n            let prefix_count: u32 = conn\n                .query_row(\n                    \"SELECT COUNT(*) FROM entries WHERE name LIKE ?1 ESCAPE '\\\\'\",\n                    params![prefix_like],\n                    |r| r.get(0),\n                )\n                .unwrap_or(0);\n            if prefix_count > 0 {\n                prefix_count\n            } else {\n                // Phase-2 contains fallback was used.\n                conn.query_row(\n                    \"SELECT COUNT(*) FROM entries WHERE name LIKE ?1 ESCAPE '\\\\'\",\n                    params![name_like],\n                    |r| r.get(0),\n                )\n                .unwrap_or(0)\n            }\n        }\n        SearchMode::GlobName { name_like } => conn\n            .query_row(\n                \"SELECT COUNT(*) FROM entries WHERE name LIKE ?1 ESCAPE '\\\\'\",\n                params![name_like],\n                |r| r.get(0),\n            )\n            .unwrap_or(0),\n        SearchMode::ExtSearch { ext, .. } => conn\n            .query_row(\n                \"SELECT COUNT(*) FROM entries WHERE ext = ?1\",\n                params![ext],\n                |r| r.get(0),\n            )\n            .unwrap_or(0),\n        SearchMode::PathSearch {\n            name_like,\n            dir_hint,\n            ..\n        } => {\n            let resolved_dirs = resolve_dir_hint(home_dir, &dir_hint)\n                .map(|p| vec![p.to_string_lossy().to_string()])\n                .unwrap_or_default();\n            let resolved_dirs = if resolved_dirs.is_empty() {\n                resolve_dirs_from_db(&conn, &dir_hint)\n            } else {\n                resolved_dirs\n            };\n\n            if !resolved_dirs.is_empty() {\n                let mut sql_params: Vec<SqlValue> = Vec::new();\n                let mut dir_conditions = Vec::new();\n                let sep = std::path::MAIN_SEPARATOR;\n                for d in &resolved_dirs {\n                    let i = sql_params.len();\n                    let pfx = format!(\"{d}{sep}\");\n                    let pfx_end = format!(\"{d}\\x7F\");\n                    sql_params.push(SqlValue::Text(d.clone()));\n                    sql_params.push(SqlValue::Text(pfx));\n                    sql_params.push(SqlValue::Text(pfx_end));\n                    dir_conditions.push(format!(\n                        \"(e.dir = ?{} OR (e.dir >= ?{} AND e.dir < ?{}))\",\n                        i + 1,\n                        i + 2,\n                        i + 3\n                    ));\n                }\n                let dir_where = dir_conditions.join(\" OR \");\n                let name_filter = if name_like == \"%\" {\n                    String::new()\n                } else {\n                    let ext_shortcut = extract_ext_from_like(&name_like);\n                    if let Some(ext_val) = ext_shortcut {\n                        let i = sql_params.len();\n                        sql_params.push(SqlValue::Text(ext_val));\n                        format!(\" AND e.ext = ?{}\", i + 1)\n                    } else {\n                        let i = sql_params.len();\n                        sql_params.push(SqlValue::Text(name_like.clone()));\n                        format!(\" AND e.name LIKE ?{} ESCAPE '\\\\'\", i + 1)\n                    }\n                };\n                let sql =\n                    format!(\"SELECT COUNT(*) FROM entries e WHERE ({dir_where}){name_filter}\");\n                conn.query_row(&sql, params_from_iter(sql_params.iter()), |r| r.get(0))\n                    .unwrap_or(0)\n            } else {\n                let sep = std::path::MAIN_SEPARATOR;\n                let native_hint = dir_hint.replace('/', &sep.to_string());\n                let escaped_sep = escape_like(&sep.to_string());\n                let dir_suffix = escape_like(&native_hint);\n                let dir_like_exact = format!(\"%{escaped_sep}{dir_suffix}\");\n                let dir_like_sub = format!(\"%{escaped_sep}{dir_suffix}{escaped_sep}%\");\n                let ext_shortcut = extract_ext_from_like(&name_like);\n                if let Some(ext_val) = ext_shortcut {\n                    conn.query_row(\n                        \"SELECT COUNT(*) FROM entries e WHERE e.ext = ?1 AND (e.dir LIKE ?2 ESCAPE '\\\\' OR e.dir LIKE ?3 ESCAPE '\\\\')\",\n                        params![ext_val, dir_like_exact, dir_like_sub],\n                        |r| r.get(0),\n                    )\n                    .unwrap_or(0)\n                } else if name_like == \"%\" {\n                    conn.query_row(\n                        \"SELECT COUNT(*) FROM entries e WHERE e.dir LIKE ?1 ESCAPE '\\\\' OR e.dir LIKE ?2 ESCAPE '\\\\'\",\n                        params![dir_like_exact, dir_like_sub],\n                        |r| r.get(0),\n                    )\n                    .unwrap_or(0)\n                } else {\n                    conn.query_row(\n                        \"SELECT COUNT(*) FROM entries e WHERE (e.dir LIKE ?1 ESCAPE '\\\\' OR e.dir LIKE ?2 ESCAPE '\\\\') AND e.name LIKE ?3 ESCAPE '\\\\'\",\n                        params![dir_like_exact, dir_like_sub, name_like],\n                        |r| r.get(0),\n                    )\n                    .unwrap_or(0)\n                }\n            }\n        }\n    };\n\n    Some(total)\n}\n\nfn execute_search(\n    state: &AppState,\n    query: String,\n    limit: Option<u32>,\n    offset: Option<u32>,\n    sort_by: Option<String>,\n    sort_dir: Option<String>,\n) -> AppResult<SearchExecution> {\n    let query = query.trim().to_string();\n    let base_limit = limit.unwrap_or(DEFAULT_LIMIT).clamp(1, MAX_LIMIT);\n    let effective_limit = if !query.is_empty() && query.chars().count() <= 1 {\n        base_limit.min(SHORT_QUERY_LIMIT)\n    } else {\n        base_limit\n    };\n    let offset = offset.unwrap_or(0);\n\n    let sort_by = sort_by.unwrap_or_else(|| \"name\".to_string());\n    let sort_dir = sort_dir.unwrap_or_else(|| \"asc\".to_string());\n    let (runtime_ignored_roots, runtime_ignored_patterns) = cached_effective_ignore_rules(state);\n\n    #[cfg(target_os = \"macos\")]\n    if !state.db_ready.load(AtomicOrdering::Acquire) {\n        let spotlight = mac::spotlight_search::search_spotlight(&state.home_dir, &query);\n        let mode_label = if spotlight.entries.is_empty() {\n            \"db_not_ready\".to_string()\n        } else if spotlight.timed_out {\n            \"spotlight_timeout\".to_string()\n        } else {\n            \"spotlight\".to_string()\n        };\n        perf_log(format!(\n            \"spotlight_fallback db_not_ready query={:?} results={} timed_out={}\",\n            query,\n            spotlight.entries.len(),\n            spotlight.timed_out\n        ));\n        return Ok(SearchExecution {\n            query,\n            sort_by,\n            sort_dir,\n            effective_limit,\n            offset,\n            mode_label,\n            results: spotlight.entries,\n        });\n    }\n\n    let is_indexing = matches!(state.status.lock().state, IndexState::Indexing);\n    let order_by = sort_clause(&sort_by, &sort_dir, \"e.\");\n\n    let mut results = Vec::with_capacity(effective_limit as usize);\n    let mode = parse_query(&query);\n    let is_name_mode = matches!(&mode, SearchMode::NameSearch { .. });\n    let allow_find_fallback = !is_indexing\n        && matches!(\n            &mode,\n            SearchMode::GlobName { .. } | SearchMode::ExtSearch { .. }\n        );\n    let mut mode_label = match &mode {\n        SearchMode::Empty => \"empty\",\n        SearchMode::NameSearch { .. } => \"name\",\n        SearchMode::GlobName { .. } => \"glob\",\n        SearchMode::ExtSearch { .. } => \"ext\",\n        SearchMode::PathSearch { .. } => \"path\",\n    }\n    .to_string();\n\n    // Fast path: search in-memory index if available (DB upsert still in progress)\n    {\n        let guard = state.mem_index.read();\n        if let Some(ref mi) = *guard {\n            let mem_results = mem_search::search_mem_index(\n                mi, &query, &mode, effective_limit, offset, &sort_by, &sort_dir,\n            );\n            mode_label = format!(\"mem_{mode_label}\");\n            return Ok(SearchExecution {\n                query,\n                sort_by,\n                sort_dir,\n                effective_limit,\n                offset,\n                mode_label,\n                results: mem_results,\n            });\n        }\n    }\n\n    if is_name_mode && !is_indexing && offset == 0 {\n        if let Some(cache_hit) = negative_name_cache_lookup(state, &query) {\n            if cache_hit.age >= WATCH_DEBOUNCE\n                && cache_hit.age <= NEGATIVE_CACHE_FALLBACK_WINDOW\n                && !cache_hit.fallback_checked\n            {\n                let fallback_results = find_search(\n                    &state.home_dir,\n                    &runtime_ignored_roots,\n                    &runtime_ignored_patterns,\n                    &query,\n                    effective_limit as usize,\n                    &sort_by,\n                    &sort_dir,\n                );\n                if !fallback_results.is_empty() {\n                    remove_negative_name_query(state, &cache_hit.query_lower);\n                    perf_log(format!(\n                        \"search_negative_cache_fallback_hit query={:?} age_ms={} results={}\",\n                        query,\n                        cache_hit.age.as_millis(),\n                        fallback_results.len()\n                    ));\n                    return Ok(SearchExecution {\n                        query,\n                        sort_by,\n                        sort_dir,\n                        effective_limit,\n                        offset,\n                        mode_label: \"find_fallback\".to_string(),\n                        results: fallback_results,\n                    });\n                }\n                mark_negative_name_fallback_checked(state, &cache_hit.query_lower);\n            }\n\n            perf_log(format!(\n                \"search_negative_cache_hit query={:?} age_ms={}\",\n                query,\n                cache_hit.age.as_millis()\n            ));\n            return Ok(SearchExecution {\n                query,\n                sort_by,\n                sort_dir,\n                effective_limit,\n                offset,\n                mode_label: \"name_neg_cache\".to_string(),\n                results: Vec::new(),\n            });\n        }\n    }\n\n    #[cfg(target_os = \"macos\")]\n    let db_unavailable;\n    match db_connection_for_search(&state.db_path) {\n        Ok(conn) => {\n            #[cfg(target_os = \"macos\")]\n            { db_unavailable = false; }\n            match &mode {\n                SearchMode::Empty => {\n                    let sql = format!(\n                        r#\"\n                        SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                        FROM entries e\n                        ORDER BY {order_by}\n                        LIMIT ?1 OFFSET ?2\n                        \"#,\n                    );\n                    let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                    let rows = stmt\n                        .query_map(params![effective_limit, offset], row_to_entry)\n                        .map_err(|e| e.to_string())?;\n                    for row in rows {\n                        results.push(row.map_err(|e| e.to_string())?);\n                    }\n                }\n\n                SearchMode::NameSearch { name_like } => {\n                    let escaped_query = escape_like(&query);\n                    let exact_query = query.clone();\n                    let prefix_like = format!(\"{}%\", escaped_query);\n                    let bare_order = sort_clause(&sort_by, &sort_dir, \"\");\n\n                    if offset == 0 {\n                        let exact_sql = format!(\n                            r#\"\n                            SELECT path, name, dir, is_dir, ext, size, mtime\n                            FROM entries\n                            WHERE name COLLATE NOCASE = ?1\n                            ORDER BY {bare_order}\n                            LIMIT ?2\n                            \"#,\n                        );\n                        let mut stmt = conn.prepare(&exact_sql).map_err(|e| e.to_string())?;\n                        let rows = stmt\n                            .query_map(params![exact_query, effective_limit], row_to_entry)\n                            .map_err(|e| e.to_string())?;\n                        for row in rows {\n                            results.push(row.map_err(|e| e.to_string())?);\n                        }\n                    }\n\n                    if (results.len() as u32) < effective_limit {\n                        let remaining = effective_limit - results.len() as u32;\n                        let adj_offset = if offset > 0 {\n                            offset.saturating_sub(results.len() as u32)\n                        } else {\n                            0\n                        };\n\n                        // Try indexed prefix search first; fall back to unindexed if\n                        // the index is temporarily unavailable (during background DB\n                        // rebuild the index may be dropped then recreated).\n                        let prefix_sql_indexed = format!(\n                            r#\"\n                            SELECT path, name, dir, is_dir, ext, size, mtime\n                            FROM entries INDEXED BY idx_entries_name_nocase\n                            WHERE name LIKE ?1 ESCAPE '\\'\n                              AND name COLLATE NOCASE != ?2\n                            ORDER BY {bare_order}\n                            LIMIT ?3 OFFSET ?4\n                            \"#,\n                        );\n                        let prefix_sql_fallback = format!(\n                            r#\"\n                            SELECT path, name, dir, is_dir, ext, size, mtime\n                            FROM entries\n                            WHERE name LIKE ?1 ESCAPE '\\'\n                              AND name COLLATE NOCASE != ?2\n                            ORDER BY {bare_order}\n                            LIMIT ?3 OFFSET ?4\n                            \"#,\n                        );\n                        let mut stmt = match conn.prepare(&prefix_sql_indexed) {\n                            Ok(s) => s,\n                            Err(_) => {\n                                eprintln!(\"[search] idx_entries_name_nocase unavailable, using fallback\");\n                                conn.prepare(&prefix_sql_fallback).map_err(|e| e.to_string())?\n                            }\n                        };\n                        let rows = stmt\n                            .query_map(\n                                params![prefix_like, exact_query, remaining, adj_offset],\n                                row_to_entry,\n                            )\n                            .map_err(|e| e.to_string())?;\n                        for row in rows {\n                            results.push(row.map_err(|e| e.to_string())?);\n                        }\n                    }\n\n                    if results.is_empty() && offset == 0 {\n                        // Phase 2: contains-match (LIKE '%q%') with tight time budget.\n                        // Combines probe + fetch in one pass to avoid double scan overhead.\n                        let phase2_start = Instant::now();\n                        conn.progress_handler(\n                            2_000,\n                            Some(move || phase2_start.elapsed().as_millis() > 5),\n                        );\n\n                        {\n\n                            let phase2_sql = format!(\n                                r#\"\n                                SELECT path, name, dir, is_dir, ext, size, mtime\n                                FROM entries\n                                WHERE name LIKE ?1 ESCAPE '\\'\n                                  AND name COLLATE NOCASE != ?2\n                                  AND name NOT LIKE ?3 ESCAPE '\\'\n                                ORDER BY {bare_order}\n                                LIMIT ?4\n                                \"#,\n                            );\n                            if let Ok(mut stmt2) = conn.prepare(&phase2_sql) {\n                                if let Ok(rows2) = stmt2.query_map(\n                                    params![name_like, exact_query, prefix_like, effective_limit],\n                                    row_to_entry,\n                                ) {\n                                    for row in rows2 {\n                                        match row {\n                                            Ok(entry) => results.push(entry),\n                                            Err(_) => break,\n                                        }\n                                    }\n                                }\n                            }\n                        }\n\n                        conn.progress_handler(0, None::<fn() -> bool>);\n                    }\n                }\n\n                SearchMode::GlobName { name_like } => {\n                    let sql = format!(\n                        r#\"\n                        SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                        FROM entries e\n                        WHERE e.name LIKE ?1 ESCAPE '\\'\n                        ORDER BY {order_by}\n                        LIMIT ?2 OFFSET ?3\n                        \"#,\n                    );\n                    let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                    let rows = stmt\n                        .query_map(params![name_like, effective_limit, offset], row_to_entry)\n                        .map_err(|e| e.to_string())?;\n                    for row in rows {\n                        results.push(row.map_err(|e| e.to_string())?);\n                    }\n                }\n\n                SearchMode::ExtSearch { ext, name_like: _ } => {\n                    let sql = format!(\n                        r#\"\n                        SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                        FROM entries e\n                        WHERE e.ext = ?1\n                        ORDER BY {order_by}\n                        LIMIT ?2 OFFSET ?3\n                        \"#,\n                    );\n                    let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                    let rows = stmt\n                        .query_map(params![ext, effective_limit, offset], row_to_entry)\n                        .map_err(|e| e.to_string())?;\n                    for row in rows {\n                        results.push(row.map_err(|e| e.to_string())?);\n                    }\n                }\n\n                SearchMode::PathSearch {\n                    path_like: _,\n                    name_like,\n                    dir_hint,\n                } => {\n                    let resolved_dirs: Vec<String> = resolve_dir_hint(&state.home_dir, dir_hint)\n                        .map(|p| vec![p.to_string_lossy().to_string()])\n                        .unwrap_or_default();\n                    let resolved_dirs = if resolved_dirs.is_empty() {\n                        resolve_dirs_from_db(&conn, dir_hint)\n                    } else {\n                        resolved_dirs\n                    };\n\n                    if !resolved_dirs.is_empty() {\n                        let ext_shortcut = extract_ext_from_like(name_like);\n                        let mut sql_params: Vec<SqlValue> = Vec::new();\n                        let mut dir_conditions = Vec::new();\n                        let sep = std::path::MAIN_SEPARATOR;\n\n                        for d in &resolved_dirs {\n                            let i = sql_params.len();\n                            let pfx = format!(\"{d}{sep}\");\n                            let pfx_end = format!(\"{d}\\x7F\");\n                            sql_params.push(SqlValue::Text(d.clone()));\n                            sql_params.push(SqlValue::Text(pfx));\n                            sql_params.push(SqlValue::Text(pfx_end));\n                            dir_conditions.push(format!(\n                                \"(e.dir = ?{} OR (e.dir >= ?{} AND e.dir < ?{}))\",\n                                i + 1,\n                                i + 2,\n                                i + 3\n                            ));\n                        }\n                        let dir_where = dir_conditions.join(\" OR \");\n\n                        let name_filter = if name_like == \"%\" {\n                            String::new()\n                        } else if let Some(ref ext_val) = ext_shortcut {\n                            let i = sql_params.len();\n                            sql_params.push(SqlValue::Text(ext_val.clone()));\n                            format!(\" AND e.ext = ?{}\", i + 1)\n                        } else {\n                            let i = sql_params.len();\n                            sql_params.push(SqlValue::Text(name_like.clone()));\n                            format!(\" AND e.name LIKE ?{} ESCAPE '\\\\'\", i + 1)\n                        };\n\n                        let limit_idx = sql_params.len() + 1;\n                        let offset_idx = sql_params.len() + 2;\n                        sql_params.push(SqlValue::Integer(effective_limit as i64));\n                        sql_params.push(SqlValue::Integer(offset as i64));\n\n                        let sql = format!(\n                            r#\"\n                            SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                            FROM entries e\n                            WHERE ({dir_where}){name_filter}\n                            ORDER BY {order_by}\n                            LIMIT ?{limit_idx} OFFSET ?{offset_idx}\n                            \"#,\n                        );\n                        let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                        let rows = stmt\n                            .query_map(params_from_iter(sql_params.iter()), row_to_entry)\n                            .map_err(|e| e.to_string())?;\n                        for row in rows {\n                            results.push(row.map_err(|e| e.to_string())?);\n                        }\n                    } else {\n                        let sep = std::path::MAIN_SEPARATOR;\n                        let sep_str = sep.to_string();\n                        let escaped_sep = escape_like(&sep_str);\n                        let (native_hint, is_absolute) = normalize_hint_to_native(dir_hint);\n                        let dir_suffix = escape_like(&native_hint);\n                        let dir_prefix = if is_absolute {\n                            String::new()\n                        } else {\n                            escaped_sep.clone()\n                        };\n                        let dir_like_exact = format!(\"%{dir_prefix}{dir_suffix}\");\n                        let dir_like_sub = format!(\"%{dir_prefix}{dir_suffix}{escaped_sep}%\");\n                        let ext_shortcut = extract_ext_from_like(name_like);\n\n                        if let Some(ext_val) = ext_shortcut {\n                            let sql = format!(\n                                r#\"\n                                SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                                FROM entries e\n                                WHERE e.ext = ?1\n                                  AND (e.dir LIKE ?2 ESCAPE '\\' OR e.dir LIKE ?3 ESCAPE '\\')\n                                ORDER BY {order_by}\n                                LIMIT ?4 OFFSET ?5\n                                \"#,\n                            );\n                            let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                            let rows = stmt\n                                .query_map(\n                                    params![\n                                        ext_val,\n                                        dir_like_exact,\n                                        dir_like_sub,\n                                        effective_limit,\n                                        offset\n                                    ],\n                                    row_to_entry,\n                                )\n                                .map_err(|e| e.to_string())?;\n                            for row in rows {\n                                results.push(row.map_err(|e| e.to_string())?);\n                            }\n                        } else if name_like == \"%\" {\n                            // Directory listing: no name filter needed, no time budget\n                            let sql = format!(\n                                r#\"\n                                SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                                FROM entries e\n                                WHERE e.dir LIKE ?1 ESCAPE '\\' OR e.dir LIKE ?2 ESCAPE '\\'\n                                ORDER BY {order_by}\n                                LIMIT ?3 OFFSET ?4\n                                \"#,\n                            );\n                            let mut stmt = conn.prepare(&sql).map_err(|e| e.to_string())?;\n                            let rows = stmt\n                                .query_map(\n                                    params![dir_like_exact, dir_like_sub, effective_limit, offset],\n                                    row_to_entry,\n                                )\n                                .map_err(|e| e.to_string())?;\n                            for row in rows {\n                                results.push(row.map_err(|e| e.to_string())?);\n                            }\n                        } else {\n                            // Phase A: fast prefix search via name index\n                            // \"%main%\" -> strip leading '%' -> \"main%\" can use idx_entries_name_nocase\n                            let prefix_like = if name_like.starts_with('%') {\n                                let rest = &name_like[1..];\n                                if !rest.is_empty() && !rest.starts_with('%') {\n                                    Some(rest.to_string())\n                                } else {\n                                    None\n                                }\n                            } else {\n                                // Already a prefix pattern (e.g. \"test%\"), use as-is\n                                Some(name_like.clone())\n                            };\n\n                            if offset == 0 {\n                                if let Some(ref pfx) = prefix_like {\n                                    let sql = format!(\n                                        r#\"\n                                        SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                                        FROM entries e INDEXED BY idx_entries_name_nocase\n                                        WHERE e.name LIKE ?1 ESCAPE '\\'\n                                          AND (e.dir LIKE ?2 ESCAPE '\\' OR e.dir LIKE ?3 ESCAPE '\\')\n                                        ORDER BY {order_by}\n                                        LIMIT ?4\n                                        \"#,\n                                    );\n                                    if let Ok(mut stmt) = conn.prepare(&sql) {\n                                        if let Ok(rows) = stmt.query_map(\n                                            params![\n                                                pfx,\n                                                dir_like_exact,\n                                                dir_like_sub,\n                                                effective_limit\n                                            ],\n                                            row_to_entry,\n                                        ) {\n                                            for row in rows {\n                                                match row {\n                                                    Ok(entry) => results.push(entry),\n                                                    Err(_) => break,\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n\n                            // Phase B: time-budgeted contains fallback if prefix found too few\n                            if results.len() < effective_limit as usize {\n                                let path_start = Instant::now();\n                                conn.progress_handler(\n                                    2_000,\n                                    Some(move || path_start.elapsed().as_millis() > 5),\n                                );\n\n                                let sql = format!(\n                                    r#\"\n                                    SELECT e.path, e.name, e.dir, e.is_dir, e.ext, e.size, e.mtime\n                                    FROM entries e\n                                    WHERE (e.dir LIKE ?1 ESCAPE '\\' OR e.dir LIKE ?2 ESCAPE '\\')\n                                      AND e.name LIKE ?3 ESCAPE '\\'\n                                    ORDER BY {order_by}\n                                    LIMIT ?4 OFFSET ?5\n                                    \"#,\n                                );\n                                if let Ok(mut stmt) = conn.prepare(&sql) {\n                                    if let Ok(rows) = stmt.query_map(\n                                        params![\n                                            dir_like_exact,\n                                            dir_like_sub,\n                                            name_like,\n                                            effective_limit,\n                                            offset\n                                        ],\n                                        row_to_entry,\n                                    ) {\n                                        for row in rows {\n                                            match row {\n                                                Ok(entry) => results.push(entry),\n                                                Err(_) => break,\n                                            }\n                                        }\n                                    }\n                                }\n\n                                conn.progress_handler(0, None::<fn() -> bool>);\n\n                                // Deduplicate (Phase A prefix results overlap with Phase B contains)\n                                let mut seen = std::collections::HashSet::new();\n                                results.retain(|e| seen.insert(e.path.clone()));\n                                results.truncate(effective_limit as usize);\n                            }\n                        }\n                    }\n                }\n            }\n\n            if results.is_empty() && !query.is_empty() && offset == 0 && allow_find_fallback {\n                results = find_search(\n                    &state.home_dir,\n                    &runtime_ignored_roots,\n                    &runtime_ignored_patterns,\n                    &query,\n                    effective_limit as usize,\n                    &sort_by,\n                    &sort_dir,\n                );\n                mode_label = \"find_fallback\".to_string();\n            }\n        }\n        Err(_) => {\n            #[cfg(target_os = \"macos\")]\n            { db_unavailable = true; }\n            perf_log(format!(\"search_db_unavailable query={:?}\", query));\n        }\n    }\n\n    #[cfg(target_os = \"macos\")]\n    if !query.is_empty() && offset == 0 {\n        let should_spotlight = if results.is_empty() {\n            true\n        } else if results.len() >= effective_limit as usize {\n            false\n        } else {\n            is_indexing || db_unavailable\n        };\n        if should_spotlight {\n            let spotlight = mac::spotlight_search::search_spotlight(&state.home_dir, &query);\n            if !spotlight.entries.is_empty() {\n                if results.is_empty() {\n                    perf_log(format!(\n                        \"spotlight_fallback empty_results query={:?} results={} timed_out={}\",\n                        query,\n                        spotlight.entries.len(),\n                        spotlight.timed_out\n                    ));\n                    results = spotlight.entries;\n                    mode_label = if spotlight.timed_out {\n                        \"spotlight_timeout\".to_string()\n                    } else {\n                        \"spotlight\".to_string()\n                    };\n                } else {\n                    let existing_paths: std::collections::HashSet<String> =\n                        results.iter().map(|e| e.path.clone()).collect();\n                    let mut merged_count = 0usize;\n                    for entry in spotlight.entries {\n                        if !existing_paths.contains(&entry.path) {\n                            results.push(entry);\n                            merged_count += 1;\n                        }\n                    }\n                    if merged_count > 0 {\n                        perf_log(format!(\n                            \"spotlight_merge indexing query={:?} merged={} timed_out={}\",\n                            query, merged_count, spotlight.timed_out\n                        ));\n                        mode_label = format!(\"{}_+spotlight\", mode_label);\n                    }\n                }\n            }\n        }\n    }\n\n    results = filter_ignored_entries(results, &runtime_ignored_roots, &runtime_ignored_patterns);\n    results.truncate(effective_limit as usize);\n    if offset == 0 {\n        if sort_by == \"name\" {\n            sort_entries_with_relevance(&mut results, &query, &sort_by, &sort_dir);\n        } else {\n            sort_entries(&mut results, &sort_by, &sort_dir);\n        }\n    }\n    if is_name_mode && !is_indexing && offset == 0 && results.is_empty() && !query.is_empty() {\n        remember_negative_name_query(state, &query);\n    }\n\n    Ok(SearchExecution {\n        query,\n        sort_by,\n        sort_dir,\n        effective_limit,\n        offset,\n        mode_label,\n        results,\n    })\n}\n\n#[tauri::command]\nasync fn search(\n    _app: AppHandle,\n    query: String,\n    limit: Option<u32>,\n    offset: Option<u32>,\n    sort_by: Option<String>,\n    sort_dir: Option<String>,\n    include_total: Option<bool>,\n    state: State<'_, AppState>,\n) -> AppResult<SearchResultDto> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        let rpc_started = Instant::now();\n        let execute_started = Instant::now();\n        let execution = execute_search(&state, query, limit, offset, sort_by, sort_dir)?;\n        let execute_elapsed_ms = execute_started.elapsed().as_secs_f64() * 1000.0;\n\n        log_search(\n            &state.db_path,\n            &execution.query,\n            &execution.mode_label,\n            &execution.results,\n        );\n\n        if perf_log_enabled() {\n            let top: Vec<&str> = execution\n                .results\n                .iter()\n                .take(5)\n                .map(|entry| entry.name.as_str())\n                .collect();\n            perf_log(format!(\n                \"search query={:?} mode={} sort={}/{} limit={} offset={} results={} elapsed_ms={:.3} top={:?}\",\n                execution.query,\n                execution.mode_label,\n                execution.sort_by,\n                execution.sort_dir,\n                execution.effective_limit,\n                execution.offset,\n                execution.results.len(),\n                execute_elapsed_ms,\n                top,\n            ));\n        }\n\n        let include_total = include_total.unwrap_or(true);\n        let count_started = Instant::now();\n        let (total_count, total_known) = if include_total {\n            match compute_total_count(&state.db_path, &state.home_dir, &execution) {\n                Some(v) => (v, true),\n                None => (0, false),\n            }\n        } else {\n            (0, false)\n        };\n        let count_elapsed_ms = if include_total {\n            count_started.elapsed().as_secs_f64() * 1000.0\n        } else {\n            0.0\n        };\n\n        let rpc_elapsed_ms = rpc_started.elapsed().as_secs_f64() * 1000.0;\n        if cfg!(debug_assertions) {\n            let db_ready = state.db_ready.load(AtomicOrdering::Acquire);\n            let indexing_active = state.indexing_active.load(AtomicOrdering::Acquire);\n            eprintln!(\n                \"[rpc/search] total={:.3}ms execute={:.3}ms total_count={:.3}ms include_total={} query={:?} mode={} sort={}/{} limit={} offset={} results={} total_count={} total_known={} db_ready={} indexing_active={}\",\n                rpc_elapsed_ms,\n                execute_elapsed_ms,\n                count_elapsed_ms,\n                include_total,\n                execution.query,\n                execution.mode_label,\n                execution.sort_by,\n                execution.sort_dir,\n                execution.effective_limit,\n                execution.offset,\n                execution.results.len(),\n                total_count,\n                total_known,\n                db_ready,\n                indexing_active,\n            );\n        }\n        Ok(SearchResultDto {\n            entries: execution.results,\n            mode_label: execution.mode_label,\n            total_count,\n            total_known,\n        })\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nasync fn quick_look(path: String) -> AppResult<()> {\n    tauri::async_runtime::spawn_blocking(move || {\n        #[cfg(target_os = \"macos\")]\n        {\n            Command::new(\"qlmanage\")\n                .args([\"-p\", &path])\n                .stdout(std::process::Stdio::null())\n                .stderr(std::process::Stdio::null())\n                .spawn()\n                .map_err(|e| e.to_string())?;\n        }\n        #[cfg(target_os = \"windows\")]\n        {\n            Command::new(\"explorer\")\n                .arg(&path)\n                .spawn()\n                .map_err(|e| e.to_string())?;\n        }\n        #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n        {\n            Command::new(\"xdg-open\")\n                .arg(&path)\n                .spawn()\n                .map_err(|e| e.to_string())?;\n        }\n        Ok(())\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nasync fn open(paths: Vec<String>) -> AppResult<()> {\n    tauri::async_runtime::spawn_blocking(move || {\n        for path in &paths {\n            #[cfg(target_os = \"macos\")]\n            {\n                let output = Command::new(\"open\")\n                    .arg(path)\n                    .output()\n                    .map_err(|e| e.to_string())?;\n\n                if !output.status.success() && Path::new(path).is_dir() {\n                    let fallback = Command::new(\"open\")\n                        .args([\"-R\", path])\n                        .status()\n                        .map_err(|e| e.to_string())?;\n\n                    if !fallback.success() {\n                        return Err(format!(\"Failed to open: {path}\"));\n                    }\n                } else if !output.status.success() {\n                    let stderr = String::from_utf8_lossy(&output.stderr);\n                    return Err(format!(\"Failed to open: {path} ({stderr})\",));\n                }\n            }\n            #[cfg(target_os = \"windows\")]\n            {\n                let mut cmd = Command::new(\"cmd\");\n                cmd.raw_arg(format!(\"/C start \\\"\\\" \\\"{}\\\"\", path.replace('\"', \"\")));\n                let status = cmd.status().map_err(|e| e.to_string())?;\n                if !status.success() {\n                    return Err(format!(\"Failed to open: {path}\"));\n                }\n            }\n            #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n            {\n                let status = Command::new(\"xdg-open\")\n                    .arg(path)\n                    .status()\n                    .map_err(|e| e.to_string())?;\n                if !status.success() {\n                    return Err(format!(\"Failed to open: {path}\"));\n                }\n            }\n        }\n\n        Ok(())\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\nfn reveal_in_finder_impl(paths: Vec<String>) -> AppResult<()> {\n    if paths.is_empty() {\n        return Ok(());\n    }\n\n    #[cfg(target_os = \"macos\")]\n    {\n        if paths.len() == 1 {\n            let status = Command::new(\"open\")\n                .arg(\"-R\")\n                .arg(&paths[0])\n                .status()\n                .map_err(|e| e.to_string())?;\n\n            if !status.success() {\n                return Err(format!(\"Failed to reveal in Finder: {}\", paths[0]));\n            }\n\n            return Ok(());\n        }\n\n        let mut unique_parents: HashSet<PathBuf> = HashSet::new();\n        for path in &paths {\n            let p = PathBuf::from(path);\n            if let Some(parent) = p.parent() {\n                unique_parents.insert(parent.to_path_buf());\n            }\n        }\n\n        for parent in unique_parents {\n            let status = Command::new(\"open\")\n                .arg(&parent)\n                .status()\n                .map_err(|e| e.to_string())?;\n\n            if !status.success() {\n                return Err(format!(\n                    \"Failed to open in Finder: {}\",\n                    parent.to_string_lossy()\n                ));\n            }\n        }\n    }\n\n    #[cfg(target_os = \"windows\")]\n    {\n        for path in &paths {\n            let mut cmd = Command::new(\"explorer\");\n            cmd.raw_arg(format!(\"/select,\\\"{}\\\"\", path.replace('\"', \"\")));\n            let _ = cmd.status();\n        }\n    }\n\n    #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n    {\n        for path in &paths {\n            let target = Path::new(path);\n            let dir = if target.is_dir() {\n                path.as_str()\n            } else {\n                target\n                    .parent()\n                    .map(|p| p.to_str().unwrap_or(\"/\"))\n                    .unwrap_or(\"/\")\n            };\n            let _ = Command::new(\"xdg-open\").arg(dir).status();\n        }\n    }\n\n    Ok(())\n}\n\nfn copy_with_command(program: &str, args: &[&str], text: &str) -> AppResult<()> {\n    let mut child = Command::new(program)\n        .args(args)\n        .stdin(Stdio::piped())\n        .spawn()\n        .map_err(|e| format!(\"Failed to run {program}: {e}\"))?;\n\n    if let Some(mut stdin) = child.stdin.take() {\n        stdin\n            .write_all(text.as_bytes())\n            .map_err(|e| format!(\"Failed to write to clipboard: {e}\"))?;\n    } else {\n        return Err(\"Cannot open clipboard input stream.\".to_string());\n    }\n\n    let status = child\n        .wait()\n        .map_err(|e| format!(\"Failed to wait for {program}: {e}\"))?;\n\n    if status.success() {\n        Ok(())\n    } else {\n        Err(format!(\"{program} execution failed.\"))\n    }\n}\n\n#[cfg(target_os = \"macos\")]\nfn copy_text_to_clipboard(text: &str) -> AppResult<()> {\n    copy_with_command(\"pbcopy\", &[], text)\n}\n\n#[cfg(target_os = \"windows\")]\nfn copy_text_to_clipboard(text: &str) -> AppResult<()> {\n    copy_with_command(\"cmd\", &[\"/C\", \"clip\"], text)\n}\n\n#[cfg(all(unix, not(target_os = \"macos\")))]\nfn copy_text_to_clipboard(text: &str) -> AppResult<()> {\n    let mut last_error = None;\n\n    match copy_with_command(\"wl-copy\", &[], text) {\n        Ok(()) => return Ok(()),\n        Err(err) => last_error = Some(err),\n    }\n    match copy_with_command(\"xclip\", &[\"-selection\", \"clipboard\"], text) {\n        Ok(()) => return Ok(()),\n        Err(err) => last_error = Some(err),\n    }\n    match copy_with_command(\"xsel\", &[\"--clipboard\", \"--input\"], text) {\n        Ok(()) => return Ok(()),\n        Err(err) => last_error = Some(err),\n    }\n\n    Err(last_error.unwrap_or_else(|| {\n        \"No supported clipboard tool found. Please install wl-copy, xclip, or xsel.\".to_string()\n    }))\n}\n\n#[tauri::command]\nasync fn open_with(path: String) -> AppResult<()> {\n    tauri::async_runtime::spawn_blocking(move || reveal_in_finder_impl(vec![path]))\n        .await\n        .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nasync fn reveal_in_finder(paths: Vec<String>) -> AppResult<()> {\n    tauri::async_runtime::spawn_blocking(move || reveal_in_finder_impl(paths))\n        .await\n        .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nfn copy_paths(paths: Vec<String>) -> AppResult<()> {\n    copy_text_to_clipboard(&paths.join(\"\\n\"))\n}\n\n#[cfg(target_os = \"macos\")]\nfn copy_files_to_clipboard(paths: &[String]) -> AppResult<()> {\n    if paths.is_empty() {\n        return Ok(());\n    }\n    let file_exprs: Vec<String> = paths\n        .iter()\n        .map(|p| {\n            let escaped = p.replace('\\\\', \"\\\\\\\\\").replace('\"', \"\\\\\\\"\");\n            format!(\"POSIX file \\\"{}\\\"\", escaped)\n        })\n        .collect();\n    let script = if file_exprs.len() == 1 {\n        format!(\"set the clipboard to {}\", file_exprs[0])\n    } else {\n        format!(\"set the clipboard to {{{}}}\", file_exprs.join(\", \"))\n    };\n    let status = Command::new(\"osascript\")\n        .arg(\"-e\")\n        .arg(&script)\n        .status()\n        .map_err(|e| e.to_string())?;\n    if !status.success() {\n        return Err(\"Failed to copy files to clipboard\".to_string());\n    }\n    Ok(())\n}\n\n#[cfg(target_os = \"macos\")]\n#[tauri::command]\nfn copy_files(paths: Vec<String>) -> AppResult<()> {\n    copy_files_to_clipboard(&paths)\n}\n\n#[cfg(not(target_os = \"macos\"))]\n#[tauri::command]\nfn copy_files(_paths: Vec<String>) -> AppResult<()> {\n    Err(\"copy_files is only supported on macOS\".to_string())\n}\n\n#[tauri::command]\nasync fn move_to_trash(\n    paths: Vec<String>,\n    app: AppHandle,\n    state: State<'_, AppState>,\n) -> AppResult<()> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        let mut deleted_targets = Vec::new();\n\n        for path in &paths {\n            trash::delete(path).map_err(|e| e.to_string())?;\n            remember_op(&state, \"trash\", Some(path.clone()), None);\n            deleted_targets.push(path.clone());\n        }\n\n        let mut conn = db_connection(&state.db_path)?;\n        let _ = delete_paths(&mut conn, &deleted_targets)?;\n        invalidate_search_caches(&state);\n\n        refresh_and_emit_status_counts(&app, &state)?;\n        Ok(())\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nasync fn rename(\n    path: String,\n    new_name: String,\n    app: AppHandle,\n    state: State<'_, AppState>,\n) -> AppResult<EntryDto> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        let validated_name = validate_new_name(&new_name)?;\n        let old_path = PathBuf::from(&path);\n\n        if !old_path.exists() {\n            return Err(\"Source file does not exist.\".to_string());\n        }\n\n        let parent = old_path\n            .parent()\n            .ok_or_else(|| \"Parent directory not found.\".to_string())?;\n\n        let new_path = parent.join(&validated_name);\n        if new_path == old_path {\n            let meta = fs::symlink_metadata(&old_path).ok();\n            return Ok(EntryDto {\n                path: path.clone(),\n                name: old_path\n                    .file_name()\n                    .map(|v| v.to_string_lossy().to_string())\n                    .unwrap_or_else(|| validated_name.clone()),\n                dir: parent.to_string_lossy().to_string(),\n                is_dir: old_path.is_dir(),\n                ext: extension_for(&old_path, old_path.is_dir()),\n                size: meta\n                    .as_ref()\n                    .filter(|m| m.is_file())\n                    .map(|m| m.len() as i64),\n                mtime: meta\n                    .and_then(|m| m.modified().ok())\n                    .and_then(|m| m.duration_since(UNIX_EPOCH).ok())\n                    .map(|d| d.as_secs() as i64),\n            });\n        }\n\n        if new_path.exists() {\n            return Err(\"A file/folder with the same name already exists.\".to_string());\n        }\n\n        let original_is_dir = old_path.is_dir();\n        fs::rename(&old_path, &new_path).map_err(|e| e.to_string())?;\n\n        let mut conn = db_connection(&state.db_path)?;\n        let _ = delete_paths(&mut conn, &[path.clone()])?;\n\n        if original_is_dir {\n            let rows =\n                collect_rows_recursive(&new_path, &state.path_ignores, &state.path_ignore_patterns);\n            for chunk in rows.chunks(BATCH_SIZE) {\n                let _ = upsert_rows(&mut conn, chunk)?;\n            }\n        } else {\n            let row = index_row_from_path(&new_path)\n                .ok_or_else(|| \"Cannot read renamed file info.\".to_string())?;\n            let _ = upsert_rows(&mut conn, &[row])?;\n        }\n\n        invalidate_search_caches(&state);\n\n        remember_op(\n            &state,\n            \"rename\",\n            Some(old_path.to_string_lossy().to_string()),\n            Some(new_path.to_string_lossy().to_string()),\n        );\n\n        refresh_and_emit_status_counts(&app, &state)?;\n\n        let new_meta = fs::symlink_metadata(&new_path).ok();\n        Ok(EntryDto {\n            path: new_path.to_string_lossy().to_string(),\n            name: validated_name,\n            dir: parent.to_string_lossy().to_string(),\n            is_dir: original_is_dir,\n            ext: extension_for(&new_path, original_is_dir),\n            size: new_meta\n                .as_ref()\n                .filter(|m| m.is_file())\n                .map(|m| m.len() as i64),\n            mtime: new_meta\n                .and_then(|m| m.modified().ok())\n                .and_then(|m| m.duration_since(UNIX_EPOCH).ok())\n                .map(|d| d.as_secs() as i64),\n        })\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nasync fn fd_search(\n    query: String,\n    limit: Option<u32>,\n    offset: Option<u32>,\n    sort_by: Option<String>,\n    sort_dir: Option<String>,\n    state: State<'_, AppState>,\n) -> AppResult<FdSearchResultDto> {\n    let state = state.inner().clone();\n    tauri::async_runtime::spawn_blocking(move || {\n        let query = query.trim().to_string();\n        let limit = limit.unwrap_or(500).clamp(1, 5000) as usize;\n        let offset = offset.unwrap_or(0) as usize;\n        let sort_by = sort_by.unwrap_or_else(|| \"name\".to_string());\n        let sort_dir = sort_dir.unwrap_or_else(|| \"asc\".to_string());\n        let (runtime_ignored_roots, runtime_ignored_patterns) =\n            cached_effective_ignore_rules(&state);\n        let ignore_fingerprint =\n            ignore_rules_fingerprint(&runtime_ignored_roots, &runtime_ignored_patterns);\n\n        if query.is_empty() {\n            return Ok(FdSearchResultDto {\n                entries: Vec::new(),\n                total: 0,\n                timed_out: false,\n            });\n        }\n\n        {\n            let cache = state.fd_search_cache.lock();\n            if let Some(cached) = cache.as_ref() {\n                let cache_hit = cached.query == query\n                    && cached.sort_by == sort_by\n                    && cached.sort_dir == sort_dir\n                    && cached.ignore_fingerprint == ignore_fingerprint;\n                if cache_hit {\n                    let total = cached.entries.len() as u64;\n                    let end = (offset + limit).min(cached.entries.len());\n                    let page = if offset < cached.entries.len() {\n                        cached.entries[offset..end].to_vec()\n                    } else {\n                        Vec::new()\n                    };\n                    return Ok(FdSearchResultDto {\n                        entries: page,\n                        total,\n                        timed_out: false,\n                    });\n                }\n            }\n        }\n\n        let result = fd_search::run_fd_search(\n            &state.scan_root,\n            &runtime_ignored_roots,\n            &runtime_ignored_patterns,\n            &query,\n            &sort_by,\n            &sort_dir,\n        );\n        let total = result.entries.len() as u64;\n        let end = (offset + limit).min(result.entries.len());\n        let page = if offset < result.entries.len() {\n            result.entries[offset..end].to_vec()\n        } else {\n            Vec::new()\n        };\n\n        {\n            let mut cache = state.fd_search_cache.lock();\n            *cache = Some(FdSearchCache {\n                query: query.clone(),\n                sort_by: sort_by.clone(),\n                sort_dir: sort_dir.clone(),\n                ignore_fingerprint,\n                entries: result.entries,\n            });\n        }\n\n        Ok(FdSearchResultDto {\n            entries: page,\n            total,\n            timed_out: result.timed_out,\n        })\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[tauri::command]\nfn frontend_log(msg: String) {\n    eprintln!(\"{msg}\");\n}\n\n#[tauri::command]\nfn mark_frontend_ready(state: State<'_, AppState>) {\n    state.frontend_ready.store(true, AtomicOrdering::Release);\n    if cfg!(debug_assertions) {\n        eprintln!(\"[startup] frontend_ready=true\");\n    }\n}\n\n#[tauri::command]\nfn get_platform() -> String {\n    if cfg!(target_os = \"windows\") {\n        \"windows\".to_string()\n    } else if cfg!(target_os = \"macos\") {\n        \"macos\".to_string()\n    } else {\n        \"linux\".to_string()\n    }\n}\n\n#[cfg(target_os = \"windows\")]\n#[tauri::command]\nasync fn show_context_menu(\n    paths: Vec<String>,\n    x: f64,\n    y: f64,\n    _single_selection: bool,\n    app: AppHandle,\n) -> AppResult<()> {\n    let window = app\n        .get_webview_window(\"main\")\n        .ok_or_else(|| \"Main window not found\".to_string())?;\n\n    let scale = window.scale_factor().map_err(|e| e.to_string())?;\n    let win_pos = window.inner_position().map_err(|e| e.to_string())?;\n    let screen_x = win_pos.x + (x * scale) as i32;\n    let screen_y = win_pos.y + (y * scale) as i32;\n\n    let hwnd_raw = window.hwnd().map_err(|e| e.to_string())?.0 as isize;\n\n    // TrackPopupMenu must run on the thread that owns the HWND (main UI thread).\n    // Use a channel to relay the result back to the async context.\n    let (tx, rx) = std::sync::mpsc::sync_channel::<Result<(), String>>(1);\n\n    app.run_on_main_thread(move || {\n        let result = win::context_menu::show(hwnd_raw, &paths, screen_x, screen_y);\n        let _ = tx.send(result);\n    })\n    .map_err(|e| e.to_string())?;\n\n    tauri::async_runtime::spawn_blocking(move || {\n        rx.recv().map_err(|e| format!(\"context menu channel: {e}\"))?\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[cfg(target_os = \"macos\")]\n#[tauri::command]\nasync fn show_context_menu(\n    _paths: Vec<String>,\n    x: f64,\n    y: f64,\n    single_selection: bool,\n    app: AppHandle,\n) -> AppResult<()> {\n    use tauri::menu::{IsMenuItem, Menu, MenuItem, PredefinedMenuItem};\n\n    let window = app\n        .get_webview_window(\"main\")\n        .ok_or_else(|| \"Main window not found\".to_string())?;\n\n    let (tx, rx) = std::sync::mpsc::sync_channel::<Result<(), String>>(1);\n\n    let app_clone = app.clone();\n    app.run_on_main_thread(move || {\n        let app = app_clone;\n        let result = (|| -> Result<(), tauri::Error> {\n            let open = MenuItem::with_id(&app, \"ctx_open\", \"Open\", true, None::<&str>)?;\n            let quick_look =\n                MenuItem::with_id(&app, \"ctx_quick_look\", \"Quick Look\", true, None::<&str>)?;\n            let open_with =\n                MenuItem::with_id(&app, \"ctx_open_with\", \"Open With...\", true, None::<&str>)?;\n            let sep1 = PredefinedMenuItem::separator(&app)?;\n            let reveal = MenuItem::with_id(\n                &app,\n                \"ctx_reveal\",\n                \"Reveal in Finder\",\n                true,\n                None::<&str>,\n            )?;\n            let sep2 = PredefinedMenuItem::separator(&app)?;\n            let copy_files =\n                MenuItem::with_id(&app, \"ctx_copy_files\", \"Copy\", true, None::<&str>)?;\n            let copy_path =\n                MenuItem::with_id(&app, \"ctx_copy_path\", \"Copy Path\", true, None::<&str>)?;\n            let sep3 = PredefinedMenuItem::separator(&app)?;\n            let trash = MenuItem::with_id(\n                &app,\n                \"ctx_trash\",\n                \"Move to Trash\",\n                true,\n                None::<&str>,\n            )?;\n            let rename =\n                MenuItem::with_id(&app, \"ctx_rename\", \"Rename\", true, None::<&str>)?;\n\n            let mut items: Vec<&dyn IsMenuItem<tauri::Wry>> = vec![\n                &open, &quick_look, &open_with, &sep1, &reveal, &sep2, &copy_files, &copy_path, &sep3, &trash,\n            ];\n            if single_selection {\n                items.push(&rename);\n            }\n\n            let menu = Menu::with_items(&app, &items)?;\n            // Position is window-relative logical pixels, matching clientX/clientY.\n            window.popup_menu_at(&menu, tauri::LogicalPosition::new(x, y))?;\n            Ok(())\n        })();\n        let _ = tx.send(result.map_err(|e| e.to_string()));\n    })\n    .map_err(|e| e.to_string())?;\n\n    tauri::async_runtime::spawn_blocking(move || {\n        rx.recv().map_err(|e| format!(\"context menu channel: {e}\"))?\n    })\n    .await\n    .map_err(|e| e.to_string())?\n}\n\n#[cfg(not(any(target_os = \"windows\", target_os = \"macos\")))]\n#[tauri::command]\nasync fn show_context_menu(\n    _paths: Vec<String>,\n    _x: f64,\n    _y: f64,\n    _single_selection: bool,\n    _app: AppHandle,\n) -> AppResult<()> {\n    Err(\"Native context menu is only supported on Windows and macOS\".to_string())\n}\n\n#[tauri::command]\nasync fn set_native_theme(theme: String, app: AppHandle) -> AppResult<()> {\n    let window = app\n        .get_webview_window(\"main\")\n        .ok_or_else(|| \"Main window not found\".to_string())?;\n    let t = if theme == \"light\" {\n        tauri::Theme::Light\n    } else {\n        tauri::Theme::Dark\n    };\n    window.set_theme(Some(t)).map_err(|e| e.to_string())\n}\n\n#[tauri::command]\nasync fn get_file_icon(\n    path: Option<String>,\n    ext: String,\n    state: State<'_, AppState>,\n) -> AppResult<Vec<u8>> {\n    let state = state.inner().clone();\n    Ok(tauri::async_runtime::spawn_blocking(move || {\n        let ext_lower = if ext.trim().is_empty() {\n            \"__default__\".to_string()\n        } else {\n            ext.to_lowercase()\n        };\n\n        #[cfg(target_os = \"windows\")]\n        let cache_key = {\n            if is_per_file_icon_ext(&ext_lower) {\n                path.as_deref().unwrap_or(&ext_lower).to_string()\n            } else {\n                ext_lower.clone()\n            }\n        };\n        #[cfg(not(target_os = \"windows\"))]\n        let cache_key = ext_lower.clone();\n\n        if let Some(cached) = state.icon_cache.lock().get(&cache_key).cloned() {\n            return cached;\n        }\n\n        #[cfg(target_os = \"windows\")]\n        let icon = {\n            let from_path = path\n                .as_deref()\n                .filter(|p| !p.is_empty())\n                .and_then(win::icon::load_icon_png);\n            from_path.or_else(|| load_system_icon_png(&ext_lower))\n        };\n        #[cfg(not(target_os = \"windows\"))]\n        let icon = {\n            let _ = path;\n            load_system_icon_png(&ext_lower)\n        };\n\n        let icon = icon.unwrap_or_default();\n        state.icon_cache.lock().insert(cache_key, icon.clone());\n        icon\n    })\n    .await\n    .unwrap_or_default())\n}\n\nfn default_bench_cases() -> Vec<BenchCase> {\n    vec![\n        BenchCase {\n            id: \"TC01_exact_name\",\n            query: \"report_00042\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC02_prefix_name\",\n            query: \"report_00\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 10,\n        },\n        BenchCase {\n            id: \"TC03_contains_name\",\n            query: \"invoice\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC04_ext_md\",\n            query: \"*.md\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC05_path_glob_png\",\n            query: \"Desktop/ *.png\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC06_path_term\",\n            query: \"Projects/rust\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC07_path_ext_rs\",\n            query: \"Projects/ *.rs\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 1,\n        },\n        BenchCase {\n            id: \"TC08_no_match\",\n            query: \"zzzz_not_exists_12345\",\n            sort_by: \"name\",\n            sort_dir: \"asc\",\n            limit: 300,\n            offset: 0,\n            expected_min_results: 0,\n        },\n    ]\n}\n\nfn bench_iterations() -> u32 {\n    std::env::var(\"EVERYTHING_BENCH_ITERATIONS\")\n        .ok()\n        .and_then(|v| v.parse::<u32>().ok())\n        .map(|v| v.clamp(1, 50))\n        .unwrap_or(5)\n}\n\nfn bench_wait_timeout() -> Duration {\n    let seconds = std::env::var(\"EVERYTHING_BENCH_WAIT_SEC\")\n        .ok()\n        .and_then(|v| v.parse::<u64>().ok())\n        .map(|v| v.clamp(10, 7200))\n        .unwrap_or(1800);\n    Duration::from_secs(seconds)\n}\n\nfn bench_run_label() -> String {\n    std::env::var(\"EVERYTHING_BENCH_RUN_LABEL\")\n        .ok()\n        .filter(|v| !v.trim().is_empty())\n        .unwrap_or_else(|| format!(\"run-{}\", now_epoch()))\n}\n\nfn bench_output_path(db_path: &Path, run_label: &str) -> PathBuf {\n    std::env::var(\"EVERYTHING_BENCH_OUTPUT\")\n        .ok()\n        .filter(|v| !v.trim().is_empty())\n        .map(PathBuf::from)\n        .unwrap_or_else(|| db_path.with_file_name(format!(\"bench-report-{run_label}.json\")))\n}\n\nfn write_bench_report(path: &Path, report: &BenchReport) -> AppResult<()> {\n    let json = serde_json::to_string_pretty(report).map_err(|e| e.to_string())?;\n    fs::write(path, json).map_err(|e| e.to_string())\n}\n\nfn start_bench_runner(app_handle: AppHandle, state: AppState) {\n    std::thread::spawn(move || {\n        let run_label = bench_run_label();\n        let output_path = bench_output_path(&state.db_path, &run_label);\n        let iterations = bench_iterations();\n        let wait_timeout = bench_wait_timeout();\n        let started_at = now_epoch();\n\n        perf_log(format!(\n            \"bench_start run_label={} output={} iterations={} wait_timeout_s={}\",\n            run_label,\n            output_path.to_string_lossy(),\n            iterations,\n            wait_timeout.as_secs(),\n        ));\n\n        let wait_started = Instant::now();\n        let mut saw_indexing = false;\n        let index_snapshot: IndexStatus;\n        loop {\n            let snapshot = state.status.lock().clone();\n            let active = state.indexing_active.load(AtomicOrdering::Acquire)\n                || matches!(snapshot.state, IndexState::Indexing);\n\n            if active {\n                saw_indexing = true;\n            }\n\n            if state.db_ready.load(AtomicOrdering::Acquire) && saw_indexing && !active {\n                index_snapshot = snapshot;\n                break;\n            }\n\n            if wait_started.elapsed() >= wait_timeout {\n                let report = BenchReport {\n                    run_label: run_label.clone(),\n                    started_at,\n                    completed_at: now_epoch(),\n                    home_dir: state.home_dir.to_string_lossy().to_string(),\n                    db_path: state.db_path.to_string_lossy().to_string(),\n                    index_wait_ms: wait_started.elapsed().as_millis(),\n                    index_scanned: snapshot.scanned,\n                    index_indexed: snapshot.indexed,\n                    index_entries_count: snapshot.entries_count,\n                    index_permission_errors: snapshot.permission_errors,\n                    index_message: Some(\"Timed out waiting for index ready\".to_string()),\n                    search_iterations: iterations,\n                    search_results: Vec::new(),\n                };\n                let _ = write_bench_report(&output_path, &report);\n                perf_log(format!(\n                    \"bench_timeout run_label={} waited_ms={}\",\n                    run_label,\n                    wait_started.elapsed().as_millis()\n                ));\n                if env_truthy(\"EVERYTHING_BENCH_EXIT\") {\n                    app_handle.exit(2);\n                }\n                return;\n            }\n\n            std::thread::sleep(Duration::from_millis(200));\n        }\n\n        let index_wait_ms = wait_started.elapsed().as_millis();\n        perf_log(format!(\n            \"bench_index_ready run_label={} waited_ms={} scanned={} indexed={} entries={} permission_errors={}\",\n            run_label,\n            index_wait_ms,\n            index_snapshot.scanned,\n            index_snapshot.indexed,\n            index_snapshot.entries_count,\n            index_snapshot.permission_errors,\n        ));\n\n        let mut search_results = Vec::new();\n        for case in default_bench_cases() {\n            let mut elapsed_sum = 0.0f64;\n            let mut success_count = 0u32;\n            let mut result_count = 0usize;\n            let mut mode = String::new();\n            let mut top_results = Vec::new();\n            let mut case_error = None;\n\n            for iter in 1..=iterations {\n                let started = Instant::now();\n                match execute_search(\n                    &state,\n                    case.query.to_string(),\n                    Some(case.limit),\n                    Some(case.offset),\n                    Some(case.sort_by.to_string()),\n                    Some(case.sort_dir.to_string()),\n                ) {\n                    Ok(execution) => {\n                        let elapsed_ms = started.elapsed().as_secs_f64() * 1000.0;\n                        elapsed_sum += elapsed_ms;\n                        success_count += 1;\n                        result_count = execution.results.len();\n                        mode = execution.mode_label;\n                        top_results = execution\n                            .results\n                            .iter()\n                            .take(5)\n                            .map(|entry| entry.path.clone())\n                            .collect();\n\n                        perf_log(format!(\n                            \"bench_query run_label={} case={} iter={}/{} query={:?} mode={} results={} elapsed_ms={:.3}\",\n                            run_label,\n                            case.id,\n                            iter,\n                            iterations,\n                            case.query,\n                            mode,\n                            result_count,\n                            elapsed_ms\n                        ));\n                    }\n                    Err(err) => {\n                        case_error = Some(err);\n                        break;\n                    }\n                }\n            }\n\n            let elapsed_ms = if success_count > 0 {\n                elapsed_sum / success_count as f64\n            } else {\n                0.0\n            };\n            let passed = case_error.is_none() && result_count >= case.expected_min_results;\n\n            search_results.push(BenchCaseResult {\n                id: case.id.to_string(),\n                query: case.query.to_string(),\n                mode,\n                sort_by: case.sort_by.to_string(),\n                sort_dir: case.sort_dir.to_string(),\n                limit: case.limit,\n                offset: case.offset,\n                elapsed_ms,\n                result_count,\n                expected_min_results: case.expected_min_results,\n                passed,\n                top_results,\n                error: case_error,\n            });\n        }\n\n        let report = BenchReport {\n            run_label: run_label.clone(),\n            started_at,\n            completed_at: now_epoch(),\n            home_dir: state.home_dir.to_string_lossy().to_string(),\n            db_path: state.db_path.to_string_lossy().to_string(),\n            index_wait_ms,\n            index_scanned: index_snapshot.scanned,\n            index_indexed: index_snapshot.indexed,\n            index_entries_count: index_snapshot.entries_count,\n            index_permission_errors: index_snapshot.permission_errors,\n            index_message: index_snapshot.message.clone(),\n            search_iterations: iterations,\n            search_results,\n        };\n\n        match write_bench_report(&output_path, &report) {\n            Ok(()) => perf_log(format!(\n                \"bench_report_written run_label={} path={}\",\n                run_label,\n                output_path.to_string_lossy()\n            )),\n            Err(err) => perf_log(format!(\n                \"bench_report_write_error run_label={} path={} err={}\",\n                run_label,\n                output_path.to_string_lossy(),\n                err\n            )),\n        }\n\n        if env_truthy(\"EVERYTHING_BENCH_EXIT\") {\n            app_handle.exit(0);\n        }\n    });\n}\n\n#[cfg(target_os = \"macos\")]\nfn register_global_shortcut(app: &AppHandle) -> AppResult<()> {\n    let shortcut = Shortcut::new(Some(Modifiers::SUPER | Modifiers::SHIFT), Code::Space);\n\n    app.global_shortcut()\n        .on_shortcut(shortcut, move |app_handle, _, _| {\n            if let Some(window) = app_handle.get_webview_window(\"main\") {\n                let _ = window.show();\n                let _ = window.unminimize();\n                let _ = window.set_focus();\n            }\n            let _ = app_handle.emit(\"focus_search\", ());\n        })\n        .map_err(|e| format!(\"Failed to register global shortcut: {e}\"))\n}\n\n#[cfg(not(target_os = \"macos\"))]\nfn register_global_shortcut(_app: &AppHandle) -> AppResult<()> {\n    Ok(())\n}\n\nfn setup_app(app: &mut tauri::App) -> AppResult<()> {\n    let setup_started = std::time::Instant::now();\n    eprintln!(\"[startup] setup_app() entered\");\n    let bench_mode = bench_mode_enabled();\n\n    #[cfg(target_os = \"macos\")]\n    if let Some(window) = app.get_webview_window(\"main\") {\n        use tauri::window::Color;\n        let is_dark = window\n            .theme()\n            .map(|t| t == tauri::Theme::Dark)\n            .unwrap_or(false);\n        let bg = if is_dark {\n            Color(0x1f, 0x1f, 0x1f, 0xff)\n        } else {\n            Color(0xf4, 0xf5, 0xf7, 0xff)\n        };\n        let _ = window.set_background_color(Some(bg));\n        let _ = window.show();\n    }\n\n    #[cfg(target_os = \"windows\")]\n    if let Some(window) = app.get_webview_window(\"main\") {\n        eprintln!(\"[startup +{}ms] windows setup: before window.show()\", startup_elapsed_ms());\n        use tauri::window::Color;\n        let is_dark = window.theme().map(|t| t == tauri::Theme::Dark).unwrap_or(false);\n        let bg = if is_dark {\n            Color(0x1f, 0x1f, 0x1f, 0xff)\n        } else {\n            Color(0xf4, 0xf5, 0xf7, 0xff)\n        };\n        let _ = window.set_background_color(Some(bg));\n        if let Err(e) = window.set_decorations(false) {\n            eprintln!(\n                \"[startup +{}ms] windows setup: set_decorations(false) failed: {}\",\n                startup_elapsed_ms(),\n                e\n            );\n        }\n        let _ = window.show();\n        eprintln!(\"[startup +{}ms] windows setup: window.show() returned\", startup_elapsed_ms());\n    }\n\n    let app_data_dir = app\n        .path()\n        .app_data_dir()\n        .map_err(|e| format!(\"Failed to get app data dir: {e}\"))?;\n    fs::create_dir_all(&app_data_dir).map_err(|e| e.to_string())?;\n\n    let db_path = app_data_dir.join(\"index.db\");\n    let home_dir = PathBuf::from(\n        std::env::var(\"HOME\")\n            .or_else(|_| std::env::var(\"USERPROFILE\"))\n            .unwrap_or_else(|_| if cfg!(windows) { \"C:\\\\\".to_string() } else { \"/\".to_string() }),\n    );\n    let scan_root = if cfg!(windows) {\n        PathBuf::from(\"C:\\\\\")\n    } else {\n        home_dir.clone()\n    };\n    let cwd = std::env::current_dir().unwrap_or_else(|_| home_dir.clone());\n    eprintln!(\"[startup] +{}ms loading pathignore rules...\", setup_started.elapsed().as_millis());\n    let (mut path_ignores, path_ignore_patterns) = load_pathignore_rules(&home_dir, &cwd);\n    if !path_ignores.iter().any(|r| r == &app_data_dir) {\n        path_ignores.push(app_data_dir.clone());\n    }\n    for root in load_gitignore_roots(&home_dir, &cwd) {\n        if !path_ignores.iter().any(|r| r == &root) {\n            path_ignores.push(root);\n        }\n    }\n    eprintln!(\"[startup] +{}ms pathignore done\", setup_started.elapsed().as_millis());\n\n    let gitignore = Arc::new(gitignore_filter::LazyGitignoreFilter::new(home_dir.clone()));\n\n    let state = AppState {\n        db_path,\n        home_dir,\n        scan_root,\n        cwd,\n        path_ignores: Arc::new(path_ignores),\n        path_ignore_patterns: Arc::new(path_ignore_patterns),\n        db_ready: Arc::new(AtomicBool::new(false)),\n        indexing_active: Arc::new(AtomicBool::new(false)),\n        status: Arc::new(Mutex::new(IndexStatus::default())),\n        recent_ops: Arc::new(Mutex::new(Vec::new())),\n        icon_cache: Arc::new(Mutex::new(HashMap::new())),\n        fd_search_cache: Arc::new(Mutex::new(None)),\n        negative_name_cache: Arc::new(Mutex::new(HashMap::new())),\n        ignore_cache: Arc::new(Mutex::new(None)),\n        gitignore,\n        mem_index: Arc::new(RwLock::new(None)),\n        watcher_stop: Arc::new(AtomicBool::new(false)),\n        watcher_active: Arc::new(AtomicBool::new(false)),\n        frontend_ready: Arc::new(AtomicBool::new(false)),\n    };\n\n    eprintln!(\"[startup] +{}ms AppState created\", setup_started.elapsed().as_millis());\n    app.manage(state.clone());\n    if !bench_mode {\n        register_global_shortcut(&app.handle())?;\n    }\n    // Context menu item IDs use the \"ctx_\" prefix by convention.\n    // All matching IDs are forwarded as \"context_menu_action\" events to the frontend.\n    #[cfg(target_os = \"macos\")]\n    {\n        app.handle().on_menu_event(|app, event| {\n            let action = match event.id().as_ref() {\n                \"ctx_open\" => \"open\",\n                \"ctx_quick_look\" => \"quick_look\",\n                \"ctx_open_with\" => \"open_with\",\n                \"ctx_reveal\" => \"reveal\",\n                \"ctx_copy_files\" => \"copy_files\",\n                \"ctx_copy_path\" => \"copy_path\",\n                \"ctx_trash\" => \"trash\",\n                \"ctx_rename\" => \"rename\",\n                _ => return,\n            };\n            let _ = app.emit(\"context_menu_action\", action);\n        });\n    }\n    eprintln!(\"[startup] +{}ms global shortcut registered\", setup_started.elapsed().as_millis());\n    if bench_mode {\n        if let Some(window) = app.get_webview_window(\"main\") {\n            let _ = window.hide();\n        }\n    }\n\n    eprintln!(\"[startup] +{}ms setup_app() done, spawning init thread\", setup_started.elapsed().as_millis());\n\n    let app_handle = app.handle().clone();\n    std::thread::spawn(move || {\n        let thread_started = std::time::Instant::now();\n        eprintln!(\"[startup/thread] init thread started\");\n\n        eprintln!(\"[startup/thread] +{}ms calling init_db...\", thread_started.elapsed().as_millis());\n        if let Err(err) = init_db(&state.db_path) {\n            set_state(&state, IndexState::Error, Some(err.clone()));\n            emit_index_state(&app_handle, \"Error\", Some(err));\n            return;\n        }\n        eprintln!(\"[startup/thread] +{}ms init_db done\", thread_started.elapsed().as_millis());\n\n        state.db_ready.store(true, AtomicOrdering::Release);\n        eprintln!(\"[startup/thread] +{}ms db_ready=true -- launching indexing immediately\", thread_started.elapsed().as_millis());\n\n        // Deferred housekeeping -- purge + status counts run in background\n        {\n            let hk_app = app_handle.clone();\n            let hk_state = state.clone();\n            std::thread::spawn(move || {\n                // Brief pause so indexing thread can start first\n                std::thread::sleep(std::time::Duration::from_millis(500));\n                let hk_started = std::time::Instant::now();\n                let _ = refresh_and_emit_status_counts(&hk_app, &hk_state);\n                eprintln!(\"[startup/housekeeping] refresh_and_emit_status_counts done in {}ms\", hk_started.elapsed().as_millis());\n                // Wait for frontend readiness so initial paint and first input are not contended by purge I/O.\n                const FRONTEND_READY_TIMEOUT: Duration = Duration::from_secs(180);\n                const POST_READY_GRACE: Duration = Duration::from_secs(2);\n                let wait_started = std::time::Instant::now();\n                while !hk_state.frontend_ready.load(AtomicOrdering::Acquire)\n                    && wait_started.elapsed() < FRONTEND_READY_TIMEOUT\n                {\n                    std::thread::sleep(Duration::from_millis(50));\n                }\n                if hk_state.frontend_ready.load(AtomicOrdering::Acquire) {\n                    eprintln!(\n                        \"[startup/housekeeping] frontend_ready observed after {}ms; purging in {}ms\",\n                        wait_started.elapsed().as_millis(),\n                        POST_READY_GRACE.as_millis()\n                    );\n                } else {\n                    eprintln!(\n                        \"[startup/housekeeping] frontend_ready wait timed out after {}ms; proceeding with purge\",\n                        FRONTEND_READY_TIMEOUT.as_millis()\n                    );\n                }\n                std::thread::sleep(POST_READY_GRACE);\n                let purge_started = std::time::Instant::now();\n                if let Err(err) = purge_ignored_entries(&hk_state.db_path, &hk_state.path_ignores) {\n                    eprintln!(\"[startup/housekeeping] purge_ignored_entries failed: {err}\");\n                } else {\n                    eprintln!(\n                        \"[startup/housekeeping] purge_ignored_entries done in {}ms\",\n                        purge_started.elapsed().as_millis()\n                    );\n                }\n                eprintln!(\"[startup/housekeeping] all done in {}ms\", hk_started.elapsed().as_millis());\n            });\n        }\n\n        #[cfg(target_os = \"macos\")]\n        {\n            if bench_mode {\n                let _ = start_full_index_worker(app_handle.clone(), state.clone());\n            } else {\n                let (stored_event_id, index_complete) = db_connection(&state.db_path)\n                    .ok()\n                    .map(|c| {\n                        let eid = get_meta(&c, \"last_event_id\")\n                            .and_then(|v| v.parse::<u64>().ok());\n                        let complete = get_meta(&c, \"index_complete\")\n                            .map(|v| v == \"1\")\n                            .unwrap_or(false);\n                        (eid, complete)\n                    })\n                    .unwrap_or((None, false));\n\n                if stored_event_id.is_some() && index_complete {\n                    // Conditional startup: try watcher replay first, skip full scan if OK\n                    start_fsevent_watcher_worker(\n                        app_handle.clone(),\n                        state.clone(),\n                        stored_event_id,\n                        true,\n                    );\n                } else {\n                    if !index_complete {\n                        eprintln!(\"[mac] index incomplete; starting full index\");\n                    }\n                    let _ = start_full_index_worker(app_handle.clone(), state.clone());\n                    start_fsevent_watcher_worker(app_handle.clone(), state.clone(), None, false);\n                }\n            }\n        }\n\n        #[cfg(target_os = \"windows\")]\n        {\n            win::start_windows_indexing(app_handle.clone(), state.clone());\n        }\n\n        #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n        {\n            let _ = start_full_index_worker(app_handle.clone(), state.clone());\n        }\n\n        if bench_mode {\n            start_bench_runner(app_handle.clone(), state.clone());\n        }\n\n        #[cfg(not(target_os = \"windows\"))]\n        if !bench_mode {\n            let icon_cache = state.icon_cache.clone();\n            std::thread::spawn(move || {\n                let exts = [\n                    \"txt\", \"pdf\", \"png\", \"jpg\", \"md\", \"json\", \"swift\", \"rs\", \"js\", \"ts\", \"html\",\n                    \"css\", \"py\", \"zip\", \"dmg\", \"app\", \"doc\", \"xls\", \"ppt\", \"mov\",\n                ];\n                for ext in &exts {\n                    let key = ext.to_string();\n                    if icon_cache.lock().contains_key(&key) {\n                        continue;\n                    }\n                    if let Some(icon) = load_system_icon_png(ext) {\n                        icon_cache.lock().insert(key, icon);\n                    }\n                }\n            });\n        }\n    });\n\n    Ok(())\n}\n\n#[cfg_attr(mobile, tauri::mobile_entry_point)]\npub fn run() {\n    let _ = STARTUP_T0.set(Instant::now());\n    eprintln!(\"[startup +{}ms] run() entered\", startup_elapsed_ms());\n    #[cfg(target_os = \"windows\")]\n    if cfg!(debug_assertions) {\n        // Safety: called at program start before any threads are spawned.\n        // Will require `unsafe` block when migrating to Rust edition 2024.\n        std::env::set_var(\n            \"WEBVIEW2_ADDITIONAL_BROWSER_ARGUMENTS\",\n            \"--no-proxy-server --disable-http-cache --disk-cache-size=1 --media-cache-size=1\",\n        );\n        eprintln!(\n            \"[startup +{}ms] set REDACTED --disable-http-cache --disk-cache-size=1 --media-cache-size=1\",\n            startup_elapsed_ms()\n        );\n    }\n    let mut builder = tauri::Builder::default()\n        .plugin(tauri_plugin_decorum::init())\n        .plugin(tauri_plugin_drag::init())\n        .plugin(tauri_plugin_global_shortcut::Builder::new().build());\n\n    if !cfg!(debug_assertions) {\n        builder = builder.plugin(tauri_plugin_window_state::Builder::default().build());\n    } else {\n        eprintln!(\n            \"[startup +{}ms] debug mode: window-state plugin disabled for startup A/B test\",\n            startup_elapsed_ms()\n        );\n    }\n\n    builder\n        .on_page_load(|window, payload| {\n            eprintln!(\n                \"[startup/page +{}ms] on_page_load label={} event={:?} url={}\",\n                startup_elapsed_ms(),\n                window.label(),\n                payload.event(),\n                payload.url()\n            );\n        })\n        .setup(|app| {\n            setup_app(app).map_err(|e| {\n                Box::<dyn std::error::Error>::from(io::Error::new(io::ErrorKind::Other, e))\n            })\n        })\n        .invoke_handler(tauri::generate_handler![\n            get_index_status,\n            get_home_dir,\n            start_full_index,\n            reset_index,\n            search,\n            fd_search,\n            quick_look,\n            open,\n            open_with,\n            reveal_in_finder,\n            copy_paths,\n            copy_files,\n            move_to_trash,\n            rename,\n            get_file_icon,\n            get_platform,\n            show_context_menu,\n            set_native_theme,\n            frontend_log,\n            mark_frontend_ready\n        ])\n        .run(tauri::generate_context!())\n        .expect(\"error while running tauri application\");\n}\n\nfn main() {\n    run();\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::time::{SystemTime, UNIX_EPOCH};\n\n    fn mk_entry(path: &str, name: &str) -> EntryDto {\n        let parent = Path::new(path)\n            .parent()\n            .map(|p| p.to_string_lossy().to_string())\n            .unwrap_or_else(|| \"/\".to_string());\n        EntryDto {\n            path: path.to_string(),\n            name: name.to_string(),\n            dir: parent,\n            is_dir: false,\n            ext: None,\n            size: None,\n            mtime: None,\n        }\n    }\n\n    fn temp_case_dir(case: &str) -> PathBuf {\n        let stamp = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .map(|d| d.as_nanos())\n            .unwrap_or(0);\n        let base = if cfg!(target_os = \"windows\") {\n            std::env::current_dir()\n                .map(|dir| dir.join(\"tmp-test-dirs\"))\n                .unwrap_or_else(|_| std::env::temp_dir())\n        } else {\n            std::env::temp_dir()\n        };\n        base.join(format!(\n            \"everything_{case}_{}_{}\",\n            std::process::id(),\n            stamp\n        ))\n    }\n\n    fn test_state_for(db_path: PathBuf, home_dir: PathBuf, cwd: PathBuf) -> AppState {\n        AppState {\n            db_path,\n            home_dir: home_dir.clone(),\n            scan_root: home_dir.clone(),\n            cwd,\n            path_ignores: Arc::new(Vec::new()),\n            path_ignore_patterns: Arc::new(Vec::new()),\n            db_ready: Arc::new(AtomicBool::new(true)),\n            indexing_active: Arc::new(AtomicBool::new(false)),\n            status: Arc::new(Mutex::new(IndexStatus::default())),\n            recent_ops: Arc::new(Mutex::new(Vec::new())),\n            icon_cache: Arc::new(Mutex::new(HashMap::new())),\n            fd_search_cache: Arc::new(Mutex::new(None)),\n            negative_name_cache: Arc::new(Mutex::new(HashMap::new())),\n            ignore_cache: Arc::new(Mutex::new(None)),\n            gitignore: Arc::new(gitignore_filter::LazyGitignoreFilter::new(home_dir.clone())),\n            mem_index: Arc::new(RwLock::new(None)),\n            watcher_stop: Arc::new(AtomicBool::new(false)),\n            watcher_active: Arc::new(AtomicBool::new(false)),\n            frontend_ready: Arc::new(AtomicBool::new(true)),\n        }\n    }\n\n    #[test]\n    fn should_skip_path_for_ignored_descendant() {\n        let ignored = vec![PathBuf::from(\n            \"/Users/al02402336/Library/Developer/Xcode/DerivedData\",\n        )];\n        let target = Path::new(\n            \"REDACTED\",\n        );\n\n        assert!(should_skip_path(target, &ignored, &[]));\n    }\n\n    #[test]\n    fn filter_ignored_entries_removes_pathignore_matches() {\n        let ignored = vec![PathBuf::from(\n            \"/Users/al02402336/Library/Developer/Xcode/DerivedData\",\n        )];\n        let entries = vec![\n            mk_entry(\n                \"REDACTED\",\n                \"-Users-al02402336-a_desktop\",\n            ),\n            mk_entry(\"/Users/al02402336/a_desktop\", \"a_desktop\"),\n        ];\n\n        let filtered = filter_ignored_entries(entries, &ignored, &[]);\n\n        assert_eq!(filtered.len(), 1);\n        assert_eq!(filtered[0].path, \"/Users/al02402336/a_desktop\");\n    }\n\n    #[test]\n    fn should_skip_path_for_glob_any_segment_target() {\n        let patterns = vec![IgnorePattern::AnySegment(\"target\".to_string())];\n\n        assert!(should_skip_path(\n            Path::new(\"/Users/al02402336/work/rust/target\"),\n            &[],\n            &patterns\n        ));\n        assert!(should_skip_path(\n            Path::new(\"/Users/al02402336/work/rust/target/debug/deps/foo.o\"),\n            &[],\n            &patterns\n        ));\n        assert!(!should_skip_path(\n            Path::new(\"/Users/al02402336/work/rust/targets/debug/deps/foo.o\"),\n            &[],\n            &patterns\n        ));\n    }\n\n    #[test]\n    fn relevance_sort_prefers_shallow_exact_match() {\n        let mut entries = vec![\n            mk_entry(\"/Users/al02402336/work/a_desktop\", \"a_desktop\"),\n            mk_entry(\"/Users/al02402336/a_desktop\", \"a_desktop\"),\n            mk_entry(\n                \"/Users/al02402336/Library/Developer/Xcode/DerivedData/-Users-al02402336-a_desktop\",\n                \"-Users-al02402336-a_desktop\",\n            ),\n        ];\n\n        sort_entries_with_relevance(&mut entries, \"a_desktop\", \"name\", \"asc\");\n\n        assert_eq!(entries[0].path, \"/Users/al02402336/a_desktop\");\n    }\n\n    #[test]\n    fn resolved_dir_range_excludes_sibling_with_same_prefix() {\n        let dir_exact = \"/Users/user/Projects\";\n        let dir_prefix = format!(\"{}/\", dir_exact);\n        let dir_prefix_end = format!(\"{}0\", dir_exact);\n\n        let in_scope = |dir: &str| {\n            dir == dir_exact || (dir >= dir_prefix.as_str() && dir < dir_prefix_end.as_str())\n        };\n\n        assert!(in_scope(\"/Users/user/Projects\"));\n        assert!(in_scope(\"/Users/user/Projects/src\"));\n        assert!(in_scope(\"/Users/user/Projects/src/deeper\"));\n\n        assert!(!in_scope(\"/Users/user/Projects-archived\"));\n        assert!(!in_scope(\"/Users/user/Projects.archived\"));\n        assert!(!in_scope(\"/Users/user/Projects_archived\"));\n        assert!(!in_scope(\"/Users/user/Projectz\"));\n    }\n\n    #[test]\n    fn delete_paths_root_clears_all_entries() {\n        let root = temp_case_dir(\"delete_paths_root\");\n        let dir_a = root.join(\"alpha\");\n        let dir_b = root.join(\"beta\").join(\"nested\");\n        fs::create_dir_all(&dir_a).unwrap();\n        fs::create_dir_all(&dir_b).unwrap();\n\n        let db_path = root.join(\"index.db\");\n        init_db(&db_path).unwrap();\n        let mut conn = db_connection(&db_path).unwrap();\n        let now = now_epoch();\n\n        for (path, name, dir, ext) in [\n            (dir_a.join(\"a.txt\"), \"a.txt\", dir_a.clone(), \"txt\"),\n            (dir_b.join(\"b.rs\"), \"b.rs\", dir_b.clone(), \"rs\"),\n        ] {\n            conn.execute(\n                \"INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n                 VALUES(?1, ?2, ?3, 0, ?4, NULL, NULL, ?5, 1)\",\n                params![\n                    path.to_string_lossy().to_string(),\n                    name,\n                    dir.to_string_lossy().to_string(),\n                    ext,\n                    now\n                ],\n            )\n            .unwrap();\n        }\n\n        let deleted = delete_paths(&mut conn, &[\"/\".to_string()]).unwrap();\n        assert!(deleted >= 2);\n\n        let remaining: i64 = conn\n            .query_row(\"SELECT COUNT(*) FROM entries\", [], |row| row.get(0))\n            .unwrap();\n        assert_eq!(remaining, 0);\n\n        let _ = fs::remove_dir_all(root);\n    }\n\n    #[test]\n    fn execute_search_resolved_path_does_not_include_prefixed_sibling_dirs() {\n        let root = temp_case_dir(\"resolved_path_scope_execute\");\n        let projects_src = root.join(\"Projects\").join(\"src\");\n        let archived_src = root.join(\"Projects-archived\").join(\"src\");\n        fs::create_dir_all(&projects_src).unwrap();\n        fs::create_dir_all(&archived_src).unwrap();\n\n        let db_path = root.join(\"index.db\");\n        init_db(&db_path).unwrap();\n        let conn = db_connection(&db_path).unwrap();\n        let now = now_epoch();\n\n        let project_path = projects_src.join(\"main.rs\");\n        let archived_path = archived_src.join(\"legacy.rs\");\n\n        conn.execute(\n            \"INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n             VALUES(?1, ?2, ?3, 0, ?4, NULL, NULL, ?5, 1)\",\n            params![\n                project_path.to_string_lossy().to_string(),\n                \"main.rs\",\n                projects_src.to_string_lossy().to_string(),\n                \"rs\",\n                now\n            ],\n        )\n        .unwrap();\n\n        conn.execute(\n            \"INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n             VALUES(?1, ?2, ?3, 0, ?4, NULL, NULL, ?5, 1)\",\n            params![\n                archived_path.to_string_lossy().to_string(),\n                \"legacy.rs\",\n                archived_src.to_string_lossy().to_string(),\n                \"rs\",\n                now\n            ],\n        )\n        .unwrap();\n\n        let state = test_state_for(db_path.clone(), root.clone(), root.clone());\n        let result = execute_search(\n            &state,\n            \"Projects/ *.rs\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        assert!(result\n            .results\n            .iter()\n            .any(|entry| entry.path == project_path.to_string_lossy()));\n        assert!(result\n            .results\n            .iter()\n            .all(|entry| !entry.path.contains(\"Projects-archived\")));\n\n        let _ = fs::remove_dir_all(root);\n    }\n\n    #[test]\n    fn find_file_upward_locates_repo_level_pathignore() {\n        let root = temp_case_dir(\"pathignore_upward\");\n        let nested = root.join(\"src-tauri\").join(\"target\");\n        fs::create_dir_all(&nested).unwrap();\n        fs::write(root.join(\".pathignore\"), \"node_modules\\n\").unwrap();\n\n        let found = find_file_upward(&nested, \".pathignore\");\n        assert_eq!(found, Some(root.join(\".pathignore\")));\n\n        let _ = fs::remove_dir_all(root);\n    }\n\n    #[test]\n    fn find_git_root_works_from_nested_directory() {\n        let root = temp_case_dir(\"git_root\");\n        let nested = root.join(\"src-tauri\").join(\"target\");\n        fs::create_dir_all(&nested).unwrap();\n        fs::create_dir_all(root.join(\".git\")).unwrap();\n\n        let found = find_git_root(&nested);\n        assert_eq!(found, Some(root.clone()));\n\n        let _ = fs::remove_dir_all(root);\n    }\n\n    #[test]\n    fn extract_ext_from_like_rejects_multi_dot() {\n        assert_eq!(extract_ext_from_like(\"%.tar.gz\"), None);\n        assert_eq!(extract_ext_from_like(\"%.d.ts\"), None);\n        assert_eq!(extract_ext_from_like(\"%.rs\"), Some(\"rs\".to_string()));\n        assert_eq!(extract_ext_from_like(\"%.png\"), Some(\"png\".to_string()));\n    }\n\n    #[test]\n    fn negative_cache_fallback_removes_matched_key_not_query() {\n        let state = test_state_for(\n            PathBuf::from(\"/tmp/neg_cache_test.db\"),\n            PathBuf::from(\"/tmp\"),\n            PathBuf::from(\"/tmp\"),\n        );\n\n        remember_negative_name_query(&state, \"abc\");\n\n        let hit = negative_name_cache_lookup(&state, \"xabc\");\n        assert!(hit.is_some());\n        assert_eq!(hit.unwrap().query_lower, \"abc\");\n\n        remove_negative_name_query(&state, \"abc\");\n\n        let hit_after = negative_name_cache_lookup(&state, \"xabc\");\n        assert!(hit_after.is_none());\n    }\n\n    #[test]\n    fn dir_listing_deep_nested_path_without_time_budget() {\n        let root = temp_case_dir(\"dir_listing_deep\");\n        // Simulate: ~/Library/Containers/jp.naver.line.mac/Data/Library/Containers/jp.naver.line/log/\n        let deep_dir = root\n            .join(\"Library\")\n            .join(\"Containers\")\n            .join(\"jp.naver.line.mac\")\n            .join(\"Data\")\n            .join(\"Library\")\n            .join(\"Containers\")\n            .join(\"jp.naver.line\")\n            .join(\"log\");\n        let sub_dir = deep_dir.join(\"archive\");\n        fs::create_dir_all(&deep_dir).unwrap();\n        fs::create_dir_all(&sub_dir).unwrap();\n\n        let db_path = root.join(\"index.db\");\n        init_db(&db_path).unwrap();\n        let conn = db_connection(&db_path).unwrap();\n        let now = now_epoch();\n\n        let file1 = deep_dir.join(\"20260211_14.txt\");\n        let file2 = sub_dir.join(\"old.log\");\n        for (path, name, dir, ext) in [\n            (&file1, \"20260211_14.txt\", &deep_dir, \"txt\"),\n            (&file2, \"old.log\", &sub_dir, \"log\"),\n        ] {\n            conn.execute(\n                \"INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n                 VALUES(?1, ?2, ?3, 0, ?4, NULL, NULL, ?5, 1)\",\n                params![\n                    path.to_string_lossy().to_string(),\n                    name,\n                    dir.to_string_lossy().to_string(),\n                    ext,\n                    now\n                ],\n            )\n            .unwrap();\n        }\n\n        let state = test_state_for(db_path, root.clone(), root.clone());\n\n        // Query: \"jp.naver.line/log/\" - dir listing, name_like = \"%\"\n        let result = execute_search(\n            &state,\n            \"jp.naver.line/log/\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        assert_eq!(\n            result.results.len(),\n            2,\n            \"should find both files under log/ and log/archive/\"\n        );\n        let names: Vec<&str> = result.results.iter().map(|e| e.name.as_str()).collect();\n        assert!(names.contains(&\"20260211_14.txt\"));\n        assert!(names.contains(&\"old.log\"));\n\n        // Query with glob: \"jp.naver.line/log/ *\"\n        let result2 = execute_search(\n            &state,\n            \"jp.naver.line/log/ *\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        assert_eq!(\n            result2.results.len(),\n            2,\n            \"glob * should also list all files\"\n        );\n\n        // Query with trailing dot: \"jp.naver.line/log/ *.\" - name_like becomes \"%.\"\n        let result3 = execute_search(\n            &state,\n            \"jp.naver.line/log/ *.\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        // \"*.\" matches files ending with \".\" - none of our test files end with \".\"\n        // so this correctly returns 0 (this is expected, NOT a bug)\n        assert_eq!(\n            result3.results.len(),\n            0,\n            \"*. matches only files ending with dot\"\n        );\n\n        // But plain \"/\" at end should list all\n        let result4 = execute_search(\n            &state,\n            \"jp.naver.line/log/\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        assert_eq!(\n            result4.results.len(),\n            2,\n            \"trailing slash should list all files\"\n        );\n\n        let _ = fs::remove_dir_all(root);\n    }\n\n    #[test]\n    fn path_search_multi_dot_ext_uses_like_not_ext_shortcut() {\n        let root = temp_case_dir(\"multi_dot_ext\");\n        let proj_dir = root.join(\"Projects\");\n        fs::create_dir_all(&proj_dir).unwrap();\n\n        let db_path = root.join(\"index.db\");\n        init_db(&db_path).unwrap();\n        let conn = db_connection(&db_path).unwrap();\n        let now = now_epoch();\n\n        let file_path = proj_dir.join(\"archive.tar.gz\");\n        conn.execute(\n            \"INSERT INTO entries(path, name, dir, is_dir, ext, mtime, size, indexed_at, run_id)\n             VALUES(?1, ?2, ?3, 0, ?4, NULL, NULL, ?5, 1)\",\n            params![\n                file_path.to_string_lossy().to_string(),\n                \"archive.tar.gz\",\n                proj_dir.to_string_lossy().to_string(),\n                \"gz\",\n                now\n            ],\n        )\n        .unwrap();\n\n        let state = test_state_for(db_path, root.clone(), root.clone());\n        let result = execute_search(\n            &state,\n            \"Projects/ *.tar.gz\".to_string(),\n            Some(300),\n            Some(0),\n            Some(\"name\".to_string()),\n            Some(\"asc\".to_string()),\n        )\n        .unwrap();\n\n        assert_eq!(result.results.len(), 1);\n        assert!(result.results[0].name == \"archive.tar.gz\");\n\n        let _ = fs::remove_dir_all(root);\n    }\n}\n","structuredPatch":[{"oldStart":2279,"oldLines":12,"newStart":2279,"newLines":12,"lines":["                             }","                         }"," ","-                        if batch.len() >= BATCH_SIZE {","+                        if batch.len() >= flush_batch_size {","                             upsert_rows(conn, &batch)?;","                             batch.clear();","                         }"," ","-                        if stamp_batch.len() >= BATCH_SIZE {","+                        if stamp_batch.len() >= flush_batch_size {","                             stamp_run_id_batch(conn, &stamp_batch, current_run_id)?;","                             stamp_batch.clear();","                         }"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"d1341dd3-7ae8-4e22-a473-867a738d385f"}
{"parentUuid":"35bbfb4c-927e-471a-bcb9-47acc323d94f","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01Ddxy54KXgYSE9u9U1E1QKW","type":"message","role":"assistant","content":[{"type":"text","text":"ë¹Œë“œí•´ì„œ ì»´íŒŒì¼ ì˜¤ë¥˜ í™•ì¸í•©ë‹ˆë‹¤."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":353,"cache_read_input_tokens":158368,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":353},"output_tokens":4,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNitBtTAWF5BKzsrhLUb","type":"assistant","uuid":"bd9341d3-de1f-463a-999f-17907714172f","timestamp":"2026-02-22T07:35:56.349Z"}
{"parentUuid":"bd9341d3-de1f-463a-999f-17907714172f","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01Ddxy54KXgYSE9u9U1E1QKW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DyZ4NYDMWnsVmoQsxGXZjZ","name":"Bash","input":{"command":"cargo build --manifest-path /Users/al02402336/everything/src-tauri/Cargo.toml 2>&1 | grep -E \"^error|^warning\\[\" | head -20","description":"Build to check for compile errors","timeout":120000},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":353,"cache_read_input_tokens":158368,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":353},"output_tokens":4,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNitBtTAWF5BKzsrhLUb","type":"assistant","uuid":"60e4beb9-29bf-4a27-91dc-3a1be60165df","timestamp":"2026-02-22T07:35:57.751Z"}
{"type":"queue-operation","operation":"enqueue","timestamp":"2026-02-22T07:36:02.145Z","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","content":"{\"task_id\":\"b69b2a7\",\"tool_use_id\":\"toolu_01DyZ4NYDMWnsVmoQsxGXZjZ\",\"description\":\"Build to check for compile errors\",\"task_type\":\"local_bash\"}"}
{"parentUuid":"60e4beb9-29bf-4a27-91dc-3a1be60165df","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":3,"totalLines":0,"totalBytes":0,"taskId":"b69b2a7","timeoutMs":120000},"toolUseID":"bash-progress-0","parentToolUseID":"toolu_01DyZ4NYDMWnsVmoQsxGXZjZ","uuid":"b4950b33-8812-4cef-8d68-b661505e5ada","timestamp":"2026-02-22T07:36:02.145Z"}
{"parentUuid":"b4950b33-8812-4cef-8d68-b661505e5ada","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":4,"totalLines":0,"totalBytes":0,"taskId":"b69b2a7","timeoutMs":120000},"toolUseID":"bash-progress-1","parentToolUseID":"toolu_01DyZ4NYDMWnsVmoQsxGXZjZ","uuid":"191afdae-ee18-4923-8628-a6866b524d15","timestamp":"2026-02-22T07:36:03.133Z"}
{"parentUuid":"191afdae-ee18-4923-8628-a6866b524d15","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":5,"totalLines":0,"totalBytes":0,"taskId":"b69b2a7","timeoutMs":120000},"toolUseID":"bash-progress-2","parentToolUseID":"toolu_01DyZ4NYDMWnsVmoQsxGXZjZ","uuid":"6efe82f8-bc41-43fc-ae28-2480423251c4","timestamp":"2026-02-22T07:36:04.134Z"}
{"parentUuid":"6efe82f8-bc41-43fc-ae28-2480423251c4","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":6,"totalLines":0,"totalBytes":0,"taskId":"b69b2a7","timeoutMs":120000},"toolUseID":"bash-progress-3","parentToolUseID":"toolu_01DyZ4NYDMWnsVmoQsxGXZjZ","uuid":"9afea9e3-6949-4180-8686-d4eaf0821211","timestamp":"2026-02-22T07:36:05.133Z"}
{"parentUuid":"9afea9e3-6949-4180-8686-d4eaf0821211","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":7,"totalLines":0,"totalBytes":0,"taskId":"b69b2a7","timeoutMs":120000},"toolUseID":"bash-progress-4","parentToolUseID":"toolu_01DyZ4NYDMWnsVmoQsxGXZjZ","uuid":"2c7de2fc-debe-4b99-b5be-4c2e8e00ca0a","timestamp":"2026-02-22T07:36:06.133Z"}
{"parentUuid":"2c7de2fc-debe-4b99-b5be-4c2e8e00ca0a","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":8,"totalLines":0,"totalBytes":0,"taskId":"b69b2a7","timeoutMs":120000},"toolUseID":"bash-progress-5","parentToolUseID":"toolu_01DyZ4NYDMWnsVmoQsxGXZjZ","uuid":"f12de8cd-f50b-44bd-b19b-1b4db7b8f64e","timestamp":"2026-02-22T07:36:07.134Z"}
{"parentUuid":"f12de8cd-f50b-44bd-b19b-1b4db7b8f64e","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":9,"totalLines":0,"totalBytes":0,"taskId":"b69b2a7","timeoutMs":120000},"toolUseID":"bash-progress-6","parentToolUseID":"toolu_01DyZ4NYDMWnsVmoQsxGXZjZ","uuid":"42e6e388-d1a8-48ef-8e0e-a7488ec5baf1","timestamp":"2026-02-22T07:36:08.137Z"}
{"parentUuid":"42e6e388-d1a8-48ef-8e0e-a7488ec5baf1","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":10,"totalLines":0,"totalBytes":0,"taskId":"b69b2a7","timeoutMs":120000},"toolUseID":"bash-progress-7","parentToolUseID":"toolu_01DyZ4NYDMWnsVmoQsxGXZjZ","uuid":"2e3b32eb-405f-48a9-8bbf-1af0f80ba7c7","timestamp":"2026-02-22T07:36:09.139Z"}
{"parentUuid":"2e3b32eb-405f-48a9-8bbf-1af0f80ba7c7","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":11,"totalLines":0,"totalBytes":0,"taskId":"b69b2a7","timeoutMs":120000},"toolUseID":"bash-progress-8","parentToolUseID":"toolu_01DyZ4NYDMWnsVmoQsxGXZjZ","uuid":"e79b1e57-c2da-49c4-bedd-4d50a0543abb","timestamp":"2026-02-22T07:36:10.140Z"}
{"parentUuid":"e79b1e57-c2da-49c4-bedd-4d50a0543abb","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":12,"totalLines":0,"totalBytes":0,"taskId":"b69b2a7","timeoutMs":120000},"toolUseID":"bash-progress-9","parentToolUseID":"toolu_01DyZ4NYDMWnsVmoQsxGXZjZ","uuid":"72d1612d-7eb4-4f64-9918-62161e326945","timestamp":"2026-02-22T07:36:11.140Z"}
{"parentUuid":"72d1612d-7eb4-4f64-9918-62161e326945","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":13,"totalLines":0,"totalBytes":0,"taskId":"b69b2a7","timeoutMs":120000},"toolUseID":"bash-progress-10","parentToolUseID":"toolu_01DyZ4NYDMWnsVmoQsxGXZjZ","uuid":"64732c17-f2ac-4e7b-8b52-f80e0571a1ba","timestamp":"2026-02-22T07:36:12.143Z"}
{"parentUuid":"64732c17-f2ac-4e7b-8b52-f80e0571a1ba","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":14,"totalLines":0,"totalBytes":0,"taskId":"b69b2a7","timeoutMs":120000},"toolUseID":"bash-progress-11","parentToolUseID":"toolu_01DyZ4NYDMWnsVmoQsxGXZjZ","uuid":"4c6eb523-0134-4958-9ce6-6f70ea7ae8c2","timestamp":"2026-02-22T07:36:13.144Z"}
{"parentUuid":"4c6eb523-0134-4958-9ce6-6f70ea7ae8c2","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":15,"totalLines":0,"totalBytes":0,"taskId":"b69b2a7","timeoutMs":120000},"toolUseID":"bash-progress-12","parentToolUseID":"toolu_01DyZ4NYDMWnsVmoQsxGXZjZ","uuid":"5a21f107-a02a-403b-9d92-694294401acd","timestamp":"2026-02-22T07:36:14.145Z"}
{"parentUuid":"5a21f107-a02a-403b-9d92-694294401acd","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":16,"totalLines":0,"totalBytes":0,"taskId":"b69b2a7","timeoutMs":120000},"toolUseID":"bash-progress-13","parentToolUseID":"toolu_01DyZ4NYDMWnsVmoQsxGXZjZ","uuid":"dcaa7854-d14c-464b-9ba1-95920956027c","timestamp":"2026-02-22T07:36:15.146Z"}
{"parentUuid":"dcaa7854-d14c-464b-9ba1-95920956027c","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":17,"totalLines":0,"totalBytes":0,"taskId":"b69b2a7","timeoutMs":120000},"toolUseID":"bash-progress-14","parentToolUseID":"toolu_01DyZ4NYDMWnsVmoQsxGXZjZ","uuid":"6cb1266a-de12-4cdc-85b9-54228f1f7505","timestamp":"2026-02-22T07:36:16.149Z"}
{"parentUuid":"60e4beb9-29bf-4a27-91dc-3a1be60165df","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DyZ4NYDMWnsVmoQsxGXZjZ","type":"tool_result","content":"","is_error":false}]},"uuid":"4eb5b212-cb9e-44fb-8bcd-d6c1128d9009","timestamp":"2026-02-22T07:36:16.597Z","toolUseResult":{"stdout":"","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"60e4beb9-29bf-4a27-91dc-3a1be60165df"}
{"parentUuid":"4eb5b212-cb9e-44fb-8bcd-d6c1128d9009","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01SRzMVREQtirT23gcNreDYi","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01J4rLLGZwLwcGQ3ttNr5LYN","name":"Bash","input":{"command":"cargo build --manifest-path /Users/al02402336/everything/src-tauri/Cargo.toml 2>&1 | tail -5","description":"Check build result","timeout":120000},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":186,"cache_read_input_tokens":158721,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":186},"output_tokens":19,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNiupqE1DEZcqodVKybW","type":"assistant","uuid":"ea20381b-8bb6-411e-aa7e-bc5a6c78aa8b","timestamp":"2026-02-22T07:36:18.953Z"}
{"parentUuid":"ea20381b-8bb6-411e-aa7e-bc5a6c78aa8b","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01J4rLLGZwLwcGQ3ttNr5LYN","type":"tool_result","content":"   |\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: `everything` (bin \"everything\") generated 1 warning\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 2.19s","is_error":false}]},"uuid":"ce56b96c-718e-4bab-9a26-6f5cd2e3b12d","timestamp":"2026-02-22T07:36:21.372Z","toolUseResult":{"stdout":"   |\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: `everything` (bin \"everything\") generated 1 warning\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 2.19s","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"ea20381b-8bb6-411e-aa7e-bc5a6c78aa8b"}
{"parentUuid":"ce56b96c-718e-4bab-9a26-6f5cd2e3b12d","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","message":{"model":"claude-sonnet-4-6","id":"msg_01YGgsj6QoGHw8rfZomkcRp8","type":"message","role":"assistant","content":[{"type":"text","text":"ì»´íŒŒì¼ ì„±ê³µ. ì ìš©ëœ ë³€ê²½ì‚¬í•­ ìš”ì•½:\n\n| ë³€ê²½ | íš¨ê³¼ |\n|---|---|\n| `synchronous = OFF` (indexing pragma) | ë°°ì¹˜ commitë§ˆë‹¤ fsync ì œê±° â€” ìˆ˜ì‹­ msì”© ì ˆì•½ |\n| `cache_size = -131072` (128MB), `mmap_size = 512MB`, `wal_autocheckpoint = 0` | ë©”ëª¨ë¦¬ì—ì„œ ìµœëŒ€í•œ ì²˜ë¦¬, ì²´í¬í¬ì¸íŠ¸ ì§€ì—° |\n| `reset_index`: DELETE ì „ `synchronous=OFF` + 128MB cache | ìˆ˜ì‹­ë§Œ í–‰ ì‚­ì œ ì‹œ WAL fsync ì œê±° |\n| fresh index: 4ê°œ secondary index DROP â†’ ì‚½ìž… â†’ ìž¬ìƒì„± | ë§¤ row INSERTë§ˆë‹¤ 4ê°œ BTREE ê°±ì‹  ì œê±° â€” ê°€ìž¥ í° íš¨ê³¼ |\n| fresh index `flush_batch_size = BATCH_SIZE * 5` (50,000) | íŠ¸ëžœìž­ì…˜ ìˆ˜ë¥¼ 1/5ë¡œ ì¤„ìž„ |\n\nfresh index(reset í›„)ì—ì„œ ê°€ìž¥ í° íš¨ê³¼ëŠ” ì¸ë±ìŠ¤ dropìž…ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ 50ë§Œ ê°œ íŒŒì¼ ê¸°ì¤€ìœ¼ë¡œ ê¸°ì¡´ì—ëŠ” 200ë§Œ BTREE ê°±ì‹ ì´ ë°œìƒí•˜ë˜ ê²ƒì´ 0ìœ¼ë¡œ ì¤„ê³ , ë§ˆì§€ë§‰ì— ì¸ë±ìŠ¤ 4ê°œë¥¼ í•œë²ˆì— ë¹Œë“œí•©ë‹ˆë‹¤."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":198,"cache_read_input_tokens":158907,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":198},"output_tokens":6,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYNivB5tKCx7eWCDg5CKL","type":"assistant","uuid":"c1ffaf73-2138-4dd2-b40a-6c8b36fd1cb1","timestamp":"2026-02-22T07:36:30.996Z"}
{"parentUuid":"c1ffaf73-2138-4dd2-b40a-6c8b36fd1cb1","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"entire hooks claude-code stop"},"parentToolUseID":"4110cf41-8e67-4a7a-ab2d-537d64040abe","toolUseID":"4110cf41-8e67-4a7a-ab2d-537d64040abe","timestamp":"2026-02-22T07:36:31.050Z","uuid":"2fb05efb-c90e-418d-8590-b0e495e27a03"}
{"type":"queue-operation","operation":"remove","timestamp":"2026-02-22T07:36:33.538Z","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8"}
{"type":"queue-operation","operation":"remove","timestamp":"2026-02-22T07:36:33.538Z","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8"}
{"parentUuid":"2fb05efb-c90e-418d-8590-b0e495e27a03","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"system","subtype":"stop_hook_summary","hookCount":1,"hookInfos":[{"command":"entire hooks claude-code stop","durationMs":2444}],"hookErrors":[],"preventedContinuation":false,"stopReason":"","hasOutput":true,"level":"suggestion","timestamp":"2026-02-22T07:36:33.496Z","uuid":"06c04ec9-a814-4d9b-825f-50a4f471907c","toolUseID":"4110cf41-8e67-4a7a-ab2d-537d64040abe"}
{"parentUuid":"06c04ec9-a814-4d9b-825f-50a4f471907c","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"system","subtype":"turn_duration","durationMs":405616,"timestamp":"2026-02-22T07:36:33.498Z","uuid":"2d5abb23-b435-4372-a8b6-606785676381","isMeta":false}
{"type":"file-history-snapshot","messageId":"7a8d92bf-3d0c-42f9-aba5-c02783f224fc","snapshot":{"messageId":"7a8d92bf-3d0c-42f9-aba5-c02783f224fc","trackedFileBackups":{"src/App.svelte":{"backupFileName":"f2ffc3f5647f6015@v4","version":4,"backupTime":"2026-02-22T07:29:26.391Z"},"src-tauri/src/main.rs":{"backupFileName":"d5d8131157dfe6bc@v2","version":2,"backupTime":"2026-02-22T07:38:54.234Z"}},"timestamp":"2026-02-22T07:38:54.232Z"},"isSnapshotUpdate":false}
{"parentUuid":"2d5abb23-b435-4372-a8b6-606785676381","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":"ì•„ì§ë„ reset í›„ ì™„ë£Œê¹Œì§€ 1ë¶„ 18ì´ˆê±¸ë ¤. 50ì´ˆ ë¯¸ë§Œì´ ë  ë•Œê¹Œì§€ í…ŒìŠ¤íŠ¸í•˜ê³  ì‹œê°„ ì¸¡ì •ê³¼ ê°œì„ ì„ ë°˜ë³µí•´"},"uuid":"7a8d92bf-3d0c-42f9-aba5-c02783f224fc","timestamp":"2026-02-22T07:38:53.955Z","permissionMode":"bypassPermissions"}
{"parentUuid":"7a8d92bf-3d0c-42f9-aba5-c02783f224fc","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"d33dc671-019d-4fe5-83bc-df3cb3db3fd8","version":"2.1.49","gitBranch":"main","slug":"snazzy-prancing-wirth","type":"user","message":{"role":"user","content":[{"type":"text","text":"[Request interrupted by user]"}]},"uuid":"e83f9918-4904-44e4-b692-cb669c6b61dc","timestamp":"2026-02-22T07:38:54.289Z"}
