{"type":"file-history-snapshot","messageId":"02a48da0-3be3-479a-8656-d141e59500be","snapshot":{"messageId":"02a48da0-3be3-479a-8656-d141e59500be","trackedFileBackups":{},"timestamp":"2026-02-21T14:16:07.988Z"},"isSnapshotUpdate":false}
{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","type":"progress","data":{"type":"hook_progress","hookEvent":"SessionStart","hookName":"SessionStart:clear","command":"entire hooks claude-code session-start"},"parentToolUseID":"0c60d466-9384-4083-9156-0999a677cba9","toolUseID":"0c60d466-9384-4083-9156-0999a677cba9","timestamp":"2026-02-21T14:16:06.276Z","uuid":"ba7e69d6-c203-40cd-8083-4f02d59847e5"}
{"parentUuid":"ba7e69d6-c203-40cd-8083-4f02d59847e5","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","type":"user","message":{"role":"user","content":"<local-command-caveat>Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to.</local-command-caveat>"},"isMeta":true,"uuid":"7e3388a6-441d-4154-8c9b-0ad0037b29a3","timestamp":"2026-02-21T14:16:07.988Z"}
{"parentUuid":"7e3388a6-441d-4154-8c9b-0ad0037b29a3","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","type":"user","message":{"role":"user","content":"<command-name>/clear</command-name>\n            <command-message>clear</command-message>\n            <command-args></command-args>"},"uuid":"02a48da0-3be3-479a-8656-d141e59500be","timestamp":"2026-02-21T14:16:05.950Z"}
{"parentUuid":"02a48da0-3be3-479a-8656-d141e59500be","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","type":"user","message":{"role":"user","content":"<local-command-stdout></local-command-stdout>"},"uuid":"d0e1bf7e-ba87-4e29-a7ea-57493793c0a3","timestamp":"2026-02-21T14:16:07.988Z"}
{"type":"file-history-snapshot","messageId":"e0d384bd-6392-4207-bb5b-294a34d34741","snapshot":{"messageId":"e0d384bd-6392-4207-bb5b-294a34d34741","trackedFileBackups":{},"timestamp":"2026-02-21T14:17:21.160Z"},"isSnapshotUpdate":false}
{"parentUuid":"d0e1bf7e-ba87-4e29-a7ea-57493793c0a3","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","type":"user","message":{"role":"user","content":"rename 했을 때 파일 이름 수정(multi line)을 위해 list item 영역이 넓어지는데.. finder 방식처럼 overlay된 이름 변경 tool이 뜨고 list item의 height가 넓어지지 않게 수정해줘"},"uuid":"e0d384bd-6392-4207-bb5b-294a34d34741","timestamp":"2026-02-21T14:17:18.558Z","permissionMode":"bypassPermissions"}
{"parentUuid":"e0d384bd-6392-4207-bb5b-294a34d34741","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","message":{"model":"claude-sonnet-4-6","id":"msg_01PEuVS3eMmAnnpMANwXe7mz","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user wants to change the rename behavior in the file list. Currently when renaming, the list item's height expands to accommodate multi-line editing. The user wants it to work like Finder - where an overlay/popup text input appears for renaming without changing the list item height.\n\nLet me read the current code to understand the implementation.","signature":"EogECkYICxgCKkDYL5l9mUy+AQtEIKhKgQr0c33ciYkeJAFoWID+a9kSiZgQhuMaLwbS4LAhwwa6cTKVKsNcXbMo4GBC5yXvw7VEEgyiubp+7zn9ZSLS8VkaDACsBpo6i9bHYolCHSIwjLAoc6HTOUpugfyQNeuL736cWgNasFuh9N/ZIXbe1dWXfpIN22x5/Ay8bQyG9Z95Ku8CZG7rArO6BlyhG/7rmtCCW0PDG9cfp56GO3zHqslxoio0w3DSMG6gqOuTn+fXeB7Z7NeiRPxYzhyYWEDDYsbWsf9b1K/bg41kVulbIxIIXo8uBUm0JOMFgPWdCkXlAFj+6rDjiXcZtDGbwg/TRu6cyRmOr0Jz8Grj1qKGh4ffQaEKgZ0kacbvIr8Ze6FvkThwKdm8/eO4rAQFSv+hb69hZAqO3KKkCbf5zQX7xin/+arBAASdM9Og8P0BaesqQzj75kQC62jrvIkEO8xdRHf35A+z5q5UHh4eramqonKSzvllbk89qBaayZHjlCrHTbeoLZNNkzRqK3IEb2XXfmuBQkGoNveUMiWyvDMf0XK8pFvrTFCq+r601G57nDER6AffrDNKRaxDfd7GGs7f2o1cHM+ytld/G9eT1fyhE6BBDLAm4smw/nT5WpZ2kk+7rt14KLjudJMkuGa3vy6I5hZYgAF1y+MPZRueMCpl6nJM1hgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":8140,"cache_read_input_tokens":25541,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":8140},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMMgohhUDhpzEWrPPyvT","type":"assistant","uuid":"b42f06dd-06fb-42c6-abae-41e07d89d476","timestamp":"2026-02-21T14:17:24.668Z"}
{"parentUuid":"b42f06dd-06fb-42c6-abae-41e07d89d476","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","message":{"model":"claude-sonnet-4-6","id":"msg_01PEuVS3eMmAnnpMANwXe7mz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BGFgqYpxLttm1qo1EtWfyU","name":"Read","input":{"file_path":"/Users/al02402336/everything/src/App.svelte"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":8140,"cache_read_input_tokens":25541,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":8140},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMMgohhUDhpzEWrPPyvT","type":"assistant","uuid":"e937e7a1-9199-473f-b644-96245df7616b","timestamp":"2026-02-21T14:17:25.092Z"}
{"parentUuid":"e937e7a1-9199-473f-b644-96245df7616b","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01BGFgqYpxLttm1qo1EtWfyU","toolUseID":"toolu_01BGFgqYpxLttm1qo1EtWfyU","timestamp":"2026-02-21T14:17:25.380Z","uuid":"af0f2cde-da8d-41ce-b57c-42e016ca0285"}
{"parentUuid":"e937e7a1-9199-473f-b644-96245df7616b","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BGFgqYpxLttm1qo1EtWfyU","type":"tool_result","content":"     1→<script>\n     2→  import { onDestroy, onMount, tick } from 'svelte';\n     3→  import { invoke } from '@tauri-apps/api/core';\n     4→  import { listen } from '@tauri-apps/api/event';\n     5→  import { getCurrentWindow } from '@tauri-apps/api/window';\n     6→  import { startDrag } from '@crabnebula/tauri-plugin-drag';\n     7→\n     8→  const rowHeight = 30;\n     9→  const PAGE_SIZE = 500;\n    10→  let homePrefix = '';\n    11→  const COL_WIDTHS_KEY = 'REDACTED';\n    12→  const THEME_KEY = 'everything-theme';\n    13→  const columnKeys = ['name', 'path', 'size', 'modified'];\n    14→  const minColumnWidth = {\n    15→    name: 180,\n    16→    path: 240,\n    17→    size: 75,\n    18→    modified: 150\n    19→  };\n    20→  const defaultColumnRatios = {\n    21→    name: 0.3,\n    22→    path: 0.45,\n    23→    size: 0.1\n    24→  };\n    25→\n    26→  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || 'dark'; } catch { return 'dark'; } })();\n    27→  function cycleTheme() {\n    28→    theme = theme === 'dark' ? 'light' : 'dark';\n    29→    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n    30→  }\n    31→\n    32→  let query = '';\n    33→  let results = [];\n    34→  let totalResults = 0;\n    35→  let totalResultsKnown = false;\n    36→\n    37→  let dbLatencyMs = null;\n    38→  let dbLastQuery = '';\n    39→  let searchModeLabel = '';\n    40→  let selectedIndices = new Set();\n    41→  let selectionAnchor = -1;\n    42→  let lastSelectedIndex = -1;\n    43→  let editing = {\n    44→    active: false,\n    45→    path: '',\n    46→    index: -1,\n    47→    draftName: ''\n    48→  };\n    49→\n    50→  let indexStatus = {\n    51→    state: 'Indexing',\n    52→    entriesCount: 0,\n    53→    lastUpdated: null,\n    54→    permissionErrors: 0,\n    55→    message: null,\n    56→    isCatchup: false\n    57→  };\n    58→\n    59→  let indexingStartTime = null;\n    60→  let indexingElapsed = '';\n    61→  let indexingFinishedAt = '';\n    62→\n    63→  let sortBy = 'name';\n    64→  let sortDir = 'asc';\n    65→\n    66→  let hasMore = true;\n    67→  let loadingMore = false;\n    68→  let searchGeneration = 0;\n    69→\n    70→  let scanned = 0;\n    71→\n    72→  let searchInputEl;\n    73→  let renameInputEl;\n    74→  let tableAreaEl;\n    75→  let tableContainer;\n    76→  let tableResizeObserver = null;\n    77→  let viewportResizeRaf = null;\n    78→  let scrollTop = 0;\n    79→  let headerScrollLeft = 0;\n    80→  let viewportHeight = 520;\n    81→  let lastTableWidth = 0;\n    82→  let resizingColumn = '';\n    83→  let resizeCleanup = null;\n    84→  let colWidths = {\n    85→    name: 250,\n    86→    path: 350,\n    87→    size: 75,\n    88→    modified: 150\n    89→  };\n    90→\n    91→  let contextMenu = {\n    92→    visible: false,\n    93→    x: 0,\n    94→    y: 0\n    95→  };\n    96→\n    97→  let platform = '';\n    98→  let toast = '';\n    99→  let searchTimer;\n   100→  let lastSearchFiredAt = 0;\n   101→  let toastTimer;\n   102→  let statusRefreshTimer;\n   103→  let elapsedTimer;\n   104→  let statusRefreshInFlight = false;\n   105→  let lastReadyCount = 0;\n   106→\n   107→  const iconCache = new Map();\n   108→  const iconLoading = new Set();\n   109→\n   110→  let highlightCache = new Map();\n   111→  let highlightCacheQuery = '';\n   112→\n   113→  const folderFallbackIcon =\n   114→    \"data:image/svg+xml;utf8,\" +\n   115→    encodeURIComponent(\n   116→      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='1' y='4' width='14' height='10' rx='2' fill='#d9b34f'/><rect x='1' y='2' width='6' height='4' rx='1' fill='#e6ca7a'/></svg>`\n   117→    );\n   118→  const fileFallbackIcon =\n   119→    \"data:image/svg+xml;utf8,\" +\n   120→    encodeURIComponent(\n   121→      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='3' y='1' width='10' height='14' rx='1.5' fill='#b4bec9'/><rect x='5' y='5' width='6' height='1.2' fill='#8d98a5'/><rect x='5' y='8' width='6' height='1.2' fill='#8d98a5'/></svg>`\n   122→    );\n   123→\n   124→  $: totalHeight = results.length * rowHeight;\n   125→  $: startIndex = Math.max(0, Math.floor(scrollTop / rowHeight) - 10);\n   126→  $: visibleCount = Math.ceil(viewportHeight / rowHeight) + 20;\n   127→  $: endIndex = Math.min(results.length, startIndex + visibleCount);\n   128→  $: visibleRows = results.slice(startIndex, endIndex);\n   129→  $: translateY = startIndex * rowHeight;\n   130→  $: tableMinWidth = colWidths.name + colWidths.path + colWidths.size + colWidths.modified;\n   131→  $: tableGridStyle = `--col-name:${colWidths.name}px;--col-path:${colWidths.path}px;--col-size:${colWidths.size}px;--col-modified:${colWidths.modified}px;--table-min-width:${tableMinWidth}px;--header-offset:${-headerScrollLeft}px;`;\n   132→\n   133→  $: {\n   134→    for (const entry of visibleRows) {\n   135→      void ensureIcon(entry);\n   136→    }\n   137→  }\n   138→\n   139→  function showToast(message) {\n   140→    toast = message;\n   141→    clearTimeout(toastTimer);\n   142→    toastTimer = setTimeout(() => {\n   143→      toast = '';\n   144→    }, 3000);\n   145→  }\n   146→\n   147→  function bytesToBase64(bytes) {\n   148→    let binary = '';\n   149→    const chunk = 0x8000;\n   150→    for (let i = 0; i < bytes.length; i += chunk) {\n   151→      const part = bytes.subarray(i, i + chunk);\n   152→      binary += String.fromCharCode(...part);\n   153→    }\n   154→    return btoa(binary);\n   155→  }\n   156→\n   157→  function highlightSegments(name, q) {\n   158→    q = (q || '').trim();\n   159→    if (!q) return [{ text: name, hl: false }];\n   160→\n   161→    // Reset cache when query changes\n   162→    if (q !== highlightCacheQuery) {\n   163→      highlightCache = new Map();\n   164→      highlightCacheQuery = q;\n   165→    }\n   166→\n   167→    // Check cache\n   168→    const cached = highlightCache.get(name);\n   169→    if (cached) return cached;\n   170→\n   171→    if (q.includes('/')) q = q.slice(q.lastIndexOf('/') + 1);\n   172→    q = q.replace(/[*?]/g, '');\n   173→    const terms = q.split(/\\s+/).filter(Boolean);\n   174→    if (terms.length === 0) return [{ text: name, hl: false }];\n   175→\n   176→    const lower = name.toLowerCase();\n   177→    const marks = new Uint8Array(name.length);\n   178→    for (const t of terms) {\n   179→      const tl = t.toLowerCase();\n   180→      let idx = lower.indexOf(tl);\n   181→      while (idx !== -1) {\n   182→        for (let i = idx; i < idx + tl.length; i++) marks[i] = 1;\n   183→        idx = lower.indexOf(tl, idx + 1);\n   184→      }\n   185→    }\n   186→\n   187→    const segs = [];\n   188→    let i = 0;\n   189→    while (i < name.length) {\n   190→      const m = marks[i];\n   191→      let j = i + 1;\n   192→      while (j < name.length && marks[j] === m) j++;\n   193→      segs.push({ text: name.slice(i, j), hl: m === 1 });\n   194→      i = j;\n   195→    }\n   196→\n   197→    highlightCache.set(name, segs);\n   198→    return segs;\n   199→  }\n   200→\n   201→  const perFileIconExts = new Set(['exe', 'lnk', 'ico', 'url', 'scr', 'appx']);\n   202→\n   203→  function iconKey(entry) {\n   204→    if (entry.isDir) return '__folder__';\n   205→    const ext = (entry.ext || '').toLowerCase();\n   206→    if (perFileIconExts.has(ext)) return entry.path;\n   207→    return ext || '__file__';\n   208→  }\n   209→\n   210→  function iconFor(entry) {\n   211→    return iconCache.get(iconKey(entry)) || (entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n   212→  }\n   213→\n   214→  async function ensureIcon(entry) {\n   215→    const key = iconKey(entry);\n   216→    if (iconCache.has(key) || iconLoading.has(key)) {\n   217→      return;\n   218→    }\n   219→\n   220→    iconLoading.add(key);\n   221→    try {\n   222→      const bytes = await invoke('get_file_icon', {\n   223→        path: entry.path,\n   224→        ext: entry.isDir ? 'folder' : entry.ext || '',\n   225→      });\n   226→      if (Array.isArray(bytes) && bytes.length > 0) {\n   227→        const image = `data:image/png;base64,${bytesToBase64(Uint8Array.from(bytes))}`;\n   228→        iconCache.set(key, image);\n   229→      } else {\n   230→        iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n   231→      }\n   232→    } catch {\n   233→      iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n   234→    } finally {\n   235→      iconLoading.delete(key);\n   236→    }\n   237→  }\n   238→\n   239→  function syncColumnWidthsToContainer() {\n   240→    const width = tableContainer?.clientWidth || tableAreaEl?.clientWidth;\n   241→    if (!width || lastTableWidth !== 0) {\n   242→      return;\n   243→    }\n   244→\n   245→    const saved = loadColWidths();\n   246→    if (saved) {\n   247→      const total = columnKeys.reduce((s, k) => s + saved[k], 0);\n   248→      if (Math.abs(total - width) > 2) {\n   249→        const scale = (width - saved.modified) / (total - saved.modified);\n   250→        let scaledName = Math.max(minColumnWidth.name, Math.round(saved.name * scale));\n   251→        let scaledSize = Math.max(minColumnWidth.size, Math.round(saved.size * scale));\n   252→        let rawPath = width - saved.modified - scaledName - scaledSize;\n   253→        if (rawPath < minColumnWidth.path) {\n   254→          const shortfall = minColumnWidth.path - rawPath;\n   255→          const nameReduction = Math.min(shortfall, scaledName - minColumnWidth.name);\n   256→          scaledName -= nameReduction;\n   257→          const remaining = shortfall - nameReduction;\n   258→          if (remaining > 0) {\n   259→            scaledSize -= Math.min(remaining, scaledSize - minColumnWidth.size);\n   260→          }\n   261→          rawPath = width - saved.modified - scaledName - scaledSize;\n   262→        }\n   263→        const scaledPath = Math.max(minColumnWidth.path, rawPath);\n   264→        colWidths = { name: scaledName, path: scaledPath, size: scaledSize, modified: saved.modified };\n   265→      } else {\n   266→        colWidths = saved;\n   267→      }\n   268→    } else {\n   269→      const fixedModified = minColumnWidth.modified;\n   270→      const rest = width - fixedModified;\n   271→      const ratioSum = defaultColumnRatios.name + defaultColumnRatios.path + defaultColumnRatios.size;\n   272→      colWidths = {\n   273→        name: Math.max(minColumnWidth.name, Math.round(rest * defaultColumnRatios.name / ratioSum)),\n   274→        path: Math.max(minColumnWidth.path, Math.round(rest * defaultColumnRatios.path / ratioSum)),\n   275→        size: Math.max(minColumnWidth.size, Math.round(rest * defaultColumnRatios.size / ratioSum)),\n   276→        modified: fixedModified\n   277→      };\n   278→    }\n   279→    lastTableWidth = width;\n   280→  }\n   281→\n   282→  function loadColWidths() {\n   283→    try {\n   284→      const raw = localStorage.getItem(COL_WIDTHS_KEY);\n   285→      if (!raw) return null;\n   286→      const parsed = JSON.parse(raw);\n   287→      for (const key of columnKeys) {\n   288→        if (typeof parsed[key] !== 'number' || parsed[key] < (minColumnWidth[key] || 0)) return null;\n   289→      }\n   290→      return parsed;\n   291→    } catch {\n   292→      return null;\n   293→    }\n   294→  }\n   295→\n   296→  function saveColWidths() {\n   297→    localStorage.setItem(COL_WIDTHS_KEY, JSON.stringify(colWidths));\n   298→  }\n   299→\n   300→  function updateViewportHeight() {\n   301→    viewportHeight = tableContainer?.clientHeight || 520;\n   302→    syncColumnWidthsToContainer();\n   303→  }\n   304→\n   305→  function scheduleViewportHeightUpdate() {\n   306→    if (viewportResizeRaf !== null) {\n   307→      return;\n   308→    }\n   309→    viewportResizeRaf = requestAnimationFrame(() => {\n   310→      viewportResizeRaf = null;\n   311→      updateViewportHeight();\n   312→    });\n   313→  }\n   314→\n   315→  function startColumnResize(event, leftKey) {\n   316→    event.preventDefault();\n   317→    event.stopPropagation();\n   318→\n   319→    const index = columnKeys.indexOf(leftKey);\n   320→    if (index < 0 || index >= columnKeys.length - 1) {\n   321→      return;\n   322→    }\n   323→\n   324→    const startX = event.clientX;\n   325→    const startLeft = colWidths[leftKey];\n   326→    const rightKey = columnKeys[index + 1];\n   327→    const startRight = colWidths[rightKey];\n   328→\n   329→    resizeCleanup?.();\n   330→    resizingColumn = leftKey;\n   331→\n   332→    const onMove = (moveEvent) => {\n   333→      const delta = Math.round(moveEvent.clientX - startX);\n   334→      if (leftKey === 'name') {\n   335→        // Two-column trade: name and path swap space, each respects its minimum\n   336→        const nextLeft = Math.max(\n   337→          minColumnWidth[leftKey],\n   338→          Math.min(startLeft + delta, startLeft + startRight - minColumnWidth[rightKey])\n   339→        );\n   340→        const nextRight = startLeft + startRight - nextLeft;\n   341→        colWidths = { ...colWidths, [leftKey]: nextLeft, [rightKey]: nextRight };\n   342→      } else {\n   343→        // path splitter: path grows unconstrained (allows horizontal scroll on right drag)\n   344→        const nextLeft = Math.max(minColumnWidth[leftKey], startLeft + delta);\n   345→        colWidths = { ...colWidths, [leftKey]: nextLeft };\n   346→      }\n   347→    };\n   348→\n   349→    const onUp = () => {\n   350→      cleanup();\n   351→    };\n   352→\n   353→    const cleanup = () => {\n   354→      window.removeEventListener('mousemove', onMove);\n   355→      window.removeEventListener('mouseup', onUp);\n   356→      document.body.style.cursor = '';\n   357→      document.body.style.userSelect = '';\n   358→      resizingColumn = '';\n   359→      saveColWidths();\n   360→      if (resizeCleanup === cleanup) {\n   361→        resizeCleanup = null;\n   362→      }\n   363→    };\n   364→\n   365→    resizeCleanup = cleanup;\n   366→    document.body.style.cursor = 'col-resize';\n   367→    document.body.style.userSelect = 'none';\n   368→    window.addEventListener('mousemove', onMove);\n   369→    window.addEventListener('mouseup', onUp);\n   370→  }\n   371→\n   372→  function selectedPaths() {\n   373→    const sorted = [...selectedIndices].sort((a, b) => a - b);\n   374→    return sorted.map((idx) => results[idx]).filter(Boolean).map((entry) => entry.path);\n   375→  }\n   376→\n   377→  function clearSelection() {\n   378→    selectedIndices = new Set();\n   379→    selectionAnchor = -1;\n   380→    lastSelectedIndex = -1;\n   381→  }\n   382→\n   383→  function selectSingle(index) {\n   384→    selectedIndices = new Set([index]);\n   385→    selectionAnchor = index;\n   386→    lastSelectedIndex = index;\n   387→  }\n   388→\n   389→  function selectToggle(index) {\n   390→    const next = new Set(selectedIndices);\n   391→    if (next.has(index)) {\n   392→      next.delete(index);\n   393→    } else {\n   394→      next.add(index);\n   395→    }\n   396→    selectedIndices = next;\n   397→    selectionAnchor = index;\n   398→    lastSelectedIndex = index;\n   399→  }\n   400→\n   401→  function selectRange(index) {\n   402→    const anchor = selectionAnchor >= 0 ? selectionAnchor : index;\n   403→    const [from, to] = [Math.min(anchor, index), Math.max(anchor, index)];\n   404→    const next = new Set();\n   405→    for (let i = from; i <= to; i += 1) {\n   406→      next.add(i);\n   407→    }\n   408→    selectedIndices = next;\n   409→    lastSelectedIndex = index;\n   410→  }\n   411→\n   412→  function primaryEntry() {\n   413→    const idx = lastSelectedIndex >= 0 ? lastSelectedIndex : -1;\n   414→    return idx >= 0 ? results[idx] : null;\n   415→  }\n   416→\n   417→  async function refreshStatus() {\n   418→    if (statusRefreshInFlight) {\n   419→      return;\n   420→    }\n   421→    statusRefreshInFlight = true;\n   422→    try {\n   423→      const status = await invoke('get_index_status');\n   424→      const prevState = indexStatus.state;\n   425→      indexStatus = {\n   426→        state: status.state,\n   427→        entriesCount: status.entriesCount,\n   428→        lastUpdated: status.lastUpdated,\n   429→        permissionErrors: status.permissionErrors ?? 0,\n   430→        message: status.message\n   431→      };\n   432→      if (status.state === 'Indexing' && prevState !== 'Indexing') {\n   433→        startElapsedTimer();\n   434→      } else if (status.state !== 'Indexing' && prevState === 'Indexing') {\n   435→        stopElapsedTimer();\n   436→      }\n   437→      if (typeof status.scanned === 'number') {\n   438→        scanned = status.scanned;\n   439→      }\n   440→      if (status.state === 'Ready' && prevState !== 'Ready') {\n   441→        scheduleSearch();\n   442→      }\n   443→    } catch (err) {\n   444→      showToast(`Failed to get status: ${String(err)}`);\n   445→    } finally {\n   446→      statusRefreshInFlight = false;\n   447→    }\n   448→  }\n   449→\n   450→  function scheduleSearch(preserveScroll = false) {\n   451→    searchGeneration += 1;\n   452→    const scheduledGen = searchGeneration;\n   453→    clearTimeout(searchTimer);\n   454→\n   455→    const now = performance.now();\n   456→    if (now - lastSearchFiredAt >= 200) {\n   457→      // Leading edge: fire immediately if enough time has passed\n   458→      lastSearchFiredAt = now;\n   459→      void runSearch(preserveScroll);\n   460→    } else {\n   461→      // Trailing edge: debounce\n   462→      searchTimer = setTimeout(() => {\n   463→        if (scheduledGen !== searchGeneration) {\n   464→          return;\n   465→        }\n   466→        lastSearchFiredAt = performance.now();\n   467→        void runSearch(preserveScroll);\n   468→      }, 200);\n   469→    }\n   470→  }\n   471→\n   472→  async function runSearch(preserveScroll = false) {\n   473→    searchGeneration += 1;\n   474→    const gen = searchGeneration;\n   475→    const searchQuery = query;\n   476→    const searchSortBy = sortBy;\n   477→    const searchSortDir = sortDir;\n   478→    const startedAt = performance.now();\n   479→    try {\n   480→      const keepPaths = new Set(selectedPaths());\n   481→      const next = await invoke('search', {\n   482→        query: searchQuery,\n   483→        limit: PAGE_SIZE,\n   484→        offset: 0,\n   485→        sortBy: searchSortBy,\n   486→        sortDir: searchSortDir\n   487→      });\n   488→\n   489→      if (gen !== searchGeneration) return;\n   490→\n   491→      dbLatencyMs = Math.round(performance.now() - startedAt);\n   492→      dbLastQuery = searchQuery;\n   493→      const entries = Array.isArray(next.entries) ? next.entries : [];\n   494→      searchModeLabel = next.modeLabel || '';\n   495→      results = entries;\n   496→      if (next.totalCount > 0) {\n   497→        totalResults = next.totalCount;\n   498→        totalResultsKnown = true;\n   499→      } else {\n   500→        totalResults = entries.length;\n   501→        totalResultsKnown = false;\n   502→      }\n   503→      hasMore = totalResultsKnown ? results.length < totalResults : entries.length >= PAGE_SIZE;\n   504→      if (!preserveScroll && tableContainer) tableContainer.scrollTop = 0;\n   505→\n   506→      const restored = new Set();\n   507→      for (let i = 0; i < results.length; i += 1) {\n   508→        if (keepPaths.has(results[i].path)) {\n   509→          restored.add(i);\n   510→        }\n   511→      }\n   512→      selectedIndices = restored;\n   513→\n   514→      updateViewportHeight();\n   515→    } catch (err) {\n   516→      if (gen !== searchGeneration) return;\n   517→      showToast(`Search failed: ${String(err)}`);\n   518→    }\n   519→  }\n   520→\n   521→  async function loadMore() {\n   522→    if (!hasMore || loadingMore) return;\n   523→    const gen = searchGeneration;\n   524→    loadingMore = true;\n   525→    try {\n   526→      const batch = await invoke('search', {\n   527→        query,\n   528→        limit: PAGE_SIZE,\n   529→        offset: results.length,\n   530→        sortBy: sortBy,\n   531→        sortDir: sortDir\n   532→      });\n   533→      if (gen !== searchGeneration) return;\n   534→      const arr = Array.isArray(batch.entries) ? batch.entries : [];\n   535→      if (arr.length > 0) results = [...results, ...arr];\n   536→      hasMore = totalResultsKnown ? results.length < totalResults : arr.length >= PAGE_SIZE;\n   537→    } catch (err) {\n   538→      showToast(`Failed to load more: ${String(err)}`);\n   539→    } finally {\n   540→      loadingMore = false;\n   541→    }\n   542→  }\n   543→\n   544→  function moveSelection(delta, withRange = false) {\n   545→    if (results.length === 0) {\n   546→      return;\n   547→    }\n   548→\n   549→    const current = lastSelectedIndex >= 0 ? lastSelectedIndex : 0;\n   550→    const next = Math.max(0, Math.min(results.length - 1, current + delta));\n   551→\n   552→    if (withRange) {\n   553→      selectRange(next);\n   554→    } else {\n   555→      selectSingle(next);\n   556→    }\n   557→\n   558→    const top = next * rowHeight;\n   559→    const bottom = top + rowHeight;\n   560→    if (top < scrollTop) {\n   561→      tableContainer.scrollTop = top;\n   562→    } else if (bottom > scrollTop + viewportHeight) {\n   563→      tableContainer.scrollTop = bottom - viewportHeight;\n   564→    }\n   565→  }\n   566→\n   567→  function handleHeaderSort(column) {\n   568→    if (sortBy === column) {\n   569→      sortDir = sortDir === 'asc' ? 'desc' : 'asc';\n   570→    } else {\n   571→      sortBy = column;\n   572→      sortDir = 'asc';\n   573→    }\n   574→    if (tableContainer) tableContainer.scrollTop = 0;\n   575→    void runSearch();\n   576→  }\n   577→\n   578→  function handleRowClick(event, index) {\n   579→    contextMenu.visible = false;\n   580→\n   581→    if (event.shiftKey) {\n   582→      selectRange(index);\n   583→      return;\n   584→    }\n   585→\n   586→    if (event.metaKey || event.ctrlKey) {\n   587→      selectToggle(index);\n   588→      return;\n   589→    }\n   590→\n   591→    selectSingle(index);\n   592→  }\n   593→\n   594→  function handleRowContextMenu(event, index) {\n   595→    event.preventDefault();\n   596→\n   597→    if (!selectedIndices.has(index)) {\n   598→      selectSingle(index);\n   599→    }\n   600→\n   601→    if (platform === 'windows' || platform === 'macos') {\n   602→      contextMenu.visible = false;\n   603→      const paths = selectedPaths();\n   604→      if (paths.length > 0) {\n   605→        invoke('show_context_menu', {\n   606→          paths,\n   607→          x: event.clientX,\n   608→          y: event.clientY,\n   609→          singleSelection: selectedIndices.size === 1\n   610→        });\n   611→      }\n   612→      return;\n   613→    }\n   614→\n   615→    contextMenu = {\n   616→      visible: true,\n   617→      x: event.clientX,\n   618→      y: event.clientY\n   619→    };\n   620→  }\n   621→\n   622→  function handleRowA11yKeydown(event, index) {\n   623→    if (event.key === ' ' || event.key === 'Enter') {\n   624→      event.preventDefault();\n   625→      handleRowClick(event, index);\n   626→    }\n   627→  }\n   628→\n   629→  const DRAG_THRESHOLD = 5;\n   630→  let dragCleanup = null;\n   631→  const dragImgCache = new Map();\n   632→\n   633→  function dragPathsForIndex(index) {\n   634→    const entry = results[index];\n   635→    if (!entry) {\n   636→      return [];\n   637→    }\n   638→\n   639→    if (selectedIndices.has(index) && selectedIndices.size > 0) {\n   640→      return selectedPaths();\n   641→    }\n   642→\n   643→    return [entry.path];\n   644→  }\n   645→\n   646→  function getDragIconEl(entry) {\n   647→    const src = iconFor(entry);\n   648→    let img = dragImgCache.get(src);\n   649→    if (!img) {\n   650→      img = new Image();\n   651→      img.src = src;\n   652→      dragImgCache.set(src, img);\n   653→    }\n   654→    return img.complete && img.naturalWidth > 0 ? img : null;\n   655→  }\n   656→\n   657→  function fillRoundRect(ctx, x, y, w, h, r) {\n   658→    ctx.beginPath();\n   659→    ctx.moveTo(x + r, y);\n   660→    ctx.arcTo(x + w, y, x + w, y + h, r);\n   661→    ctx.arcTo(x + w, y + h, x, y + h, r);\n   662→    ctx.arcTo(x, y + h, x, y, r);\n   663→    ctx.arcTo(x, y, x + w, y, r);\n   664→    ctx.closePath();\n   665→    ctx.fill();\n   666→  }\n   667→\n   668→  function buildDragPreview(index) {\n   669→    const entry = results[index];\n   670→    if (!entry) return null;\n   671→\n   672→    const count = selectedIndices.has(index) ? selectedIndices.size : 1;\n   673→    const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\n   674→\n   675→    const w = 260;\n   676→    const h = 28;\n   677→    const stackGap = count > 1 ? 4 : 0;\n   678→\n   679→    const canvas = document.createElement('canvas');\n   680→    canvas.width = w;\n   681→    canvas.height = h + stackGap;\n   682→    const ctx = canvas.getContext('2d');\n   683→\n   684→    if (count > 1) {\n   685→      ctx.globalAlpha = 0.35;\n   686→      ctx.fillStyle = isDark ? '#5a6070' : '#b0c4de';\n   687→      fillRoundRect(ctx, 3, 0, w - 3, h, 5);\n   688→      ctx.globalAlpha = 1.0;\n   689→    }\n   690→\n   691→    const ry = stackGap;\n   692→    ctx.fillStyle = isDark ? 'rgba(58, 64, 74, 0.94)' : 'rgba(214, 231, 255, 0.94)';\n   693→    fillRoundRect(ctx, 0, ry, w, h, 5);\n   694→\n   695→    ctx.strokeStyle = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';\n   696→    ctx.lineWidth = 0.5;\n   697→    ctx.beginPath();\n   698→    ctx.moveTo(5, ry);\n   699→    ctx.arcTo(w, ry, w, ry + h, 5);\n   700→    ctx.arcTo(w, ry + h, 0, ry + h, 5);\n   701→    ctx.arcTo(0, ry + h, 0, ry, 5);\n   702→    ctx.arcTo(0, ry, w, ry, 5);\n   703→    ctx.closePath();\n   704→    ctx.stroke();\n   705→\n   706→    const iconEl = getDragIconEl(entry);\n   707→    if (iconEl) {\n   708→      ctx.drawImage(iconEl, 6, ry + 6, 16, 16);\n   709→    } else {\n   710→      ctx.fillStyle = entry.isDir ? '#d9b34f' : '#8d98a5';\n   711→      fillRoundRect(ctx, 6, ry + 6, 16, 16, 2);\n   712→    }\n   713→\n   714→    ctx.fillStyle = isDark ? '#e6e6e8' : '#1a1a1a';\n   715→    ctx.font = '12px -apple-system, \"SF Pro Text\", system-ui, sans-serif';\n   716→    ctx.textBaseline = 'middle';\n   717→\n   718→    let nameMaxW = w - 34;\n   719→    if (count > 1) nameMaxW -= 34;\n   720→\n   721→    let name = entry.name;\n   722→    if (ctx.measureText(name).width > nameMaxW) {\n   723→      while (name.length > 4 && ctx.measureText(name + '\\u2026').width > nameMaxW) {\n   724→        name = name.slice(0, -1);\n   725→      }\n   726→      name += '\\u2026';\n   727→    }\n   728→    ctx.fillText(name, 28, ry + h / 2 + 1);\n   729→\n   730→    if (count > 1) {\n   731→      const badge = String(count);\n   732→      ctx.font = 'bold 10px -apple-system, system-ui, sans-serif';\n   733→      const tw = ctx.measureText(badge).width;\n   734→      const bw = Math.max(20, tw + 10);\n   735→      const bx = w - bw - 6;\n   736→      const by = ry + (h - 18) / 2;\n   737→\n   738→      ctx.fillStyle = isDark ? '#5b8bd9' : '#007aff';\n   739→      fillRoundRect(ctx, bx, by, bw, 18, 9);\n   740→\n   741→      ctx.fillStyle = '#ffffff';\n   742→      ctx.textAlign = 'center';\n   743→      ctx.textBaseline = 'middle';\n   744→      ctx.fillText(badge, bx + bw / 2, by + 9);\n   745→    }\n   746→\n   747→    return canvas.toDataURL('image/png');\n   748→  }\n   749→\n   750→  function handleRowMouseDown(event, index) {\n   751→    if (event.button !== 0) return;\n   752→    if (event.metaKey || event.ctrlKey || event.shiftKey) return;\n   753→    if (editing.active) return;\n   754→\n   755→    const startX = event.clientX;\n   756→    const startY = event.clientY;\n   757→    let dragging = false;\n   758→\n   759→    dragCleanup?.();\n   760→\n   761→    const onMove = (e) => {\n   762→      if (dragging) return;\n   763→      const dx = e.clientX - startX;\n   764→      const dy = e.clientY - startY;\n   765→      if (dx * dx + dy * dy < DRAG_THRESHOLD * DRAG_THRESHOLD) return;\n   766→\n   767→      dragging = true;\n   768→      cleanup();\n   769→\n   770→      if (!selectedIndices.has(index)) {\n   771→        selectSingle(index);\n   772→      }\n   773→\n   774→      const paths = dragPathsForIndex(index);\n   775→      if (paths.length > 0) {\n   776→        const icon = buildDragPreview(index);\n   777→        startDrag({ item: paths, icon }).catch(() => {});\n   778→      }\n   779→    };\n   780→\n   781→    const onUp = () => cleanup();\n   782→\n   783→    const cleanup = () => {\n   784→      window.removeEventListener('mousemove', onMove);\n   785→      window.removeEventListener('mouseup', onUp);\n   786→      if (dragCleanup === cleanup) dragCleanup = null;\n   787→    };\n   788→\n   789→    dragCleanup = cleanup;\n   790→    window.addEventListener('mousemove', onMove);\n   791→    window.addEventListener('mouseup', onUp);\n   792→  }\n   793→\n   794→  async function handleRowDoubleClick(index) {\n   795→    if (!selectedIndices.has(index) || selectedIndices.size > 1) {\n   796→      selectSingle(index);\n   797→      await tick();\n   798→    }\n   799→    await invoke('open', { paths: [results[index].path] }).catch((err) => {\n   800→      showToast(`Failed to open: ${String(err)}`);\n   801→    });\n   802→  }\n   803→\n   804→  function closeContextMenu() {\n   805→    contextMenu = {\n   806→      ...contextMenu,\n   807→      visible: false\n   808→    };\n   809→  }\n   810→\n   811→  async function openSelected() {\n   812→    const paths = selectedPaths();\n   813→    if (paths.length === 0) {\n   814→      return;\n   815→    }\n   816→\n   817→    try {\n   818→      await invoke('open', { paths });\n   819→    } catch (err) {\n   820→      showToast(`Failed to open: ${String(err)}`);\n   821→    }\n   822→  }\n   823→\n   824→  async function openWithFallback() {\n   825→    const target = primaryEntry();\n   826→    if (!target) {\n   827→      return;\n   828→    }\n   829→\n   830→    try {\n   831→      await invoke('open_with', { path: target.path });\n   832→    } catch (err) {\n   833→      showToast(`Open With failed: ${String(err)}`);\n   834→    }\n   835→  }\n   836→\n   837→  async function revealSelected() {\n   838→    const paths = selectedPaths();\n   839→    if (paths.length === 0) {\n   840→      return;\n   841→    }\n   842→\n   843→    try {\n   844→      await invoke('reveal_in_finder', { paths });\n   845→    } catch (err) {\n   846→      showToast(`Failed to reveal in Finder: ${String(err)}`);\n   847→    }\n   848→  }\n   849→\n   850→  async function copySelectedPaths() {\n   851→    const paths = selectedPaths();\n   852→    if (paths.length === 0) {\n   853→      return;\n   854→    }\n   855→\n   856→    try {\n   857→      await invoke('copy_paths', { paths });\n   858→      showToast(`Copied ${paths.length} path(s)`);\n   859→    } catch (err) {\n   860→      showToast(`Failed to copy path: ${String(err)}`);\n   861→    }\n   862→  }\n   863→\n   864→  async function copyFiles() {\n   865→    const paths = selectedPaths();\n   866→    if (paths.length === 0) {\n   867→      return;\n   868→    }\n   869→\n   870→    try {\n   871→      await invoke('copy_files', { paths });\n   872→      showToast(`Copied ${paths.length} item(s)`);\n   873→    } catch (err) {\n   874→      showToast(`Failed to copy: ${String(err)}`);\n   875→    }\n   876→  }\n   877→\n   878→  async function trashSelected() {\n   879→    const paths = selectedPaths();\n   880→    if (paths.length === 0) {\n   881→      return;\n   882→    }\n   883→\n   884→    const message =\n   885→      paths.length === 1\n   886→        ? 'Move selected item to Trash?'\n   887→        : `Move ${paths.length} items to Trash?`;\n   888→\n   889→    if (!window.confirm(message)) {\n   890→      return;\n   891→    }\n   892→\n   893→    try {\n   894→      await invoke('move_to_trash', { paths });\n   895→      showToast('Moved to Trash.');\n   896→      clearSelection();\n   897→      await runSearch();\n   898→    } catch (err) {\n   899→      showToast(`Failed to move to Trash: ${String(err)}`);\n   900→    }\n   901→  }\n   902→\n   903→  async function resetIndex() {\n   904→    if (indexStatus.state === 'Indexing') {\n   905→      showToast('Indexing in progress. Please try again after it completes.');\n   906→      return;\n   907→    }\n   908→\n   909→    results = [];\n   910→    totalResults = 0;\n   911→    totalResultsKnown = false;\n   912→    clearSelection();\n   913→    scanned = 0;\n   914→    dbLatencyMs = null;\n   915→    dbLastQuery = '';\n   916→    indexStatus = { ...indexStatus, state: 'Indexing', entriesCount: 0, message: null };\n   917→    indexingStartTime = Date.now();\n   918→    indexingElapsed = '';\n   919→    indexingFinishedAt = '';\n   920→\n   921→    try {\n   922→      await invoke('reset_index');\n   923→    } catch (err) {\n   924→      showToast(`Failed to reset index: ${String(err)}`);\n   925→      await refreshStatus();\n   926→    }\n   927→  }\n   928→\n   929→  function isMultiSelected() {\n   930→    return selectedIndices.size > 1;\n   931→  }\n   932→\n   933→  async function startRename() {\n   934→    if (isMultiSelected()) {\n   935→      return;\n   936→    }\n   937→\n   938→    const idx = lastSelectedIndex;\n   939→    if (idx < 0 || !results[idx]) {\n   940→      return;\n   941→    }\n   942→\n   943→    const entry = results[idx];\n   944→    editing = {\n   945→      active: true,\n   946→      path: entry.path,\n   947→      index: idx,\n   948→      draftName: entry.name\n   949→    };\n   950→\n   951→    await tick();\n   952→\n   953→    if (renameInputEl) {\n   954→      renameInputEl.focus();\n   955→      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n   956→      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n   957→      renameInputEl.setSelectionRange(0, selectionEnd);\n   958→    }\n   959→  }\n   960→\n   961→  function cancelRename() {\n   962→    editing = {\n   963→      active: false,\n   964→      path: '',\n   965→      index: -1,\n   966→      draftName: ''\n   967→    };\n   968→  }\n   969→\n   970→  async function commitRename() {\n   971→    if (!editing.active || editing.index < 0 || !results[editing.index]) {\n   972→      return;\n   973→    }\n   974→\n   975→    const current = results[editing.index];\n   976→    const nextName = editing.draftName;\n   977→\n   978→    try {\n   979→      await invoke('rename', {\n   980→        path: current.path,\n   981→        newName: nextName\n   982→      });\n   983→      cancelRename();\n   984→      await runSearch();\n   985→    } catch (err) {\n   986→      showToast(`Failed to rename: ${String(err)}`);\n   987→      await tick();\n   988→      renameInputEl?.focus();\n   989→    }\n   990→  }\n   991→\n   992→  function onGlobalClick() {\n   993→    closeContextMenu();\n   994→  }\n   995→\n   996→  function onTitleBarMouseDown(event) {\n   997→    if (event.button !== 0) {\n   998→      return;\n   999→    }\n  1000→\n  1001→    const activeElement = document.activeElement;\n  1002→    if (activeElement instanceof HTMLElement && isTextInputTarget(activeElement)) {\n  1003→      activeElement.blur();\n  1004→    }\n  1005→  }\n  1006→\n  1007→  async function focusSearch() {\n  1008→    await getCurrentWindow().show();\n  1009→    await getCurrentWindow().setFocus();\n  1010→    searchInputEl?.focus();\n  1011→    searchInputEl?.select();\n  1012→  }\n  1013→\n  1014→  function isTextInputTarget(target) {\n  1015→    return (\n  1016→      target instanceof HTMLInputElement ||\n  1017→      target instanceof HTMLTextAreaElement ||\n  1018→      target?.isContentEditable\n  1019→    );\n  1020→  }\n  1021→\n  1022→  async function handleKeydown(event) {\n  1023→    const isMetaSelectAll = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'a';\n  1024→    const isMetaCopy = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c';\n  1025→    const target = event.target;\n  1026→    const isTextInput = isTextInputTarget(target);\n  1027→\n  1028→    if (isMetaCopy && isTextInput) {\n  1029→      return;\n  1030→    }\n  1031→\n  1032→    if (isMetaSelectAll) {\n  1033→      if (isTextInput) {\n  1034→        event.preventDefault();\n  1035→        if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n  1036→          target.select();\n  1037→        }\n  1038→        return;\n  1039→      }\n  1040→    }\n  1041→\n  1042→    if (editing.active) {\n  1043→      if (event.key === 'Enter') {\n  1044→        event.preventDefault();\n  1045→        await commitRename();\n  1046→        return;\n  1047→      }\n  1048→\n  1049→      if (event.key === 'Escape') {\n  1050→        event.preventDefault();\n  1051→        cancelRename();\n  1052→        searchInputEl?.focus();\n  1053→        return;\n  1054→      }\n  1055→      return;\n  1056→    }\n  1057→\n  1058→    if (event.key === 'Escape') {\n  1059→      event.preventDefault();\n  1060→      clearSelection();\n  1061→      searchInputEl?.focus();\n  1062→      return;\n  1063→    }\n  1064→\n  1065→    if (event.key === 'ArrowDown') {\n  1066→      event.preventDefault();\n  1067→      moveSelection(1, event.shiftKey);\n  1068→      return;\n  1069→    }\n  1070→\n  1071→    if (event.key === 'ArrowUp') {\n  1072→      event.preventDefault();\n  1073→      moveSelection(-1, event.shiftKey);\n  1074→      return;\n  1075→    }\n  1076→\n  1077→    if (event.key === 'PageDown') {\n  1078→      event.preventDefault();\n  1079→      moveSelection(Math.floor(viewportHeight / rowHeight), event.shiftKey);\n  1080→      return;\n  1081→    }\n  1082→\n  1083→    if (event.key === 'PageUp') {\n  1084→      event.preventDefault();\n  1085→      moveSelection(-Math.floor(viewportHeight / rowHeight), event.shiftKey);\n  1086→      return;\n  1087→    }\n  1088→\n  1089→    if (event.key === 'Enter') {\n  1090→      event.preventDefault();\n  1091→      if (platform === 'windows') {\n  1092→        await openSelected();\n  1093→      } else {\n  1094→        await startRename();\n  1095→      }\n  1096→      return;\n  1097→    }\n  1098→\n  1099→    if (event.key === 'F2') {\n  1100→      event.preventDefault();\n  1101→      await startRename();\n  1102→      return;\n  1103→    }\n  1104→\n  1105→    if (event.key === ' ' && !isTextInput) {\n  1106→      event.preventDefault();\n  1107→      const entry = primaryEntry();\n  1108→      if (entry) {\n  1109→        await invoke('quick_look', { path: entry.path });\n  1110→      }\n  1111→      return;\n  1112→    }\n  1113→\n  1114→    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'f') {\n  1115→      event.preventDefault();\n  1116→      clearSelection();\n  1117→      searchInputEl?.focus();\n  1118→      searchInputEl?.select();\n  1119→      return;\n  1120→    }\n  1121→\n  1122→    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'o') {\n  1123→      event.preventDefault();\n  1124→      await openSelected();\n  1125→      return;\n  1126→    }\n  1127→\n  1128→    if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {\n  1129→      event.preventDefault();\n  1130→      await revealSelected();\n  1131→      return;\n  1132→    }\n  1133→\n  1134→    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c') {\n  1135→      event.preventDefault();\n  1136→      await copySelectedPaths();\n  1137→      return;\n  1138→    }\n  1139→\n  1140→    if (isMetaSelectAll) {\n  1141→      event.preventDefault();\n  1142→      selectedIndices = new Set(Array.from({ length: results.length }, (_, i) => i));\n  1143→      return;\n  1144→    }\n  1145→\n  1146→    if (event.key === 'Delete' || ((event.metaKey || event.ctrlKey) && event.key === 'Backspace')) {\n  1147→      if (!isTextInput) {\n  1148→        event.preventDefault();\n  1149→        await trashSelected();\n  1150→      }\n  1151→      return;\n  1152→    }\n  1153→  }\n  1154→\n  1155→  function formatSize(entry) {\n  1156→    if (entry.isDir || entry.size == null) return '';\n  1157→    const bytes = entry.size;\n  1158→    if (bytes < 1024) return `${bytes} B`;\n  1159→    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n  1160→    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n  1161→    return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n  1162→  }\n  1163→\n  1164→  function formatModified(entry) {\n  1165→    if (!entry.mtime) {\n  1166→      return '';\n  1167→    }\n  1168→\n  1169→    const d = new Date(entry.mtime * 1000);\n  1170→    const pad = (n) => String(n).padStart(2, '0');\n  1171→    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;\n  1172→  }\n  1173→\n  1174→  function formatLastUpdated(timestamp) {\n  1175→    if (!timestamp) {\n  1176→      return '-';\n  1177→    }\n  1178→\n  1179→    return new Date(timestamp * 1000).toLocaleString();\n  1180→  }\n  1181→\n  1182→  function formatElapsed(ms) {\n  1183→    const totalSec = Math.floor(ms / 1000);\n  1184→    const min = Math.floor(totalSec / 60);\n  1185→    const sec = totalSec % 60;\n  1186→    return min > 0 ? `${min}m ${sec}s` : `${sec}s`;\n  1187→  }\n  1188→\n  1189→  function updateElapsed() {\n  1190→    if (indexingStartTime && indexStatus.state === 'Indexing') {\n  1191→      indexingElapsed = formatElapsed(Date.now() - indexingStartTime);\n  1192→    }\n  1193→  }\n  1194→\n  1195→  function startElapsedTimer() {\n  1196→    clearInterval(elapsedTimer);\n  1197→    indexingStartTime = Date.now();\n  1198→    indexingElapsed = '0s';\n  1199→    indexingFinishedAt = '';\n  1200→    elapsedTimer = setInterval(updateElapsed, 1000);\n  1201→  }\n  1202→\n  1203→  function stopElapsedTimer() {\n  1204→    clearInterval(elapsedTimer);\n  1205→    if (indexingStartTime) {\n  1206→      const elapsed = Date.now() - indexingStartTime;\n  1207→      indexingFinishedAt = `${formatElapsed(elapsed)}`;\n  1208→    }\n  1209→    indexingStartTime = null;\n  1210→    indexingElapsed = '';\n  1211→  }\n  1212→\n  1213→  function displayPath(path) {\n  1214→    if (!path) {\n  1215→      return path;\n  1216→    }\n  1217→\n  1218→    if (!homePrefix) {\n  1219→      return path;\n  1220→    }\n  1221→\n  1222→    if (path === homePrefix) {\n  1223→      return '~';\n  1224→    }\n  1225→\n  1226→    if (path.startsWith(`${homePrefix}/`)) {\n  1227→      return `~${path.slice(homePrefix.length)}`;\n  1228→    }\n  1229→\n  1230→    return path;\n  1231→  }\n  1232→\n  1233→  let unlistenFns = [];\n  1234→\n  1235→  onMount(async () => {\n  1236→    const t0 = performance.now();\n  1237→    const ms = () => Math.round(performance.now() - t0);\n  1238→    const DEBUG_STARTUP = false;\n  1239→    const flog = DEBUG_STARTUP ? (msg) => invoke('frontend_log', { msg }).catch(() => {}) : () => {};\n  1240→\n  1241→    flog(`[startup/fe] onMount entered`);\n  1242→\n  1243→    updateViewportHeight();\n  1244→    flog(`[startup/fe] +${ms()}ms updateViewportHeight done`);\n  1245→\n  1246→    platform = await invoke('get_platform');\n  1247→    flog(`[startup/fe] +${ms()}ms get_platform done`);\n  1248→\n  1249→    const unlistenProgress = await listen('index_progress', (event) => {\n  1250→      scanned = event.payload.scanned;\n  1251→      if (indexStatus.state !== 'Indexing') {\n  1252→        indexStatus = {\n  1253→          ...indexStatus,\n  1254→          state: 'Indexing'\n  1255→        };\n  1256→      }\n  1257→    });\n  1258→    flog(`[startup/fe] +${ms()}ms listen(index_progress) registered`);\n  1259→\n  1260→    const unlistenState = await listen('index_state', (event) => {\n  1261→      flog(`[startup/fe] index_state event received: ${event.payload.state} at +${ms()}ms`);\n  1262→      const prevState = indexStatus.state;\n  1263→      indexStatus = {\n  1264→        ...indexStatus,\n  1265→        state: event.payload.state,\n  1266→        message: event.payload.message ?? null,\n  1267→        isCatchup: event.payload.isCatchup ?? false\n  1268→      };\n  1269→\n  1270→      if (event.payload.state === 'Indexing' && prevState !== 'Indexing') {\n  1271→        if (prevState === 'Ready') {\n  1272→          lastReadyCount = indexStatus.entriesCount;\n  1273→        }\n  1274→        startElapsedTimer();\n  1275→      } else if (event.payload.state !== 'Indexing' && prevState === 'Indexing') {\n  1276→        stopElapsedTimer();\n  1277→      }\n  1278→\n  1279→      if (event.payload.state === 'Ready') {\n  1280→        scheduleSearch();\n  1281→      }\n  1282→    });\n  1283→    flog(`[startup/fe] +${ms()}ms listen(index_state) registered`);\n  1284→\n  1285→    const unlistenUpdated = await listen('index_updated', (event) => {\n  1286→      indexStatus = {\n  1287→        ...indexStatus,\n  1288→        entriesCount: event.payload.entriesCount,\n  1289→        lastUpdated: event.payload.lastUpdated,\n  1290→        permissionErrors: event.payload.permissionErrors ?? indexStatus.permissionErrors\n  1291→      };\n  1292→\n  1293→      scheduleSearch(true);\n  1294→    });\n  1295→\n  1296→    const unlistenFocus = await listen('focus_search', () => {\n  1297→      void focusSearch();\n  1298→    });\n  1299→\n  1300→    const unlistenCtxMenuAction = await listen('context_menu_action', (event) => {\n  1301→      switch (event.payload) {\n  1302→        case 'open': void openSelected(); break;\n  1303→        case 'quick_look': {\n  1304→          const e = primaryEntry();\n  1305→          if (e) void invoke('quick_look', { path: e.path });\n  1306→          break;\n  1307→        }\n  1308→        case 'open_with': void openWithFallback(); break;\n  1309→        case 'reveal': void revealSelected(); break;\n  1310→        case 'copy_files': void copyFiles(); break;\n  1311→        case 'copy_path': void copySelectedPaths(); break;\n  1312→        case 'trash': void trashSelected(); break;\n  1313→        case 'rename': void startRename(); break;\n  1314→      }\n  1315→    });\n  1316→\n  1317→    unlistenFns = [unlistenProgress, unlistenState, unlistenUpdated, unlistenFocus, unlistenCtxMenuAction];\n  1318→    flog(`[startup/fe] +${ms()}ms all listeners registered`);\n  1319→\n  1320→    // Fetch backend state IMMEDIATELY after listeners are registered.\n  1321→    // Events emitted before listener registration are lost, so this\n  1322→    // is the only reliable way to get the current state.\n  1323→    await refreshStatus();\n  1324→    flog(`[startup/fe] +${ms()}ms refreshStatus done (state=${indexStatus.state})`);\n  1325→\n  1326→    // Show Svelte UI: remove skeleton, focus search input.\n  1327→    await tick();\n  1328→    document.getElementById('skeleton')?.remove();\n  1329→    await focusSearch();\n  1330→    flog(`[startup/fe] +${ms()}ms WINDOW VISIBLE — skeleton removed`);\n  1331→\n  1332→    try {\n  1333→      homePrefix = await invoke('get_home_dir');\n  1334→    } catch {\n  1335→      homePrefix = '';\n  1336→    }\n  1337→    flog(`[startup/fe] +${ms()}ms get_home_dir done`);\n  1338→\n  1339→    if (!localStorage.getItem('everything-fda-notice-v1')) {\n  1340→      showToast('macOS Full Disk Access permission may be required for full disk search.');\n  1341→      localStorage.setItem('everything-fda-notice-v1', '1');\n  1342→    }\n  1343→    flog(`[startup/fe] +${ms()}ms calling runSearch...`);\n  1344→    await runSearch();\n  1345→    flog(`[startup/fe] +${ms()}ms runSearch done`);\n  1346→\n  1347→    if (typeof ResizeObserver !== 'undefined') {\n  1348→      tableResizeObserver = new ResizeObserver(() => {\n  1349→        scheduleViewportHeightUpdate();\n  1350→      });\n  1351→      if (tableContainer) {\n  1352→        tableResizeObserver.observe(tableContainer);\n  1353→      } else if (tableAreaEl) {\n  1354→        tableResizeObserver.observe(tableAreaEl);\n  1355→      }\n  1356→    }\n  1357→\n  1358→    window.addEventListener('resize', scheduleViewportHeightUpdate);\n  1359→    window.addEventListener('click', onGlobalClick);\n  1360→    statusRefreshTimer = setInterval(() => {\n  1361→      if (indexStatus.state === 'Indexing') {\n  1362→        void refreshStatus();\n  1363→      }\n  1364→    }, 1000);\n  1365→    console.log(`[startup/fe] +${ms()}ms onMount complete`);\n  1366→  });\n  1367→\n  1368→  onDestroy(async () => {\n  1369→    clearTimeout(searchTimer);\n  1370→    clearTimeout(toastTimer);\n  1371→    clearInterval(statusRefreshTimer);\n  1372→    clearInterval(elapsedTimer);\n  1373→    resizeCleanup?.();\n  1374→\n  1375→    for (const unlisten of unlistenFns) {\n  1376→      unlisten();\n  1377→    }\n  1378→\n  1379→    tableResizeObserver?.disconnect();\n  1380→    tableResizeObserver = null;\n  1381→    if (viewportResizeRaf !== null) {\n  1382→      cancelAnimationFrame(viewportResizeRaf);\n  1383→      viewportResizeRaf = null;\n  1384→    }\n  1385→    window.removeEventListener('resize', scheduleViewportHeightUpdate);\n  1386→    window.removeEventListener('click', onGlobalClick);\n  1387→  });\n  1388→</script>\n  1389→\n  1390→<svelte:window on:keydown={handleKeydown} />\n  1391→\n  1392→<div class=\"app-shell\" data-theme={theme}>\n  1393→  <div class=\"title-bar\" role=\"presentation\" data-tauri-drag-region on:mousedown={onTitleBarMouseDown}>\n  1394→    <div class=\"title-left\"></div>\n  1395→    <div class=\"title-center\">\n  1396→      <svg class=\"title-icon\" viewBox=\"0 0 215 205\" fill-rule=\"evenodd\" aria-hidden=\"true\">\n  1397→        <path d=\"M85 0c46.9 0 85 38.1 85 85 0 20.1-7.2 38.5-19.2 52.7l40.7 40.8c5.8 5.8 5.8 15.2 0 21-5.8 5.8-15.2 5.8-21 0l-40.7-40.7c-13.6 9.7-30.4 15.2-44.8 15.2-46.9 0-85-42.1-85-89 0-46.9 38.1-85 85-85z m0 32c-29.3 0-53 23.7-53 53 0 29.3 23.7 53 53 53 29.3 0 53-23.7 53-53 0-29.3-23.7-53-53-53z\"/>\n  1398→      </svg>\n  1399→      <span class=\"title-text\">Everything</span>\n  1400→    </div>\n  1401→    <div class=\"title-right\"></div>\n  1402→  </div>\n  1403→\n  1404→  <header class=\"search-bar\">\n  1405→    <input\n  1406→      bind:this={searchInputEl}\n  1407→      class=\"search-input\"\n  1408→      type=\"text\"\n  1409→      bind:value={query}\n  1410→      on:input={scheduleSearch}\n  1411→      on:focus={clearSelection}\n  1412→      placeholder=\"Search file/folder names\"\n  1413→      autocomplete=\"off\"\n  1414→      spellcheck=\"false\"\n  1415→    />\n  1416→  </header>\n  1417→\n  1418→  <section class=\"table-area\" bind:this={tableAreaEl} style={tableGridStyle}>\n  1419→    <div class=\"table-header\">\n  1420→      <div class=\"table-header-track\">\n  1421→        <div class=\"col name\">\n  1422→          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('name')}>\n  1423→            Name{#if sortBy === 'name'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n  1424→          </button>\n  1425→          <button\n  1426→            type=\"button\"\n  1427→            class=\"col-resizer\"\n  1428→            class:active={resizingColumn === 'name'}\n  1429→            on:mousedown={(event) => startColumnResize(event, 'name')}\n  1430→            aria-label=\"Resize Name column\"\n  1431→          />\n  1432→        </div>\n  1433→\n  1434→        <div class=\"col path\">\n  1435→          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('dir')}>\n  1436→            Path{#if sortBy === 'dir'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n  1437→          </button>\n  1438→          <button\n  1439→            type=\"button\"\n  1440→            class=\"col-resizer\"\n  1441→            class:active={resizingColumn === 'path'}\n  1442→            on:mousedown={(event) => startColumnResize(event, 'path')}\n  1443→            aria-label=\"Resize Path column\"\n  1444→          />\n  1445→        </div>\n  1446→\n  1447→        <div class=\"col size\">\n  1448→          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('size')}>\n  1449→            Size{#if sortBy === 'size'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n  1450→          </button>\n  1451→        </div>\n  1452→\n  1453→        <div class=\"col modified\">\n  1454→          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('mtime')}>\n  1455→            Modified{#if sortBy === 'mtime'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n  1456→          </button>\n  1457→        </div>\n  1458→      </div>\n  1459→    </div>\n  1460→\n  1461→    <div\n  1462→      class=\"table-body\"\n  1463→      bind:this={tableContainer}\n  1464→      on:scroll={() => {\n  1465→        scrollTop = tableContainer.scrollTop;\n  1466→        headerScrollLeft = tableContainer.scrollLeft;\n  1467→        const scrollBottom = scrollTop + tableContainer.clientHeight;\n  1468→        if (scrollBottom >= totalHeight - rowHeight * 10) {\n  1469→          void loadMore();\n  1470→        }\n  1471→      }}\n  1472→    >\n  1473→      <div class=\"spacer\" style={`height:${totalHeight}px`}>\n  1474→        <div class=\"rows\" style={`transform: translateY(${translateY}px);`}>\n  1475→          {#each visibleRows as entry, localIndex}\n  1476→            {@const index = startIndex + localIndex}\n  1477→            <div\n  1478→              class=\"row {selectedIndices.has(index) ? 'selected' : ''} {editing.active && editing.index === index ? 'renaming' : ''}\"\n  1479→              on:mousedown={(event) => handleRowMouseDown(event, index)}\n  1480→              on:click={(event) => handleRowClick(event, index)}\n  1481→              on:keydown={(event) => handleRowA11yKeydown(event, index)}\n  1482→              on:dblclick={() => handleRowDoubleClick(index)}\n  1483→              on:contextmenu={(event) => handleRowContextMenu(event, index)}\n  1484→              role=\"row\"\n  1485→              tabindex=\"0\"\n  1486→            >\n  1487→              <div class=\"cell name\">\n  1488→                <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n  1489→\n  1490→                {#if editing.active && editing.index === index}\n  1491→                  <span class=\"rename-wrapper\">\n  1492→                    <span class=\"rename-sizer\" aria-hidden=\"true\">{editing.draftName || '\\u00A0'}</span>\n  1493→                    <textarea\n  1494→                      bind:this={renameInputEl}\n  1495→                      class=\"rename-input\"\n  1496→                      bind:value={editing.draftName}\n  1497→                      rows=\"1\"\n  1498→                      on:click|stopPropagation\n  1499→                      on:blur={commitRename}\n  1500→                      on:keydown={(e) => { if (e.key === 'Enter') e.preventDefault(); }}\n  1501→                    />\n  1502→                  </span>\n  1503→                {:else}\n  1504→                  <span class=\"ellipsis\">{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n  1505→                {/if}\n  1506→              </div>\n  1507→              <div class=\"cell path\"><span class=\"ellipsis\">{displayPath(entry.dir)}</span></div>\n  1508→              <div class=\"cell size\">{formatSize(entry)}</div>\n  1509→              <div class=\"cell modified\">{formatModified(entry)}</div>\n  1510→            </div>\n  1511→          {/each}\n  1512→        </div>\n  1513→      </div>\n  1514→    </div>\n  1515→  </section>\n  1516→\n  1517→  <footer class=\"status-bar\">\n  1518→    <div class=\"status-left\">\n  1519→      <span class=\"status-state\">\n  1520→        <span class=\"state-dot {indexStatus.state === 'Indexing' ? 'indexing' : indexStatus.state === 'Error' ? 'error' : 'ready'}\"></span>\n  1521→        {#if indexStatus.state === 'Indexing'}\n  1522→          Indexing{#if lastReadyCount > 0} ({Math.min(99, Math.round((scanned / lastReadyCount) * 100))}%){/if}{#if indexingElapsed} · {indexingElapsed}{/if}\n  1523→          {#if !indexStatus.isCatchup}\n  1524→            · {scanned.toLocaleString()} scanned\n  1525→          {/if}\n  1526→        {:else}\n  1527→          Index: {indexStatus.state}\n  1528→        {/if}\n  1529→      </span>\n  1530→      <span>{indexStatus.entriesCount.toLocaleString()} entries</span>\n  1531→      {#if indexingFinishedAt && indexStatus.state !== 'Indexing'}\n  1532→        <span>in {indexingFinishedAt}</span>\n  1533→      {/if}\n  1534→      {#if dbLatencyMs !== null && dbLastQuery}\n  1535→        <span>\"{dbLastQuery}\" {dbLatencyMs}ms · {totalResults} results</span>\n  1536→      {/if}\n  1537→      {#if searchModeLabel === 'spotlight' || searchModeLabel === 'spotlight_timeout'}\n  1538→        <span class=\"status-spotlight\">Spotlight fallback{#if searchModeLabel === 'spotlight_timeout'} (partial){/if}</span>\n  1539→      {/if}\n  1540→      {#if indexStatus.permissionErrors > 0}\n  1541→        <span class=\"status-warning\">{indexStatus.permissionErrors.toLocaleString()} permission errors</span>\n  1542→      {/if}\n  1543→      {#if indexStatus.message}\n  1544→        <span class={indexStatus.isCatchup ? 'index-progress' : 'status-error'}>{indexStatus.message}</span>\n  1545→      {/if}\n  1546→    </div>\n  1547→    <div class=\"status-right\">\n  1548→      <button class=\"status-btn theme-btn\" on:click={cycleTheme} title=\"Switch theme\">\n  1549→        {theme === 'dark' ? '☀ Light' : '◑ Dark'}\n  1550→      </button>\n  1551→      <button\n  1552→        class=\"status-btn rebuild-btn\"\n  1553→        on:click={resetIndex}\n  1554→        disabled={indexStatus.state === 'Indexing'}\n  1555→        title={indexStatus.state === 'Indexing' ? 'Cannot reset while indexing is in progress.' : 'Reset and rebuild the index.'}\n  1556→      >\n  1557→        <svg class=\"rebuild-icon\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n  1558→          <path d=\"M23 4v6h-6\"/><path d=\"M20.49 15a9 9 0 1 1-2.12-9.36L23 10\"/>\n  1559→        </svg>\n  1560→        Rebuild Index\n  1561→      </button>\n  1562→    </div>\n  1563→  </footer>\n  1564→\n  1565→  {#if contextMenu.visible}\n  1566→    <div class=\"context-menu\" style={`left:${contextMenu.x}px;top:${contextMenu.y}px;`}>\n  1567→      <button on:click={() => (closeContextMenu(), openSelected())}>Open</button>\n  1568→      <button on:click={async () => { closeContextMenu(); const e = primaryEntry(); if (e) await invoke('quick_look', { path: e.path }); }}>Quick Look</button>\n  1569→      <button on:click={() => (closeContextMenu(), openWithFallback())}>Open With... (Reveal in Finder)</button>\n  1570→      <button on:click={() => (closeContextMenu(), revealSelected())}>Reveal in Finder</button>\n  1571→      <button on:click={() => (closeContextMenu(), copySelectedPaths())}>Copy Path</button>\n  1572→      <button on:click={() => (closeContextMenu(), trashSelected())}>Move to Trash</button>\n  1573→      {#if selectedIndices.size === 1}\n  1574→        <button on:click={() => (closeContextMenu(), startRename())}>Rename</button>\n  1575→      {/if}\n  1576→    </div>\n  1577→  {/if}\n  1578→\n  1579→  {#if toast}\n  1580→    <div class=\"toast\">{toast}</div>\n  1581→  {/if}\n  1582→</div>\n  1583→\n  1584→<style>\n  1585→  :global(:root) {\n  1586→    color-scheme: light dark;\n  1587→    --bg-app: transparent;\n  1588→    --text-primary: #0d1826;\n  1589→    --text-muted: #48596c;\n  1590→    --bar-grad-top: rgba(255, 255, 255, 0.48);\n  1591→    --bar-grad-bottom: rgba(248, 250, 253, 0.42);\n  1592→    --surface-header: rgba(252, 252, 255, 0.40);\n  1593→    --surface: rgba(255, 255, 255, 0.22);\n  1594→    --border-soft: rgba(0, 0, 0, 0.07);\n  1595→    --border-input: rgba(0, 0, 0, 0.13);\n  1596→    --focus-ring: #6f96e6;\n  1597→    --row-border: rgba(0, 0, 0, 0.032);\n  1598→    --row-hover: rgba(0, 0, 0, 0.06);\n  1599→    --row-selected: rgba(0, 0, 0, 0.12);\n  1600→    --button-bg: rgba(255, 255, 255, 0.62);\n  1601→    --button-border: rgba(0, 0, 0, 0.10);\n  1602→    --button-text: #2c3e50;\n  1603→    --menu-bg: rgba(240, 241, 248, 0.90);\n  1604→    --menu-border: rgba(0, 0, 0, 0.06);\n  1605→    --menu-hover: rgba(255, 255, 255, 0.62);\n  1606→    --menu-text: #1a2a38;\n  1607→    --error-text: #b64545;\n  1608→    --warning-text: #8f6500;\n  1609→    --toast-bg: rgba(18, 22, 32, 0.90);\n  1610→    --toast-text: #ffffff;\n  1611→  }\n  1612→\n  1613→  @media (prefers-color-scheme: dark) {\n  1614→    :global(:root) {\n  1615→      --bg-app: transparent;\n  1616→      --text-primary: #e6e6ea;\n  1617→      --text-muted: #9494a4;\n  1618→      --bar-grad-top: rgba(38, 38, 46, 0.52);\n  1619→      --bar-grad-bottom: rgba(30, 30, 38, 0.46);\n  1620→      --surface-header: rgba(32, 32, 40, 0.46);\n  1621→      --surface: rgba(18, 18, 26, 0.32);\n  1622→      --border-soft: rgba(255, 255, 255, 0.065);\n  1623→      --border-input: rgba(255, 255, 255, 0.14);\n  1624→      --focus-ring: #5b8bd9;\n  1625→      --row-border: rgba(255, 255, 255, 0.026);\n  1626→      --row-hover: rgba(255, 255, 255, 0.08);\n  1627→      --row-selected: rgba(255, 255, 255, 0.14);\n  1628→      --button-bg: rgba(255, 255, 255, 0.072);\n  1629→      --button-border: rgba(255, 255, 255, 0.11);\n  1630→      --button-text: #d6d6e0;\n  1631→      --menu-bg: rgba(36, 36, 46, 0.90);\n  1632→      --menu-border: rgba(255, 255, 255, 0.066);\n  1633→      --menu-hover: rgba(255, 255, 255, 0.062);\n  1634→      --menu-text: #e0e0e8;\n  1635→      --error-text: #ff9d9d;\n  1636→      --warning-text: #e0c670;\n  1637→      --toast-bg: rgba(10, 10, 16, 0.93);\n  1638→      --toast-text: #f2f2f6;\n  1639→    }\n  1640→  }\n  1641→\n  1642→  /* ── Theme: Dark ──────────────────────────────────────────────── */\n  1643→  :global([data-theme=\"dark\"]) {\n  1644→    color-scheme: dark;\n  1645→    --bg-app: #1E1E21;\n  1646→    --text-primary: #E2E8F0;\n  1647→    --text-muted: #94A3B8;\n  1648→    --bar-grad-top: #1E1E21;\n  1649→    --bar-grad-bottom: #1E1E21;\n  1650→    --surface-header: #1E1E21;\n  1651→    --surface: #1E1E21;\n  1652→    --bg-input: #161618;\n  1653→    --border-soft: #2A2A2D;\n  1654→    --border-input: rgba(255, 255, 255, 0.06);\n  1655→    --focus-ring: #4DA8FF;\n  1656→    --accent: #4DA8FF;\n  1657→    --row-border: rgba(255, 255, 255, 0.02);\n  1658→    --row-hover: #282828;\n  1659→    --row-selected: rgba(77, 168, 255, 0.10);\n  1660→    --button-bg: rgba(255, 255, 255, 0.05);\n  1661→    --button-border: #2A2A2D;\n  1662→    --button-text: #94A3B8;\n  1663→    --menu-bg: #252528;\n  1664→    --menu-border: #2A2A2D;\n  1665→    --menu-hover: rgba(255, 255, 255, 0.04);\n  1666→    --menu-text: #E2E8F0;\n  1667→    --error-text: #ff9d9d;\n  1668→    --warning-text: #e0c670;\n  1669→    --toast-bg: rgba(10, 10, 16, 0.93);\n  1670→    --toast-text: #f2f2f6;\n  1671→  }\n  1672→\n  1673→  /* ── Theme: Light ─────────────────────────────────────────────── */\n  1674→  :global([data-theme=\"light\"]) {\n  1675→    color-scheme: light;\n  1676→    --bg-app: #F5F5F7;\n  1677→    --text-primary: #1C1C1E;\n  1678→    --text-muted: #6E6E7A;\n  1679→    --bar-grad-top: #F5F5F7;\n  1680→    --bar-grad-bottom: #F5F5F7;\n  1681→    --surface-header: #F5F5F7;\n  1682→    --surface: #F5F5F7;\n  1683→    --bg-input: #FFFFFF;\n  1684→    --border-soft: #D1D1D6;\n  1685→    --border-input: rgba(0, 0, 0, 0.10);\n  1686→    --focus-ring: #3A8BF5;\n  1687→    --accent: #3A8BF5;\n  1688→    --row-border: rgba(0, 0, 0, 0.04);\n  1689→    --row-hover: rgba(0, 0, 0, 0.04);\n  1690→    --row-selected: rgba(58, 139, 245, 0.10);\n  1691→    --button-bg: #FFFFFF;\n  1692→    --button-border: #D1D1D6;\n  1693→    --button-text: #3C3C43;\n  1694→    --menu-bg: #FFFFFF;\n  1695→    --menu-border: #D1D1D6;\n  1696→    --menu-hover: rgba(0, 0, 0, 0.05);\n  1697→    --menu-text: #1C1C1E;\n  1698→    --error-text: #D93025;\n  1699→    --warning-text: #B45309;\n  1700→    --toast-bg: rgba(255, 255, 255, 0.95);\n  1701→    --toast-text: #1C1C1E;\n  1702→  }\n  1703→\n  1704→  /* ── Themed element overrides ─────────────────────────────────── */\n  1705→  :global([data-theme]) {\n  1706→    background: var(--bg-app);\n  1707→  }\n  1708→\n  1709→  /* Search bar: flat, no gradient, no separator */\n  1710→  :global([data-theme]) .search-bar {\n  1711→    height: 44px;\n  1712→    padding: 0 16px;\n  1713→    background: var(--bg-app);\n  1714→    border-bottom: none;\n  1715→  }\n  1716→\n  1717→  :global([data-theme]) .search-input {\n  1718→    backdrop-filter: none;\n  1719→    -webkit-backdrop-filter: none;\n  1720→    font-family: 'JetBrains Mono', 'SF Mono', monospace;\n  1721→    font-size: 12px;\n  1722→    height: 34px;\n  1723→    border-radius: 8px;\n  1724→  }\n  1725→\n  1726→  /* Table header: flat bg, 16px edge padding */\n  1727→  :global([data-theme]) .table-header {\n  1728→    background: var(--bg-app);\n  1729→  }\n  1730→\n  1731→  :global([data-theme]) .col-button {\n  1732→    padding: 0 8px;\n  1733→  }\n  1734→\n  1735→  :global([data-theme]) .col.name .col-button {\n  1736→    padding-left: 16px;\n  1737→  }\n  1738→\n  1739→  /* Row cells: JetBrains Mono, 16px outer edges */\n  1740→  :global([data-theme]) .cell {\n  1741→    font-family: 'JetBrains Mono', monospace;\n  1742→  }\n  1743→\n  1744→  :global([data-theme]) .cell.name {\n  1745→    font-family: Inter, 'SF Pro Text', sans-serif;\n  1746→    padding-left: 16px;\n  1747→    font-size: 12px;\n  1748→    color: var(--text-primary);\n  1749→  }\n  1750→\n  1751→  :global([data-theme]) .cell.path {\n  1752→    font-size: 11px;\n  1753→  }\n  1754→\n  1755→  :global([data-theme]) .cell.size {\n  1756→    font-size: 11px;\n  1757→  }\n  1758→\n  1759→  :global([data-theme]) .cell.modified {\n  1760→    padding-right: 16px;\n  1761→    font-size: 11px;\n  1762→    white-space: nowrap;\n  1763→  }\n  1764→\n  1765→  :global([data-theme]) .row.selected {\n  1766→    box-shadow: inset 3px 0 0 var(--accent);\n  1767→  }\n  1768→\n  1769→  /* Dim path/size/date cells in themed mode */\n  1770→  :global([data-theme]) .cell.path,\n  1771→  :global([data-theme]) .cell.size,\n  1772→  :global([data-theme]) .cell.modified {\n  1773→    color: var(--text-muted);\n  1774→  }\n  1775→\n  1776→  :global(:root) {\n  1777→    background: transparent;\n  1778→  }\n  1779→\n  1780→  :global(html, body) {\n  1781→    margin: 0;\n  1782→    width: 100%;\n  1783→    height: 100%;\n  1784→    overflow: hidden;\n  1785→    background: transparent;\n  1786→    color: var(--text-primary);\n  1787→    font-family: Inter, 'SF Pro Text', 'Segoe UI', Helvetica, Arial, sans-serif;\n  1788→  }\n  1789→\n  1790→  :global(#app) {\n  1791→    width: 100%;\n  1792→    height: 100%;\n  1793→  }\n  1794→\n  1795→  .app-shell {\n  1796→    display: grid;\n  1797→    grid-template-rows: auto auto 1fr auto;\n  1798→    height: 100%;\n  1799→    min-width: 0;\n  1800→  }\n  1801→\n  1802→  .title-bar {\n  1803→    display: flex;\n  1804→    align-items: center;\n  1805→    justify-content: space-between;\n  1806→    height: 44px;\n  1807→    padding: 0 16px;\n  1808→    background: var(--surface-header);\n  1809→    cursor: default;\n  1810→    flex-shrink: 0;\n  1811→    user-select: none;\n  1812→    -webkit-user-select: none;\n  1813→  }\n  1814→\n  1815→  .title-left {\n  1816→    width: 72px;\n  1817→    pointer-events: none;\n  1818→    user-select: none;\n  1819→    -webkit-user-select: none;\n  1820→  }\n  1821→\n  1822→  .title-center {\n  1823→    display: flex;\n  1824→    align-items: center;\n  1825→    gap: 8px;\n  1826→    pointer-events: none;\n  1827→    user-select: none;\n  1828→    -webkit-user-select: none;\n  1829→  }\n  1830→\n  1831→  .title-right {\n  1832→    width: 72px;\n  1833→    pointer-events: none;\n  1834→    user-select: none;\n  1835→    -webkit-user-select: none;\n  1836→  }\n  1837→\n  1838→  .title-icon {\n  1839→    width: 14px;\n  1840→    height: 14px;\n  1841→    fill: var(--accent);\n  1842→    flex-shrink: 0;\n  1843→  }\n  1844→\n  1845→  .title-text {\n  1846→    font-family: Inter, 'SF Pro Text', sans-serif;\n  1847→    font-size: 13px;\n  1848→    font-weight: 500;\n  1849→    color: var(--text-primary);\n  1850→    letter-spacing: -0.01em;\n  1851→  }\n  1852→\n  1853→  .search-bar {\n  1854→    display: flex;\n  1855→    align-items: center;\n  1856→    gap: 6px;\n  1857→    padding: 8px;\n  1858→    background: linear-gradient(180deg, var(--bar-grad-top) 0%, var(--bar-grad-bottom) 100%);\n  1859→    border-bottom: 1px solid var(--border-soft);\n  1860→    min-width: 0;\n  1861→    flex-shrink: 0;\n  1862→  }\n  1863→\n  1864→  .search-input {\n  1865→    display: block;\n  1866→    box-sizing: border-box;\n  1867→    width: 100%;\n  1868→    min-width: 0;\n  1869→    flex: 1 1 auto;\n  1870→    height: 36px;\n  1871→    border: 1px solid var(--border-input);\n  1872→    border-radius: 14px;\n  1873→    padding: 0 10px;\n  1874→    font-size: 14px;\n  1875→    background: var(--bg-input, var(--surface));\n  1876→    color: var(--text-primary);\n  1877→    backdrop-filter: blur(12px) saturate(160%);\n  1878→    -webkit-backdrop-filter: blur(12px) saturate(160%);\n  1879→  }\n  1880→\n  1881→  .search-input::placeholder {\n  1882→    color: var(--text-muted);\n  1883→    opacity: 0.85;\n  1884→    font-size: 12px;\n  1885→  }\n  1886→\n  1887→  .search-input:focus {\n  1888→    outline: none;\n  1889→    border-color: var(--focus-ring);\n  1890→    box-shadow: 0 0 0 2px rgba(125, 169, 255, 0.25);\n  1891→  }\n  1892→\n  1893→  .table-area {\n  1894→    display: grid;\n  1895→    grid-template-rows: auto 1fr;\n  1896→    min-height: 0;\n  1897→    min-width: 0;\n  1898→  }\n  1899→\n  1900→  .table-header-track,\n  1901→  .row {\n  1902→    display: grid;\n  1903→    grid-template-columns: var(--col-name) var(--col-path) var(--col-size) var(--col-modified);\n  1904→    align-items: center;\n  1905→    width: max(var(--table-min-width, 0px), 100%);\n  1906→  }\n  1907→\n  1908→  .table-header {\n  1909→    height: 32px;\n  1910→    border-bottom: 1px solid var(--border-soft);\n  1911→    background: var(--surface-header);\n  1912→    user-select: none;\n  1913→    overflow: hidden;\n  1914→    flex-shrink: 0;\n  1915→  }\n  1916→\n  1917→  .table-header-track {\n  1918→    height: 100%;\n  1919→    transform: translateX(var(--header-offset, 0px));\n  1920→    will-change: transform;\n  1921→  }\n  1922→\n  1923→  .table-header .col {\n  1924→    position: relative;\n  1925→    min-width: 0;\n  1926→    height: 100%;\n  1927→  }\n  1928→\n  1929→  .col-button {\n  1930→    width: 100%;\n  1931→    height: 100%;\n  1932→    display: flex;\n  1933→    align-items: center;\n  1934→    justify-content: flex-start;\n  1935→    gap: 4px;\n  1936→    box-sizing: border-box;\n  1937→    padding: 0 8px;\n  1938→    font-family: Inter, 'SF Pro Text', sans-serif;\n  1939→    font-size: 11px;\n  1940→    font-weight: 600;\n  1941→    line-height: 1;\n  1942→    color: var(--text-muted);\n  1943→    text-align: left;\n  1944→    margin: 0;\n  1945→    border: none;\n  1946→    background: transparent;\n  1947→    cursor: pointer;\n  1948→  }\n  1949→\n  1950→  .sort-icon {\n  1951→    width: 10px;\n  1952→    height: 10px;\n  1953→    flex-shrink: 0;\n  1954→    color: var(--accent);\n  1955→  }\n  1956→\n  1957→  .col-resizer {\n  1958→    position: absolute;\n  1959→    top: 0;\n  1960→    right: -4px;\n  1961→    width: 8px;\n  1962→    height: 100%;\n  1963→    border: none;\n  1964→    padding: 0;\n  1965→    background: transparent;\n  1966→    cursor: col-resize;\n  1967→    z-index: 30;\n  1968→  }\n  1969→\n  1970→  .col-resizer::after {\n  1971→    content: '';\n  1972→    position: absolute;\n  1973→    top: 7px;\n  1974→    bottom: 7px;\n  1975→    left: 50%;\n  1976→    width: 1px;\n  1977→    transform: translateX(-50%);\n  1978→    background: var(--border-soft);\n  1979→    opacity: 0;\n  1980→    transition: opacity 0.15s ease;\n  1981→  }\n  1982→\n  1983→  .table-header .col:hover .col-resizer::after,\n  1984→  .col-resizer.active::after {\n  1985→    opacity: 1;\n  1986→  }\n  1987→\n  1988→  .table-body {\n  1989→    overflow: auto;\n  1990→    min-height: 0;\n  1991→    min-width: 0;\n  1992→    background: var(--surface);\n  1993→  }\n  1994→\n  1995→  .spacer {\n  1996→    position: relative;\n  1997→    width: max(var(--table-min-width, 0px), 100%);\n  1998→  }\n  1999→\n  2000→  .rows {\n  2001→    position: absolute;\n  2002→    top: 0;\n  2003→    left: 0;\n  2004→    width: max(var(--table-min-width, 0px), 100%);\n  2005→  }\n  2006→\n  2007→  .row {\n  2008→    height: 30px;\n  2009→    border-bottom: 1px solid var(--row-border);\n  2010→    cursor: default;\n  2011→    -webkit-user-select: none;\n  2012→    user-select: none;\n  2013→    outline: none;\n  2014→  }\n  2015→\n  2016→  .row:hover {\n  2017→    background: var(--row-hover);\n  2018→  }\n  2019→\n  2020→  .row.selected {\n  2021→    background: var(--row-selected);\n  2022→  }\n  2023→\n  2024→  .cell {\n  2025→    padding: 0 8px;\n  2026→    font-size: 12px;\n  2027→    display: flex;\n  2028→    align-items: center;\n  2029→    gap: 6px;\n  2030→    min-width: 0;\n  2031→  }\n  2032→\n  2033→  .cell.size {\n  2034→    text-align: right;\n  2035→    font-variant-numeric: tabular-nums;\n  2036→  }\n  2037→\n  2038→  .ellipsis {\n  2039→    overflow: hidden;\n  2040→    text-overflow: ellipsis;\n  2041→    white-space: nowrap;\n  2042→  }\n  2043→\n  2044→  .hl {\n  2045→    background: none;\n  2046→    color: inherit;\n  2047→    font-weight: 700;\n  2048→  }\n  2049→\n  2050→  .file-icon {\n  2051→    width: 16px;\n  2052→    height: 16px;\n  2053→    flex: 0 0 auto;\n  2054→  }\n  2055→\n  2056→  .row.renaming {\n  2057→    height: auto;\n  2058→    min-height: 30px;\n  2059→    align-items: start;\n  2060→  }\n  2061→\n  2062→  .row.renaming .cell.name {\n  2063→    align-items: start;\n  2064→  }\n  2065→\n  2066→  .rename-wrapper {\n  2067→    display: grid;\n  2068→    flex: 1;\n  2069→    min-width: 0;\n  2070→    margin-left: calc(-1.5px - 5px);\n  2071→  }\n  2072→\n  2073→  .rename-sizer {\n  2074→    grid-area: 1 / 1;\n  2075→    font-family: 'JetBrains Mono', monospace;\n  2076→    font-size: 12px;\n  2077→    padding: 2px 5px;\n  2078→    border: 1.5px solid transparent;\n  2079→    visibility: hidden;\n  2080→    white-space: pre-wrap;\n  2081→    word-break: break-word;\n  2082→  }\n  2083→\n  2084→  .rename-input {\n  2085→    grid-area: 1 / 1;\n  2086→    width: 100%;\n  2087→    font-family: 'JetBrains Mono', monospace;\n  2088→    font-size: 12px;\n  2089→    padding: 2px 5px;\n  2090→    border: 1.5px solid var(--focus-ring);\n  2091→    border-radius: 4px;\n  2092→    background: var(--bg-input, var(--surface));\n  2093→    color: var(--text-primary);\n  2094→    outline: none;\n  2095→    resize: none;\n  2096→    overflow: hidden;\n  2097→  }\n  2098→\n  2099→  .status-bar {\n  2100→    display: flex;\n  2101→    align-items: center;\n  2102→    justify-content: space-between;\n  2103→    height: 32px;\n  2104→    padding: 0 16px;\n  2105→    background: var(--surface-header);\n  2106→    border-top: 1px solid var(--border-soft);\n  2107→    font-family: 'JetBrains Mono', monospace;\n  2108→    font-size: 11px;\n  2109→    color: var(--text-muted);\n  2110→    white-space: nowrap;\n  2111→    overflow: hidden;\n  2112→    min-width: 0;\n  2113→    flex-shrink: 0;\n  2114→  }\n  2115→\n  2116→  .status-left {\n  2117→    display: flex;\n  2118→    align-items: center;\n  2119→    gap: 16px;\n  2120→    overflow: hidden;\n  2121→    min-width: 0;\n  2122→  }\n  2123→\n  2124→  .status-right {\n  2125→    display: flex;\n  2126→    align-items: center;\n  2127→    gap: 8px;\n  2128→    flex-shrink: 0;\n  2129→  }\n  2130→\n  2131→  .status-btn {\n  2132→    border: 1px solid var(--button-border);\n  2133→    border-radius: 5px;\n  2134→    background: var(--button-bg);\n  2135→    color: var(--button-text);\n  2136→    font-size: 11px;\n  2137→    height: 22px;\n  2138→    padding: 0 8px;\n  2139→    cursor: pointer;\n  2140→  }\n  2141→\n  2142→  .status-btn:hover {\n  2143→    filter: brightness(1.06);\n  2144→  }\n  2145→\n  2146→  .status-btn:disabled {\n  2147→    opacity: 0.55;\n  2148→    cursor: not-allowed;\n  2149→    filter: none;\n  2150→  }\n  2151→\n  2152→  .status-state {\n  2153→    display: flex;\n  2154→    align-items: center;\n  2155→    gap: 6px;\n  2156→  }\n  2157→\n  2158→  .state-dot {\n  2159→    width: 6px;\n  2160→    height: 6px;\n  2161→    border-radius: 50%;\n  2162→    flex-shrink: 0;\n  2163→  }\n  2164→\n  2165→  .state-dot.ready { background: #28C840; }\n  2166→  .state-dot.indexing { background: #FEBC2E; }\n  2167→  .state-dot.error { background: #FF5F57; }\n  2168→\n  2169→  .rebuild-btn {\n  2170→    display: flex;\n  2171→    align-items: center;\n  2172→    gap: 6px;\n  2173→    font-family: Inter, 'SF Pro Text', sans-serif;\n  2174→    font-size: 10px;\n  2175→    font-weight: 500;\n  2176→    background: var(--button-bg);\n  2177→    border: 1px solid var(--button-border);\n  2178→    border-radius: 4px;\n  2179→    color: var(--button-text);\n  2180→    height: 22px;\n  2181→    padding: 0 10px;\n  2182→    cursor: pointer;\n  2183→  }\n  2184→\n  2185→  .rebuild-btn:hover {\n  2186→    filter: brightness(1.1);\n  2187→  }\n  2188→\n  2189→  .rebuild-btn:disabled {\n  2190→    opacity: 0.5;\n  2191→    cursor: not-allowed;\n  2192→    filter: none;\n  2193→  }\n  2194→\n  2195→  .rebuild-icon {\n  2196→    width: 11px;\n  2197→    height: 11px;\n  2198→    color: var(--accent);\n  2199→    flex-shrink: 0;\n  2200→  }\n  2201→\n  2202→  .status-error {\n  2203→    color: var(--error-text);\n  2204→  }\n  2205→\n  2206→  .status-warning {\n  2207→    color: var(--warning-text);\n  2208→  }\n  2209→\n  2210→  .status-spotlight {\n  2211→    color: #f59e0b;\n  2212→    font-weight: 600;\n  2213→  }\n  2214→\n  2215→  .context-menu {\n  2216→    position: fixed;\n  2217→    z-index: 200;\n  2218→    width: 220px;\n  2219→    border: 1px solid var(--menu-border);\n  2220→    border-radius: 10px;\n  2221→    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.16), inset 0 0 0 0.5px rgba(255, 255, 255, 0.18);\n  2222→    background: var(--menu-bg);\n  2223→    backdrop-filter: blur(28px) saturate(180%);\n  2224→    -webkit-backdrop-filter: blur(28px) saturate(180%);\n  2225→    overflow: hidden;\n  2226→  }\n  2227→\n  2228→  .context-menu button {\n  2229→    width: 100%;\n  2230→    text-align: left;\n  2231→    border: none;\n  2232→    background: transparent;\n  2233→    padding: 8px 10px;\n  2234→    font-size: 12px;\n  2235→    color: var(--menu-text);\n  2236→  }\n  2237→\n  2238→  .context-menu button:hover {\n  2239→    background: var(--menu-hover);\n  2240→  }\n  2241→\n  2242→  .toast {\n  2243→    position: fixed;\n  2244→    right: 14px;\n  2245→    bottom: 18px;\n  2246→    background: var(--toast-bg);\n  2247→    color: var(--toast-text);\n  2248→    border-radius: 10px;\n  2249→    padding: 9px 12px;\n  2250→    font-size: 12px;\n  2251→    z-index: 250;\n  2252→    backdrop-filter: blur(20px) saturate(180%);\n  2253→    -webkit-backdrop-filter: blur(20px) saturate(180%);\n  2254→    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);\n  2255→  }\n  2256→</style>\n  2257→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"11a5d4ce-31e1-4a08-95b4-d90ec04acdae","timestamp":"2026-02-21T14:17:25.378Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src/App.svelte","content":"<script>\n  import { onDestroy, onMount, tick } from 'svelte';\n  import { invoke } from '@tauri-apps/api/core';\n  import { listen } from '@tauri-apps/api/event';\n  import { getCurrentWindow } from '@tauri-apps/api/window';\n  import { startDrag } from '@crabnebula/tauri-plugin-drag';\n\n  const rowHeight = 30;\n  const PAGE_SIZE = 500;\n  let homePrefix = '';\n  const COL_WIDTHS_KEY = 'REDACTED';\n  const THEME_KEY = 'everything-theme';\n  const columnKeys = ['name', 'path', 'size', 'modified'];\n  const minColumnWidth = {\n    name: 180,\n    path: 240,\n    size: 75,\n    modified: 150\n  };\n  const defaultColumnRatios = {\n    name: 0.3,\n    path: 0.45,\n    size: 0.1\n  };\n\n  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || 'dark'; } catch { return 'dark'; } })();\n  function cycleTheme() {\n    theme = theme === 'dark' ? 'light' : 'dark';\n    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n  }\n\n  let query = '';\n  let results = [];\n  let totalResults = 0;\n  let totalResultsKnown = false;\n\n  let dbLatencyMs = null;\n  let dbLastQuery = '';\n  let searchModeLabel = '';\n  let selectedIndices = new Set();\n  let selectionAnchor = -1;\n  let lastSelectedIndex = -1;\n  let editing = {\n    active: false,\n    path: '',\n    index: -1,\n    draftName: ''\n  };\n\n  let indexStatus = {\n    state: 'Indexing',\n    entriesCount: 0,\n    lastUpdated: null,\n    permissionErrors: 0,\n    message: null,\n    isCatchup: false\n  };\n\n  let indexingStartTime = null;\n  let indexingElapsed = '';\n  let indexingFinishedAt = '';\n\n  let sortBy = 'name';\n  let sortDir = 'asc';\n\n  let hasMore = true;\n  let loadingMore = false;\n  let searchGeneration = 0;\n\n  let scanned = 0;\n\n  let searchInputEl;\n  let renameInputEl;\n  let tableAreaEl;\n  let tableContainer;\n  let tableResizeObserver = null;\n  let viewportResizeRaf = null;\n  let scrollTop = 0;\n  let headerScrollLeft = 0;\n  let viewportHeight = 520;\n  let lastTableWidth = 0;\n  let resizingColumn = '';\n  let resizeCleanup = null;\n  let colWidths = {\n    name: 250,\n    path: 350,\n    size: 75,\n    modified: 150\n  };\n\n  let contextMenu = {\n    visible: false,\n    x: 0,\n    y: 0\n  };\n\n  let platform = '';\n  let toast = '';\n  let searchTimer;\n  let lastSearchFiredAt = 0;\n  let toastTimer;\n  let statusRefreshTimer;\n  let elapsedTimer;\n  let statusRefreshInFlight = false;\n  let lastReadyCount = 0;\n\n  const iconCache = new Map();\n  const iconLoading = new Set();\n\n  let highlightCache = new Map();\n  let highlightCacheQuery = '';\n\n  const folderFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='1' y='4' width='14' height='10' rx='2' fill='#d9b34f'/><rect x='1' y='2' width='6' height='4' rx='1' fill='#e6ca7a'/></svg>`\n    );\n  const fileFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='3' y='1' width='10' height='14' rx='1.5' fill='#b4bec9'/><rect x='5' y='5' width='6' height='1.2' fill='#8d98a5'/><rect x='5' y='8' width='6' height='1.2' fill='#8d98a5'/></svg>`\n    );\n\n  $: totalHeight = results.length * rowHeight;\n  $: startIndex = Math.max(0, Math.floor(scrollTop / rowHeight) - 10);\n  $: visibleCount = Math.ceil(viewportHeight / rowHeight) + 20;\n  $: endIndex = Math.min(results.length, startIndex + visibleCount);\n  $: visibleRows = results.slice(startIndex, endIndex);\n  $: translateY = startIndex * rowHeight;\n  $: tableMinWidth = colWidths.name + colWidths.path + colWidths.size + colWidths.modified;\n  $: tableGridStyle = `--col-name:${colWidths.name}px;--col-path:${colWidths.path}px;--col-size:${colWidths.size}px;--col-modified:${colWidths.modified}px;--table-min-width:${tableMinWidth}px;--header-offset:${-headerScrollLeft}px;`;\n\n  $: {\n    for (const entry of visibleRows) {\n      void ensureIcon(entry);\n    }\n  }\n\n  function showToast(message) {\n    toast = message;\n    clearTimeout(toastTimer);\n    toastTimer = setTimeout(() => {\n      toast = '';\n    }, 3000);\n  }\n\n  function bytesToBase64(bytes) {\n    let binary = '';\n    const chunk = 0x8000;\n    for (let i = 0; i < bytes.length; i += chunk) {\n      const part = bytes.subarray(i, i + chunk);\n      binary += String.fromCharCode(...part);\n    }\n    return btoa(binary);\n  }\n\n  function highlightSegments(name, q) {\n    q = (q || '').trim();\n    if (!q) return [{ text: name, hl: false }];\n\n    // Reset cache when query changes\n    if (q !== highlightCacheQuery) {\n      highlightCache = new Map();\n      highlightCacheQuery = q;\n    }\n\n    // Check cache\n    const cached = highlightCache.get(name);\n    if (cached) return cached;\n\n    if (q.includes('/')) q = q.slice(q.lastIndexOf('/') + 1);\n    q = q.replace(/[*?]/g, '');\n    const terms = q.split(/\\s+/).filter(Boolean);\n    if (terms.length === 0) return [{ text: name, hl: false }];\n\n    const lower = name.toLowerCase();\n    const marks = new Uint8Array(name.length);\n    for (const t of terms) {\n      const tl = t.toLowerCase();\n      let idx = lower.indexOf(tl);\n      while (idx !== -1) {\n        for (let i = idx; i < idx + tl.length; i++) marks[i] = 1;\n        idx = lower.indexOf(tl, idx + 1);\n      }\n    }\n\n    const segs = [];\n    let i = 0;\n    while (i < name.length) {\n      const m = marks[i];\n      let j = i + 1;\n      while (j < name.length && marks[j] === m) j++;\n      segs.push({ text: name.slice(i, j), hl: m === 1 });\n      i = j;\n    }\n\n    highlightCache.set(name, segs);\n    return segs;\n  }\n\n  const perFileIconExts = new Set(['exe', 'lnk', 'ico', 'url', 'scr', 'appx']);\n\n  function iconKey(entry) {\n    if (entry.isDir) return '__folder__';\n    const ext = (entry.ext || '').toLowerCase();\n    if (perFileIconExts.has(ext)) return entry.path;\n    return ext || '__file__';\n  }\n\n  function iconFor(entry) {\n    return iconCache.get(iconKey(entry)) || (entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n  }\n\n  async function ensureIcon(entry) {\n    const key = iconKey(entry);\n    if (iconCache.has(key) || iconLoading.has(key)) {\n      return;\n    }\n\n    iconLoading.add(key);\n    try {\n      const bytes = await invoke('get_file_icon', {\n        path: entry.path,\n        ext: entry.isDir ? 'folder' : entry.ext || '',\n      });\n      if (Array.isArray(bytes) && bytes.length > 0) {\n        const image = `data:image/png;base64,${bytesToBase64(Uint8Array.from(bytes))}`;\n        iconCache.set(key, image);\n      } else {\n        iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n      }\n    } catch {\n      iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n    } finally {\n      iconLoading.delete(key);\n    }\n  }\n\n  function syncColumnWidthsToContainer() {\n    const width = tableContainer?.clientWidth || tableAreaEl?.clientWidth;\n    if (!width || lastTableWidth !== 0) {\n      return;\n    }\n\n    const saved = loadColWidths();\n    if (saved) {\n      const total = columnKeys.reduce((s, k) => s + saved[k], 0);\n      if (Math.abs(total - width) > 2) {\n        const scale = (width - saved.modified) / (total - saved.modified);\n        let scaledName = Math.max(minColumnWidth.name, Math.round(saved.name * scale));\n        let scaledSize = Math.max(minColumnWidth.size, Math.round(saved.size * scale));\n        let rawPath = width - saved.modified - scaledName - scaledSize;\n        if (rawPath < minColumnWidth.path) {\n          const shortfall = minColumnWidth.path - rawPath;\n          const nameReduction = Math.min(shortfall, scaledName - minColumnWidth.name);\n          scaledName -= nameReduction;\n          const remaining = shortfall - nameReduction;\n          if (remaining > 0) {\n            scaledSize -= Math.min(remaining, scaledSize - minColumnWidth.size);\n          }\n          rawPath = width - saved.modified - scaledName - scaledSize;\n        }\n        const scaledPath = Math.max(minColumnWidth.path, rawPath);\n        colWidths = { name: scaledName, path: scaledPath, size: scaledSize, modified: saved.modified };\n      } else {\n        colWidths = saved;\n      }\n    } else {\n      const fixedModified = minColumnWidth.modified;\n      const rest = width - fixedModified;\n      const ratioSum = defaultColumnRatios.name + defaultColumnRatios.path + defaultColumnRatios.size;\n      colWidths = {\n        name: Math.max(minColumnWidth.name, Math.round(rest * defaultColumnRatios.name / ratioSum)),\n        path: Math.max(minColumnWidth.path, Math.round(rest * defaultColumnRatios.path / ratioSum)),\n        size: Math.max(minColumnWidth.size, Math.round(rest * defaultColumnRatios.size / ratioSum)),\n        modified: fixedModified\n      };\n    }\n    lastTableWidth = width;\n  }\n\n  function loadColWidths() {\n    try {\n      const raw = localStorage.getItem(COL_WIDTHS_KEY);\n      if (!raw) return null;\n      const parsed = JSON.parse(raw);\n      for (const key of columnKeys) {\n        if (typeof parsed[key] !== 'number' || parsed[key] < (minColumnWidth[key] || 0)) return null;\n      }\n      return parsed;\n    } catch {\n      return null;\n    }\n  }\n\n  function saveColWidths() {\n    localStorage.setItem(COL_WIDTHS_KEY, JSON.stringify(colWidths));\n  }\n\n  function updateViewportHeight() {\n    viewportHeight = tableContainer?.clientHeight || 520;\n    syncColumnWidthsToContainer();\n  }\n\n  function scheduleViewportHeightUpdate() {\n    if (viewportResizeRaf !== null) {\n      return;\n    }\n    viewportResizeRaf = requestAnimationFrame(() => {\n      viewportResizeRaf = null;\n      updateViewportHeight();\n    });\n  }\n\n  function startColumnResize(event, leftKey) {\n    event.preventDefault();\n    event.stopPropagation();\n\n    const index = columnKeys.indexOf(leftKey);\n    if (index < 0 || index >= columnKeys.length - 1) {\n      return;\n    }\n\n    const startX = event.clientX;\n    const startLeft = colWidths[leftKey];\n    const rightKey = columnKeys[index + 1];\n    const startRight = colWidths[rightKey];\n\n    resizeCleanup?.();\n    resizingColumn = leftKey;\n\n    const onMove = (moveEvent) => {\n      const delta = Math.round(moveEvent.clientX - startX);\n      if (leftKey === 'name') {\n        // Two-column trade: name and path swap space, each respects its minimum\n        const nextLeft = Math.max(\n          minColumnWidth[leftKey],\n          Math.min(startLeft + delta, startLeft + startRight - minColumnWidth[rightKey])\n        );\n        const nextRight = startLeft + startRight - nextLeft;\n        colWidths = { ...colWidths, [leftKey]: nextLeft, [rightKey]: nextRight };\n      } else {\n        // path splitter: path grows unconstrained (allows horizontal scroll on right drag)\n        const nextLeft = Math.max(minColumnWidth[leftKey], startLeft + delta);\n        colWidths = { ...colWidths, [leftKey]: nextLeft };\n      }\n    };\n\n    const onUp = () => {\n      cleanup();\n    };\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      document.body.style.cursor = '';\n      document.body.style.userSelect = '';\n      resizingColumn = '';\n      saveColWidths();\n      if (resizeCleanup === cleanup) {\n        resizeCleanup = null;\n      }\n    };\n\n    resizeCleanup = cleanup;\n    document.body.style.cursor = 'col-resize';\n    document.body.style.userSelect = 'none';\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  function selectedPaths() {\n    const sorted = [...selectedIndices].sort((a, b) => a - b);\n    return sorted.map((idx) => results[idx]).filter(Boolean).map((entry) => entry.path);\n  }\n\n  function clearSelection() {\n    selectedIndices = new Set();\n    selectionAnchor = -1;\n    lastSelectedIndex = -1;\n  }\n\n  function selectSingle(index) {\n    selectedIndices = new Set([index]);\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectToggle(index) {\n    const next = new Set(selectedIndices);\n    if (next.has(index)) {\n      next.delete(index);\n    } else {\n      next.add(index);\n    }\n    selectedIndices = next;\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectRange(index) {\n    const anchor = selectionAnchor >= 0 ? selectionAnchor : index;\n    const [from, to] = [Math.min(anchor, index), Math.max(anchor, index)];\n    const next = new Set();\n    for (let i = from; i <= to; i += 1) {\n      next.add(i);\n    }\n    selectedIndices = next;\n    lastSelectedIndex = index;\n  }\n\n  function primaryEntry() {\n    const idx = lastSelectedIndex >= 0 ? lastSelectedIndex : -1;\n    return idx >= 0 ? results[idx] : null;\n  }\n\n  async function refreshStatus() {\n    if (statusRefreshInFlight) {\n      return;\n    }\n    statusRefreshInFlight = true;\n    try {\n      const status = await invoke('get_index_status');\n      const prevState = indexStatus.state;\n      indexStatus = {\n        state: status.state,\n        entriesCount: status.entriesCount,\n        lastUpdated: status.lastUpdated,\n        permissionErrors: status.permissionErrors ?? 0,\n        message: status.message\n      };\n      if (status.state === 'Indexing' && prevState !== 'Indexing') {\n        startElapsedTimer();\n      } else if (status.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n      if (typeof status.scanned === 'number') {\n        scanned = status.scanned;\n      }\n      if (status.state === 'Ready' && prevState !== 'Ready') {\n        scheduleSearch();\n      }\n    } catch (err) {\n      showToast(`Failed to get status: ${String(err)}`);\n    } finally {\n      statusRefreshInFlight = false;\n    }\n  }\n\n  function scheduleSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const scheduledGen = searchGeneration;\n    clearTimeout(searchTimer);\n\n    const now = performance.now();\n    if (now - lastSearchFiredAt >= 200) {\n      // Leading edge: fire immediately if enough time has passed\n      lastSearchFiredAt = now;\n      void runSearch(preserveScroll);\n    } else {\n      // Trailing edge: debounce\n      searchTimer = setTimeout(() => {\n        if (scheduledGen !== searchGeneration) {\n          return;\n        }\n        lastSearchFiredAt = performance.now();\n        void runSearch(preserveScroll);\n      }, 200);\n    }\n  }\n\n  async function runSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const gen = searchGeneration;\n    const searchQuery = query;\n    const searchSortBy = sortBy;\n    const searchSortDir = sortDir;\n    const startedAt = performance.now();\n    try {\n      const keepPaths = new Set(selectedPaths());\n      const next = await invoke('search', {\n        query: searchQuery,\n        limit: PAGE_SIZE,\n        offset: 0,\n        sortBy: searchSortBy,\n        sortDir: searchSortDir\n      });\n\n      if (gen !== searchGeneration) return;\n\n      dbLatencyMs = Math.round(performance.now() - startedAt);\n      dbLastQuery = searchQuery;\n      const entries = Array.isArray(next.entries) ? next.entries : [];\n      searchModeLabel = next.modeLabel || '';\n      results = entries;\n      if (next.totalCount > 0) {\n        totalResults = next.totalCount;\n        totalResultsKnown = true;\n      } else {\n        totalResults = entries.length;\n        totalResultsKnown = false;\n      }\n      hasMore = totalResultsKnown ? results.length < totalResults : entries.length >= PAGE_SIZE;\n      if (!preserveScroll && tableContainer) tableContainer.scrollTop = 0;\n\n      const restored = new Set();\n      for (let i = 0; i < results.length; i += 1) {\n        if (keepPaths.has(results[i].path)) {\n          restored.add(i);\n        }\n      }\n      selectedIndices = restored;\n\n      updateViewportHeight();\n    } catch (err) {\n      if (gen !== searchGeneration) return;\n      showToast(`Search failed: ${String(err)}`);\n    }\n  }\n\n  async function loadMore() {\n    if (!hasMore || loadingMore) return;\n    const gen = searchGeneration;\n    loadingMore = true;\n    try {\n      const batch = await invoke('search', {\n        query,\n        limit: PAGE_SIZE,\n        offset: results.length,\n        sortBy: sortBy,\n        sortDir: sortDir\n      });\n      if (gen !== searchGeneration) return;\n      const arr = Array.isArray(batch.entries) ? batch.entries : [];\n      if (arr.length > 0) results = [...results, ...arr];\n      hasMore = totalResultsKnown ? results.length < totalResults : arr.length >= PAGE_SIZE;\n    } catch (err) {\n      showToast(`Failed to load more: ${String(err)}`);\n    } finally {\n      loadingMore = false;\n    }\n  }\n\n  function moveSelection(delta, withRange = false) {\n    if (results.length === 0) {\n      return;\n    }\n\n    const current = lastSelectedIndex >= 0 ? lastSelectedIndex : 0;\n    const next = Math.max(0, Math.min(results.length - 1, current + delta));\n\n    if (withRange) {\n      selectRange(next);\n    } else {\n      selectSingle(next);\n    }\n\n    const top = next * rowHeight;\n    const bottom = top + rowHeight;\n    if (top < scrollTop) {\n      tableContainer.scrollTop = top;\n    } else if (bottom > scrollTop + viewportHeight) {\n      tableContainer.scrollTop = bottom - viewportHeight;\n    }\n  }\n\n  function handleHeaderSort(column) {\n    if (sortBy === column) {\n      sortDir = sortDir === 'asc' ? 'desc' : 'asc';\n    } else {\n      sortBy = column;\n      sortDir = 'asc';\n    }\n    if (tableContainer) tableContainer.scrollTop = 0;\n    void runSearch();\n  }\n\n  function handleRowClick(event, index) {\n    contextMenu.visible = false;\n\n    if (event.shiftKey) {\n      selectRange(index);\n      return;\n    }\n\n    if (event.metaKey || event.ctrlKey) {\n      selectToggle(index);\n      return;\n    }\n\n    selectSingle(index);\n  }\n\n  function handleRowContextMenu(event, index) {\n    event.preventDefault();\n\n    if (!selectedIndices.has(index)) {\n      selectSingle(index);\n    }\n\n    if (platform === 'windows' || platform === 'macos') {\n      contextMenu.visible = false;\n      const paths = selectedPaths();\n      if (paths.length > 0) {\n        invoke('show_context_menu', {\n          paths,\n          x: event.clientX,\n          y: event.clientY,\n          singleSelection: selectedIndices.size === 1\n        });\n      }\n      return;\n    }\n\n    contextMenu = {\n      visible: true,\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n\n  function handleRowA11yKeydown(event, index) {\n    if (event.key === ' ' || event.key === 'Enter') {\n      event.preventDefault();\n      handleRowClick(event, index);\n    }\n  }\n\n  const DRAG_THRESHOLD = 5;\n  let dragCleanup = null;\n  const dragImgCache = new Map();\n\n  function dragPathsForIndex(index) {\n    const entry = results[index];\n    if (!entry) {\n      return [];\n    }\n\n    if (selectedIndices.has(index) && selectedIndices.size > 0) {\n      return selectedPaths();\n    }\n\n    return [entry.path];\n  }\n\n  function getDragIconEl(entry) {\n    const src = iconFor(entry);\n    let img = dragImgCache.get(src);\n    if (!img) {\n      img = new Image();\n      img.src = src;\n      dragImgCache.set(src, img);\n    }\n    return img.complete && img.naturalWidth > 0 ? img : null;\n  }\n\n  function fillRoundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function buildDragPreview(index) {\n    const entry = results[index];\n    if (!entry) return null;\n\n    const count = selectedIndices.has(index) ? selectedIndices.size : 1;\n    const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\n\n    const w = 260;\n    const h = 28;\n    const stackGap = count > 1 ? 4 : 0;\n\n    const canvas = document.createElement('canvas');\n    canvas.width = w;\n    canvas.height = h + stackGap;\n    const ctx = canvas.getContext('2d');\n\n    if (count > 1) {\n      ctx.globalAlpha = 0.35;\n      ctx.fillStyle = isDark ? '#5a6070' : '#b0c4de';\n      fillRoundRect(ctx, 3, 0, w - 3, h, 5);\n      ctx.globalAlpha = 1.0;\n    }\n\n    const ry = stackGap;\n    ctx.fillStyle = isDark ? 'rgba(58, 64, 74, 0.94)' : 'rgba(214, 231, 255, 0.94)';\n    fillRoundRect(ctx, 0, ry, w, h, 5);\n\n    ctx.strokeStyle = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';\n    ctx.lineWidth = 0.5;\n    ctx.beginPath();\n    ctx.moveTo(5, ry);\n    ctx.arcTo(w, ry, w, ry + h, 5);\n    ctx.arcTo(w, ry + h, 0, ry + h, 5);\n    ctx.arcTo(0, ry + h, 0, ry, 5);\n    ctx.arcTo(0, ry, w, ry, 5);\n    ctx.closePath();\n    ctx.stroke();\n\n    const iconEl = getDragIconEl(entry);\n    if (iconEl) {\n      ctx.drawImage(iconEl, 6, ry + 6, 16, 16);\n    } else {\n      ctx.fillStyle = entry.isDir ? '#d9b34f' : '#8d98a5';\n      fillRoundRect(ctx, 6, ry + 6, 16, 16, 2);\n    }\n\n    ctx.fillStyle = isDark ? '#e6e6e8' : '#1a1a1a';\n    ctx.font = '12px -apple-system, \"SF Pro Text\", system-ui, sans-serif';\n    ctx.textBaseline = 'middle';\n\n    let nameMaxW = w - 34;\n    if (count > 1) nameMaxW -= 34;\n\n    let name = entry.name;\n    if (ctx.measureText(name).width > nameMaxW) {\n      while (name.length > 4 && ctx.measureText(name + '\\u2026').width > nameMaxW) {\n        name = name.slice(0, -1);\n      }\n      name += '\\u2026';\n    }\n    ctx.fillText(name, 28, ry + h / 2 + 1);\n\n    if (count > 1) {\n      const badge = String(count);\n      ctx.font = 'bold 10px -apple-system, system-ui, sans-serif';\n      const tw = ctx.measureText(badge).width;\n      const bw = Math.max(20, tw + 10);\n      const bx = w - bw - 6;\n      const by = ry + (h - 18) / 2;\n\n      ctx.fillStyle = isDark ? '#5b8bd9' : '#007aff';\n      fillRoundRect(ctx, bx, by, bw, 18, 9);\n\n      ctx.fillStyle = '#ffffff';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(badge, bx + bw / 2, by + 9);\n    }\n\n    return canvas.toDataURL('image/png');\n  }\n\n  function handleRowMouseDown(event, index) {\n    if (event.button !== 0) return;\n    if (event.metaKey || event.ctrlKey || event.shiftKey) return;\n    if (editing.active) return;\n\n    const startX = event.clientX;\n    const startY = event.clientY;\n    let dragging = false;\n\n    dragCleanup?.();\n\n    const onMove = (e) => {\n      if (dragging) return;\n      const dx = e.clientX - startX;\n      const dy = e.clientY - startY;\n      if (dx * dx + dy * dy < DRAG_THRESHOLD * DRAG_THRESHOLD) return;\n\n      dragging = true;\n      cleanup();\n\n      if (!selectedIndices.has(index)) {\n        selectSingle(index);\n      }\n\n      const paths = dragPathsForIndex(index);\n      if (paths.length > 0) {\n        const icon = buildDragPreview(index);\n        startDrag({ item: paths, icon }).catch(() => {});\n      }\n    };\n\n    const onUp = () => cleanup();\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      if (dragCleanup === cleanup) dragCleanup = null;\n    };\n\n    dragCleanup = cleanup;\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  async function handleRowDoubleClick(index) {\n    if (!selectedIndices.has(index) || selectedIndices.size > 1) {\n      selectSingle(index);\n      await tick();\n    }\n    await invoke('open', { paths: [results[index].path] }).catch((err) => {\n      showToast(`Failed to open: ${String(err)}`);\n    });\n  }\n\n  function closeContextMenu() {\n    contextMenu = {\n      ...contextMenu,\n      visible: false\n    };\n  }\n\n  async function openSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('open', { paths });\n    } catch (err) {\n      showToast(`Failed to open: ${String(err)}`);\n    }\n  }\n\n  async function openWithFallback() {\n    const target = primaryEntry();\n    if (!target) {\n      return;\n    }\n\n    try {\n      await invoke('open_with', { path: target.path });\n    } catch (err) {\n      showToast(`Open With failed: ${String(err)}`);\n    }\n  }\n\n  async function revealSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('reveal_in_finder', { paths });\n    } catch (err) {\n      showToast(`Failed to reveal in Finder: ${String(err)}`);\n    }\n  }\n\n  async function copySelectedPaths() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_paths', { paths });\n      showToast(`Copied ${paths.length} path(s)`);\n    } catch (err) {\n      showToast(`Failed to copy path: ${String(err)}`);\n    }\n  }\n\n  async function copyFiles() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_files', { paths });\n      showToast(`Copied ${paths.length} item(s)`);\n    } catch (err) {\n      showToast(`Failed to copy: ${String(err)}`);\n    }\n  }\n\n  async function trashSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    const message =\n      paths.length === 1\n        ? 'Move selected item to Trash?'\n        : `Move ${paths.length} items to Trash?`;\n\n    if (!window.confirm(message)) {\n      return;\n    }\n\n    try {\n      await invoke('move_to_trash', { paths });\n      showToast('Moved to Trash.');\n      clearSelection();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to move to Trash: ${String(err)}`);\n    }\n  }\n\n  async function resetIndex() {\n    if (indexStatus.state === 'Indexing') {\n      showToast('Indexing in progress. Please try again after it completes.');\n      return;\n    }\n\n    results = [];\n    totalResults = 0;\n    totalResultsKnown = false;\n    clearSelection();\n    scanned = 0;\n    dbLatencyMs = null;\n    dbLastQuery = '';\n    indexStatus = { ...indexStatus, state: 'Indexing', entriesCount: 0, message: null };\n    indexingStartTime = Date.now();\n    indexingElapsed = '';\n    indexingFinishedAt = '';\n\n    try {\n      await invoke('reset_index');\n    } catch (err) {\n      showToast(`Failed to reset index: ${String(err)}`);\n      await refreshStatus();\n    }\n  }\n\n  function isMultiSelected() {\n    return selectedIndices.size > 1;\n  }\n\n  async function startRename() {\n    if (isMultiSelected()) {\n      return;\n    }\n\n    const idx = lastSelectedIndex;\n    if (idx < 0 || !results[idx]) {\n      return;\n    }\n\n    const entry = results[idx];\n    editing = {\n      active: true,\n      path: entry.path,\n      index: idx,\n      draftName: entry.name\n    };\n\n    await tick();\n\n    if (renameInputEl) {\n      renameInputEl.focus();\n      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n      renameInputEl.setSelectionRange(0, selectionEnd);\n    }\n  }\n\n  function cancelRename() {\n    editing = {\n      active: false,\n      path: '',\n      index: -1,\n      draftName: ''\n    };\n  }\n\n  async function commitRename() {\n    if (!editing.active || editing.index < 0 || !results[editing.index]) {\n      return;\n    }\n\n    const current = results[editing.index];\n    const nextName = editing.draftName;\n\n    try {\n      await invoke('rename', {\n        path: current.path,\n        newName: nextName\n      });\n      cancelRename();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to rename: ${String(err)}`);\n      await tick();\n      renameInputEl?.focus();\n    }\n  }\n\n  function onGlobalClick() {\n    closeContextMenu();\n  }\n\n  function onTitleBarMouseDown(event) {\n    if (event.button !== 0) {\n      return;\n    }\n\n    const activeElement = document.activeElement;\n    if (activeElement instanceof HTMLElement && isTextInputTarget(activeElement)) {\n      activeElement.blur();\n    }\n  }\n\n  async function focusSearch() {\n    await getCurrentWindow().show();\n    await getCurrentWindow().setFocus();\n    searchInputEl?.focus();\n    searchInputEl?.select();\n  }\n\n  function isTextInputTarget(target) {\n    return (\n      target instanceof HTMLInputElement ||\n      target instanceof HTMLTextAreaElement ||\n      target?.isContentEditable\n    );\n  }\n\n  async function handleKeydown(event) {\n    const isMetaSelectAll = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'a';\n    const isMetaCopy = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c';\n    const target = event.target;\n    const isTextInput = isTextInputTarget(target);\n\n    if (isMetaCopy && isTextInput) {\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      if (isTextInput) {\n        event.preventDefault();\n        if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n          target.select();\n        }\n        return;\n      }\n    }\n\n    if (editing.active) {\n      if (event.key === 'Enter') {\n        event.preventDefault();\n        await commitRename();\n        return;\n      }\n\n      if (event.key === 'Escape') {\n        event.preventDefault();\n        cancelRename();\n        searchInputEl?.focus();\n        return;\n      }\n      return;\n    }\n\n    if (event.key === 'Escape') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      return;\n    }\n\n    if (event.key === 'ArrowDown') {\n      event.preventDefault();\n      moveSelection(1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'ArrowUp') {\n      event.preventDefault();\n      moveSelection(-1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageDown') {\n      event.preventDefault();\n      moveSelection(Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageUp') {\n      event.preventDefault();\n      moveSelection(-Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'Enter') {\n      event.preventDefault();\n      if (platform === 'windows') {\n        await openSelected();\n      } else {\n        await startRename();\n      }\n      return;\n    }\n\n    if (event.key === 'F2') {\n      event.preventDefault();\n      await startRename();\n      return;\n    }\n\n    if (event.key === ' ' && !isTextInput) {\n      event.preventDefault();\n      const entry = primaryEntry();\n      if (entry) {\n        await invoke('quick_look', { path: entry.path });\n      }\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'f') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      searchInputEl?.select();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'o') {\n      event.preventDefault();\n      await openSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {\n      event.preventDefault();\n      await revealSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c') {\n      event.preventDefault();\n      await copySelectedPaths();\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      event.preventDefault();\n      selectedIndices = new Set(Array.from({ length: results.length }, (_, i) => i));\n      return;\n    }\n\n    if (event.key === 'Delete' || ((event.metaKey || event.ctrlKey) && event.key === 'Backspace')) {\n      if (!isTextInput) {\n        event.preventDefault();\n        await trashSelected();\n      }\n      return;\n    }\n  }\n\n  function formatSize(entry) {\n    if (entry.isDir || entry.size == null) return '';\n    const bytes = entry.size;\n    if (bytes < 1024) return `${bytes} B`;\n    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n    return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n  }\n\n  function formatModified(entry) {\n    if (!entry.mtime) {\n      return '';\n    }\n\n    const d = new Date(entry.mtime * 1000);\n    const pad = (n) => String(n).padStart(2, '0');\n    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;\n  }\n\n  function formatLastUpdated(timestamp) {\n    if (!timestamp) {\n      return '-';\n    }\n\n    return new Date(timestamp * 1000).toLocaleString();\n  }\n\n  function formatElapsed(ms) {\n    const totalSec = Math.floor(ms / 1000);\n    const min = Math.floor(totalSec / 60);\n    const sec = totalSec % 60;\n    return min > 0 ? `${min}m ${sec}s` : `${sec}s`;\n  }\n\n  function updateElapsed() {\n    if (indexingStartTime && indexStatus.state === 'Indexing') {\n      indexingElapsed = formatElapsed(Date.now() - indexingStartTime);\n    }\n  }\n\n  function startElapsedTimer() {\n    clearInterval(elapsedTimer);\n    indexingStartTime = Date.now();\n    indexingElapsed = '0s';\n    indexingFinishedAt = '';\n    elapsedTimer = setInterval(updateElapsed, 1000);\n  }\n\n  function stopElapsedTimer() {\n    clearInterval(elapsedTimer);\n    if (indexingStartTime) {\n      const elapsed = Date.now() - indexingStartTime;\n      indexingFinishedAt = `${formatElapsed(elapsed)}`;\n    }\n    indexingStartTime = null;\n    indexingElapsed = '';\n  }\n\n  function displayPath(path) {\n    if (!path) {\n      return path;\n    }\n\n    if (!homePrefix) {\n      return path;\n    }\n\n    if (path === homePrefix) {\n      return '~';\n    }\n\n    if (path.startsWith(`${homePrefix}/`)) {\n      return `~${path.slice(homePrefix.length)}`;\n    }\n\n    return path;\n  }\n\n  let unlistenFns = [];\n\n  onMount(async () => {\n    const t0 = performance.now();\n    const ms = () => Math.round(performance.now() - t0);\n    const DEBUG_STARTUP = false;\n    const flog = DEBUG_STARTUP ? (msg) => invoke('frontend_log', { msg }).catch(() => {}) : () => {};\n\n    flog(`[startup/fe] onMount entered`);\n\n    updateViewportHeight();\n    flog(`[startup/fe] +${ms()}ms updateViewportHeight done`);\n\n    platform = await invoke('get_platform');\n    flog(`[startup/fe] +${ms()}ms get_platform done`);\n\n    const unlistenProgress = await listen('index_progress', (event) => {\n      scanned = event.payload.scanned;\n      if (indexStatus.state !== 'Indexing') {\n        indexStatus = {\n          ...indexStatus,\n          state: 'Indexing'\n        };\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_progress) registered`);\n\n    const unlistenState = await listen('index_state', (event) => {\n      flog(`[startup/fe] index_state event received: ${event.payload.state} at +${ms()}ms`);\n      const prevState = indexStatus.state;\n      indexStatus = {\n        ...indexStatus,\n        state: event.payload.state,\n        message: event.payload.message ?? null,\n        isCatchup: event.payload.isCatchup ?? false\n      };\n\n      if (event.payload.state === 'Indexing' && prevState !== 'Indexing') {\n        if (prevState === 'Ready') {\n          lastReadyCount = indexStatus.entriesCount;\n        }\n        startElapsedTimer();\n      } else if (event.payload.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n\n      if (event.payload.state === 'Ready') {\n        scheduleSearch();\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_state) registered`);\n\n    const unlistenUpdated = await listen('index_updated', (event) => {\n      indexStatus = {\n        ...indexStatus,\n        entriesCount: event.payload.entriesCount,\n        lastUpdated: event.payload.lastUpdated,\n        permissionErrors: event.payload.permissionErrors ?? indexStatus.permissionErrors\n      };\n\n      scheduleSearch(true);\n    });\n\n    const unlistenFocus = await listen('focus_search', () => {\n      void focusSearch();\n    });\n\n    const unlistenCtxMenuAction = await listen('context_menu_action', (event) => {\n      switch (event.payload) {\n        case 'open': void openSelected(); break;\n        case 'quick_look': {\n          const e = primaryEntry();\n          if (e) void invoke('quick_look', { path: e.path });\n          break;\n        }\n        case 'open_with': void openWithFallback(); break;\n        case 'reveal': void revealSelected(); break;\n        case 'copy_files': void copyFiles(); break;\n        case 'copy_path': void copySelectedPaths(); break;\n        case 'trash': void trashSelected(); break;\n        case 'rename': void startRename(); break;\n      }\n    });\n\n    unlistenFns = [unlistenProgress, unlistenState, unlistenUpdated, unlistenFocus, unlistenCtxMenuAction];\n    flog(`[startup/fe] +${ms()}ms all listeners registered`);\n\n    // Fetch backend state IMMEDIATELY after listeners are registered.\n    // Events emitted before listener registration are lost, so this\n    // is the only reliable way to get the current state.\n    await refreshStatus();\n    flog(`[startup/fe] +${ms()}ms refreshStatus done (state=${indexStatus.state})`);\n\n    // Show Svelte UI: remove skeleton, focus search input.\n    await tick();\n    document.getElementById('skeleton')?.remove();\n    await focusSearch();\n    flog(`[startup/fe] +${ms()}ms WINDOW VISIBLE — skeleton removed`);\n\n    try {\n      homePrefix = await invoke('get_home_dir');\n    } catch {\n      homePrefix = '';\n    }\n    flog(`[startup/fe] +${ms()}ms get_home_dir done`);\n\n    if (!localStorage.getItem('everything-fda-notice-v1')) {\n      showToast('macOS Full Disk Access permission may be required for full disk search.');\n      localStorage.setItem('everything-fda-notice-v1', '1');\n    }\n    flog(`[startup/fe] +${ms()}ms calling runSearch...`);\n    await runSearch();\n    flog(`[startup/fe] +${ms()}ms runSearch done`);\n\n    if (typeof ResizeObserver !== 'undefined') {\n      tableResizeObserver = new ResizeObserver(() => {\n        scheduleViewportHeightUpdate();\n      });\n      if (tableContainer) {\n        tableResizeObserver.observe(tableContainer);\n      } else if (tableAreaEl) {\n        tableResizeObserver.observe(tableAreaEl);\n      }\n    }\n\n    window.addEventListener('resize', scheduleViewportHeightUpdate);\n    window.addEventListener('click', onGlobalClick);\n    statusRefreshTimer = setInterval(() => {\n      if (indexStatus.state === 'Indexing') {\n        void refreshStatus();\n      }\n    }, 1000);\n    console.log(`[startup/fe] +${ms()}ms onMount complete`);\n  });\n\n  onDestroy(async () => {\n    clearTimeout(searchTimer);\n    clearTimeout(toastTimer);\n    clearInterval(statusRefreshTimer);\n    clearInterval(elapsedTimer);\n    resizeCleanup?.();\n\n    for (const unlisten of unlistenFns) {\n      unlisten();\n    }\n\n    tableResizeObserver?.disconnect();\n    tableResizeObserver = null;\n    if (viewportResizeRaf !== null) {\n      cancelAnimationFrame(viewportResizeRaf);\n      viewportResizeRaf = null;\n    }\n    window.removeEventListener('resize', scheduleViewportHeightUpdate);\n    window.removeEventListener('click', onGlobalClick);\n  });\n</script>\n\n<svelte:window on:keydown={handleKeydown} />\n\n<div class=\"app-shell\" data-theme={theme}>\n  <div class=\"title-bar\" role=\"presentation\" data-tauri-drag-region on:mousedown={onTitleBarMouseDown}>\n    <div class=\"title-left\"></div>\n    <div class=\"title-center\">\n      <svg class=\"title-icon\" viewBox=\"0 0 215 205\" fill-rule=\"evenodd\" aria-hidden=\"true\">\n        <path d=\"M85 0c46.9 0 85 38.1 85 85 0 20.1-7.2 38.5-19.2 52.7l40.7 40.8c5.8 5.8 5.8 15.2 0 21-5.8 5.8-15.2 5.8-21 0l-40.7-40.7c-13.6 9.7-30.4 15.2-44.8 15.2-46.9 0-85-42.1-85-89 0-46.9 38.1-85 85-85z m0 32c-29.3 0-53 23.7-53 53 0 29.3 23.7 53 53 53 29.3 0 53-23.7 53-53 0-29.3-23.7-53-53-53z\"/>\n      </svg>\n      <span class=\"title-text\">Everything</span>\n    </div>\n    <div class=\"title-right\"></div>\n  </div>\n\n  <header class=\"search-bar\">\n    <input\n      bind:this={searchInputEl}\n      class=\"search-input\"\n      type=\"text\"\n      bind:value={query}\n      on:input={scheduleSearch}\n      on:focus={clearSelection}\n      placeholder=\"Search file/folder names\"\n      autocomplete=\"off\"\n      spellcheck=\"false\"\n    />\n  </header>\n\n  <section class=\"table-area\" bind:this={tableAreaEl} style={tableGridStyle}>\n    <div class=\"table-header\">\n      <div class=\"table-header-track\">\n        <div class=\"col name\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('name')}>\n            Name{#if sortBy === 'name'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'name'}\n            on:mousedown={(event) => startColumnResize(event, 'name')}\n            aria-label=\"Resize Name column\"\n          />\n        </div>\n\n        <div class=\"col path\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('dir')}>\n            Path{#if sortBy === 'dir'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'path'}\n            on:mousedown={(event) => startColumnResize(event, 'path')}\n            aria-label=\"Resize Path column\"\n          />\n        </div>\n\n        <div class=\"col size\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('size')}>\n            Size{#if sortBy === 'size'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n\n        <div class=\"col modified\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('mtime')}>\n            Modified{#if sortBy === 'mtime'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n      </div>\n    </div>\n\n    <div\n      class=\"table-body\"\n      bind:this={tableContainer}\n      on:scroll={() => {\n        scrollTop = tableContainer.scrollTop;\n        headerScrollLeft = tableContainer.scrollLeft;\n        const scrollBottom = scrollTop + tableContainer.clientHeight;\n        if (scrollBottom >= totalHeight - rowHeight * 10) {\n          void loadMore();\n        }\n      }}\n    >\n      <div class=\"spacer\" style={`height:${totalHeight}px`}>\n        <div class=\"rows\" style={`transform: translateY(${translateY}px);`}>\n          {#each visibleRows as entry, localIndex}\n            {@const index = startIndex + localIndex}\n            <div\n              class=\"row {selectedIndices.has(index) ? 'selected' : ''} {editing.active && editing.index === index ? 'renaming' : ''}\"\n              on:mousedown={(event) => handleRowMouseDown(event, index)}\n              on:click={(event) => handleRowClick(event, index)}\n              on:keydown={(event) => handleRowA11yKeydown(event, index)}\n              on:dblclick={() => handleRowDoubleClick(index)}\n              on:contextmenu={(event) => handleRowContextMenu(event, index)}\n              role=\"row\"\n              tabindex=\"0\"\n            >\n              <div class=\"cell name\">\n                <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n\n                {#if editing.active && editing.index === index}\n                  <span class=\"rename-wrapper\">\n                    <span class=\"rename-sizer\" aria-hidden=\"true\">{editing.draftName || '\\u00A0'}</span>\n                    <textarea\n                      bind:this={renameInputEl}\n                      class=\"rename-input\"\n                      bind:value={editing.draftName}\n                      rows=\"1\"\n                      on:click|stopPropagation\n                      on:blur={commitRename}\n                      on:keydown={(e) => { if (e.key === 'Enter') e.preventDefault(); }}\n                    />\n                  </span>\n                {:else}\n                  <span class=\"ellipsis\">{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n                {/if}\n              </div>\n              <div class=\"cell path\"><span class=\"ellipsis\">{displayPath(entry.dir)}</span></div>\n              <div class=\"cell size\">{formatSize(entry)}</div>\n              <div class=\"cell modified\">{formatModified(entry)}</div>\n            </div>\n          {/each}\n        </div>\n      </div>\n    </div>\n  </section>\n\n  <footer class=\"status-bar\">\n    <div class=\"status-left\">\n      <span class=\"status-state\">\n        <span class=\"state-dot {indexStatus.state === 'Indexing' ? 'indexing' : indexStatus.state === 'Error' ? 'error' : 'ready'}\"></span>\n        {#if indexStatus.state === 'Indexing'}\n          Indexing{#if lastReadyCount > 0} ({Math.min(99, Math.round((scanned / lastReadyCount) * 100))}%){/if}{#if indexingElapsed} · {indexingElapsed}{/if}\n          {#if !indexStatus.isCatchup}\n            · {scanned.toLocaleString()} scanned\n          {/if}\n        {:else}\n          Index: {indexStatus.state}\n        {/if}\n      </span>\n      <span>{indexStatus.entriesCount.toLocaleString()} entries</span>\n      {#if indexingFinishedAt && indexStatus.state !== 'Indexing'}\n        <span>in {indexingFinishedAt}</span>\n      {/if}\n      {#if dbLatencyMs !== null && dbLastQuery}\n        <span>\"{dbLastQuery}\" {dbLatencyMs}ms · {totalResults} results</span>\n      {/if}\n      {#if searchModeLabel === 'spotlight' || searchModeLabel === 'spotlight_timeout'}\n        <span class=\"status-spotlight\">Spotlight fallback{#if searchModeLabel === 'spotlight_timeout'} (partial){/if}</span>\n      {/if}\n      {#if indexStatus.permissionErrors > 0}\n        <span class=\"status-warning\">{indexStatus.permissionErrors.toLocaleString()} permission errors</span>\n      {/if}\n      {#if indexStatus.message}\n        <span class={indexStatus.isCatchup ? 'index-progress' : 'status-error'}>{indexStatus.message}</span>\n      {/if}\n    </div>\n    <div class=\"status-right\">\n      <button class=\"status-btn theme-btn\" on:click={cycleTheme} title=\"Switch theme\">\n        {theme === 'dark' ? '☀ Light' : '◑ Dark'}\n      </button>\n      <button\n        class=\"status-btn rebuild-btn\"\n        on:click={resetIndex}\n        disabled={indexStatus.state === 'Indexing'}\n        title={indexStatus.state === 'Indexing' ? 'Cannot reset while indexing is in progress.' : 'Reset and rebuild the index.'}\n      >\n        <svg class=\"rebuild-icon\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n          <path d=\"M23 4v6h-6\"/><path d=\"M20.49 15a9 9 0 1 1-2.12-9.36L23 10\"/>\n        </svg>\n        Rebuild Index\n      </button>\n    </div>\n  </footer>\n\n  {#if contextMenu.visible}\n    <div class=\"context-menu\" style={`left:${contextMenu.x}px;top:${contextMenu.y}px;`}>\n      <button on:click={() => (closeContextMenu(), openSelected())}>Open</button>\n      <button on:click={async () => { closeContextMenu(); const e = primaryEntry(); if (e) await invoke('quick_look', { path: e.path }); }}>Quick Look</button>\n      <button on:click={() => (closeContextMenu(), openWithFallback())}>Open With... (Reveal in Finder)</button>\n      <button on:click={() => (closeContextMenu(), revealSelected())}>Reveal in Finder</button>\n      <button on:click={() => (closeContextMenu(), copySelectedPaths())}>Copy Path</button>\n      <button on:click={() => (closeContextMenu(), trashSelected())}>Move to Trash</button>\n      {#if selectedIndices.size === 1}\n        <button on:click={() => (closeContextMenu(), startRename())}>Rename</button>\n      {/if}\n    </div>\n  {/if}\n\n  {#if toast}\n    <div class=\"toast\">{toast}</div>\n  {/if}\n</div>\n\n<style>\n  :global(:root) {\n    color-scheme: light dark;\n    --bg-app: transparent;\n    --text-primary: #0d1826;\n    --text-muted: #48596c;\n    --bar-grad-top: rgba(255, 255, 255, 0.48);\n    --bar-grad-bottom: rgba(248, 250, 253, 0.42);\n    --surface-header: rgba(252, 252, 255, 0.40);\n    --surface: rgba(255, 255, 255, 0.22);\n    --border-soft: rgba(0, 0, 0, 0.07);\n    --border-input: rgba(0, 0, 0, 0.13);\n    --focus-ring: #6f96e6;\n    --row-border: rgba(0, 0, 0, 0.032);\n    --row-hover: rgba(0, 0, 0, 0.06);\n    --row-selected: rgba(0, 0, 0, 0.12);\n    --button-bg: rgba(255, 255, 255, 0.62);\n    --button-border: rgba(0, 0, 0, 0.10);\n    --button-text: #2c3e50;\n    --menu-bg: rgba(240, 241, 248, 0.90);\n    --menu-border: rgba(0, 0, 0, 0.06);\n    --menu-hover: rgba(255, 255, 255, 0.62);\n    --menu-text: #1a2a38;\n    --error-text: #b64545;\n    --warning-text: #8f6500;\n    --toast-bg: rgba(18, 22, 32, 0.90);\n    --toast-text: #ffffff;\n  }\n\n  @media (prefers-color-scheme: dark) {\n    :global(:root) {\n      --bg-app: transparent;\n      --text-primary: #e6e6ea;\n      --text-muted: #9494a4;\n      --bar-grad-top: rgba(38, 38, 46, 0.52);\n      --bar-grad-bottom: rgba(30, 30, 38, 0.46);\n      --surface-header: rgba(32, 32, 40, 0.46);\n      --surface: rgba(18, 18, 26, 0.32);\n      --border-soft: rgba(255, 255, 255, 0.065);\n      --border-input: rgba(255, 255, 255, 0.14);\n      --focus-ring: #5b8bd9;\n      --row-border: rgba(255, 255, 255, 0.026);\n      --row-hover: rgba(255, 255, 255, 0.08);\n      --row-selected: rgba(255, 255, 255, 0.14);\n      --button-bg: rgba(255, 255, 255, 0.072);\n      --button-border: rgba(255, 255, 255, 0.11);\n      --button-text: #d6d6e0;\n      --menu-bg: rgba(36, 36, 46, 0.90);\n      --menu-border: rgba(255, 255, 255, 0.066);\n      --menu-hover: rgba(255, 255, 255, 0.062);\n      --menu-text: #e0e0e8;\n      --error-text: #ff9d9d;\n      --warning-text: #e0c670;\n      --toast-bg: rgba(10, 10, 16, 0.93);\n      --toast-text: #f2f2f6;\n    }\n  }\n\n  /* ── Theme: Dark ──────────────────────────────────────────────── */\n  :global([data-theme=\"dark\"]) {\n    color-scheme: dark;\n    --bg-app: #1E1E21;\n    --text-primary: #E2E8F0;\n    --text-muted: #94A3B8;\n    --bar-grad-top: #1E1E21;\n    --bar-grad-bottom: #1E1E21;\n    --surface-header: #1E1E21;\n    --surface: #1E1E21;\n    --bg-input: #161618;\n    --border-soft: #2A2A2D;\n    --border-input: rgba(255, 255, 255, 0.06);\n    --focus-ring: #4DA8FF;\n    --accent: #4DA8FF;\n    --row-border: rgba(255, 255, 255, 0.02);\n    --row-hover: #282828;\n    --row-selected: rgba(77, 168, 255, 0.10);\n    --button-bg: rgba(255, 255, 255, 0.05);\n    --button-border: #2A2A2D;\n    --button-text: #94A3B8;\n    --menu-bg: #252528;\n    --menu-border: #2A2A2D;\n    --menu-hover: rgba(255, 255, 255, 0.04);\n    --menu-text: #E2E8F0;\n    --error-text: #ff9d9d;\n    --warning-text: #e0c670;\n    --toast-bg: rgba(10, 10, 16, 0.93);\n    --toast-text: #f2f2f6;\n  }\n\n  /* ── Theme: Light ─────────────────────────────────────────────── */\n  :global([data-theme=\"light\"]) {\n    color-scheme: light;\n    --bg-app: #F5F5F7;\n    --text-primary: #1C1C1E;\n    --text-muted: #6E6E7A;\n    --bar-grad-top: #F5F5F7;\n    --bar-grad-bottom: #F5F5F7;\n    --surface-header: #F5F5F7;\n    --surface: #F5F5F7;\n    --bg-input: #FFFFFF;\n    --border-soft: #D1D1D6;\n    --border-input: rgba(0, 0, 0, 0.10);\n    --focus-ring: #3A8BF5;\n    --accent: #3A8BF5;\n    --row-border: rgba(0, 0, 0, 0.04);\n    --row-hover: rgba(0, 0, 0, 0.04);\n    --row-selected: rgba(58, 139, 245, 0.10);\n    --button-bg: #FFFFFF;\n    --button-border: #D1D1D6;\n    --button-text: #3C3C43;\n    --menu-bg: #FFFFFF;\n    --menu-border: #D1D1D6;\n    --menu-hover: rgba(0, 0, 0, 0.05);\n    --menu-text: #1C1C1E;\n    --error-text: #D93025;\n    --warning-text: #B45309;\n    --toast-bg: rgba(255, 255, 255, 0.95);\n    --toast-text: #1C1C1E;\n  }\n\n  /* ── Themed element overrides ─────────────────────────────────── */\n  :global([data-theme]) {\n    background: var(--bg-app);\n  }\n\n  /* Search bar: flat, no gradient, no separator */\n  :global([data-theme]) .search-bar {\n    height: 44px;\n    padding: 0 16px;\n    background: var(--bg-app);\n    border-bottom: none;\n  }\n\n  :global([data-theme]) .search-input {\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n    font-family: 'JetBrains Mono', 'SF Mono', monospace;\n    font-size: 12px;\n    height: 34px;\n    border-radius: 8px;\n  }\n\n  /* Table header: flat bg, 16px edge padding */\n  :global([data-theme]) .table-header {\n    background: var(--bg-app);\n  }\n\n  :global([data-theme]) .col-button {\n    padding: 0 8px;\n  }\n\n  :global([data-theme]) .col.name .col-button {\n    padding-left: 16px;\n  }\n\n  /* Row cells: JetBrains Mono, 16px outer edges */\n  :global([data-theme]) .cell {\n    font-family: 'JetBrains Mono', monospace;\n  }\n\n  :global([data-theme]) .cell.name {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    padding-left: 16px;\n    font-size: 12px;\n    color: var(--text-primary);\n  }\n\n  :global([data-theme]) .cell.path {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.size {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.modified {\n    padding-right: 16px;\n    font-size: 11px;\n    white-space: nowrap;\n  }\n\n  :global([data-theme]) .row.selected {\n    box-shadow: inset 3px 0 0 var(--accent);\n  }\n\n  /* Dim path/size/date cells in themed mode */\n  :global([data-theme]) .cell.path,\n  :global([data-theme]) .cell.size,\n  :global([data-theme]) .cell.modified {\n    color: var(--text-muted);\n  }\n\n  :global(:root) {\n    background: transparent;\n  }\n\n  :global(html, body) {\n    margin: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    background: transparent;\n    color: var(--text-primary);\n    font-family: Inter, 'SF Pro Text', 'Segoe UI', Helvetica, Arial, sans-serif;\n  }\n\n  :global(#app) {\n    width: 100%;\n    height: 100%;\n  }\n\n  .app-shell {\n    display: grid;\n    grid-template-rows: auto auto 1fr auto;\n    height: 100%;\n    min-width: 0;\n  }\n\n  .title-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 44px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    cursor: default;\n    flex-shrink: 0;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-left {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-center {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-right {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-icon {\n    width: 14px;\n    height: 14px;\n    fill: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .title-text {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 13px;\n    font-weight: 500;\n    color: var(--text-primary);\n    letter-spacing: -0.01em;\n  }\n\n  .search-bar {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding: 8px;\n    background: linear-gradient(180deg, var(--bar-grad-top) 0%, var(--bar-grad-bottom) 100%);\n    border-bottom: 1px solid var(--border-soft);\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .search-input {\n    display: block;\n    box-sizing: border-box;\n    width: 100%;\n    min-width: 0;\n    flex: 1 1 auto;\n    height: 36px;\n    border: 1px solid var(--border-input);\n    border-radius: 14px;\n    padding: 0 10px;\n    font-size: 14px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    backdrop-filter: blur(12px) saturate(160%);\n    -webkit-backdrop-filter: blur(12px) saturate(160%);\n  }\n\n  .search-input::placeholder {\n    color: var(--text-muted);\n    opacity: 0.85;\n    font-size: 12px;\n  }\n\n  .search-input:focus {\n    outline: none;\n    border-color: var(--focus-ring);\n    box-shadow: 0 0 0 2px rgba(125, 169, 255, 0.25);\n  }\n\n  .table-area {\n    display: grid;\n    grid-template-rows: auto 1fr;\n    min-height: 0;\n    min-width: 0;\n  }\n\n  .table-header-track,\n  .row {\n    display: grid;\n    grid-template-columns: var(--col-name) var(--col-path) var(--col-size) var(--col-modified);\n    align-items: center;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .table-header {\n    height: 32px;\n    border-bottom: 1px solid var(--border-soft);\n    background: var(--surface-header);\n    user-select: none;\n    overflow: hidden;\n    flex-shrink: 0;\n  }\n\n  .table-header-track {\n    height: 100%;\n    transform: translateX(var(--header-offset, 0px));\n    will-change: transform;\n  }\n\n  .table-header .col {\n    position: relative;\n    min-width: 0;\n    height: 100%;\n  }\n\n  .col-button {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n    gap: 4px;\n    box-sizing: border-box;\n    padding: 0 8px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 11px;\n    font-weight: 600;\n    line-height: 1;\n    color: var(--text-muted);\n    text-align: left;\n    margin: 0;\n    border: none;\n    background: transparent;\n    cursor: pointer;\n  }\n\n  .sort-icon {\n    width: 10px;\n    height: 10px;\n    flex-shrink: 0;\n    color: var(--accent);\n  }\n\n  .col-resizer {\n    position: absolute;\n    top: 0;\n    right: -4px;\n    width: 8px;\n    height: 100%;\n    border: none;\n    padding: 0;\n    background: transparent;\n    cursor: col-resize;\n    z-index: 30;\n  }\n\n  .col-resizer::after {\n    content: '';\n    position: absolute;\n    top: 7px;\n    bottom: 7px;\n    left: 50%;\n    width: 1px;\n    transform: translateX(-50%);\n    background: var(--border-soft);\n    opacity: 0;\n    transition: opacity 0.15s ease;\n  }\n\n  .table-header .col:hover .col-resizer::after,\n  .col-resizer.active::after {\n    opacity: 1;\n  }\n\n  .table-body {\n    overflow: auto;\n    min-height: 0;\n    min-width: 0;\n    background: var(--surface);\n  }\n\n  .spacer {\n    position: relative;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .rows {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .row {\n    height: 30px;\n    border-bottom: 1px solid var(--row-border);\n    cursor: default;\n    -webkit-user-select: none;\n    user-select: none;\n    outline: none;\n  }\n\n  .row:hover {\n    background: var(--row-hover);\n  }\n\n  .row.selected {\n    background: var(--row-selected);\n  }\n\n  .cell {\n    padding: 0 8px;\n    font-size: 12px;\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    min-width: 0;\n  }\n\n  .cell.size {\n    text-align: right;\n    font-variant-numeric: tabular-nums;\n  }\n\n  .ellipsis {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n\n  .hl {\n    background: none;\n    color: inherit;\n    font-weight: 700;\n  }\n\n  .file-icon {\n    width: 16px;\n    height: 16px;\n    flex: 0 0 auto;\n  }\n\n  .row.renaming {\n    height: auto;\n    min-height: 30px;\n    align-items: start;\n  }\n\n  .row.renaming .cell.name {\n    align-items: start;\n  }\n\n  .rename-wrapper {\n    display: grid;\n    flex: 1;\n    min-width: 0;\n    margin-left: calc(-1.5px - 5px);\n  }\n\n  .rename-sizer {\n    grid-area: 1 / 1;\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 12px;\n    padding: 2px 5px;\n    border: 1.5px solid transparent;\n    visibility: hidden;\n    white-space: pre-wrap;\n    word-break: break-word;\n  }\n\n  .rename-input {\n    grid-area: 1 / 1;\n    width: 100%;\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 12px;\n    padding: 2px 5px;\n    border: 1.5px solid var(--focus-ring);\n    border-radius: 4px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    outline: none;\n    resize: none;\n    overflow: hidden;\n  }\n\n  .status-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 32px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    border-top: 1px solid var(--border-soft);\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 11px;\n    color: var(--text-muted);\n    white-space: nowrap;\n    overflow: hidden;\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .status-left {\n    display: flex;\n    align-items: center;\n    gap: 16px;\n    overflow: hidden;\n    min-width: 0;\n  }\n\n  .status-right {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    flex-shrink: 0;\n  }\n\n  .status-btn {\n    border: 1px solid var(--button-border);\n    border-radius: 5px;\n    background: var(--button-bg);\n    color: var(--button-text);\n    font-size: 11px;\n    height: 22px;\n    padding: 0 8px;\n    cursor: pointer;\n  }\n\n  .status-btn:hover {\n    filter: brightness(1.06);\n  }\n\n  .status-btn:disabled {\n    opacity: 0.55;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .status-state {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n  }\n\n  .state-dot {\n    width: 6px;\n    height: 6px;\n    border-radius: 50%;\n    flex-shrink: 0;\n  }\n\n  .state-dot.ready { background: #28C840; }\n  .state-dot.indexing { background: #FEBC2E; }\n  .state-dot.error { background: #FF5F57; }\n\n  .rebuild-btn {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 10px;\n    font-weight: 500;\n    background: var(--button-bg);\n    border: 1px solid var(--button-border);\n    border-radius: 4px;\n    color: var(--button-text);\n    height: 22px;\n    padding: 0 10px;\n    cursor: pointer;\n  }\n\n  .rebuild-btn:hover {\n    filter: brightness(1.1);\n  }\n\n  .rebuild-btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .rebuild-icon {\n    width: 11px;\n    height: 11px;\n    color: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .status-error {\n    color: var(--error-text);\n  }\n\n  .status-warning {\n    color: var(--warning-text);\n  }\n\n  .status-spotlight {\n    color: #f59e0b;\n    font-weight: 600;\n  }\n\n  .context-menu {\n    position: fixed;\n    z-index: 200;\n    width: 220px;\n    border: 1px solid var(--menu-border);\n    border-radius: 10px;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.16), inset 0 0 0 0.5px rgba(255, 255, 255, 0.18);\n    background: var(--menu-bg);\n    backdrop-filter: blur(28px) saturate(180%);\n    -webkit-backdrop-filter: blur(28px) saturate(180%);\n    overflow: hidden;\n  }\n\n  .context-menu button {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    padding: 8px 10px;\n    font-size: 12px;\n    color: var(--menu-text);\n  }\n\n  .context-menu button:hover {\n    background: var(--menu-hover);\n  }\n\n  .toast {\n    position: fixed;\n    right: 14px;\n    bottom: 18px;\n    background: var(--toast-bg);\n    color: var(--toast-text);\n    border-radius: 10px;\n    padding: 9px 12px;\n    font-size: 12px;\n    z-index: 250;\n    backdrop-filter: blur(20px) saturate(180%);\n    -webkit-backdrop-filter: blur(20px) saturate(180%);\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);\n  }\n</style>\n","numLines":2257,"startLine":1,"totalLines":2257}},"sourceToolAssistantUUID":"e937e7a1-9199-473f-b644-96245df7616b"}
{"parentUuid":"11a5d4ce-31e1-4a08-95b4-d90ec04acdae","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","message":{"model":"claude-sonnet-4-6","id":"msg_01VALoN5gWWzhAnjJ9EMgjQV","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Now I understand the current implementation. The rename functionality uses a `<textarea>` with a `rename-sizer` (hidden ghost element) to auto-resize the row height. The user wants to change this to an overlay-style rename (like Finder) where the row height stays fixed and an overlay input appears on top of the row.\n\nThe key changes needed:\n1. Remove the auto-height expanding row behavior (`.row.renaming { height: auto; min-height: 30px; ... }`)\n2. Keep the row at fixed `30px` height during rename\n3. Show an overlay input positioned absolutely over the name cell\n\n\n4. The overlay should appear like Finder's inline rename - a floating input box over the file name\n\nThe simplest approach is to keep the row at its normal height, position the rename wrapper absolutely to overlay the name text, and have it sit on top of the row at the exact location of the name cell.\n\nBut absolute positioning inside a virtual scroll list gets tricky since rows are translated. I think the better solution is to position the overlay relative to the name cell itself - give the cell `position: relative` and let the rename input float absolutely within it. This keeps the row height fixed at 30px and is more maintainable than calculating positions relative to the table body.\n\nSo I'll remove the height and alignment overrides from the renaming state, add relative positioning to the name cell, and make the rename wrapper absolutely positioned to cover the text.\n\nPositioning the overlay...\n\nActually, I'm overcomplicating this. Since flex containers create a containing block for absolutely positioned children, I can just add `position: relative` to the name cell and then position the input wrapper absolutely to cover where the text would normally appear. explicitly (to be safe)\n2. Make `.rename-wrapper` use `position: absolute` with proper coordinates\n\nLet me look at the cell structure and think about how the input should overlay the filename text. The row is a flex layout with the icon, gap, and text area, so I need the input to appear right where the filename would be.\n\nActually, I should reconsider this approach. For a Finder-style rename, the row should stay at its normal height while the input field floats over the filename area as a compact text field. This means keeping the row at 30px, making the rename-wrapper a regular inline element that fits naturally in the flex layout, and switching to a standard text input instead of a textarea since multiline expansion isn't needed here.\n\nImplementing this now: I'll change the textarea to a text input, remove the ghost sizer element, strip out the height expansion CSS, and style the input to sit cleanly within the row's fixed height. Styling the rename input...\n\nI need to keep the `renameInputEl` binding for focus and selection management, and switching from a textarea to a standard text input means the Enter key will naturally stay single-line without needing the preventDefault handler. The `setSelectionRange` method works fine on text inputs, so that's compatible. Now I'm updating the template to replace the textarea with the styled input element.\n\nUpdating the styles... Still writing styles...\n\nNow I'm thinking through the details—since we're switching from a textarea to an input element, I can remove the resize and overflow properties that were specific to textareas. The font styling should work fine since the input's own font-family rule will take precedence over any parent styles. I could keep the `renaming` class on the row even though it's no longer doing anything, or I could clean it up. And I'm considering whether to add a subtle shadow or elevation effect to give it more of a Finder-like overlay appearance.\n\nBut actually, re-reading the request about an \"overlay된 이름 변경 tool\"—I need to clarify what they're really asking for. In Finder, the rename input doesn't float detached from the layout; it replaces the text label inline while keeping the row height consistent. That's probably what makes sense here too, rather than a truly floating overlay.\n\nI should make sure the input inherits the styling context from the `.cell.name` element, including the padding and font, and since it's in a flex container with `flex: 1` and `min-width: 0`, it'll naturally fill the available space. Now I'm ready to write the implementation, making sure the `renameInputEl` binding works correctly with the input element.\n\nUpdating the styles now...","signature":"EqdeCkYICxgCKkB5X/zVVOvNQ/qqk04/JEUJ0iU9lmjKRKbwCvB5lHoPEOA/3r1N+rT8B/CngJ7fBwVXm9IdlonWvA9e0N8318BmEgxW5hbeXcowJuJXqRoaDGOrq7VH7F0gfFHaRiIw6VQPXlcsoEXEnaYTvrAZepJP7q3YlvZp/vsSdjFrAo9PNOgYx8KnUial8o18W0ZBKo5dhdCxZFX8tWm9RyA8iivmj1elTze4aH9/qyEpIB3WeYDnHu/u5nAcREGGI9SlyUnGWURAC5U7gsDsvMm158hVLFjILQfZY5ICJmEj4+6Klx/2sKw3ZBUr1jZ3rANptHOgqByIa2GkwkPhIBiJ6i99VAR3k3po/Nu0ovZPBe2abzbAa92G+gxZA6ldGbFdK4TNK3n48Ce19SjKueIVYns6xvU+JxzmYP46R+WiGEV1pLl7JSxAo00cznO75wZPX4tS+PEO2tunR15OnDWuWVC4r5XPzxcmKDJbRcfHpAOgwLVG2eoHyn1tpFQSCE8lFDDeAo8fc7QGfR9x/ZIkqWyau07oteIxBmcYstdqe5xSBU21r0X6O81oIEJAz4pLtvhqknZHMqSJ7lSD3vKBV5T33bycRtTFBiKV7XUkYSNXGn1/tc58M3mbsM5BtxcbK5fIlOKsi3Y99oELpVm5RB/pDBArliCmtBFElVg/MidmMwEcyS5la1Yw82g2Nj6JnDcl3BYR8YueVVu5jX8uqtOC0cHa0KhZHaQeK6hG3/VdvoWhOzN5Fshuau8LUHul9JRcw/7+ITaDLLa53ir4ofd5uN+uAdtDvAvmsn98WIYC57NW+dGmysZsbQZSu4RaK7MH8e0g1HIdhoku+ubv0tlh/3wVPaxCCSFD8TE4IKslqpeNdEfCGHlo5t5tMNObQXc/9kih8tO82BqcADjAehJBQjCRpmkPWLqJT88HH/3Q6cVUSnDCizphyGg2FPMHwBNVKSUulCdr/XSgFlHCGXTvWUwn7Uz1tyV6s/KD5ULgOAxHZ+f7QTIcY1dwkq5EX+pqq7p1BfryFjLzAJ1QTVvXdbwo/G6atiMi96lMGkeneVURo5MHnnrgZbmYX2yO/Dc4F02qgauBcOu75lzrZsG/AJ74oBl+7jgXcGupfmruRFB92wUlaF0lfnIwy1yQL6t+NZ9LomfIzAKmsAUNldRAhPRpdqDS6d2W+/LiWckwD0JFYyh6u/eC14ymhnKIm3nHenO0p4cAiZy3Omh/5AVqjnUdf2EJzzX2s518bMUyq8fjetrbgzAHHI+6Ck2ISuZO2MGboTFXbKPI+2Nq1kfWY95c0B+TbX/ISJFSnMKnwx0QwCrusd4lnBVX4AOHKdVACMbgmmP86bzE96He29uh/lj6OlShDomsyDvTmaK05gmknzZJP96cP69/T4hji61hfioo5zmdTxGySnCRBL3pnb2DVfkHcQs/np1mkloRQ8vWXLCqYhgwO5jFHkhALSGZ95fKOZQF8/LXSJPyKKSdYQuCFb3mZZ2YdLAeB2GZhH2ZiGLbY5vw1uJnExmg858qopR2dccMywcWrq4M/YCRnoanOJ0dAxHoiMxo18SPJhQMUYoJSH9O1n4UqTc7hlFb84KCmQH0rAsIUX4ysl3DZbEyNNZt+w5D9+DaenFR9s4/CgySitH5TKV4BntrH5sggGUO0gGDPXDOVjAuJn8Ll9HbhjoCPmOfqUBciscVd+bhA5qSJWmnYB+e9NhMfwzg3D3PwPLd0uicKNIlDFj+LZPsFv49k+7nqZbCZ/AnPesERP8JvKepKX0qw6NW5omHAiB+NmbJ14DcoATorugDW08Z2Fud0qInsshoJrJpBZInevckWXRNe3AdVmRGpkLCKTBxsKSE8fhKyn9xO42k28XEkGMqE1Zudpmj1DXUPj253UQhQASgbGTNsc1AMvM2Lrme8BlNKzsgdkCzeRzPKOc/9WEiM6yZ1trixAPHxce+eMXdicd4VliUJWUnRidZzdSQuU82WlIt8tLQkuz3f5ERnTEhRkkQHA2UMhReEAioJIlcbEXZuSZ99eWhprFsCRz+Ae6ubraubGkOw5eDSRagvdO4X2WJcMxWRpGyDTL4lIYE8HT4goJ11U3KT1UvjNIRiRPTaUqaEqdrMXPQ9S8AJYRkhi42eNhlLp0T/kaSeI6wsckfm7clFsYlxEHOgesYsphXfUDjP1VCliPVnlOSue/OYrn8zw+QOBCBdoSzZMoBvzx/+EFhtWi2psz/BW9BILqaYIQhQddnSk48ZSya9ZFgJeaPW13z1ZyXgvjo/tVhJY9er4v2Sj9WfpNFIYHv8rHqHR/mqnVJ1LIcw543rvY4ZaqDc9Yk2pkTgAGBHlNB/fJ6SZ/b5zwvaKRS+/ZWBEiamzYLzR/fiY6INy9C/zGcPHnJI+ot9Vfy2IiC+9DOh3Qw6WWeTEUW95MtP/gFcE0nSXLBtjyFPTxMYcIMety+zt7lmC/TP9Qo04SZjZdMLL2r/TpQ0z6TL3+NOE8M9FNhVX4YQrJN4lirTebgkzIgCnc2m/0GxDqB31zvAV2M9pamrLyB2BARuXki7XdMC6oJIfEqPJkng1C7OECA5EQeKNX/slra8nnlpRE5RxOSiMBq6KAzpOXIt1iWLQ4VLTutIg5pcQ984VqKcBMfl3RURjdS1kygb1OLbjwNBq3yVo96A1MT2Nz4tbC2gVxn2qU+7C4N4bW1K3YOFl+sWXfkSqi+QckDnI8x4hGR/yC9ryV9pxA0fjxs3UKEEnfilW3vznzA1hWPH0TdYR5fTwTRfuh4zBpHnUrE41TWyCX9u/ZiPqVDQv6O/OKNcF8dgAeh7QArL0rzPDvP+hZsTOIDtwNa6i2iD9hVD99JB4Ovd6Z28E4WPJ/oYkVgB3FfpEMHI28KMZXncvZNW2cKEWwYCMLmdO2NT93hl6P2cj7eTubOjSFX51Drmj/t08BKEEdWRyVoeHgvOXpwXz8N0isRVnDYvg7/CwJaWhtT2CysT6hkRNJQDHMZnCOheMu4Bbr+VCyKArP8Wt5J9vaECvCBGt/iB4VVToiIOO06nv7BK3J0Pp2hwA9yints9nD6ilHHF3m/UaJEUP+99y8WRcvGb9T2IW4cI0kVQ84Wvp/MWkqHaEa8F/46emPwfgHUr1Y0ArsVnjZM1r3e6UZSYPgDWE4CySFPrLglKRea624QZgAzZQKG8USo3R0+b6ACQ2Ngji0JPjue6Pa+81cwDEykqeP11LcVxpt/fu3og9wqi+1oijpQsx2khT9+lfsR6//cqFWhMOGmlJJeSPnPB+TlNuOsKz/kt1UiCI5FMODhQiDA+wndFiHxHXuUUJVbVY0Euaj5n3Fm11xduKNDD8sUSV1x0whMPhV+yeHwFzjY5FIPUj9vO+NbkAg9IYzleN9rtHvalKbHZIUrL5HDDA98jkAUd5VGrLHaVDjCSS9qbOwCbnOqvZ8vexUdLdLt/o2H3aWz1dArwj7kd/Fx8qqv14DTETl9xUUci0Wq8H9HjBYntlsuVfPCczO8fDVI2ba3M7j9+oaUD13GSjquH7H1iQtAjfPBHiHtuOEkfUYOTCeC25CMuFayU6bC/557ZuqRgJoM8j1LVjpHbvg64V1KaG53p2UcBt+lm3nJSrI6QMWFUsAL8SKldMF225joPy3BeQfDx0EeTNuOuUlm18DWyFWEfnt4DRzKAJrb8ByMW3JAL7oVdO5K2P5ssCmbMWIJa9K2KoovintPy2bqPuZlSaJLHP/Scx0GmJawkS/7AlTt+WHCkYGJHfiDF95MBA0KBR94C5Mm8NLH9CkhoPCOufddAbDnq57WggyCJNSJxiWLMomhpgA19Mca5C9QH6h4gFNJ8HZ7dV6FFVGxMPnjlIJr6UnduFwcB3Dw8mbAdeMoNxczyU5hqoiZ0rPJQr3CV52fkMQAWUu/XRZ89Rotpkti9BuqVDywjXT+GlfQQXDPylc92zOvBX41PtwKxsd3mFsppSVxeg4Q/az0JL8fWwjM3iuR9KwxYaP6iMvZh2EDbyjoelHC8+HhDe0IMWf2TjnYnxML/y0Vka5xIc39AgywX0R2uYtAKGlzIgXfdCs8OQc3MYQ2RkIFyfrLzS3PCM+laPIno628lTAirSUQn/zJ5NnBUXbxzI3i+X0PZs0viSWwKnrTv26wEiZyD7ENM8Egyp8IgEjPFO6HEyv+Z7Yh0AtILOW7FdggvO+/bloOSmHvAEcimktKxkgAbxpMtchwc8GliBgwTK1WP8GrZ8akar5AKQ8lyLsy3ngjv7adDatJ1soB+q85CfJTAzX15GbVANxGuaZBRa2xuJUIy2pjyDNRJbJKQbxI1yESiAfOBBovNwHf2IM6lxJWkyKoQhh4aOPmGOKlXG1B1k6n0tRss9bmRP7R5wZawa+9Q1KTEpfPhf2G7qr8Cnqyw7HdTvZEJK9cq6A/uvVTZbnHS4fFWSkx6uir7KAkxGXKgGjpHPWL0u87HawEN5n/Z3vjNpz7QzsY1WmtnIzCntptuMccPZr/3lOvwQ4DKciU0NVqV+vTW749Gq3J6VgbkA6yr3durx7B6hYpvZCVI8xpLeYyktLN3BbYIrB4tjSjszVag5RiOsr6Fn6qLW74v62489YPnHAdAYStQa+m3CHoomKFEotn/WzcnpJYFvTvNj1RxLR/Dk3W5vE7IKmNyqUp7yo+OfGM5sl9i3DhsqBK1UWcPLT4aSJSFCALHTbrudyelth1Y8S2WHKlj8+2TXO+o4J+7hetB3cJvvgG2O13HnzvoFbPALo/n3j+ALkxOP9ndSmryp/UyELNRLAXblB3FP2IvV/efqtFZ9zUYAwg4oWt6/yoBLHzvoNh4pmCqBiRH7pBZTWvVjz/ynT37sOb0Ch9IKQvFWjXwHXm5qMj0qDk69vuvkQPrFkCmhoZORPNGj3c5MtOIc+0GAjeiLwPf+e0VnXxryELT+GISwrb0g8n9K8mSwEGOPXrEhh/RJNI+q2qBZRCmOTdv9EG8Xqf01VonoOF090UWZK06yHMWtQIL8lFw7FbL3GISpLveEMbMOWo9xzZ8jOgFxwqWjjxaj3nEE9JCOy58nGFaRQVV8iBV1W4AFQ92RjN6MhKSbVKZOyz/GXHLawQ8IrvxVMWIW9lDhzMfZ+HjLSVbktmyJYqUv/V30F+YcvculFyOr1jnKsSwPC7GC9xZ95YslEaik4uM9Vc++ckXR+/kJfSEDovBINwHjkGyU/PAcRCaoMAAj7YgYZU4rB2r/Vjup10sUsFKPJ/v4Y2wqzqClJSzOFF+uUqWymJISAiQn4uVLtr558rrXntDlPSnCyfh9GOTQ0P8M1zVu4MQYKtW+cg/VN0KsHSK5nUu4EjwCLjp9Lcd2krNy8FiGGLgmcrIcG+eix0rPAxJ35SJE+mPayvfgA3q3J4CPxp3P83sHaXnzwuSY07N4DnEf1S1O4Sg1MO1FgbKvu7DptA/K5L4IN8CGT0xYdPbqg1ONcAu/LA0lNeWY1z/be0e1yzYbXRBeWgofjDarmvHwlpkRTEY3/tMbdKoLafvo9QKruhtJ5IueoBMif5QueFGOh/OSpoOC6viauWnqpwlwyJErax6EYpCfjZ50XsOfUce9ADxwIhidXUlA8VtPZWwGPKLt0uoIHJHZ6q1MYZqXr45iIOm/5ys318uspIPEGDuz19Um6dIaqDL8tppPnzX2XBzk7y1WJD8a8tYT6zjJGIaqYaWf3wfVaiWZxMy/iwDkBRbk0boXs4siJ2opnk0COzywDZNLfYUwTkWncGWfLyFNVN7l5c7Tvw1vwOza+f/q6VxrfNsF0s5CsVouK0x5JfzDcL1+QXaYOPy+R+fvKv1umCPugaRgW0lxMLxJRQrXwBxQzfyV0tZvvpjK0ZEdDCa+VDR8qqxtHdWDm+eYWvcNLvaoXoqoN8Aw0TXgbb9TsLD87jQy5HWwtn7K4hVCmyND4dgwirdQ8ab2QC2BfIYrpjCUdsMXbRbc5kkU1nfY7C7Tty0SZ6xBuXADzJJ/EXV3+5rukrCi8TlLxiBabzAnmS7SBJuYFGXPfKG24xSVGGE8W3EyvFQtQc6FQPN4NEWA6ACKQO7/9wXPnOICgsZSjp6qrvXZsoMyEvalrgQ3BW8OFNg6UamSF+9cVAICPMSEvVGQ/yIn7s9zToy8mPAHUUlNfJQenGPStHg6O82YAAVlVtkIdxPAoHhuCnb5IgwwXmYchjjcqoERfkG6WnX9yMOHab38ir8v30CxsSjIcT+a40hQY+vvKNRdZsrJQ5fzClXR/hp+8pIbDQVbzU8pKH2Y/pPXemVH807nFi97+IBR50GtbCOJJ79eGU23YiDLTIfI5zaq9hRUeimvWGxirNc7Ms9qIPvn+X0Kd54byvd8x2+dzQsevWUfdFlGd9SsikPQBcq9NmiJuFHEpMMuccS1p65oru70/1FPvRDTnUrmNgP+JmTtJgeOCmmuaHZCOoOISB7ESbLQcw0gMOnbnm1Uf7dBNKvbar8CtU8YeEsa1Zg8qUJ0y7BS/5wvw63KgTpO7BhpynxeO97vTJL0BsjDFIHlSxMKgCSjpKMCWNARUmVU+db1tPIJ3E/AELZVzxv2JE7kWIYCu2dDihXjPECRoPaQEASnD8eFx7CQKPiQNL2WOw9cOx2HnG7IypZ/C2qUse20mj/U8VAHRH/kZBEclTh8MI2tLQhM34OSweZNiePAVaDO3mdaoNSkWNZS3TMeuQu+9mT8CpjySemi0iM9HTJWIvwPf5WLKANIU/hznElfxK8s80atkeXdERS+MgtGpT1H1d4nIy1tfyBuhcpirRZgw2jtI/LxC9WtKvdYD2SINYSqLhwDbvL8XfGOhtdMjzOqLoVQtTaJImKzC3aumjYtECjvUQxDqMcosntF0Ic+uOsjQuLdhIAWxJ8NAiFpmYKBbXk3yrre622+Rllkw9NGpG1MZe/bpBuLkn7mXrgmxxj+ha1FfV0HPIQc+ehwbonUKFLgZaowUrbd3JcKPs2mieX/KsFYBVG3Rli9UBhmjvMjv+TbP1czbRYyx4E1hokF4uYozXnCc8dvi1L/UnTYBVI7Nh32HPG6itLCHZDxu9Q2r1AZyPUDREIfCQygr8s4sHhNNSoJ0Q8V/rXqKuFyITNviTZLJvkpXZgQlY5txUh0kcTU5/7CMN+7pSsx5iePFFMo8tBOhiRgnGP3iP8iwcXxrBBSAbaSZV+AKYqEw4QrbvXewZ7a/L65YWiwnqdFgSIFcwdXHwEPAquumn+jXGzBmoaHj7SPT6ZgQ8RhN2IWa1k8cZsx7DocwJcQQmckxffMheRANMbhxyrjM2EnjZd42t6UdF1/tm+0zvd/oq5DohXvcGpevhN4Z6PjhcY6stJbMEuiF1sFwbRdEKYhRkwV1JVIleXZ8FR4DlqlytoGSe80lDdYsj/lGIy0ewIg5wpJhkZf7a64sXs02JsZgsv65tHuamWCMf5Tu31FcMpVAO+BzeLHvaEkJKyF2enkLfDuSip1ypJ+lqDs5A8Sx8RL93jlkKicgh1jhaTlB2osP4u6hVcK66pZyI8nbQ2+HlHVTxCUYYmC5AUnzyQNlBvEslclBh4Z1YfUHL3O5nz+z30SmQ+LIapNeTCipn3cfyD5GkpC6/HIeyUOxpcSV0aA2XFetAbZ/8pV7d+gKkZWVEdm+PjjEn3ZRcJoGO+XJ1CwN7pMOkQnWihvTWIXNw/430l06/2q592hTlFg3ue66Bss2omavKfB28KhErT2UhY4PR5K1UQyeVZNV81uWA3wkCM1FfHUMnLrNBkLPNbLYuQRGQwdtZPy6ITODRzUAxv53/g5+c7ZbgsCMLFI24PujT4C9OW6bWb70eMm4VTq0ee1ccz+Z1saKJK4UnVL3QLXxNqH6tdCOu9S9p5adNe8Xj59iWd1dZHc/Ox06zzlhYSlvy9GfjlqmxvO84icTQuEmQXQ9NYA5+y/+a1bt0ZP9FG7u0+NUhMIjdWHsjQprSO48i8xweTHylmjh36PjWFEB+p8+iOSZToJvU0sS6VVjlgc9oKyhoIuCCQb7+O/STDoz1L517a6h668oOZHwC3b+puWiY1s2ven02IAp9AyTjellze7dxG3KKTbldwIoDXg1zKFfeJSr2H7gtqJwaEy4oT/LazWmgqDyWqWwrTGy8UzP4/5bw6l6z1RFy8U8rCFUpcIMIqadwf4LvgeCDWcCMU8j4uLCcKQ0PAxrnAxqwK3R1BtqTDqE9kYkgiQH+GukBRnGckOGLAJul8wiqeJ7rVIR0+ATyrvJxPQiM22UlkjeINMTx7NGhGiTn9dtPFgSgOQO5jc+Ju8JWQmn3nLRCs5w8g+Ra+qxqyk0SzuEQCrbuZZIJZ9pgOBQ8ROVRGqOLvCTpGZXNIikXev6zxwJ4QqFMdto8+Fs/OUTKggCmQKvDKv5uriORuFskt2Bc3TqdFrsOUvK0end3vFNHsifoXAwpsw+eXsA/9zgyiDMS8la4rninCxY5BjPlSZyb5FyqWNPl6O99ZfIS2zfhkSgT4bcN9gWegwFuUgdu0xyREFLiVc21YVY5v76/HlakD3V1NluBu6sH4bktx/8K0Lli/OFKuMroXbkUGYe8BrmU+H4tFQ+25jCfUhMPIhM4Zk6p/dQN2Xzfhpb7vYLxzSILgB+UeWS6qvAl2CBNk3tyL7+7Ro5UV+O5Tbz9wFT6iD2zqruYHs3VnoLgRsuUcA1YW3Eyggq6agf0hdzfMfv92/80NfzPm+62HgCMiBbvLZV8ExzYPYjXOXADkwyGRLifoG7YLVeVPpMZC/9MjAkGek+Uv0Je9hI3+2fsn94m73KvSovLQz4OH+mQbK/jZ0b8wVNiSiIsvvshN6YOYjKE/ldotRE/r3fZnSqnjuEmIBSbvgGQG0n9tTbLSaF3gQnKx/C0s1q7Z7vaUkdZYB/tyj2l8YuA9b0ZelXVUABHuDpQn8TxWMOK9O2W/8bmQCvOLv/TWZrjfQU7nmeB/ofbkacuj1oxfdL+nzMggHKgYDoOZC/FbaXoKUxkE0TSSyuvJB1RAeGr1l9EIhG6uNBG6uSVej7b3qdrkCRQ96D957AhcsTHqDHeDvQ+men/8lh8ZJbRnSD/IA6FUXBJfQcITAHBqiP0l7S8jn/z0DIyBN/LkHDA8Oed2JnP9q4f8y+S7yN3pxZyLeUVtnh0mqmAGbrLs85+m5pKv7/EtkBwCC917ZSsXp8AXpEhPF/EnM/Q6TgfXWXOS8OeqHxR/NmbrLTWYQdzR2l75smyrK7RqLmLAJhJZYQD2VejiXQg+/StUEd5OZ4QVpbDL0AxEo8yEkWrtUy3Iwt3QtjenF0HU85XXhnad04d0Ezl4c5fUHxa882HvuVyS497HYC6BAcgv/sowhhj2jqxImuth6wMmAV8fmbeb3lfRE6HwEUj+N1PcPfOk3ekN4qFsX8coKIvl4ycWJHSIy9UmaBwllEa46blr4FSEOrbvH9GgZgqBkV6NVnSAkfyPpMgqK7FRNs9zSqwX+YqKKCSPz6y3YI+5nBgr3EAFSo/6R0/b76EHHxtTt2pegYae+l7AG9i5HBYqPmv5SCq9HkdaKGLK3Z8TG3r2UCKY5JdIGfLg9LTxudDA8ivRsjYr5E8VHTIayiupSbG3qcSThjmpIZ4r/QMgibXoQgDUA+XXssMTcLnW2jKPFe3pE/Q4uMJoEUFCf7nyF3pVH3QcQX+2RTRtXJ3btC0khuNAQ4TSe5OXzXkD2i9fcR/PNBDxjPRJN0QB39zD95tjOLmD+Ngo1xgP/Hvjejo9TLaOiYEvMM3rnjnitIV7N27Y0ZYS90xQfb8/33EB3NTzUXhizjHWC7GjUCiq2w9q/yPQj61PkUs6syQn+UXMm886tCvOYmki5r3F6c5xrcupYEV9yLW6WyO9wmbrVNrwJ2qL4xbbW2y+Gp3dRS+/RsfbHmgMiaiD8gSTwZbkHePBR2gMuVGFp5F3V3q2M9i7kfOmkMcMCOCA4tqC2TsCfV2wKxHmwSFHGLEYupGLi66tmBT0F55VNJwlir5ogYFz8pD277p8xQRbiYYS9ANpKxJk6yFkQWKVesPcLFH0XJSvtYEpEv8froKuttvqDk1qlEV12SbHeEwwA/Ka/uenMUGQFz5l2Ma/02IT+gehr438bMDvf4n8+Xt+J011prThGEk7nHZh1/hjAwBxt+xMd8Fe59xO8RgS9JtMSS4sGHnorx47rek/wavQwTQa18sLiWC9VYgFjDAFvR2dgCplznh5zyz59rQm1k0Tr0ItoTy+tywNpLvl5odvPuhVVzB2MPV8ue1MnztIQejKDSW1Ker5BAD9rii0G8caY5TwiQ5YOREHQDuaTXKHz2Xs0fOX3gD5cLRH0IOXQpMvR3KlNwiwXIlj/m6BmO5Ycj93qB7UqoWGqSZ3WiqXiTkAEVyo0OWGPwIxQLNQvc4kUfVw6YWZryvkaGedJIJyiTIkAxVLkMykDZgh90F+ZPXgBzGcbWY6/hviiXX9D9cpSBiFHvL4ud+68cGL2N7ZI9eQes5jCQ6hac4BGHn4N9gWE19lmdF5tMTAZjpH5PWq2Wt9/pdhztBzLlbkS50G4ibru7guhDRNa8Lk6waN8BLuaDyzyyMsr1gXw6yhR7sZfR40wNM0cewhvrxX2kyHcsUG00ECsI3UHcWvnprQcVNv/Czpj0ZsY5LxNcNIx+uV8lSYbu7Ymz7ntKerRtrJ83RXWNC2BaghBdgT/Bl2QNaMu/I+NIjrC9hTExS22WRQ38BftJDqx0RTtwRh1AVElWRHwnwkXmsHVNgchanAGE+NV2Xkh5RmdcJMdNEgYI4uxqtkrjV9C1YzGkrqbNM1+sQVoly52hVLB1IL1VYDd6g6ADHVjcHq1/LBaNcAc85LlGCWybHQl17kFnaAemSrZqUT0fqB6eM271gXnud3LqLUm67tz06wWU7PqzUS33ahoLpboxJbFc9XueIthYqXXDxgkRBauuIqNZVZYwbuRGMdlp1uS09NBpyOMsR6rv7cyYREMsuDX48ScWFjwxc7Ea8bQv7WSoaNE/zeJH+NGabZqQRKqtg3LpxESqeGbUDQkDrNHUszu4xLnHynhl0LF7O7Wb4OaBiOv34lUMS/RNlFpUl31vXu0dSf0yanHqcNM9hetgHwwo1nZsH5tWxytdkJzSDJT3/AZZsuPInG2AVV3qVm2CPe3EJs+8XHSkGXPG5jg4JH94HWVstZzbnPR7G+w7hecyV+0PAJ5h0mkoIcRQiLUDyvzq75fSyt8KE/9L7kWbAwjmvG3p9MZQbbyk/uj9xr7eOanJ0I5I2S1yFbFKhSMCk6LQ0fsqfjkqn5+LSZWfuXNpSz7TSl+73lYRu4+xTM7I5D66e54b2B32bVtFoOnvF0uEEiYCLQK4ZwMfbupGENCoEZbOSiq8hlEkzNgqPnJtpZThqrTbceUbCtlChtKUqvYpBizdBivOjvO9eFVldWiGb0+yMKJ/Nas9ZP6aPVsfGQlC+62eF5MtUXXSrXsIeojQfnVNqpiF2T7N2F2fesJGpyrZyY4kE/X31MgJrK6StPmGyhzth2xtW1hKPPwd1QUr8+z7SX25+PxRAj0nyFxJqD1zdsgXtD0+EGyrJONeW8IVLoU8DDH8ubZlKhmJxDPlFGwWWe+00rOezbQWzENDiwFJLuTfH1bTCkPUeSMptZfIN6fu5yZxiDcZ2QkanI2HG9HtWqIhZmUYewyfTETpKAHrxTTE30ZewUayKbBUINhq2ADlAnJDgi0jETetP1iSVAdY+ln9MqLYnRVlfgHjMqUL8mSmTurt1YYvEDm4aIWA0L+tb+SvNFH5KPOSawoFbean3WAJWlG0IENVjBH/Jjr6ie9lOb8ojXFrYetGtnnmi1yG6b48ZikEstJRAHz7qxQ1BCMHLxZiECh7MDBP8rmvZ5vrbNApCeZujU5xJZDt0LV7NsBm1KobIfUFtcgzvlR8IRfT3B/5fwXj9MUaevudXnBM7nTf9x+jNtBwdPJJ75Aq/GqxtO1fuACzhEpBDLPasfMgmved5STkb+TMUhFpMYBxW41S4dX4G1ah0fkB0zVUx1+fU2p6nWaJU9q11YClJO+Y9PJmtq5thFpwySWBX8gyYOmMPPHSgcZtsmezS8paOlfUFmABM5pZ26GC3HkPHZJZrxZ7uxg3BXkW7z7wu5217We8/8XsnpZv9xBPCCWMTIkLGMatk5ayq4gTFrn6W0kOIjo/t2qzdxkZ7D4koY/wO9JQF5U+va0UQbNv0e2ad5weEW3u8eto5eqH0llxxW/wTKg/4l1p/yCD5mEBE01c+O/2TLH0lbt6KVWZQrWsMz6afSgLh4X+pYR4hW6UjHJd0/IKNA1KirtFJUfatS/GRfSrI/9pdgmNXCOLqPC5UvEE1gOXgWkp9am5S0uYA5MKqjrH4gqlkcNeVPrhBEpygFNYcJnKqQ93vBt59WfhF98GMDfJI3OHNkAoEKS+9ZIHyd+odgj+vX3SHz2CSKgD8r7z2NNli3ryjsZGBenBWmE8W54VsbzrSSpFGD5ohAmEX0SRAIvferGcSUC56M08vKNwwwEsz4fT9xcQGbKfgiZqvDmLTI4vw8pdWGYP8jKUK//8HP54PYT9qU+TzEHzhhor0E+QoDK/GMwmmcu+hsdiNVHxP1G8nwaCiLqoJlO2NiLka5KR5Ew3arENlCe6kWbPYNsaPCMBiTES7aY1b9usP83T44AZCkkOAOA5n3SDNKhSzFNauUnXP5Sah8IOTsTwrnI7k9Mgbk7dMiLL46JZsiswQyePItt9aoDDMMSx6b4wstbqhYC1vUDj4qe3t4D3aaEUgs05/+ZaL6kZipmtrxNnmlm/+4A3IouTN8z0dQFsAHncPa6QOnNDU42GD/0SvNiUpGy//aqjHl5JI8eKJxL4yx7vOdWxnjyh5EO6yqtCSazzBp4xWd10Uv6mb9bi+uWd5BMdfHEdCUX6VliRRwC177AsWZ7+1eEh6Ti+HVoAvT1/9VIUBk6nPuLnt6KsEoAp4HvwfIXK/P4buNp2zOsjNYFd7YEh5OGFWAUCms6C4v6pl2/qv0TLSUc+fiNgDoAhkXMCrb9kcPKL+Cru0LB1Lh9mFXpT1tJJBnd4+rNrtWSP5TLlxJ/BFx9aDgT2o27dek43ssnRIWGGsP1gtuENceUsgmcq6cmiRXP60rXQRubxBZBToIRlDP3Stnrb2crBElMftn/sVzk3lT0RwBveP8TrZiDoH+nAln3lE7v7AsaoO2S5GD+sBKowgCXuqu+fVsWwEEFT4oVaZH/MK+TKBX9/CSYMrr6SdtterHS28yji7hPkfJ6WknF/QOkQW7gheYGnUkS26Ow/Fwx1OQa2vCJvOz620UheC4+o6qtIrr8khZXP+GfyXsJT7o+d0SkMCUocyfjBEGQPdld5BaK+itpJNw8gV8ddFz6lq1Z4yAPD2tya0BzqnkxZuSmJnepNTsdXiY9ENTja5K71gL5PcDjeaj7vhD0y5MaHBVP7rmop461KFSN2yXNzfmn3dIEAE1PdM+5OyGdQbtbx5U7+rWUMi8jdfPUh2e+Izx4EVwUIxgcFoKoMfowhQPY/1Oxoqw13xJsP2uqtL+2ujOpmC8AG/L8FmxeEv+3Q+O1aeA3NgYakvhNBnXF1OhfYotfAASoQLls72rVzCMpuWadQ8/c18pmyRnYaYpUMdNeyWV0bvd6ncBLY+vBxb/K0g27BtwqXVdGcCVyTXJuOva/r8BqVBHTtPvBjYfDi39aEg+T6D4GiL52tRgopp4PpIL9b4drLlVzc7DDG1vArz+z4gM3yoyKfbiY3m4tFnY3ODB5KtrOJK9v/EWb7DejMvBEh8JZHyK74oYxYbmaztZsOW44bIwxOkdrTjCjZazhCioQ1e7rXbcS+N+OjC84ODXRJ0ONteOFCMaxQDPmwPuuaM8sOZxUrNqLXBL4hBuJIM93OkNssT6dAS+8RJdmgogpIAMJNtzTuYS+PUpD/51Z7vZGH/qgI5ICNEL/H8ad1oRdQu9QV7j3MhmfJ5lk++3wc8y4hG3h2/Q5tQUQUOymB+mG3snEEmKUrxnB9oSUp+yZ5HoaLrb/g7iq9XijCXGLi+6a3oI8TnzN2eyzGa8exJLVd1ZpCylleIToI9ccCG6/jHhZaxMGC1ubPmMSQRFrVgW2nUeMCrGDXJNTAWWnQN1bsXszU6O3OW6Oti9VnhR5EF2fLDkT4LOzAuY4fkt+mbItpFZas60VRDEkzeXVfEvGYjyiW9Eq8WI90ZfqVDoxzqd5yrHLa6Ad1BMZQVV+GXVupnvkc/S3LNbJZo/wXfIIBRjGNOzEr9zJoWJ5FlYC1+OXlYb/KKTZj7mQ9v67foga1ZQW1R9ZK3kVfZxOab/1t6CklXlIAzw9HVSbjCKtPgp18VLYM3cVYMvaCi9KInyKCxD1juZ/kV7Fk/zGcczSJROMihHYlaKEHDS/OZcIw/PGzxJf6BfWuDZQ4/yiWsdzgbl95JHdIqyzIX0YgVCYnPQmnnAFAOgUDE1Em39YkDzxoofJnV7svKbV1wxbY9DaXRCtM69wGfn6U7RDLikZG2dmQaPMwCHLrGe8CWLyN1WEJoXUwLklxETwij8fsfgxHQhpv5Ek5RcMja52i/bcLrxUNTC225m5imn81eGd4TK9vXf/nCdTUaenykLPrb0pjIgzuTEbSh18U9ZUbUtu/TsbuEimRaBlJ/teDPGPuETk4zP6zAdNh+YgX9/VfM//O21VZ7GkfizhXzJ5na3G9w8AAf/RkwQQxO7IZ+xt+F+P8MeVUzVGHVevGvHePrGWyQwLdG2LTTo3mvQ9Mgp5EXvXFOaYuuLYghPosL5uulr5PG6cMvkgczYyR+uyM3HjgsWBw4QcXLI5OtZRp0QumJncrT7w4pJ78pucW5lfo8NRYEgNTPKqwr1qCP8vx37P0b/lOeggZK+47C/3NYCcMvpKDLPJriH2ZHdoCe+PJPz+5jYlrlLO3lqvtg+ZGyBsethqXNDWqn9YzWFz9i/9JUFlqHEN9P4IkCIkMklQTBqMoVPZoGqbxEPfF51ELo4LVWXMdrRLi6YpqnGxd42qfqpf2k1zANDR0NxW0EGYv3Q+pIAkLgekbOJgsAbzy0QKMUhyTfGcT77EPmfvRJuBpONWVgJ5dv8ZaTX3G3grT+gqayj/AUPmfaQypHQDgjUWGMhMK58RDWMocxUruHWxCm0e4ftq9oQhRv4E4jZyBGb4/2R1kyBXy8I+J9VlWYnBppelXUoFPFy+LSMX1MrkuCAnjIiHmYdRoP7/BsV1ryGsP8t7ZXvbN+SAGnWO1tvqYZOPBUTR9l5x32LRUhEOpvm67ng4Vtex63XhV+w83/6N2AU+nln1EoC9q1bsqtsw8s6ldNpL/+SfV+aBBZQZTdiucYKukTMwEJgg5C0fYp1cefkwp0JRtkVxSssshf8rJO8+SCFmRBRS3fRrWTHtOWlTZxUGn9gmZ6Nu+ZBrhTxOZU9xt+0znHJnbkRAMEs3twtbhZkoG4H64ds5GD4Z6rW6CvB2+4RBzep83bTM3Q0zxx77l8OAennW0WytfC7E3EuZFz1fE+OdxISASK4kyw6l5/zRhbJf8CgavEOCKKrDytSYIzynE8UBsip/wmbHR32XazUo4r5iNQaQOTtJQxGt24ybPJUEVw/8YsXnOGT5K+BLTl4GlC9Rek1ReFahJNdwaNiecJ63yf1fACPOU+sD9fsJDyVQtin56apE0K1Br5aTg8J2xnIysyITDf5k2WwgrFjEVkcbilmgoIJechRQyLY2ox5NYTLCfH0D42Gg99TeNRXJ9/M3nV6CqNT+yGmKHGcF6TO/bdUVyGOG5UAl9hGE+Rkq8RZ/SXKjNj6uHTwfW1QPY58iGfzDsNotuJ6mxLNPxgD4q0NizOcWfvJSI07MS+TFo4gdr0/mMS1N1kDa7CHvXidVoaPzfh4fUo/af2eUgUoJOFcki5a8j7lyq3YFkNFJ6KKWwqHTw6DUPMmObTDFAq+MnQrSn+eoNwO4pFJRga+lbbnbnWRd49+urn7xRyAkyUqRv0+F8YAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":30617,"cache_read_input_tokens":33681,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":30617},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMMh7ZzHiucgzzLBuxPE","type":"assistant","uuid":"4955e02d-c78a-4f06-8400-594a939abcee","timestamp":"2026-02-21T14:18:25.394Z"}
{"parentUuid":"4955e02d-c78a-4f06-8400-594a939abcee","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","message":{"model":"claude-sonnet-4-6","id":"msg_01VALoN5gWWzhAnjJ9EMgjQV","type":"message","role":"assistant","content":[{"type":"text","text":"현재 구현을 파악했습니다. `textarea` + `rename-sizer` 방식으로 row 높이가 늘어나는 구조입니다. Finder처럼 row 높이 고정 + inline overlay input으로 변경하겠습니다."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":30617,"cache_read_input_tokens":33681,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":30617},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMMh7ZzHiucgzzLBuxPE","type":"assistant","uuid":"68f85bd6-80f6-4b3e-b7aa-3d1ce433e53a","timestamp":"2026-02-21T14:18:26.381Z"}
{"type":"file-history-snapshot","messageId":"30e5c15c-b579-485b-8c0e-c984fc522051","snapshot":{"messageId":"e0d384bd-6392-4207-bb5b-294a34d34741","trackedFileBackups":{"src/App.svelte":{"backupFileName":"f2ffc3f5647f6015@v1","version":1,"backupTime":"2026-02-21T14:18:29.238Z"}},"timestamp":"2026-02-21T14:17:21.160Z"},"isSnapshotUpdate":true}
{"parentUuid":"68f85bd6-80f6-4b3e-b7aa-3d1ce433e53a","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","message":{"model":"claude-sonnet-4-6","id":"msg_01VALoN5gWWzhAnjJ9EMgjQV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MM9L3UQDXcNBo7Cq3VRSMQ","name":"Edit","input":{"replace_all":false,"file_path":"/Users/al02402336/everything/src/App.svelte","old_string":"                {#if editing.active && editing.index === index}\n                  <span class=\"rename-wrapper\">\n                    <span class=\"rename-sizer\" aria-hidden=\"true\">{editing.draftName || '\\u00A0'}</span>\n                    <textarea\n                      bind:this={renameInputEl}\n                      class=\"rename-input\"\n                      bind:value={editing.draftName}\n                      rows=\"1\"\n                      on:click|stopPropagation\n                      on:blur={commitRename}\n                      on:keydown={(e) => { if (e.key === 'Enter') e.preventDefault(); }}\n                    />\n                  </span>","new_string":"                {#if editing.active && editing.index === index}\n                  <input\n                    bind:this={renameInputEl}\n                    class=\"rename-input\"\n                    type=\"text\"\n                    bind:value={editing.draftName}\n                    on:click|stopPropagation\n                    on:blur={commitRename}\n                  />"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":30617,"cache_read_input_tokens":33681,"output_tokens":3968,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":30617,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYMMh7ZzHiucgzzLBuxPE","type":"assistant","uuid":"30e5c15c-b579-485b-8c0e-c984fc522051","timestamp":"2026-02-21T14:18:29.231Z"}
{"parentUuid":"30e5c15c-b579-485b-8c0e-c984fc522051","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01MM9L3UQDXcNBo7Cq3VRSMQ","toolUseID":"toolu_01MM9L3UQDXcNBo7Cq3VRSMQ","timestamp":"2026-02-21T14:18:29.243Z","uuid":"3f2f8371-396e-4b7a-afaf-a860b74225f2"}
{"parentUuid":"30e5c15c-b579-485b-8c0e-c984fc522051","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MM9L3UQDXcNBo7Cq3VRSMQ","type":"tool_result","content":"The file /Users/al02402336/everything/src/App.svelte has been updated successfully."}]},"uuid":"313470ef-b53a-4497-bbca-80d711f684b2","timestamp":"2026-02-21T14:18:29.242Z","toolUseResult":{"filePath":"/Users/al02402336/everything/src/App.svelte","oldString":"                {#if editing.active && editing.index === index}\n                  <span class=\"rename-wrapper\">\n                    <span class=\"rename-sizer\" aria-hidden=\"true\">{editing.draftName || '\\u00A0'}</span>\n                    <textarea\n                      bind:this={renameInputEl}\n                      class=\"rename-input\"\n                      bind:value={editing.draftName}\n                      rows=\"1\"\n                      on:click|stopPropagation\n                      on:blur={commitRename}\n                      on:keydown={(e) => { if (e.key === 'Enter') e.preventDefault(); }}\n                    />\n                  </span>","newString":"                {#if editing.active && editing.index === index}\n                  <input\n                    bind:this={renameInputEl}\n                    class=\"rename-input\"\n                    type=\"text\"\n                    bind:value={editing.draftName}\n                    on:click|stopPropagation\n                    on:blur={commitRename}\n                  />","originalFile":"<script>\n  import { onDestroy, onMount, tick } from 'svelte';\n  import { invoke } from '@tauri-apps/api/core';\n  import { listen } from '@tauri-apps/api/event';\n  import { getCurrentWindow } from '@tauri-apps/api/window';\n  import { startDrag } from '@crabnebula/tauri-plugin-drag';\n\n  const rowHeight = 30;\n  const PAGE_SIZE = 500;\n  let homePrefix = '';\n  const COL_WIDTHS_KEY = 'REDACTED';\n  const THEME_KEY = 'everything-theme';\n  const columnKeys = ['name', 'path', 'size', 'modified'];\n  const minColumnWidth = {\n    name: 180,\n    path: 240,\n    size: 75,\n    modified: 150\n  };\n  const defaultColumnRatios = {\n    name: 0.3,\n    path: 0.45,\n    size: 0.1\n  };\n\n  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || 'dark'; } catch { return 'dark'; } })();\n  function cycleTheme() {\n    theme = theme === 'dark' ? 'light' : 'dark';\n    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n  }\n\n  let query = '';\n  let results = [];\n  let totalResults = 0;\n  let totalResultsKnown = false;\n\n  let dbLatencyMs = null;\n  let dbLastQuery = '';\n  let searchModeLabel = '';\n  let selectedIndices = new Set();\n  let selectionAnchor = -1;\n  let lastSelectedIndex = -1;\n  let editing = {\n    active: false,\n    path: '',\n    index: -1,\n    draftName: ''\n  };\n\n  let indexStatus = {\n    state: 'Indexing',\n    entriesCount: 0,\n    lastUpdated: null,\n    permissionErrors: 0,\n    message: null,\n    isCatchup: false\n  };\n\n  let indexingStartTime = null;\n  let indexingElapsed = '';\n  let indexingFinishedAt = '';\n\n  let sortBy = 'name';\n  let sortDir = 'asc';\n\n  let hasMore = true;\n  let loadingMore = false;\n  let searchGeneration = 0;\n\n  let scanned = 0;\n\n  let searchInputEl;\n  let renameInputEl;\n  let tableAreaEl;\n  let tableContainer;\n  let tableResizeObserver = null;\n  let viewportResizeRaf = null;\n  let scrollTop = 0;\n  let headerScrollLeft = 0;\n  let viewportHeight = 520;\n  let lastTableWidth = 0;\n  let resizingColumn = '';\n  let resizeCleanup = null;\n  let colWidths = {\n    name: 250,\n    path: 350,\n    size: 75,\n    modified: 150\n  };\n\n  let contextMenu = {\n    visible: false,\n    x: 0,\n    y: 0\n  };\n\n  let platform = '';\n  let toast = '';\n  let searchTimer;\n  let lastSearchFiredAt = 0;\n  let toastTimer;\n  let statusRefreshTimer;\n  let elapsedTimer;\n  let statusRefreshInFlight = false;\n  let lastReadyCount = 0;\n\n  const iconCache = new Map();\n  const iconLoading = new Set();\n\n  let highlightCache = new Map();\n  let highlightCacheQuery = '';\n\n  const folderFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='1' y='4' width='14' height='10' rx='2' fill='#d9b34f'/><rect x='1' y='2' width='6' height='4' rx='1' fill='#e6ca7a'/></svg>`\n    );\n  const fileFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='3' y='1' width='10' height='14' rx='1.5' fill='#b4bec9'/><rect x='5' y='5' width='6' height='1.2' fill='#8d98a5'/><rect x='5' y='8' width='6' height='1.2' fill='#8d98a5'/></svg>`\n    );\n\n  $: totalHeight = results.length * rowHeight;\n  $: startIndex = Math.max(0, Math.floor(scrollTop / rowHeight) - 10);\n  $: visibleCount = Math.ceil(viewportHeight / rowHeight) + 20;\n  $: endIndex = Math.min(results.length, startIndex + visibleCount);\n  $: visibleRows = results.slice(startIndex, endIndex);\n  $: translateY = startIndex * rowHeight;\n  $: tableMinWidth = colWidths.name + colWidths.path + colWidths.size + colWidths.modified;\n  $: tableGridStyle = `--col-name:${colWidths.name}px;--col-path:${colWidths.path}px;--col-size:${colWidths.size}px;--col-modified:${colWidths.modified}px;--table-min-width:${tableMinWidth}px;--header-offset:${-headerScrollLeft}px;`;\n\n  $: {\n    for (const entry of visibleRows) {\n      void ensureIcon(entry);\n    }\n  }\n\n  function showToast(message) {\n    toast = message;\n    clearTimeout(toastTimer);\n    toastTimer = setTimeout(() => {\n      toast = '';\n    }, 3000);\n  }\n\n  function bytesToBase64(bytes) {\n    let binary = '';\n    const chunk = 0x8000;\n    for (let i = 0; i < bytes.length; i += chunk) {\n      const part = bytes.subarray(i, i + chunk);\n      binary += String.fromCharCode(...part);\n    }\n    return btoa(binary);\n  }\n\n  function highlightSegments(name, q) {\n    q = (q || '').trim();\n    if (!q) return [{ text: name, hl: false }];\n\n    // Reset cache when query changes\n    if (q !== highlightCacheQuery) {\n      highlightCache = new Map();\n      highlightCacheQuery = q;\n    }\n\n    // Check cache\n    const cached = highlightCache.get(name);\n    if (cached) return cached;\n\n    if (q.includes('/')) q = q.slice(q.lastIndexOf('/') + 1);\n    q = q.replace(/[*?]/g, '');\n    const terms = q.split(/\\s+/).filter(Boolean);\n    if (terms.length === 0) return [{ text: name, hl: false }];\n\n    const lower = name.toLowerCase();\n    const marks = new Uint8Array(name.length);\n    for (const t of terms) {\n      const tl = t.toLowerCase();\n      let idx = lower.indexOf(tl);\n      while (idx !== -1) {\n        for (let i = idx; i < idx + tl.length; i++) marks[i] = 1;\n        idx = lower.indexOf(tl, idx + 1);\n      }\n    }\n\n    const segs = [];\n    let i = 0;\n    while (i < name.length) {\n      const m = marks[i];\n      let j = i + 1;\n      while (j < name.length && marks[j] === m) j++;\n      segs.push({ text: name.slice(i, j), hl: m === 1 });\n      i = j;\n    }\n\n    highlightCache.set(name, segs);\n    return segs;\n  }\n\n  const perFileIconExts = new Set(['exe', 'lnk', 'ico', 'url', 'scr', 'appx']);\n\n  function iconKey(entry) {\n    if (entry.isDir) return '__folder__';\n    const ext = (entry.ext || '').toLowerCase();\n    if (perFileIconExts.has(ext)) return entry.path;\n    return ext || '__file__';\n  }\n\n  function iconFor(entry) {\n    return iconCache.get(iconKey(entry)) || (entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n  }\n\n  async function ensureIcon(entry) {\n    const key = iconKey(entry);\n    if (iconCache.has(key) || iconLoading.has(key)) {\n      return;\n    }\n\n    iconLoading.add(key);\n    try {\n      const bytes = await invoke('get_file_icon', {\n        path: entry.path,\n        ext: entry.isDir ? 'folder' : entry.ext || '',\n      });\n      if (Array.isArray(bytes) && bytes.length > 0) {\n        const image = `data:image/png;base64,${bytesToBase64(Uint8Array.from(bytes))}`;\n        iconCache.set(key, image);\n      } else {\n        iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n      }\n    } catch {\n      iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n    } finally {\n      iconLoading.delete(key);\n    }\n  }\n\n  function syncColumnWidthsToContainer() {\n    const width = tableContainer?.clientWidth || tableAreaEl?.clientWidth;\n    if (!width || lastTableWidth !== 0) {\n      return;\n    }\n\n    const saved = loadColWidths();\n    if (saved) {\n      const total = columnKeys.reduce((s, k) => s + saved[k], 0);\n      if (Math.abs(total - width) > 2) {\n        const scale = (width - saved.modified) / (total - saved.modified);\n        let scaledName = Math.max(minColumnWidth.name, Math.round(saved.name * scale));\n        let scaledSize = Math.max(minColumnWidth.size, Math.round(saved.size * scale));\n        let rawPath = width - saved.modified - scaledName - scaledSize;\n        if (rawPath < minColumnWidth.path) {\n          const shortfall = minColumnWidth.path - rawPath;\n          const nameReduction = Math.min(shortfall, scaledName - minColumnWidth.name);\n          scaledName -= nameReduction;\n          const remaining = shortfall - nameReduction;\n          if (remaining > 0) {\n            scaledSize -= Math.min(remaining, scaledSize - minColumnWidth.size);\n          }\n          rawPath = width - saved.modified - scaledName - scaledSize;\n        }\n        const scaledPath = Math.max(minColumnWidth.path, rawPath);\n        colWidths = { name: scaledName, path: scaledPath, size: scaledSize, modified: saved.modified };\n      } else {\n        colWidths = saved;\n      }\n    } else {\n      const fixedModified = minColumnWidth.modified;\n      const rest = width - fixedModified;\n      const ratioSum = defaultColumnRatios.name + defaultColumnRatios.path + defaultColumnRatios.size;\n      colWidths = {\n        name: Math.max(minColumnWidth.name, Math.round(rest * defaultColumnRatios.name / ratioSum)),\n        path: Math.max(minColumnWidth.path, Math.round(rest * defaultColumnRatios.path / ratioSum)),\n        size: Math.max(minColumnWidth.size, Math.round(rest * defaultColumnRatios.size / ratioSum)),\n        modified: fixedModified\n      };\n    }\n    lastTableWidth = width;\n  }\n\n  function loadColWidths() {\n    try {\n      const raw = localStorage.getItem(COL_WIDTHS_KEY);\n      if (!raw) return null;\n      const parsed = JSON.parse(raw);\n      for (const key of columnKeys) {\n        if (typeof parsed[key] !== 'number' || parsed[key] < (minColumnWidth[key] || 0)) return null;\n      }\n      return parsed;\n    } catch {\n      return null;\n    }\n  }\n\n  function saveColWidths() {\n    localStorage.setItem(COL_WIDTHS_KEY, JSON.stringify(colWidths));\n  }\n\n  function updateViewportHeight() {\n    viewportHeight = tableContainer?.clientHeight || 520;\n    syncColumnWidthsToContainer();\n  }\n\n  function scheduleViewportHeightUpdate() {\n    if (viewportResizeRaf !== null) {\n      return;\n    }\n    viewportResizeRaf = requestAnimationFrame(() => {\n      viewportResizeRaf = null;\n      updateViewportHeight();\n    });\n  }\n\n  function startColumnResize(event, leftKey) {\n    event.preventDefault();\n    event.stopPropagation();\n\n    const index = columnKeys.indexOf(leftKey);\n    if (index < 0 || index >= columnKeys.length - 1) {\n      return;\n    }\n\n    const startX = event.clientX;\n    const startLeft = colWidths[leftKey];\n    const rightKey = columnKeys[index + 1];\n    const startRight = colWidths[rightKey];\n\n    resizeCleanup?.();\n    resizingColumn = leftKey;\n\n    const onMove = (moveEvent) => {\n      const delta = Math.round(moveEvent.clientX - startX);\n      if (leftKey === 'name') {\n        // Two-column trade: name and path swap space, each respects its minimum\n        const nextLeft = Math.max(\n          minColumnWidth[leftKey],\n          Math.min(startLeft + delta, startLeft + startRight - minColumnWidth[rightKey])\n        );\n        const nextRight = startLeft + startRight - nextLeft;\n        colWidths = { ...colWidths, [leftKey]: nextLeft, [rightKey]: nextRight };\n      } else {\n        // path splitter: path grows unconstrained (allows horizontal scroll on right drag)\n        const nextLeft = Math.max(minColumnWidth[leftKey], startLeft + delta);\n        colWidths = { ...colWidths, [leftKey]: nextLeft };\n      }\n    };\n\n    const onUp = () => {\n      cleanup();\n    };\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      document.body.style.cursor = '';\n      document.body.style.userSelect = '';\n      resizingColumn = '';\n      saveColWidths();\n      if (resizeCleanup === cleanup) {\n        resizeCleanup = null;\n      }\n    };\n\n    resizeCleanup = cleanup;\n    document.body.style.cursor = 'col-resize';\n    document.body.style.userSelect = 'none';\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  function selectedPaths() {\n    const sorted = [...selectedIndices].sort((a, b) => a - b);\n    return sorted.map((idx) => results[idx]).filter(Boolean).map((entry) => entry.path);\n  }\n\n  function clearSelection() {\n    selectedIndices = new Set();\n    selectionAnchor = -1;\n    lastSelectedIndex = -1;\n  }\n\n  function selectSingle(index) {\n    selectedIndices = new Set([index]);\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectToggle(index) {\n    const next = new Set(selectedIndices);\n    if (next.has(index)) {\n      next.delete(index);\n    } else {\n      next.add(index);\n    }\n    selectedIndices = next;\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectRange(index) {\n    const anchor = selectionAnchor >= 0 ? selectionAnchor : index;\n    const [from, to] = [Math.min(anchor, index), Math.max(anchor, index)];\n    const next = new Set();\n    for (let i = from; i <= to; i += 1) {\n      next.add(i);\n    }\n    selectedIndices = next;\n    lastSelectedIndex = index;\n  }\n\n  function primaryEntry() {\n    const idx = lastSelectedIndex >= 0 ? lastSelectedIndex : -1;\n    return idx >= 0 ? results[idx] : null;\n  }\n\n  async function refreshStatus() {\n    if (statusRefreshInFlight) {\n      return;\n    }\n    statusRefreshInFlight = true;\n    try {\n      const status = await invoke('get_index_status');\n      const prevState = indexStatus.state;\n      indexStatus = {\n        state: status.state,\n        entriesCount: status.entriesCount,\n        lastUpdated: status.lastUpdated,\n        permissionErrors: status.permissionErrors ?? 0,\n        message: status.message\n      };\n      if (status.state === 'Indexing' && prevState !== 'Indexing') {\n        startElapsedTimer();\n      } else if (status.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n      if (typeof status.scanned === 'number') {\n        scanned = status.scanned;\n      }\n      if (status.state === 'Ready' && prevState !== 'Ready') {\n        scheduleSearch();\n      }\n    } catch (err) {\n      showToast(`Failed to get status: ${String(err)}`);\n    } finally {\n      statusRefreshInFlight = false;\n    }\n  }\n\n  function scheduleSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const scheduledGen = searchGeneration;\n    clearTimeout(searchTimer);\n\n    const now = performance.now();\n    if (now - lastSearchFiredAt >= 200) {\n      // Leading edge: fire immediately if enough time has passed\n      lastSearchFiredAt = now;\n      void runSearch(preserveScroll);\n    } else {\n      // Trailing edge: debounce\n      searchTimer = setTimeout(() => {\n        if (scheduledGen !== searchGeneration) {\n          return;\n        }\n        lastSearchFiredAt = performance.now();\n        void runSearch(preserveScroll);\n      }, 200);\n    }\n  }\n\n  async function runSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const gen = searchGeneration;\n    const searchQuery = query;\n    const searchSortBy = sortBy;\n    const searchSortDir = sortDir;\n    const startedAt = performance.now();\n    try {\n      const keepPaths = new Set(selectedPaths());\n      const next = await invoke('search', {\n        query: searchQuery,\n        limit: PAGE_SIZE,\n        offset: 0,\n        sortBy: searchSortBy,\n        sortDir: searchSortDir\n      });\n\n      if (gen !== searchGeneration) return;\n\n      dbLatencyMs = Math.round(performance.now() - startedAt);\n      dbLastQuery = searchQuery;\n      const entries = Array.isArray(next.entries) ? next.entries : [];\n      searchModeLabel = next.modeLabel || '';\n      results = entries;\n      if (next.totalCount > 0) {\n        totalResults = next.totalCount;\n        totalResultsKnown = true;\n      } else {\n        totalResults = entries.length;\n        totalResultsKnown = false;\n      }\n      hasMore = totalResultsKnown ? results.length < totalResults : entries.length >= PAGE_SIZE;\n      if (!preserveScroll && tableContainer) tableContainer.scrollTop = 0;\n\n      const restored = new Set();\n      for (let i = 0; i < results.length; i += 1) {\n        if (keepPaths.has(results[i].path)) {\n          restored.add(i);\n        }\n      }\n      selectedIndices = restored;\n\n      updateViewportHeight();\n    } catch (err) {\n      if (gen !== searchGeneration) return;\n      showToast(`Search failed: ${String(err)}`);\n    }\n  }\n\n  async function loadMore() {\n    if (!hasMore || loadingMore) return;\n    const gen = searchGeneration;\n    loadingMore = true;\n    try {\n      const batch = await invoke('search', {\n        query,\n        limit: PAGE_SIZE,\n        offset: results.length,\n        sortBy: sortBy,\n        sortDir: sortDir\n      });\n      if (gen !== searchGeneration) return;\n      const arr = Array.isArray(batch.entries) ? batch.entries : [];\n      if (arr.length > 0) results = [...results, ...arr];\n      hasMore = totalResultsKnown ? results.length < totalResults : arr.length >= PAGE_SIZE;\n    } catch (err) {\n      showToast(`Failed to load more: ${String(err)}`);\n    } finally {\n      loadingMore = false;\n    }\n  }\n\n  function moveSelection(delta, withRange = false) {\n    if (results.length === 0) {\n      return;\n    }\n\n    const current = lastSelectedIndex >= 0 ? lastSelectedIndex : 0;\n    const next = Math.max(0, Math.min(results.length - 1, current + delta));\n\n    if (withRange) {\n      selectRange(next);\n    } else {\n      selectSingle(next);\n    }\n\n    const top = next * rowHeight;\n    const bottom = top + rowHeight;\n    if (top < scrollTop) {\n      tableContainer.scrollTop = top;\n    } else if (bottom > scrollTop + viewportHeight) {\n      tableContainer.scrollTop = bottom - viewportHeight;\n    }\n  }\n\n  function handleHeaderSort(column) {\n    if (sortBy === column) {\n      sortDir = sortDir === 'asc' ? 'desc' : 'asc';\n    } else {\n      sortBy = column;\n      sortDir = 'asc';\n    }\n    if (tableContainer) tableContainer.scrollTop = 0;\n    void runSearch();\n  }\n\n  function handleRowClick(event, index) {\n    contextMenu.visible = false;\n\n    if (event.shiftKey) {\n      selectRange(index);\n      return;\n    }\n\n    if (event.metaKey || event.ctrlKey) {\n      selectToggle(index);\n      return;\n    }\n\n    selectSingle(index);\n  }\n\n  function handleRowContextMenu(event, index) {\n    event.preventDefault();\n\n    if (!selectedIndices.has(index)) {\n      selectSingle(index);\n    }\n\n    if (platform === 'windows' || platform === 'macos') {\n      contextMenu.visible = false;\n      const paths = selectedPaths();\n      if (paths.length > 0) {\n        invoke('show_context_menu', {\n          paths,\n          x: event.clientX,\n          y: event.clientY,\n          singleSelection: selectedIndices.size === 1\n        });\n      }\n      return;\n    }\n\n    contextMenu = {\n      visible: true,\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n\n  function handleRowA11yKeydown(event, index) {\n    if (event.key === ' ' || event.key === 'Enter') {\n      event.preventDefault();\n      handleRowClick(event, index);\n    }\n  }\n\n  const DRAG_THRESHOLD = 5;\n  let dragCleanup = null;\n  const dragImgCache = new Map();\n\n  function dragPathsForIndex(index) {\n    const entry = results[index];\n    if (!entry) {\n      return [];\n    }\n\n    if (selectedIndices.has(index) && selectedIndices.size > 0) {\n      return selectedPaths();\n    }\n\n    return [entry.path];\n  }\n\n  function getDragIconEl(entry) {\n    const src = iconFor(entry);\n    let img = dragImgCache.get(src);\n    if (!img) {\n      img = new Image();\n      img.src = src;\n      dragImgCache.set(src, img);\n    }\n    return img.complete && img.naturalWidth > 0 ? img : null;\n  }\n\n  function fillRoundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function buildDragPreview(index) {\n    const entry = results[index];\n    if (!entry) return null;\n\n    const count = selectedIndices.has(index) ? selectedIndices.size : 1;\n    const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\n\n    const w = 260;\n    const h = 28;\n    const stackGap = count > 1 ? 4 : 0;\n\n    const canvas = document.createElement('canvas');\n    canvas.width = w;\n    canvas.height = h + stackGap;\n    const ctx = canvas.getContext('2d');\n\n    if (count > 1) {\n      ctx.globalAlpha = 0.35;\n      ctx.fillStyle = isDark ? '#5a6070' : '#b0c4de';\n      fillRoundRect(ctx, 3, 0, w - 3, h, 5);\n      ctx.globalAlpha = 1.0;\n    }\n\n    const ry = stackGap;\n    ctx.fillStyle = isDark ? 'rgba(58, 64, 74, 0.94)' : 'rgba(214, 231, 255, 0.94)';\n    fillRoundRect(ctx, 0, ry, w, h, 5);\n\n    ctx.strokeStyle = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';\n    ctx.lineWidth = 0.5;\n    ctx.beginPath();\n    ctx.moveTo(5, ry);\n    ctx.arcTo(w, ry, w, ry + h, 5);\n    ctx.arcTo(w, ry + h, 0, ry + h, 5);\n    ctx.arcTo(0, ry + h, 0, ry, 5);\n    ctx.arcTo(0, ry, w, ry, 5);\n    ctx.closePath();\n    ctx.stroke();\n\n    const iconEl = getDragIconEl(entry);\n    if (iconEl) {\n      ctx.drawImage(iconEl, 6, ry + 6, 16, 16);\n    } else {\n      ctx.fillStyle = entry.isDir ? '#d9b34f' : '#8d98a5';\n      fillRoundRect(ctx, 6, ry + 6, 16, 16, 2);\n    }\n\n    ctx.fillStyle = isDark ? '#e6e6e8' : '#1a1a1a';\n    ctx.font = '12px -apple-system, \"SF Pro Text\", system-ui, sans-serif';\n    ctx.textBaseline = 'middle';\n\n    let nameMaxW = w - 34;\n    if (count > 1) nameMaxW -= 34;\n\n    let name = entry.name;\n    if (ctx.measureText(name).width > nameMaxW) {\n      while (name.length > 4 && ctx.measureText(name + '\\u2026').width > nameMaxW) {\n        name = name.slice(0, -1);\n      }\n      name += '\\u2026';\n    }\n    ctx.fillText(name, 28, ry + h / 2 + 1);\n\n    if (count > 1) {\n      const badge = String(count);\n      ctx.font = 'bold 10px -apple-system, system-ui, sans-serif';\n      const tw = ctx.measureText(badge).width;\n      const bw = Math.max(20, tw + 10);\n      const bx = w - bw - 6;\n      const by = ry + (h - 18) / 2;\n\n      ctx.fillStyle = isDark ? '#5b8bd9' : '#007aff';\n      fillRoundRect(ctx, bx, by, bw, 18, 9);\n\n      ctx.fillStyle = '#ffffff';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(badge, bx + bw / 2, by + 9);\n    }\n\n    return canvas.toDataURL('image/png');\n  }\n\n  function handleRowMouseDown(event, index) {\n    if (event.button !== 0) return;\n    if (event.metaKey || event.ctrlKey || event.shiftKey) return;\n    if (editing.active) return;\n\n    const startX = event.clientX;\n    const startY = event.clientY;\n    let dragging = false;\n\n    dragCleanup?.();\n\n    const onMove = (e) => {\n      if (dragging) return;\n      const dx = e.clientX - startX;\n      const dy = e.clientY - startY;\n      if (dx * dx + dy * dy < DRAG_THRESHOLD * DRAG_THRESHOLD) return;\n\n      dragging = true;\n      cleanup();\n\n      if (!selectedIndices.has(index)) {\n        selectSingle(index);\n      }\n\n      const paths = dragPathsForIndex(index);\n      if (paths.length > 0) {\n        const icon = buildDragPreview(index);\n        startDrag({ item: paths, icon }).catch(() => {});\n      }\n    };\n\n    const onUp = () => cleanup();\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      if (dragCleanup === cleanup) dragCleanup = null;\n    };\n\n    dragCleanup = cleanup;\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  async function handleRowDoubleClick(index) {\n    if (!selectedIndices.has(index) || selectedIndices.size > 1) {\n      selectSingle(index);\n      await tick();\n    }\n    await invoke('open', { paths: [results[index].path] }).catch((err) => {\n      showToast(`Failed to open: ${String(err)}`);\n    });\n  }\n\n  function closeContextMenu() {\n    contextMenu = {\n      ...contextMenu,\n      visible: false\n    };\n  }\n\n  async function openSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('open', { paths });\n    } catch (err) {\n      showToast(`Failed to open: ${String(err)}`);\n    }\n  }\n\n  async function openWithFallback() {\n    const target = primaryEntry();\n    if (!target) {\n      return;\n    }\n\n    try {\n      await invoke('open_with', { path: target.path });\n    } catch (err) {\n      showToast(`Open With failed: ${String(err)}`);\n    }\n  }\n\n  async function revealSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('reveal_in_finder', { paths });\n    } catch (err) {\n      showToast(`Failed to reveal in Finder: ${String(err)}`);\n    }\n  }\n\n  async function copySelectedPaths() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_paths', { paths });\n      showToast(`Copied ${paths.length} path(s)`);\n    } catch (err) {\n      showToast(`Failed to copy path: ${String(err)}`);\n    }\n  }\n\n  async function copyFiles() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_files', { paths });\n      showToast(`Copied ${paths.length} item(s)`);\n    } catch (err) {\n      showToast(`Failed to copy: ${String(err)}`);\n    }\n  }\n\n  async function trashSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    const message =\n      paths.length === 1\n        ? 'Move selected item to Trash?'\n        : `Move ${paths.length} items to Trash?`;\n\n    if (!window.confirm(message)) {\n      return;\n    }\n\n    try {\n      await invoke('move_to_trash', { paths });\n      showToast('Moved to Trash.');\n      clearSelection();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to move to Trash: ${String(err)}`);\n    }\n  }\n\n  async function resetIndex() {\n    if (indexStatus.state === 'Indexing') {\n      showToast('Indexing in progress. Please try again after it completes.');\n      return;\n    }\n\n    results = [];\n    totalResults = 0;\n    totalResultsKnown = false;\n    clearSelection();\n    scanned = 0;\n    dbLatencyMs = null;\n    dbLastQuery = '';\n    indexStatus = { ...indexStatus, state: 'Indexing', entriesCount: 0, message: null };\n    indexingStartTime = Date.now();\n    indexingElapsed = '';\n    indexingFinishedAt = '';\n\n    try {\n      await invoke('reset_index');\n    } catch (err) {\n      showToast(`Failed to reset index: ${String(err)}`);\n      await refreshStatus();\n    }\n  }\n\n  function isMultiSelected() {\n    return selectedIndices.size > 1;\n  }\n\n  async function startRename() {\n    if (isMultiSelected()) {\n      return;\n    }\n\n    const idx = lastSelectedIndex;\n    if (idx < 0 || !results[idx]) {\n      return;\n    }\n\n    const entry = results[idx];\n    editing = {\n      active: true,\n      path: entry.path,\n      index: idx,\n      draftName: entry.name\n    };\n\n    await tick();\n\n    if (renameInputEl) {\n      renameInputEl.focus();\n      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n      renameInputEl.setSelectionRange(0, selectionEnd);\n    }\n  }\n\n  function cancelRename() {\n    editing = {\n      active: false,\n      path: '',\n      index: -1,\n      draftName: ''\n    };\n  }\n\n  async function commitRename() {\n    if (!editing.active || editing.index < 0 || !results[editing.index]) {\n      return;\n    }\n\n    const current = results[editing.index];\n    const nextName = editing.draftName;\n\n    try {\n      await invoke('rename', {\n        path: current.path,\n        newName: nextName\n      });\n      cancelRename();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to rename: ${String(err)}`);\n      await tick();\n      renameInputEl?.focus();\n    }\n  }\n\n  function onGlobalClick() {\n    closeContextMenu();\n  }\n\n  function onTitleBarMouseDown(event) {\n    if (event.button !== 0) {\n      return;\n    }\n\n    const activeElement = document.activeElement;\n    if (activeElement instanceof HTMLElement && isTextInputTarget(activeElement)) {\n      activeElement.blur();\n    }\n  }\n\n  async function focusSearch() {\n    await getCurrentWindow().show();\n    await getCurrentWindow().setFocus();\n    searchInputEl?.focus();\n    searchInputEl?.select();\n  }\n\n  function isTextInputTarget(target) {\n    return (\n      target instanceof HTMLInputElement ||\n      target instanceof HTMLTextAreaElement ||\n      target?.isContentEditable\n    );\n  }\n\n  async function handleKeydown(event) {\n    const isMetaSelectAll = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'a';\n    const isMetaCopy = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c';\n    const target = event.target;\n    const isTextInput = isTextInputTarget(target);\n\n    if (isMetaCopy && isTextInput) {\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      if (isTextInput) {\n        event.preventDefault();\n        if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n          target.select();\n        }\n        return;\n      }\n    }\n\n    if (editing.active) {\n      if (event.key === 'Enter') {\n        event.preventDefault();\n        await commitRename();\n        return;\n      }\n\n      if (event.key === 'Escape') {\n        event.preventDefault();\n        cancelRename();\n        searchInputEl?.focus();\n        return;\n      }\n      return;\n    }\n\n    if (event.key === 'Escape') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      return;\n    }\n\n    if (event.key === 'ArrowDown') {\n      event.preventDefault();\n      moveSelection(1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'ArrowUp') {\n      event.preventDefault();\n      moveSelection(-1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageDown') {\n      event.preventDefault();\n      moveSelection(Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageUp') {\n      event.preventDefault();\n      moveSelection(-Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'Enter') {\n      event.preventDefault();\n      if (platform === 'windows') {\n        await openSelected();\n      } else {\n        await startRename();\n      }\n      return;\n    }\n\n    if (event.key === 'F2') {\n      event.preventDefault();\n      await startRename();\n      return;\n    }\n\n    if (event.key === ' ' && !isTextInput) {\n      event.preventDefault();\n      const entry = primaryEntry();\n      if (entry) {\n        await invoke('quick_look', { path: entry.path });\n      }\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'f') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      searchInputEl?.select();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'o') {\n      event.preventDefault();\n      await openSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {\n      event.preventDefault();\n      await revealSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c') {\n      event.preventDefault();\n      await copySelectedPaths();\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      event.preventDefault();\n      selectedIndices = new Set(Array.from({ length: results.length }, (_, i) => i));\n      return;\n    }\n\n    if (event.key === 'Delete' || ((event.metaKey || event.ctrlKey) && event.key === 'Backspace')) {\n      if (!isTextInput) {\n        event.preventDefault();\n        await trashSelected();\n      }\n      return;\n    }\n  }\n\n  function formatSize(entry) {\n    if (entry.isDir || entry.size == null) return '';\n    const bytes = entry.size;\n    if (bytes < 1024) return `${bytes} B`;\n    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n    return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n  }\n\n  function formatModified(entry) {\n    if (!entry.mtime) {\n      return '';\n    }\n\n    const d = new Date(entry.mtime * 1000);\n    const pad = (n) => String(n).padStart(2, '0');\n    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;\n  }\n\n  function formatLastUpdated(timestamp) {\n    if (!timestamp) {\n      return '-';\n    }\n\n    return new Date(timestamp * 1000).toLocaleString();\n  }\n\n  function formatElapsed(ms) {\n    const totalSec = Math.floor(ms / 1000);\n    const min = Math.floor(totalSec / 60);\n    const sec = totalSec % 60;\n    return min > 0 ? `${min}m ${sec}s` : `${sec}s`;\n  }\n\n  function updateElapsed() {\n    if (indexingStartTime && indexStatus.state === 'Indexing') {\n      indexingElapsed = formatElapsed(Date.now() - indexingStartTime);\n    }\n  }\n\n  function startElapsedTimer() {\n    clearInterval(elapsedTimer);\n    indexingStartTime = Date.now();\n    indexingElapsed = '0s';\n    indexingFinishedAt = '';\n    elapsedTimer = setInterval(updateElapsed, 1000);\n  }\n\n  function stopElapsedTimer() {\n    clearInterval(elapsedTimer);\n    if (indexingStartTime) {\n      const elapsed = Date.now() - indexingStartTime;\n      indexingFinishedAt = `${formatElapsed(elapsed)}`;\n    }\n    indexingStartTime = null;\n    indexingElapsed = '';\n  }\n\n  function displayPath(path) {\n    if (!path) {\n      return path;\n    }\n\n    if (!homePrefix) {\n      return path;\n    }\n\n    if (path === homePrefix) {\n      return '~';\n    }\n\n    if (path.startsWith(`${homePrefix}/`)) {\n      return `~${path.slice(homePrefix.length)}`;\n    }\n\n    return path;\n  }\n\n  let unlistenFns = [];\n\n  onMount(async () => {\n    const t0 = performance.now();\n    const ms = () => Math.round(performance.now() - t0);\n    const DEBUG_STARTUP = false;\n    const flog = DEBUG_STARTUP ? (msg) => invoke('frontend_log', { msg }).catch(() => {}) : () => {};\n\n    flog(`[startup/fe] onMount entered`);\n\n    updateViewportHeight();\n    flog(`[startup/fe] +${ms()}ms updateViewportHeight done`);\n\n    platform = await invoke('get_platform');\n    flog(`[startup/fe] +${ms()}ms get_platform done`);\n\n    const unlistenProgress = await listen('index_progress', (event) => {\n      scanned = event.payload.scanned;\n      if (indexStatus.state !== 'Indexing') {\n        indexStatus = {\n          ...indexStatus,\n          state: 'Indexing'\n        };\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_progress) registered`);\n\n    const unlistenState = await listen('index_state', (event) => {\n      flog(`[startup/fe] index_state event received: ${event.payload.state} at +${ms()}ms`);\n      const prevState = indexStatus.state;\n      indexStatus = {\n        ...indexStatus,\n        state: event.payload.state,\n        message: event.payload.message ?? null,\n        isCatchup: event.payload.isCatchup ?? false\n      };\n\n      if (event.payload.state === 'Indexing' && prevState !== 'Indexing') {\n        if (prevState === 'Ready') {\n          lastReadyCount = indexStatus.entriesCount;\n        }\n        startElapsedTimer();\n      } else if (event.payload.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n\n      if (event.payload.state === 'Ready') {\n        scheduleSearch();\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_state) registered`);\n\n    const unlistenUpdated = await listen('index_updated', (event) => {\n      indexStatus = {\n        ...indexStatus,\n        entriesCount: event.payload.entriesCount,\n        lastUpdated: event.payload.lastUpdated,\n        permissionErrors: event.payload.permissionErrors ?? indexStatus.permissionErrors\n      };\n\n      scheduleSearch(true);\n    });\n\n    const unlistenFocus = await listen('focus_search', () => {\n      void focusSearch();\n    });\n\n    const unlistenCtxMenuAction = await listen('context_menu_action', (event) => {\n      switch (event.payload) {\n        case 'open': void openSelected(); break;\n        case 'quick_look': {\n          const e = primaryEntry();\n          if (e) void invoke('quick_look', { path: e.path });\n          break;\n        }\n        case 'open_with': void openWithFallback(); break;\n        case 'reveal': void revealSelected(); break;\n        case 'copy_files': void copyFiles(); break;\n        case 'copy_path': void copySelectedPaths(); break;\n        case 'trash': void trashSelected(); break;\n        case 'rename': void startRename(); break;\n      }\n    });\n\n    unlistenFns = [unlistenProgress, unlistenState, unlistenUpdated, unlistenFocus, unlistenCtxMenuAction];\n    flog(`[startup/fe] +${ms()}ms all listeners registered`);\n\n    // Fetch backend state IMMEDIATELY after listeners are registered.\n    // Events emitted before listener registration are lost, so this\n    // is the only reliable way to get the current state.\n    await refreshStatus();\n    flog(`[startup/fe] +${ms()}ms refreshStatus done (state=${indexStatus.state})`);\n\n    // Show Svelte UI: remove skeleton, focus search input.\n    await tick();\n    document.getElementById('skeleton')?.remove();\n    await focusSearch();\n    flog(`[startup/fe] +${ms()}ms WINDOW VISIBLE — skeleton removed`);\n\n    try {\n      homePrefix = await invoke('get_home_dir');\n    } catch {\n      homePrefix = '';\n    }\n    flog(`[startup/fe] +${ms()}ms get_home_dir done`);\n\n    if (!localStorage.getItem('everything-fda-notice-v1')) {\n      showToast('macOS Full Disk Access permission may be required for full disk search.');\n      localStorage.setItem('everything-fda-notice-v1', '1');\n    }\n    flog(`[startup/fe] +${ms()}ms calling runSearch...`);\n    await runSearch();\n    flog(`[startup/fe] +${ms()}ms runSearch done`);\n\n    if (typeof ResizeObserver !== 'undefined') {\n      tableResizeObserver = new ResizeObserver(() => {\n        scheduleViewportHeightUpdate();\n      });\n      if (tableContainer) {\n        tableResizeObserver.observe(tableContainer);\n      } else if (tableAreaEl) {\n        tableResizeObserver.observe(tableAreaEl);\n      }\n    }\n\n    window.addEventListener('resize', scheduleViewportHeightUpdate);\n    window.addEventListener('click', onGlobalClick);\n    statusRefreshTimer = setInterval(() => {\n      if (indexStatus.state === 'Indexing') {\n        void refreshStatus();\n      }\n    }, 1000);\n    console.log(`[startup/fe] +${ms()}ms onMount complete`);\n  });\n\n  onDestroy(async () => {\n    clearTimeout(searchTimer);\n    clearTimeout(toastTimer);\n    clearInterval(statusRefreshTimer);\n    clearInterval(elapsedTimer);\n    resizeCleanup?.();\n\n    for (const unlisten of unlistenFns) {\n      unlisten();\n    }\n\n    tableResizeObserver?.disconnect();\n    tableResizeObserver = null;\n    if (viewportResizeRaf !== null) {\n      cancelAnimationFrame(viewportResizeRaf);\n      viewportResizeRaf = null;\n    }\n    window.removeEventListener('resize', scheduleViewportHeightUpdate);\n    window.removeEventListener('click', onGlobalClick);\n  });\n</script>\n\n<svelte:window on:keydown={handleKeydown} />\n\n<div class=\"app-shell\" data-theme={theme}>\n  <div class=\"title-bar\" role=\"presentation\" data-tauri-drag-region on:mousedown={onTitleBarMouseDown}>\n    <div class=\"title-left\"></div>\n    <div class=\"title-center\">\n      <svg class=\"title-icon\" viewBox=\"0 0 215 205\" fill-rule=\"evenodd\" aria-hidden=\"true\">\n        <path d=\"M85 0c46.9 0 85 38.1 85 85 0 20.1-7.2 38.5-19.2 52.7l40.7 40.8c5.8 5.8 5.8 15.2 0 21-5.8 5.8-15.2 5.8-21 0l-40.7-40.7c-13.6 9.7-30.4 15.2-44.8 15.2-46.9 0-85-42.1-85-89 0-46.9 38.1-85 85-85z m0 32c-29.3 0-53 23.7-53 53 0 29.3 23.7 53 53 53 29.3 0 53-23.7 53-53 0-29.3-23.7-53-53-53z\"/>\n      </svg>\n      <span class=\"title-text\">Everything</span>\n    </div>\n    <div class=\"title-right\"></div>\n  </div>\n\n  <header class=\"search-bar\">\n    <input\n      bind:this={searchInputEl}\n      class=\"search-input\"\n      type=\"text\"\n      bind:value={query}\n      on:input={scheduleSearch}\n      on:focus={clearSelection}\n      placeholder=\"Search file/folder names\"\n      autocomplete=\"off\"\n      spellcheck=\"false\"\n    />\n  </header>\n\n  <section class=\"table-area\" bind:this={tableAreaEl} style={tableGridStyle}>\n    <div class=\"table-header\">\n      <div class=\"table-header-track\">\n        <div class=\"col name\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('name')}>\n            Name{#if sortBy === 'name'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'name'}\n            on:mousedown={(event) => startColumnResize(event, 'name')}\n            aria-label=\"Resize Name column\"\n          />\n        </div>\n\n        <div class=\"col path\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('dir')}>\n            Path{#if sortBy === 'dir'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'path'}\n            on:mousedown={(event) => startColumnResize(event, 'path')}\n            aria-label=\"Resize Path column\"\n          />\n        </div>\n\n        <div class=\"col size\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('size')}>\n            Size{#if sortBy === 'size'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n\n        <div class=\"col modified\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('mtime')}>\n            Modified{#if sortBy === 'mtime'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n      </div>\n    </div>\n\n    <div\n      class=\"table-body\"\n      bind:this={tableContainer}\n      on:scroll={() => {\n        scrollTop = tableContainer.scrollTop;\n        headerScrollLeft = tableContainer.scrollLeft;\n        const scrollBottom = scrollTop + tableContainer.clientHeight;\n        if (scrollBottom >= totalHeight - rowHeight * 10) {\n          void loadMore();\n        }\n      }}\n    >\n      <div class=\"spacer\" style={`height:${totalHeight}px`}>\n        <div class=\"rows\" style={`transform: translateY(${translateY}px);`}>\n          {#each visibleRows as entry, localIndex}\n            {@const index = startIndex + localIndex}\n            <div\n              class=\"row {selectedIndices.has(index) ? 'selected' : ''} {editing.active && editing.index === index ? 'renaming' : ''}\"\n              on:mousedown={(event) => handleRowMouseDown(event, index)}\n              on:click={(event) => handleRowClick(event, index)}\n              on:keydown={(event) => handleRowA11yKeydown(event, index)}\n              on:dblclick={() => handleRowDoubleClick(index)}\n              on:contextmenu={(event) => handleRowContextMenu(event, index)}\n              role=\"row\"\n              tabindex=\"0\"\n            >\n              <div class=\"cell name\">\n                <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n\n                {#if editing.active && editing.index === index}\n                  <span class=\"rename-wrapper\">\n                    <span class=\"rename-sizer\" aria-hidden=\"true\">{editing.draftName || '\\u00A0'}</span>\n                    <textarea\n                      bind:this={renameInputEl}\n                      class=\"rename-input\"\n                      bind:value={editing.draftName}\n                      rows=\"1\"\n                      on:click|stopPropagation\n                      on:blur={commitRename}\n                      on:keydown={(e) => { if (e.key === 'Enter') e.preventDefault(); }}\n                    />\n                  </span>\n                {:else}\n                  <span class=\"ellipsis\">{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n                {/if}\n              </div>\n              <div class=\"cell path\"><span class=\"ellipsis\">{displayPath(entry.dir)}</span></div>\n              <div class=\"cell size\">{formatSize(entry)}</div>\n              <div class=\"cell modified\">{formatModified(entry)}</div>\n            </div>\n          {/each}\n        </div>\n      </div>\n    </div>\n  </section>\n\n  <footer class=\"status-bar\">\n    <div class=\"status-left\">\n      <span class=\"status-state\">\n        <span class=\"state-dot {indexStatus.state === 'Indexing' ? 'indexing' : indexStatus.state === 'Error' ? 'error' : 'ready'}\"></span>\n        {#if indexStatus.state === 'Indexing'}\n          Indexing{#if lastReadyCount > 0} ({Math.min(99, Math.round((scanned / lastReadyCount) * 100))}%){/if}{#if indexingElapsed} · {indexingElapsed}{/if}\n          {#if !indexStatus.isCatchup}\n            · {scanned.toLocaleString()} scanned\n          {/if}\n        {:else}\n          Index: {indexStatus.state}\n        {/if}\n      </span>\n      <span>{indexStatus.entriesCount.toLocaleString()} entries</span>\n      {#if indexingFinishedAt && indexStatus.state !== 'Indexing'}\n        <span>in {indexingFinishedAt}</span>\n      {/if}\n      {#if dbLatencyMs !== null && dbLastQuery}\n        <span>\"{dbLastQuery}\" {dbLatencyMs}ms · {totalResults} results</span>\n      {/if}\n      {#if searchModeLabel === 'spotlight' || searchModeLabel === 'spotlight_timeout'}\n        <span class=\"status-spotlight\">Spotlight fallback{#if searchModeLabel === 'spotlight_timeout'} (partial){/if}</span>\n      {/if}\n      {#if indexStatus.permissionErrors > 0}\n        <span class=\"status-warning\">{indexStatus.permissionErrors.toLocaleString()} permission errors</span>\n      {/if}\n      {#if indexStatus.message}\n        <span class={indexStatus.isCatchup ? 'index-progress' : 'status-error'}>{indexStatus.message}</span>\n      {/if}\n    </div>\n    <div class=\"status-right\">\n      <button class=\"status-btn theme-btn\" on:click={cycleTheme} title=\"Switch theme\">\n        {theme === 'dark' ? '☀ Light' : '◑ Dark'}\n      </button>\n      <button\n        class=\"status-btn rebuild-btn\"\n        on:click={resetIndex}\n        disabled={indexStatus.state === 'Indexing'}\n        title={indexStatus.state === 'Indexing' ? 'Cannot reset while indexing is in progress.' : 'Reset and rebuild the index.'}\n      >\n        <svg class=\"rebuild-icon\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n          <path d=\"M23 4v6h-6\"/><path d=\"M20.49 15a9 9 0 1 1-2.12-9.36L23 10\"/>\n        </svg>\n        Rebuild Index\n      </button>\n    </div>\n  </footer>\n\n  {#if contextMenu.visible}\n    <div class=\"context-menu\" style={`left:${contextMenu.x}px;top:${contextMenu.y}px;`}>\n      <button on:click={() => (closeContextMenu(), openSelected())}>Open</button>\n      <button on:click={async () => { closeContextMenu(); const e = primaryEntry(); if (e) await invoke('quick_look', { path: e.path }); }}>Quick Look</button>\n      <button on:click={() => (closeContextMenu(), openWithFallback())}>Open With... (Reveal in Finder)</button>\n      <button on:click={() => (closeContextMenu(), revealSelected())}>Reveal in Finder</button>\n      <button on:click={() => (closeContextMenu(), copySelectedPaths())}>Copy Path</button>\n      <button on:click={() => (closeContextMenu(), trashSelected())}>Move to Trash</button>\n      {#if selectedIndices.size === 1}\n        <button on:click={() => (closeContextMenu(), startRename())}>Rename</button>\n      {/if}\n    </div>\n  {/if}\n\n  {#if toast}\n    <div class=\"toast\">{toast}</div>\n  {/if}\n</div>\n\n<style>\n  :global(:root) {\n    color-scheme: light dark;\n    --bg-app: transparent;\n    --text-primary: #0d1826;\n    --text-muted: #48596c;\n    --bar-grad-top: rgba(255, 255, 255, 0.48);\n    --bar-grad-bottom: rgba(248, 250, 253, 0.42);\n    --surface-header: rgba(252, 252, 255, 0.40);\n    --surface: rgba(255, 255, 255, 0.22);\n    --border-soft: rgba(0, 0, 0, 0.07);\n    --border-input: rgba(0, 0, 0, 0.13);\n    --focus-ring: #6f96e6;\n    --row-border: rgba(0, 0, 0, 0.032);\n    --row-hover: rgba(0, 0, 0, 0.06);\n    --row-selected: rgba(0, 0, 0, 0.12);\n    --button-bg: rgba(255, 255, 255, 0.62);\n    --button-border: rgba(0, 0, 0, 0.10);\n    --button-text: #2c3e50;\n    --menu-bg: rgba(240, 241, 248, 0.90);\n    --menu-border: rgba(0, 0, 0, 0.06);\n    --menu-hover: rgba(255, 255, 255, 0.62);\n    --menu-text: #1a2a38;\n    --error-text: #b64545;\n    --warning-text: #8f6500;\n    --toast-bg: rgba(18, 22, 32, 0.90);\n    --toast-text: #ffffff;\n  }\n\n  @media (prefers-color-scheme: dark) {\n    :global(:root) {\n      --bg-app: transparent;\n      --text-primary: #e6e6ea;\n      --text-muted: #9494a4;\n      --bar-grad-top: rgba(38, 38, 46, 0.52);\n      --bar-grad-bottom: rgba(30, 30, 38, 0.46);\n      --surface-header: rgba(32, 32, 40, 0.46);\n      --surface: rgba(18, 18, 26, 0.32);\n      --border-soft: rgba(255, 255, 255, 0.065);\n      --border-input: rgba(255, 255, 255, 0.14);\n      --focus-ring: #5b8bd9;\n      --row-border: rgba(255, 255, 255, 0.026);\n      --row-hover: rgba(255, 255, 255, 0.08);\n      --row-selected: rgba(255, 255, 255, 0.14);\n      --button-bg: rgba(255, 255, 255, 0.072);\n      --button-border: rgba(255, 255, 255, 0.11);\n      --button-text: #d6d6e0;\n      --menu-bg: rgba(36, 36, 46, 0.90);\n      --menu-border: rgba(255, 255, 255, 0.066);\n      --menu-hover: rgba(255, 255, 255, 0.062);\n      --menu-text: #e0e0e8;\n      --error-text: #ff9d9d;\n      --warning-text: #e0c670;\n      --toast-bg: rgba(10, 10, 16, 0.93);\n      --toast-text: #f2f2f6;\n    }\n  }\n\n  /* ── Theme: Dark ──────────────────────────────────────────────── */\n  :global([data-theme=\"dark\"]) {\n    color-scheme: dark;\n    --bg-app: #1E1E21;\n    --text-primary: #E2E8F0;\n    --text-muted: #94A3B8;\n    --bar-grad-top: #1E1E21;\n    --bar-grad-bottom: #1E1E21;\n    --surface-header: #1E1E21;\n    --surface: #1E1E21;\n    --bg-input: #161618;\n    --border-soft: #2A2A2D;\n    --border-input: rgba(255, 255, 255, 0.06);\n    --focus-ring: #4DA8FF;\n    --accent: #4DA8FF;\n    --row-border: rgba(255, 255, 255, 0.02);\n    --row-hover: #282828;\n    --row-selected: rgba(77, 168, 255, 0.10);\n    --button-bg: rgba(255, 255, 255, 0.05);\n    --button-border: #2A2A2D;\n    --button-text: #94A3B8;\n    --menu-bg: #252528;\n    --menu-border: #2A2A2D;\n    --menu-hover: rgba(255, 255, 255, 0.04);\n    --menu-text: #E2E8F0;\n    --error-text: #ff9d9d;\n    --warning-text: #e0c670;\n    --toast-bg: rgba(10, 10, 16, 0.93);\n    --toast-text: #f2f2f6;\n  }\n\n  /* ── Theme: Light ─────────────────────────────────────────────── */\n  :global([data-theme=\"light\"]) {\n    color-scheme: light;\n    --bg-app: #F5F5F7;\n    --text-primary: #1C1C1E;\n    --text-muted: #6E6E7A;\n    --bar-grad-top: #F5F5F7;\n    --bar-grad-bottom: #F5F5F7;\n    --surface-header: #F5F5F7;\n    --surface: #F5F5F7;\n    --bg-input: #FFFFFF;\n    --border-soft: #D1D1D6;\n    --border-input: rgba(0, 0, 0, 0.10);\n    --focus-ring: #3A8BF5;\n    --accent: #3A8BF5;\n    --row-border: rgba(0, 0, 0, 0.04);\n    --row-hover: rgba(0, 0, 0, 0.04);\n    --row-selected: rgba(58, 139, 245, 0.10);\n    --button-bg: #FFFFFF;\n    --button-border: #D1D1D6;\n    --button-text: #3C3C43;\n    --menu-bg: #FFFFFF;\n    --menu-border: #D1D1D6;\n    --menu-hover: rgba(0, 0, 0, 0.05);\n    --menu-text: #1C1C1E;\n    --error-text: #D93025;\n    --warning-text: #B45309;\n    --toast-bg: rgba(255, 255, 255, 0.95);\n    --toast-text: #1C1C1E;\n  }\n\n  /* ── Themed element overrides ─────────────────────────────────── */\n  :global([data-theme]) {\n    background: var(--bg-app);\n  }\n\n  /* Search bar: flat, no gradient, no separator */\n  :global([data-theme]) .search-bar {\n    height: 44px;\n    padding: 0 16px;\n    background: var(--bg-app);\n    border-bottom: none;\n  }\n\n  :global([data-theme]) .search-input {\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n    font-family: 'JetBrains Mono', 'SF Mono', monospace;\n    font-size: 12px;\n    height: 34px;\n    border-radius: 8px;\n  }\n\n  /* Table header: flat bg, 16px edge padding */\n  :global([data-theme]) .table-header {\n    background: var(--bg-app);\n  }\n\n  :global([data-theme]) .col-button {\n    padding: 0 8px;\n  }\n\n  :global([data-theme]) .col.name .col-button {\n    padding-left: 16px;\n  }\n\n  /* Row cells: JetBrains Mono, 16px outer edges */\n  :global([data-theme]) .cell {\n    font-family: 'JetBrains Mono', monospace;\n  }\n\n  :global([data-theme]) .cell.name {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    padding-left: 16px;\n    font-size: 12px;\n    color: var(--text-primary);\n  }\n\n  :global([data-theme]) .cell.path {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.size {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.modified {\n    padding-right: 16px;\n    font-size: 11px;\n    white-space: nowrap;\n  }\n\n  :global([data-theme]) .row.selected {\n    box-shadow: inset 3px 0 0 var(--accent);\n  }\n\n  /* Dim path/size/date cells in themed mode */\n  :global([data-theme]) .cell.path,\n  :global([data-theme]) .cell.size,\n  :global([data-theme]) .cell.modified {\n    color: var(--text-muted);\n  }\n\n  :global(:root) {\n    background: transparent;\n  }\n\n  :global(html, body) {\n    margin: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    background: transparent;\n    color: var(--text-primary);\n    font-family: Inter, 'SF Pro Text', 'Segoe UI', Helvetica, Arial, sans-serif;\n  }\n\n  :global(#app) {\n    width: 100%;\n    height: 100%;\n  }\n\n  .app-shell {\n    display: grid;\n    grid-template-rows: auto auto 1fr auto;\n    height: 100%;\n    min-width: 0;\n  }\n\n  .title-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 44px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    cursor: default;\n    flex-shrink: 0;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-left {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-center {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-right {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-icon {\n    width: 14px;\n    height: 14px;\n    fill: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .title-text {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 13px;\n    font-weight: 500;\n    color: var(--text-primary);\n    letter-spacing: -0.01em;\n  }\n\n  .search-bar {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding: 8px;\n    background: linear-gradient(180deg, var(--bar-grad-top) 0%, var(--bar-grad-bottom) 100%);\n    border-bottom: 1px solid var(--border-soft);\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .search-input {\n    display: block;\n    box-sizing: border-box;\n    width: 100%;\n    min-width: 0;\n    flex: 1 1 auto;\n    height: 36px;\n    border: 1px solid var(--border-input);\n    border-radius: 14px;\n    padding: 0 10px;\n    font-size: 14px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    backdrop-filter: blur(12px) saturate(160%);\n    -webkit-backdrop-filter: blur(12px) saturate(160%);\n  }\n\n  .search-input::placeholder {\n    color: var(--text-muted);\n    opacity: 0.85;\n    font-size: 12px;\n  }\n\n  .search-input:focus {\n    outline: none;\n    border-color: var(--focus-ring);\n    box-shadow: 0 0 0 2px rgba(125, 169, 255, 0.25);\n  }\n\n  .table-area {\n    display: grid;\n    grid-template-rows: auto 1fr;\n    min-height: 0;\n    min-width: 0;\n  }\n\n  .table-header-track,\n  .row {\n    display: grid;\n    grid-template-columns: var(--col-name) var(--col-path) var(--col-size) var(--col-modified);\n    align-items: center;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .table-header {\n    height: 32px;\n    border-bottom: 1px solid var(--border-soft);\n    background: var(--surface-header);\n    user-select: none;\n    overflow: hidden;\n    flex-shrink: 0;\n  }\n\n  .table-header-track {\n    height: 100%;\n    transform: translateX(var(--header-offset, 0px));\n    will-change: transform;\n  }\n\n  .table-header .col {\n    position: relative;\n    min-width: 0;\n    height: 100%;\n  }\n\n  .col-button {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n    gap: 4px;\n    box-sizing: border-box;\n    padding: 0 8px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 11px;\n    font-weight: 600;\n    line-height: 1;\n    color: var(--text-muted);\n    text-align: left;\n    margin: 0;\n    border: none;\n    background: transparent;\n    cursor: pointer;\n  }\n\n  .sort-icon {\n    width: 10px;\n    height: 10px;\n    flex-shrink: 0;\n    color: var(--accent);\n  }\n\n  .col-resizer {\n    position: absolute;\n    top: 0;\n    right: -4px;\n    width: 8px;\n    height: 100%;\n    border: none;\n    padding: 0;\n    background: transparent;\n    cursor: col-resize;\n    z-index: 30;\n  }\n\n  .col-resizer::after {\n    content: '';\n    position: absolute;\n    top: 7px;\n    bottom: 7px;\n    left: 50%;\n    width: 1px;\n    transform: translateX(-50%);\n    background: var(--border-soft);\n    opacity: 0;\n    transition: opacity 0.15s ease;\n  }\n\n  .table-header .col:hover .col-resizer::after,\n  .col-resizer.active::after {\n    opacity: 1;\n  }\n\n  .table-body {\n    overflow: auto;\n    min-height: 0;\n    min-width: 0;\n    background: var(--surface);\n  }\n\n  .spacer {\n    position: relative;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .rows {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .row {\n    height: 30px;\n    border-bottom: 1px solid var(--row-border);\n    cursor: default;\n    -webkit-user-select: none;\n    user-select: none;\n    outline: none;\n  }\n\n  .row:hover {\n    background: var(--row-hover);\n  }\n\n  .row.selected {\n    background: var(--row-selected);\n  }\n\n  .cell {\n    padding: 0 8px;\n    font-size: 12px;\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    min-width: 0;\n  }\n\n  .cell.size {\n    text-align: right;\n    font-variant-numeric: tabular-nums;\n  }\n\n  .ellipsis {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n\n  .hl {\n    background: none;\n    color: inherit;\n    font-weight: 700;\n  }\n\n  .file-icon {\n    width: 16px;\n    height: 16px;\n    flex: 0 0 auto;\n  }\n\n  .row.renaming {\n    height: auto;\n    min-height: 30px;\n    align-items: start;\n  }\n\n  .row.renaming .cell.name {\n    align-items: start;\n  }\n\n  .rename-wrapper {\n    display: grid;\n    flex: 1;\n    min-width: 0;\n    margin-left: calc(-1.5px - 5px);\n  }\n\n  .rename-sizer {\n    grid-area: 1 / 1;\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 12px;\n    padding: 2px 5px;\n    border: 1.5px solid transparent;\n    visibility: hidden;\n    white-space: pre-wrap;\n    word-break: break-word;\n  }\n\n  .rename-input {\n    grid-area: 1 / 1;\n    width: 100%;\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 12px;\n    padding: 2px 5px;\n    border: 1.5px solid var(--focus-ring);\n    border-radius: 4px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    outline: none;\n    resize: none;\n    overflow: hidden;\n  }\n\n  .status-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 32px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    border-top: 1px solid var(--border-soft);\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 11px;\n    color: var(--text-muted);\n    white-space: nowrap;\n    overflow: hidden;\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .status-left {\n    display: flex;\n    align-items: center;\n    gap: 16px;\n    overflow: hidden;\n    min-width: 0;\n  }\n\n  .status-right {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    flex-shrink: 0;\n  }\n\n  .status-btn {\n    border: 1px solid var(--button-border);\n    border-radius: 5px;\n    background: var(--button-bg);\n    color: var(--button-text);\n    font-size: 11px;\n    height: 22px;\n    padding: 0 8px;\n    cursor: pointer;\n  }\n\n  .status-btn:hover {\n    filter: brightness(1.06);\n  }\n\n  .status-btn:disabled {\n    opacity: 0.55;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .status-state {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n  }\n\n  .state-dot {\n    width: 6px;\n    height: 6px;\n    border-radius: 50%;\n    flex-shrink: 0;\n  }\n\n  .state-dot.ready { background: #28C840; }\n  .state-dot.indexing { background: #FEBC2E; }\n  .state-dot.error { background: #FF5F57; }\n\n  .rebuild-btn {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 10px;\n    font-weight: 500;\n    background: var(--button-bg);\n    border: 1px solid var(--button-border);\n    border-radius: 4px;\n    color: var(--button-text);\n    height: 22px;\n    padding: 0 10px;\n    cursor: pointer;\n  }\n\n  .rebuild-btn:hover {\n    filter: brightness(1.1);\n  }\n\n  .rebuild-btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .rebuild-icon {\n    width: 11px;\n    height: 11px;\n    color: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .status-error {\n    color: var(--error-text);\n  }\n\n  .status-warning {\n    color: var(--warning-text);\n  }\n\n  .status-spotlight {\n    color: #f59e0b;\n    font-weight: 600;\n  }\n\n  .context-menu {\n    position: fixed;\n    z-index: 200;\n    width: 220px;\n    border: 1px solid var(--menu-border);\n    border-radius: 10px;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.16), inset 0 0 0 0.5px rgba(255, 255, 255, 0.18);\n    background: var(--menu-bg);\n    backdrop-filter: blur(28px) saturate(180%);\n    -webkit-backdrop-filter: blur(28px) saturate(180%);\n    overflow: hidden;\n  }\n\n  .context-menu button {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    padding: 8px 10px;\n    font-size: 12px;\n    color: var(--menu-text);\n  }\n\n  .context-menu button:hover {\n    background: var(--menu-hover);\n  }\n\n  .toast {\n    position: fixed;\n    right: 14px;\n    bottom: 18px;\n    background: var(--toast-bg);\n    color: var(--toast-text);\n    border-radius: 10px;\n    padding: 9px 12px;\n    font-size: 12px;\n    z-index: 250;\n    backdrop-filter: blur(20px) saturate(180%);\n    -webkit-backdrop-filter: blur(20px) saturate(180%);\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);\n  }\n</style>\n","structuredPatch":[{"oldStart":1488,"oldLines":18,"newStart":1488,"newLines":14,"lines":["                 <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />"," ","                 {#if editing.active && editing.index === index}","-                  <span class=\"rename-wrapper\">","-                    <span class=\"rename-sizer\" aria-hidden=\"true\">{editing.draftName || '\\u00A0'}</span>","-                    <textarea","-                      bind:this={renameInputEl}","-                      class=\"rename-input\"","-                      bind:value={editing.draftName}","-                      rows=\"1\"","-                      on:click|stopPropagation","-                      on:blur={commitRename}","-                      on:keydown={(e) => { if (e.key === 'Enter') e.preventDefault(); }}","-                    />","-                  </span>","+                  <input","+                    bind:this={renameInputEl}","+                    class=\"rename-input\"","+                    type=\"text\"","+                    bind:value={editing.draftName}","+                    on:click|stopPropagation","+                    on:blur={commitRename}","+                  />","                 {:else}","                   <span class=\"ellipsis\">{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>","                 {/if}"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"30e5c15c-b579-485b-8c0e-c984fc522051"}
{"parentUuid":"313470ef-b53a-4497-bbca-80d711f684b2","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","message":{"model":"claude-sonnet-4-6","id":"msg_01WuiUftJugYEUxqEFKaRXvS","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Sot7pZEyAxVVKFF9PRUg1X","name":"Edit","input":{"replace_all":false,"file_path":"/Users/al02402336/everything/src/App.svelte","old_string":"  .row.renaming {\n    height: auto;\n    min-height: 30px;\n    align-items: start;\n  }\n\n  .row.renaming .cell.name {\n    align-items: start;\n  }\n\n  .rename-wrapper {\n    display: grid;\n    flex: 1;\n    min-width: 0;\n    margin-left: calc(-1.5px - 5px);\n  }\n\n  .rename-sizer {\n    grid-area: 1 / 1;\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 12px;\n    padding: 2px 5px;\n    border: 1.5px solid transparent;\n    visibility: hidden;\n    white-space: pre-wrap;\n    word-break: break-word;\n  }\n\n  .rename-input {\n    grid-area: 1 / 1;\n    width: 100%;\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 12px;\n    padding: 2px 5px;\n    border: 1.5px solid var(--focus-ring);\n    border-radius: 4px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    outline: none;\n    resize: none;\n    overflow: hidden;\n  }","new_string":"  .rename-input {\n    flex: 1;\n    min-width: 0;\n    height: 22px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 12px;\n    padding: 0 6px;\n    border: 1.5px solid var(--focus-ring);\n    border-radius: 4px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    outline: none;\n    box-shadow: 0 1px 6px rgba(0, 0, 0, 0.18), 0 0 0 3px rgba(77, 168, 255, 0.12);\n  }"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3943,"cache_read_input_tokens":64298,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3943},"output_tokens":18,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMMmppoqd1FCKXFJUVWo","type":"assistant","uuid":"379d143e-9f22-434c-9af0-b682968cc083","timestamp":"2026-02-21T14:18:35.422Z"}
{"parentUuid":"379d143e-9f22-434c-9af0-b682968cc083","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01Sot7pZEyAxVVKFF9PRUg1X","toolUseID":"toolu_01Sot7pZEyAxVVKFF9PRUg1X","timestamp":"2026-02-21T14:18:35.432Z","uuid":"7c1bc83e-1bf6-4a0e-9c1b-ca0915b542f1"}
{"parentUuid":"379d143e-9f22-434c-9af0-b682968cc083","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Sot7pZEyAxVVKFF9PRUg1X","type":"tool_result","content":"The file /Users/al02402336/everything/src/App.svelte has been updated successfully."}]},"uuid":"e25a9103-9cef-4bed-bf45-5b1f784f35fc","timestamp":"2026-02-21T14:18:35.431Z","toolUseResult":{"filePath":"/Users/al02402336/everything/src/App.svelte","oldString":"  .row.renaming {\n    height: auto;\n    min-height: 30px;\n    align-items: start;\n  }\n\n  .row.renaming .cell.name {\n    align-items: start;\n  }\n\n  .rename-wrapper {\n    display: grid;\n    flex: 1;\n    min-width: 0;\n    margin-left: calc(-1.5px - 5px);\n  }\n\n  .rename-sizer {\n    grid-area: 1 / 1;\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 12px;\n    padding: 2px 5px;\n    border: 1.5px solid transparent;\n    visibility: hidden;\n    white-space: pre-wrap;\n    word-break: break-word;\n  }\n\n  .rename-input {\n    grid-area: 1 / 1;\n    width: 100%;\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 12px;\n    padding: 2px 5px;\n    border: 1.5px solid var(--focus-ring);\n    border-radius: 4px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    outline: none;\n    resize: none;\n    overflow: hidden;\n  }","newString":"  .rename-input {\n    flex: 1;\n    min-width: 0;\n    height: 22px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 12px;\n    padding: 0 6px;\n    border: 1.5px solid var(--focus-ring);\n    border-radius: 4px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    outline: none;\n    box-shadow: 0 1px 6px rgba(0, 0, 0, 0.18), 0 0 0 3px rgba(77, 168, 255, 0.12);\n  }","originalFile":"<script>\n  import { onDestroy, onMount, tick } from 'svelte';\n  import { invoke } from '@tauri-apps/api/core';\n  import { listen } from '@tauri-apps/api/event';\n  import { getCurrentWindow } from '@tauri-apps/api/window';\n  import { startDrag } from '@crabnebula/tauri-plugin-drag';\n\n  const rowHeight = 30;\n  const PAGE_SIZE = 500;\n  let homePrefix = '';\n  const COL_WIDTHS_KEY = 'REDACTED';\n  const THEME_KEY = 'everything-theme';\n  const columnKeys = ['name', 'path', 'size', 'modified'];\n  const minColumnWidth = {\n    name: 180,\n    path: 240,\n    size: 75,\n    modified: 150\n  };\n  const defaultColumnRatios = {\n    name: 0.3,\n    path: 0.45,\n    size: 0.1\n  };\n\n  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || 'dark'; } catch { return 'dark'; } })();\n  function cycleTheme() {\n    theme = theme === 'dark' ? 'light' : 'dark';\n    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n  }\n\n  let query = '';\n  let results = [];\n  let totalResults = 0;\n  let totalResultsKnown = false;\n\n  let dbLatencyMs = null;\n  let dbLastQuery = '';\n  let searchModeLabel = '';\n  let selectedIndices = new Set();\n  let selectionAnchor = -1;\n  let lastSelectedIndex = -1;\n  let editing = {\n    active: false,\n    path: '',\n    index: -1,\n    draftName: ''\n  };\n\n  let indexStatus = {\n    state: 'Indexing',\n    entriesCount: 0,\n    lastUpdated: null,\n    permissionErrors: 0,\n    message: null,\n    isCatchup: false\n  };\n\n  let indexingStartTime = null;\n  let indexingElapsed = '';\n  let indexingFinishedAt = '';\n\n  let sortBy = 'name';\n  let sortDir = 'asc';\n\n  let hasMore = true;\n  let loadingMore = false;\n  let searchGeneration = 0;\n\n  let scanned = 0;\n\n  let searchInputEl;\n  let renameInputEl;\n  let tableAreaEl;\n  let tableContainer;\n  let tableResizeObserver = null;\n  let viewportResizeRaf = null;\n  let scrollTop = 0;\n  let headerScrollLeft = 0;\n  let viewportHeight = 520;\n  let lastTableWidth = 0;\n  let resizingColumn = '';\n  let resizeCleanup = null;\n  let colWidths = {\n    name: 250,\n    path: 350,\n    size: 75,\n    modified: 150\n  };\n\n  let contextMenu = {\n    visible: false,\n    x: 0,\n    y: 0\n  };\n\n  let platform = '';\n  let toast = '';\n  let searchTimer;\n  let lastSearchFiredAt = 0;\n  let toastTimer;\n  let statusRefreshTimer;\n  let elapsedTimer;\n  let statusRefreshInFlight = false;\n  let lastReadyCount = 0;\n\n  const iconCache = new Map();\n  const iconLoading = new Set();\n\n  let highlightCache = new Map();\n  let highlightCacheQuery = '';\n\n  const folderFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='1' y='4' width='14' height='10' rx='2' fill='#d9b34f'/><rect x='1' y='2' width='6' height='4' rx='1' fill='#e6ca7a'/></svg>`\n    );\n  const fileFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='3' y='1' width='10' height='14' rx='1.5' fill='#b4bec9'/><rect x='5' y='5' width='6' height='1.2' fill='#8d98a5'/><rect x='5' y='8' width='6' height='1.2' fill='#8d98a5'/></svg>`\n    );\n\n  $: totalHeight = results.length * rowHeight;\n  $: startIndex = Math.max(0, Math.floor(scrollTop / rowHeight) - 10);\n  $: visibleCount = Math.ceil(viewportHeight / rowHeight) + 20;\n  $: endIndex = Math.min(results.length, startIndex + visibleCount);\n  $: visibleRows = results.slice(startIndex, endIndex);\n  $: translateY = startIndex * rowHeight;\n  $: tableMinWidth = colWidths.name + colWidths.path + colWidths.size + colWidths.modified;\n  $: tableGridStyle = `--col-name:${colWidths.name}px;--col-path:${colWidths.path}px;--col-size:${colWidths.size}px;--col-modified:${colWidths.modified}px;--table-min-width:${tableMinWidth}px;--header-offset:${-headerScrollLeft}px;`;\n\n  $: {\n    for (const entry of visibleRows) {\n      void ensureIcon(entry);\n    }\n  }\n\n  function showToast(message) {\n    toast = message;\n    clearTimeout(toastTimer);\n    toastTimer = setTimeout(() => {\n      toast = '';\n    }, 3000);\n  }\n\n  function bytesToBase64(bytes) {\n    let binary = '';\n    const chunk = 0x8000;\n    for (let i = 0; i < bytes.length; i += chunk) {\n      const part = bytes.subarray(i, i + chunk);\n      binary += String.fromCharCode(...part);\n    }\n    return btoa(binary);\n  }\n\n  function highlightSegments(name, q) {\n    q = (q || '').trim();\n    if (!q) return [{ text: name, hl: false }];\n\n    // Reset cache when query changes\n    if (q !== highlightCacheQuery) {\n      highlightCache = new Map();\n      highlightCacheQuery = q;\n    }\n\n    // Check cache\n    const cached = highlightCache.get(name);\n    if (cached) return cached;\n\n    if (q.includes('/')) q = q.slice(q.lastIndexOf('/') + 1);\n    q = q.replace(/[*?]/g, '');\n    const terms = q.split(/\\s+/).filter(Boolean);\n    if (terms.length === 0) return [{ text: name, hl: false }];\n\n    const lower = name.toLowerCase();\n    const marks = new Uint8Array(name.length);\n    for (const t of terms) {\n      const tl = t.toLowerCase();\n      let idx = lower.indexOf(tl);\n      while (idx !== -1) {\n        for (let i = idx; i < idx + tl.length; i++) marks[i] = 1;\n        idx = lower.indexOf(tl, idx + 1);\n      }\n    }\n\n    const segs = [];\n    let i = 0;\n    while (i < name.length) {\n      const m = marks[i];\n      let j = i + 1;\n      while (j < name.length && marks[j] === m) j++;\n      segs.push({ text: name.slice(i, j), hl: m === 1 });\n      i = j;\n    }\n\n    highlightCache.set(name, segs);\n    return segs;\n  }\n\n  const perFileIconExts = new Set(['exe', 'lnk', 'ico', 'url', 'scr', 'appx']);\n\n  function iconKey(entry) {\n    if (entry.isDir) return '__folder__';\n    const ext = (entry.ext || '').toLowerCase();\n    if (perFileIconExts.has(ext)) return entry.path;\n    return ext || '__file__';\n  }\n\n  function iconFor(entry) {\n    return iconCache.get(iconKey(entry)) || (entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n  }\n\n  async function ensureIcon(entry) {\n    const key = iconKey(entry);\n    if (iconCache.has(key) || iconLoading.has(key)) {\n      return;\n    }\n\n    iconLoading.add(key);\n    try {\n      const bytes = await invoke('get_file_icon', {\n        path: entry.path,\n        ext: entry.isDir ? 'folder' : entry.ext || '',\n      });\n      if (Array.isArray(bytes) && bytes.length > 0) {\n        const image = `data:image/png;base64,${bytesToBase64(Uint8Array.from(bytes))}`;\n        iconCache.set(key, image);\n      } else {\n        iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n      }\n    } catch {\n      iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n    } finally {\n      iconLoading.delete(key);\n    }\n  }\n\n  function syncColumnWidthsToContainer() {\n    const width = tableContainer?.clientWidth || tableAreaEl?.clientWidth;\n    if (!width || lastTableWidth !== 0) {\n      return;\n    }\n\n    const saved = loadColWidths();\n    if (saved) {\n      const total = columnKeys.reduce((s, k) => s + saved[k], 0);\n      if (Math.abs(total - width) > 2) {\n        const scale = (width - saved.modified) / (total - saved.modified);\n        let scaledName = Math.max(minColumnWidth.name, Math.round(saved.name * scale));\n        let scaledSize = Math.max(minColumnWidth.size, Math.round(saved.size * scale));\n        let rawPath = width - saved.modified - scaledName - scaledSize;\n        if (rawPath < minColumnWidth.path) {\n          const shortfall = minColumnWidth.path - rawPath;\n          const nameReduction = Math.min(shortfall, scaledName - minColumnWidth.name);\n          scaledName -= nameReduction;\n          const remaining = shortfall - nameReduction;\n          if (remaining > 0) {\n            scaledSize -= Math.min(remaining, scaledSize - minColumnWidth.size);\n          }\n          rawPath = width - saved.modified - scaledName - scaledSize;\n        }\n        const scaledPath = Math.max(minColumnWidth.path, rawPath);\n        colWidths = { name: scaledName, path: scaledPath, size: scaledSize, modified: saved.modified };\n      } else {\n        colWidths = saved;\n      }\n    } else {\n      const fixedModified = minColumnWidth.modified;\n      const rest = width - fixedModified;\n      const ratioSum = defaultColumnRatios.name + defaultColumnRatios.path + defaultColumnRatios.size;\n      colWidths = {\n        name: Math.max(minColumnWidth.name, Math.round(rest * defaultColumnRatios.name / ratioSum)),\n        path: Math.max(minColumnWidth.path, Math.round(rest * defaultColumnRatios.path / ratioSum)),\n        size: Math.max(minColumnWidth.size, Math.round(rest * defaultColumnRatios.size / ratioSum)),\n        modified: fixedModified\n      };\n    }\n    lastTableWidth = width;\n  }\n\n  function loadColWidths() {\n    try {\n      const raw = localStorage.getItem(COL_WIDTHS_KEY);\n      if (!raw) return null;\n      const parsed = JSON.parse(raw);\n      for (const key of columnKeys) {\n        if (typeof parsed[key] !== 'number' || parsed[key] < (minColumnWidth[key] || 0)) return null;\n      }\n      return parsed;\n    } catch {\n      return null;\n    }\n  }\n\n  function saveColWidths() {\n    localStorage.setItem(COL_WIDTHS_KEY, JSON.stringify(colWidths));\n  }\n\n  function updateViewportHeight() {\n    viewportHeight = tableContainer?.clientHeight || 520;\n    syncColumnWidthsToContainer();\n  }\n\n  function scheduleViewportHeightUpdate() {\n    if (viewportResizeRaf !== null) {\n      return;\n    }\n    viewportResizeRaf = requestAnimationFrame(() => {\n      viewportResizeRaf = null;\n      updateViewportHeight();\n    });\n  }\n\n  function startColumnResize(event, leftKey) {\n    event.preventDefault();\n    event.stopPropagation();\n\n    const index = columnKeys.indexOf(leftKey);\n    if (index < 0 || index >= columnKeys.length - 1) {\n      return;\n    }\n\n    const startX = event.clientX;\n    const startLeft = colWidths[leftKey];\n    const rightKey = columnKeys[index + 1];\n    const startRight = colWidths[rightKey];\n\n    resizeCleanup?.();\n    resizingColumn = leftKey;\n\n    const onMove = (moveEvent) => {\n      const delta = Math.round(moveEvent.clientX - startX);\n      if (leftKey === 'name') {\n        // Two-column trade: name and path swap space, each respects its minimum\n        const nextLeft = Math.max(\n          minColumnWidth[leftKey],\n          Math.min(startLeft + delta, startLeft + startRight - minColumnWidth[rightKey])\n        );\n        const nextRight = startLeft + startRight - nextLeft;\n        colWidths = { ...colWidths, [leftKey]: nextLeft, [rightKey]: nextRight };\n      } else {\n        // path splitter: path grows unconstrained (allows horizontal scroll on right drag)\n        const nextLeft = Math.max(minColumnWidth[leftKey], startLeft + delta);\n        colWidths = { ...colWidths, [leftKey]: nextLeft };\n      }\n    };\n\n    const onUp = () => {\n      cleanup();\n    };\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      document.body.style.cursor = '';\n      document.body.style.userSelect = '';\n      resizingColumn = '';\n      saveColWidths();\n      if (resizeCleanup === cleanup) {\n        resizeCleanup = null;\n      }\n    };\n\n    resizeCleanup = cleanup;\n    document.body.style.cursor = 'col-resize';\n    document.body.style.userSelect = 'none';\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  function selectedPaths() {\n    const sorted = [...selectedIndices].sort((a, b) => a - b);\n    return sorted.map((idx) => results[idx]).filter(Boolean).map((entry) => entry.path);\n  }\n\n  function clearSelection() {\n    selectedIndices = new Set();\n    selectionAnchor = -1;\n    lastSelectedIndex = -1;\n  }\n\n  function selectSingle(index) {\n    selectedIndices = new Set([index]);\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectToggle(index) {\n    const next = new Set(selectedIndices);\n    if (next.has(index)) {\n      next.delete(index);\n    } else {\n      next.add(index);\n    }\n    selectedIndices = next;\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectRange(index) {\n    const anchor = selectionAnchor >= 0 ? selectionAnchor : index;\n    const [from, to] = [Math.min(anchor, index), Math.max(anchor, index)];\n    const next = new Set();\n    for (let i = from; i <= to; i += 1) {\n      next.add(i);\n    }\n    selectedIndices = next;\n    lastSelectedIndex = index;\n  }\n\n  function primaryEntry() {\n    const idx = lastSelectedIndex >= 0 ? lastSelectedIndex : -1;\n    return idx >= 0 ? results[idx] : null;\n  }\n\n  async function refreshStatus() {\n    if (statusRefreshInFlight) {\n      return;\n    }\n    statusRefreshInFlight = true;\n    try {\n      const status = await invoke('get_index_status');\n      const prevState = indexStatus.state;\n      indexStatus = {\n        state: status.state,\n        entriesCount: status.entriesCount,\n        lastUpdated: status.lastUpdated,\n        permissionErrors: status.permissionErrors ?? 0,\n        message: status.message\n      };\n      if (status.state === 'Indexing' && prevState !== 'Indexing') {\n        startElapsedTimer();\n      } else if (status.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n      if (typeof status.scanned === 'number') {\n        scanned = status.scanned;\n      }\n      if (status.state === 'Ready' && prevState !== 'Ready') {\n        scheduleSearch();\n      }\n    } catch (err) {\n      showToast(`Failed to get status: ${String(err)}`);\n    } finally {\n      statusRefreshInFlight = false;\n    }\n  }\n\n  function scheduleSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const scheduledGen = searchGeneration;\n    clearTimeout(searchTimer);\n\n    const now = performance.now();\n    if (now - lastSearchFiredAt >= 200) {\n      // Leading edge: fire immediately if enough time has passed\n      lastSearchFiredAt = now;\n      void runSearch(preserveScroll);\n    } else {\n      // Trailing edge: debounce\n      searchTimer = setTimeout(() => {\n        if (scheduledGen !== searchGeneration) {\n          return;\n        }\n        lastSearchFiredAt = performance.now();\n        void runSearch(preserveScroll);\n      }, 200);\n    }\n  }\n\n  async function runSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const gen = searchGeneration;\n    const searchQuery = query;\n    const searchSortBy = sortBy;\n    const searchSortDir = sortDir;\n    const startedAt = performance.now();\n    try {\n      const keepPaths = new Set(selectedPaths());\n      const next = await invoke('search', {\n        query: searchQuery,\n        limit: PAGE_SIZE,\n        offset: 0,\n        sortBy: searchSortBy,\n        sortDir: searchSortDir\n      });\n\n      if (gen !== searchGeneration) return;\n\n      dbLatencyMs = Math.round(performance.now() - startedAt);\n      dbLastQuery = searchQuery;\n      const entries = Array.isArray(next.entries) ? next.entries : [];\n      searchModeLabel = next.modeLabel || '';\n      results = entries;\n      if (next.totalCount > 0) {\n        totalResults = next.totalCount;\n        totalResultsKnown = true;\n      } else {\n        totalResults = entries.length;\n        totalResultsKnown = false;\n      }\n      hasMore = totalResultsKnown ? results.length < totalResults : entries.length >= PAGE_SIZE;\n      if (!preserveScroll && tableContainer) tableContainer.scrollTop = 0;\n\n      const restored = new Set();\n      for (let i = 0; i < results.length; i += 1) {\n        if (keepPaths.has(results[i].path)) {\n          restored.add(i);\n        }\n      }\n      selectedIndices = restored;\n\n      updateViewportHeight();\n    } catch (err) {\n      if (gen !== searchGeneration) return;\n      showToast(`Search failed: ${String(err)}`);\n    }\n  }\n\n  async function loadMore() {\n    if (!hasMore || loadingMore) return;\n    const gen = searchGeneration;\n    loadingMore = true;\n    try {\n      const batch = await invoke('search', {\n        query,\n        limit: PAGE_SIZE,\n        offset: results.length,\n        sortBy: sortBy,\n        sortDir: sortDir\n      });\n      if (gen !== searchGeneration) return;\n      const arr = Array.isArray(batch.entries) ? batch.entries : [];\n      if (arr.length > 0) results = [...results, ...arr];\n      hasMore = totalResultsKnown ? results.length < totalResults : arr.length >= PAGE_SIZE;\n    } catch (err) {\n      showToast(`Failed to load more: ${String(err)}`);\n    } finally {\n      loadingMore = false;\n    }\n  }\n\n  function moveSelection(delta, withRange = false) {\n    if (results.length === 0) {\n      return;\n    }\n\n    const current = lastSelectedIndex >= 0 ? lastSelectedIndex : 0;\n    const next = Math.max(0, Math.min(results.length - 1, current + delta));\n\n    if (withRange) {\n      selectRange(next);\n    } else {\n      selectSingle(next);\n    }\n\n    const top = next * rowHeight;\n    const bottom = top + rowHeight;\n    if (top < scrollTop) {\n      tableContainer.scrollTop = top;\n    } else if (bottom > scrollTop + viewportHeight) {\n      tableContainer.scrollTop = bottom - viewportHeight;\n    }\n  }\n\n  function handleHeaderSort(column) {\n    if (sortBy === column) {\n      sortDir = sortDir === 'asc' ? 'desc' : 'asc';\n    } else {\n      sortBy = column;\n      sortDir = 'asc';\n    }\n    if (tableContainer) tableContainer.scrollTop = 0;\n    void runSearch();\n  }\n\n  function handleRowClick(event, index) {\n    contextMenu.visible = false;\n\n    if (event.shiftKey) {\n      selectRange(index);\n      return;\n    }\n\n    if (event.metaKey || event.ctrlKey) {\n      selectToggle(index);\n      return;\n    }\n\n    selectSingle(index);\n  }\n\n  function handleRowContextMenu(event, index) {\n    event.preventDefault();\n\n    if (!selectedIndices.has(index)) {\n      selectSingle(index);\n    }\n\n    if (platform === 'windows' || platform === 'macos') {\n      contextMenu.visible = false;\n      const paths = selectedPaths();\n      if (paths.length > 0) {\n        invoke('show_context_menu', {\n          paths,\n          x: event.clientX,\n          y: event.clientY,\n          singleSelection: selectedIndices.size === 1\n        });\n      }\n      return;\n    }\n\n    contextMenu = {\n      visible: true,\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n\n  function handleRowA11yKeydown(event, index) {\n    if (event.key === ' ' || event.key === 'Enter') {\n      event.preventDefault();\n      handleRowClick(event, index);\n    }\n  }\n\n  const DRAG_THRESHOLD = 5;\n  let dragCleanup = null;\n  const dragImgCache = new Map();\n\n  function dragPathsForIndex(index) {\n    const entry = results[index];\n    if (!entry) {\n      return [];\n    }\n\n    if (selectedIndices.has(index) && selectedIndices.size > 0) {\n      return selectedPaths();\n    }\n\n    return [entry.path];\n  }\n\n  function getDragIconEl(entry) {\n    const src = iconFor(entry);\n    let img = dragImgCache.get(src);\n    if (!img) {\n      img = new Image();\n      img.src = src;\n      dragImgCache.set(src, img);\n    }\n    return img.complete && img.naturalWidth > 0 ? img : null;\n  }\n\n  function fillRoundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function buildDragPreview(index) {\n    const entry = results[index];\n    if (!entry) return null;\n\n    const count = selectedIndices.has(index) ? selectedIndices.size : 1;\n    const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\n\n    const w = 260;\n    const h = 28;\n    const stackGap = count > 1 ? 4 : 0;\n\n    const canvas = document.createElement('canvas');\n    canvas.width = w;\n    canvas.height = h + stackGap;\n    const ctx = canvas.getContext('2d');\n\n    if (count > 1) {\n      ctx.globalAlpha = 0.35;\n      ctx.fillStyle = isDark ? '#5a6070' : '#b0c4de';\n      fillRoundRect(ctx, 3, 0, w - 3, h, 5);\n      ctx.globalAlpha = 1.0;\n    }\n\n    const ry = stackGap;\n    ctx.fillStyle = isDark ? 'rgba(58, 64, 74, 0.94)' : 'rgba(214, 231, 255, 0.94)';\n    fillRoundRect(ctx, 0, ry, w, h, 5);\n\n    ctx.strokeStyle = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';\n    ctx.lineWidth = 0.5;\n    ctx.beginPath();\n    ctx.moveTo(5, ry);\n    ctx.arcTo(w, ry, w, ry + h, 5);\n    ctx.arcTo(w, ry + h, 0, ry + h, 5);\n    ctx.arcTo(0, ry + h, 0, ry, 5);\n    ctx.arcTo(0, ry, w, ry, 5);\n    ctx.closePath();\n    ctx.stroke();\n\n    const iconEl = getDragIconEl(entry);\n    if (iconEl) {\n      ctx.drawImage(iconEl, 6, ry + 6, 16, 16);\n    } else {\n      ctx.fillStyle = entry.isDir ? '#d9b34f' : '#8d98a5';\n      fillRoundRect(ctx, 6, ry + 6, 16, 16, 2);\n    }\n\n    ctx.fillStyle = isDark ? '#e6e6e8' : '#1a1a1a';\n    ctx.font = '12px -apple-system, \"SF Pro Text\", system-ui, sans-serif';\n    ctx.textBaseline = 'middle';\n\n    let nameMaxW = w - 34;\n    if (count > 1) nameMaxW -= 34;\n\n    let name = entry.name;\n    if (ctx.measureText(name).width > nameMaxW) {\n      while (name.length > 4 && ctx.measureText(name + '\\u2026').width > nameMaxW) {\n        name = name.slice(0, -1);\n      }\n      name += '\\u2026';\n    }\n    ctx.fillText(name, 28, ry + h / 2 + 1);\n\n    if (count > 1) {\n      const badge = String(count);\n      ctx.font = 'bold 10px -apple-system, system-ui, sans-serif';\n      const tw = ctx.measureText(badge).width;\n      const bw = Math.max(20, tw + 10);\n      const bx = w - bw - 6;\n      const by = ry + (h - 18) / 2;\n\n      ctx.fillStyle = isDark ? '#5b8bd9' : '#007aff';\n      fillRoundRect(ctx, bx, by, bw, 18, 9);\n\n      ctx.fillStyle = '#ffffff';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(badge, bx + bw / 2, by + 9);\n    }\n\n    return canvas.toDataURL('image/png');\n  }\n\n  function handleRowMouseDown(event, index) {\n    if (event.button !== 0) return;\n    if (event.metaKey || event.ctrlKey || event.shiftKey) return;\n    if (editing.active) return;\n\n    const startX = event.clientX;\n    const startY = event.clientY;\n    let dragging = false;\n\n    dragCleanup?.();\n\n    const onMove = (e) => {\n      if (dragging) return;\n      const dx = e.clientX - startX;\n      const dy = e.clientY - startY;\n      if (dx * dx + dy * dy < DRAG_THRESHOLD * DRAG_THRESHOLD) return;\n\n      dragging = true;\n      cleanup();\n\n      if (!selectedIndices.has(index)) {\n        selectSingle(index);\n      }\n\n      const paths = dragPathsForIndex(index);\n      if (paths.length > 0) {\n        const icon = buildDragPreview(index);\n        startDrag({ item: paths, icon }).catch(() => {});\n      }\n    };\n\n    const onUp = () => cleanup();\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      if (dragCleanup === cleanup) dragCleanup = null;\n    };\n\n    dragCleanup = cleanup;\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  async function handleRowDoubleClick(index) {\n    if (!selectedIndices.has(index) || selectedIndices.size > 1) {\n      selectSingle(index);\n      await tick();\n    }\n    await invoke('open', { paths: [results[index].path] }).catch((err) => {\n      showToast(`Failed to open: ${String(err)}`);\n    });\n  }\n\n  function closeContextMenu() {\n    contextMenu = {\n      ...contextMenu,\n      visible: false\n    };\n  }\n\n  async function openSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('open', { paths });\n    } catch (err) {\n      showToast(`Failed to open: ${String(err)}`);\n    }\n  }\n\n  async function openWithFallback() {\n    const target = primaryEntry();\n    if (!target) {\n      return;\n    }\n\n    try {\n      await invoke('open_with', { path: target.path });\n    } catch (err) {\n      showToast(`Open With failed: ${String(err)}`);\n    }\n  }\n\n  async function revealSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('reveal_in_finder', { paths });\n    } catch (err) {\n      showToast(`Failed to reveal in Finder: ${String(err)}`);\n    }\n  }\n\n  async function copySelectedPaths() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_paths', { paths });\n      showToast(`Copied ${paths.length} path(s)`);\n    } catch (err) {\n      showToast(`Failed to copy path: ${String(err)}`);\n    }\n  }\n\n  async function copyFiles() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_files', { paths });\n      showToast(`Copied ${paths.length} item(s)`);\n    } catch (err) {\n      showToast(`Failed to copy: ${String(err)}`);\n    }\n  }\n\n  async function trashSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    const message =\n      paths.length === 1\n        ? 'Move selected item to Trash?'\n        : `Move ${paths.length} items to Trash?`;\n\n    if (!window.confirm(message)) {\n      return;\n    }\n\n    try {\n      await invoke('move_to_trash', { paths });\n      showToast('Moved to Trash.');\n      clearSelection();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to move to Trash: ${String(err)}`);\n    }\n  }\n\n  async function resetIndex() {\n    if (indexStatus.state === 'Indexing') {\n      showToast('Indexing in progress. Please try again after it completes.');\n      return;\n    }\n\n    results = [];\n    totalResults = 0;\n    totalResultsKnown = false;\n    clearSelection();\n    scanned = 0;\n    dbLatencyMs = null;\n    dbLastQuery = '';\n    indexStatus = { ...indexStatus, state: 'Indexing', entriesCount: 0, message: null };\n    indexingStartTime = Date.now();\n    indexingElapsed = '';\n    indexingFinishedAt = '';\n\n    try {\n      await invoke('reset_index');\n    } catch (err) {\n      showToast(`Failed to reset index: ${String(err)}`);\n      await refreshStatus();\n    }\n  }\n\n  function isMultiSelected() {\n    return selectedIndices.size > 1;\n  }\n\n  async function startRename() {\n    if (isMultiSelected()) {\n      return;\n    }\n\n    const idx = lastSelectedIndex;\n    if (idx < 0 || !results[idx]) {\n      return;\n    }\n\n    const entry = results[idx];\n    editing = {\n      active: true,\n      path: entry.path,\n      index: idx,\n      draftName: entry.name\n    };\n\n    await tick();\n\n    if (renameInputEl) {\n      renameInputEl.focus();\n      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n      renameInputEl.setSelectionRange(0, selectionEnd);\n    }\n  }\n\n  function cancelRename() {\n    editing = {\n      active: false,\n      path: '',\n      index: -1,\n      draftName: ''\n    };\n  }\n\n  async function commitRename() {\n    if (!editing.active || editing.index < 0 || !results[editing.index]) {\n      return;\n    }\n\n    const current = results[editing.index];\n    const nextName = editing.draftName;\n\n    try {\n      await invoke('rename', {\n        path: current.path,\n        newName: nextName\n      });\n      cancelRename();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to rename: ${String(err)}`);\n      await tick();\n      renameInputEl?.focus();\n    }\n  }\n\n  function onGlobalClick() {\n    closeContextMenu();\n  }\n\n  function onTitleBarMouseDown(event) {\n    if (event.button !== 0) {\n      return;\n    }\n\n    const activeElement = document.activeElement;\n    if (activeElement instanceof HTMLElement && isTextInputTarget(activeElement)) {\n      activeElement.blur();\n    }\n  }\n\n  async function focusSearch() {\n    await getCurrentWindow().show();\n    await getCurrentWindow().setFocus();\n    searchInputEl?.focus();\n    searchInputEl?.select();\n  }\n\n  function isTextInputTarget(target) {\n    return (\n      target instanceof HTMLInputElement ||\n      target instanceof HTMLTextAreaElement ||\n      target?.isContentEditable\n    );\n  }\n\n  async function handleKeydown(event) {\n    const isMetaSelectAll = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'a';\n    const isMetaCopy = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c';\n    const target = event.target;\n    const isTextInput = isTextInputTarget(target);\n\n    if (isMetaCopy && isTextInput) {\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      if (isTextInput) {\n        event.preventDefault();\n        if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n          target.select();\n        }\n        return;\n      }\n    }\n\n    if (editing.active) {\n      if (event.key === 'Enter') {\n        event.preventDefault();\n        await commitRename();\n        return;\n      }\n\n      if (event.key === 'Escape') {\n        event.preventDefault();\n        cancelRename();\n        searchInputEl?.focus();\n        return;\n      }\n      return;\n    }\n\n    if (event.key === 'Escape') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      return;\n    }\n\n    if (event.key === 'ArrowDown') {\n      event.preventDefault();\n      moveSelection(1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'ArrowUp') {\n      event.preventDefault();\n      moveSelection(-1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageDown') {\n      event.preventDefault();\n      moveSelection(Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageUp') {\n      event.preventDefault();\n      moveSelection(-Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'Enter') {\n      event.preventDefault();\n      if (platform === 'windows') {\n        await openSelected();\n      } else {\n        await startRename();\n      }\n      return;\n    }\n\n    if (event.key === 'F2') {\n      event.preventDefault();\n      await startRename();\n      return;\n    }\n\n    if (event.key === ' ' && !isTextInput) {\n      event.preventDefault();\n      const entry = primaryEntry();\n      if (entry) {\n        await invoke('quick_look', { path: entry.path });\n      }\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'f') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      searchInputEl?.select();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'o') {\n      event.preventDefault();\n      await openSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {\n      event.preventDefault();\n      await revealSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c') {\n      event.preventDefault();\n      await copySelectedPaths();\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      event.preventDefault();\n      selectedIndices = new Set(Array.from({ length: results.length }, (_, i) => i));\n      return;\n    }\n\n    if (event.key === 'Delete' || ((event.metaKey || event.ctrlKey) && event.key === 'Backspace')) {\n      if (!isTextInput) {\n        event.preventDefault();\n        await trashSelected();\n      }\n      return;\n    }\n  }\n\n  function formatSize(entry) {\n    if (entry.isDir || entry.size == null) return '';\n    const bytes = entry.size;\n    if (bytes < 1024) return `${bytes} B`;\n    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n    return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n  }\n\n  function formatModified(entry) {\n    if (!entry.mtime) {\n      return '';\n    }\n\n    const d = new Date(entry.mtime * 1000);\n    const pad = (n) => String(n).padStart(2, '0');\n    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;\n  }\n\n  function formatLastUpdated(timestamp) {\n    if (!timestamp) {\n      return '-';\n    }\n\n    return new Date(timestamp * 1000).toLocaleString();\n  }\n\n  function formatElapsed(ms) {\n    const totalSec = Math.floor(ms / 1000);\n    const min = Math.floor(totalSec / 60);\n    const sec = totalSec % 60;\n    return min > 0 ? `${min}m ${sec}s` : `${sec}s`;\n  }\n\n  function updateElapsed() {\n    if (indexingStartTime && indexStatus.state === 'Indexing') {\n      indexingElapsed = formatElapsed(Date.now() - indexingStartTime);\n    }\n  }\n\n  function startElapsedTimer() {\n    clearInterval(elapsedTimer);\n    indexingStartTime = Date.now();\n    indexingElapsed = '0s';\n    indexingFinishedAt = '';\n    elapsedTimer = setInterval(updateElapsed, 1000);\n  }\n\n  function stopElapsedTimer() {\n    clearInterval(elapsedTimer);\n    if (indexingStartTime) {\n      const elapsed = Date.now() - indexingStartTime;\n      indexingFinishedAt = `${formatElapsed(elapsed)}`;\n    }\n    indexingStartTime = null;\n    indexingElapsed = '';\n  }\n\n  function displayPath(path) {\n    if (!path) {\n      return path;\n    }\n\n    if (!homePrefix) {\n      return path;\n    }\n\n    if (path === homePrefix) {\n      return '~';\n    }\n\n    if (path.startsWith(`${homePrefix}/`)) {\n      return `~${path.slice(homePrefix.length)}`;\n    }\n\n    return path;\n  }\n\n  let unlistenFns = [];\n\n  onMount(async () => {\n    const t0 = performance.now();\n    const ms = () => Math.round(performance.now() - t0);\n    const DEBUG_STARTUP = false;\n    const flog = DEBUG_STARTUP ? (msg) => invoke('frontend_log', { msg }).catch(() => {}) : () => {};\n\n    flog(`[startup/fe] onMount entered`);\n\n    updateViewportHeight();\n    flog(`[startup/fe] +${ms()}ms updateViewportHeight done`);\n\n    platform = await invoke('get_platform');\n    flog(`[startup/fe] +${ms()}ms get_platform done`);\n\n    const unlistenProgress = await listen('index_progress', (event) => {\n      scanned = event.payload.scanned;\n      if (indexStatus.state !== 'Indexing') {\n        indexStatus = {\n          ...indexStatus,\n          state: 'Indexing'\n        };\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_progress) registered`);\n\n    const unlistenState = await listen('index_state', (event) => {\n      flog(`[startup/fe] index_state event received: ${event.payload.state} at +${ms()}ms`);\n      const prevState = indexStatus.state;\n      indexStatus = {\n        ...indexStatus,\n        state: event.payload.state,\n        message: event.payload.message ?? null,\n        isCatchup: event.payload.isCatchup ?? false\n      };\n\n      if (event.payload.state === 'Indexing' && prevState !== 'Indexing') {\n        if (prevState === 'Ready') {\n          lastReadyCount = indexStatus.entriesCount;\n        }\n        startElapsedTimer();\n      } else if (event.payload.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n\n      if (event.payload.state === 'Ready') {\n        scheduleSearch();\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_state) registered`);\n\n    const unlistenUpdated = await listen('index_updated', (event) => {\n      indexStatus = {\n        ...indexStatus,\n        entriesCount: event.payload.entriesCount,\n        lastUpdated: event.payload.lastUpdated,\n        permissionErrors: event.payload.permissionErrors ?? indexStatus.permissionErrors\n      };\n\n      scheduleSearch(true);\n    });\n\n    const unlistenFocus = await listen('focus_search', () => {\n      void focusSearch();\n    });\n\n    const unlistenCtxMenuAction = await listen('context_menu_action', (event) => {\n      switch (event.payload) {\n        case 'open': void openSelected(); break;\n        case 'quick_look': {\n          const e = primaryEntry();\n          if (e) void invoke('quick_look', { path: e.path });\n          break;\n        }\n        case 'open_with': void openWithFallback(); break;\n        case 'reveal': void revealSelected(); break;\n        case 'copy_files': void copyFiles(); break;\n        case 'copy_path': void copySelectedPaths(); break;\n        case 'trash': void trashSelected(); break;\n        case 'rename': void startRename(); break;\n      }\n    });\n\n    unlistenFns = [unlistenProgress, unlistenState, unlistenUpdated, unlistenFocus, unlistenCtxMenuAction];\n    flog(`[startup/fe] +${ms()}ms all listeners registered`);\n\n    // Fetch backend state IMMEDIATELY after listeners are registered.\n    // Events emitted before listener registration are lost, so this\n    // is the only reliable way to get the current state.\n    await refreshStatus();\n    flog(`[startup/fe] +${ms()}ms refreshStatus done (state=${indexStatus.state})`);\n\n    // Show Svelte UI: remove skeleton, focus search input.\n    await tick();\n    document.getElementById('skeleton')?.remove();\n    await focusSearch();\n    flog(`[startup/fe] +${ms()}ms WINDOW VISIBLE — skeleton removed`);\n\n    try {\n      homePrefix = await invoke('get_home_dir');\n    } catch {\n      homePrefix = '';\n    }\n    flog(`[startup/fe] +${ms()}ms get_home_dir done`);\n\n    if (!localStorage.getItem('everything-fda-notice-v1')) {\n      showToast('macOS Full Disk Access permission may be required for full disk search.');\n      localStorage.setItem('everything-fda-notice-v1', '1');\n    }\n    flog(`[startup/fe] +${ms()}ms calling runSearch...`);\n    await runSearch();\n    flog(`[startup/fe] +${ms()}ms runSearch done`);\n\n    if (typeof ResizeObserver !== 'undefined') {\n      tableResizeObserver = new ResizeObserver(() => {\n        scheduleViewportHeightUpdate();\n      });\n      if (tableContainer) {\n        tableResizeObserver.observe(tableContainer);\n      } else if (tableAreaEl) {\n        tableResizeObserver.observe(tableAreaEl);\n      }\n    }\n\n    window.addEventListener('resize', scheduleViewportHeightUpdate);\n    window.addEventListener('click', onGlobalClick);\n    statusRefreshTimer = setInterval(() => {\n      if (indexStatus.state === 'Indexing') {\n        void refreshStatus();\n      }\n    }, 1000);\n    console.log(`[startup/fe] +${ms()}ms onMount complete`);\n  });\n\n  onDestroy(async () => {\n    clearTimeout(searchTimer);\n    clearTimeout(toastTimer);\n    clearInterval(statusRefreshTimer);\n    clearInterval(elapsedTimer);\n    resizeCleanup?.();\n\n    for (const unlisten of unlistenFns) {\n      unlisten();\n    }\n\n    tableResizeObserver?.disconnect();\n    tableResizeObserver = null;\n    if (viewportResizeRaf !== null) {\n      cancelAnimationFrame(viewportResizeRaf);\n      viewportResizeRaf = null;\n    }\n    window.removeEventListener('resize', scheduleViewportHeightUpdate);\n    window.removeEventListener('click', onGlobalClick);\n  });\n</script>\n\n<svelte:window on:keydown={handleKeydown} />\n\n<div class=\"app-shell\" data-theme={theme}>\n  <div class=\"title-bar\" role=\"presentation\" data-tauri-drag-region on:mousedown={onTitleBarMouseDown}>\n    <div class=\"title-left\"></div>\n    <div class=\"title-center\">\n      <svg class=\"title-icon\" viewBox=\"0 0 215 205\" fill-rule=\"evenodd\" aria-hidden=\"true\">\n        <path d=\"M85 0c46.9 0 85 38.1 85 85 0 20.1-7.2 38.5-19.2 52.7l40.7 40.8c5.8 5.8 5.8 15.2 0 21-5.8 5.8-15.2 5.8-21 0l-40.7-40.7c-13.6 9.7-30.4 15.2-44.8 15.2-46.9 0-85-42.1-85-89 0-46.9 38.1-85 85-85z m0 32c-29.3 0-53 23.7-53 53 0 29.3 23.7 53 53 53 29.3 0 53-23.7 53-53 0-29.3-23.7-53-53-53z\"/>\n      </svg>\n      <span class=\"title-text\">Everything</span>\n    </div>\n    <div class=\"title-right\"></div>\n  </div>\n\n  <header class=\"search-bar\">\n    <input\n      bind:this={searchInputEl}\n      class=\"search-input\"\n      type=\"text\"\n      bind:value={query}\n      on:input={scheduleSearch}\n      on:focus={clearSelection}\n      placeholder=\"Search file/folder names\"\n      autocomplete=\"off\"\n      spellcheck=\"false\"\n    />\n  </header>\n\n  <section class=\"table-area\" bind:this={tableAreaEl} style={tableGridStyle}>\n    <div class=\"table-header\">\n      <div class=\"table-header-track\">\n        <div class=\"col name\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('name')}>\n            Name{#if sortBy === 'name'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'name'}\n            on:mousedown={(event) => startColumnResize(event, 'name')}\n            aria-label=\"Resize Name column\"\n          />\n        </div>\n\n        <div class=\"col path\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('dir')}>\n            Path{#if sortBy === 'dir'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'path'}\n            on:mousedown={(event) => startColumnResize(event, 'path')}\n            aria-label=\"Resize Path column\"\n          />\n        </div>\n\n        <div class=\"col size\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('size')}>\n            Size{#if sortBy === 'size'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n\n        <div class=\"col modified\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('mtime')}>\n            Modified{#if sortBy === 'mtime'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n      </div>\n    </div>\n\n    <div\n      class=\"table-body\"\n      bind:this={tableContainer}\n      on:scroll={() => {\n        scrollTop = tableContainer.scrollTop;\n        headerScrollLeft = tableContainer.scrollLeft;\n        const scrollBottom = scrollTop + tableContainer.clientHeight;\n        if (scrollBottom >= totalHeight - rowHeight * 10) {\n          void loadMore();\n        }\n      }}\n    >\n      <div class=\"spacer\" style={`height:${totalHeight}px`}>\n        <div class=\"rows\" style={`transform: translateY(${translateY}px);`}>\n          {#each visibleRows as entry, localIndex}\n            {@const index = startIndex + localIndex}\n            <div\n              class=\"row {selectedIndices.has(index) ? 'selected' : ''} {editing.active && editing.index === index ? 'renaming' : ''}\"\n              on:mousedown={(event) => handleRowMouseDown(event, index)}\n              on:click={(event) => handleRowClick(event, index)}\n              on:keydown={(event) => handleRowA11yKeydown(event, index)}\n              on:dblclick={() => handleRowDoubleClick(index)}\n              on:contextmenu={(event) => handleRowContextMenu(event, index)}\n              role=\"row\"\n              tabindex=\"0\"\n            >\n              <div class=\"cell name\">\n                <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n\n                {#if editing.active && editing.index === index}\n                  <input\n                    bind:this={renameInputEl}\n                    class=\"rename-input\"\n                    type=\"text\"\n                    bind:value={editing.draftName}\n                    on:click|stopPropagation\n                    on:blur={commitRename}\n                  />\n                {:else}\n                  <span class=\"ellipsis\">{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n                {/if}\n              </div>\n              <div class=\"cell path\"><span class=\"ellipsis\">{displayPath(entry.dir)}</span></div>\n              <div class=\"cell size\">{formatSize(entry)}</div>\n              <div class=\"cell modified\">{formatModified(entry)}</div>\n            </div>\n          {/each}\n        </div>\n      </div>\n    </div>\n  </section>\n\n  <footer class=\"status-bar\">\n    <div class=\"status-left\">\n      <span class=\"status-state\">\n        <span class=\"state-dot {indexStatus.state === 'Indexing' ? 'indexing' : indexStatus.state === 'Error' ? 'error' : 'ready'}\"></span>\n        {#if indexStatus.state === 'Indexing'}\n          Indexing{#if lastReadyCount > 0} ({Math.min(99, Math.round((scanned / lastReadyCount) * 100))}%){/if}{#if indexingElapsed} · {indexingElapsed}{/if}\n          {#if !indexStatus.isCatchup}\n            · {scanned.toLocaleString()} scanned\n          {/if}\n        {:else}\n          Index: {indexStatus.state}\n        {/if}\n      </span>\n      <span>{indexStatus.entriesCount.toLocaleString()} entries</span>\n      {#if indexingFinishedAt && indexStatus.state !== 'Indexing'}\n        <span>in {indexingFinishedAt}</span>\n      {/if}\n      {#if dbLatencyMs !== null && dbLastQuery}\n        <span>\"{dbLastQuery}\" {dbLatencyMs}ms · {totalResults} results</span>\n      {/if}\n      {#if searchModeLabel === 'spotlight' || searchModeLabel === 'spotlight_timeout'}\n        <span class=\"status-spotlight\">Spotlight fallback{#if searchModeLabel === 'spotlight_timeout'} (partial){/if}</span>\n      {/if}\n      {#if indexStatus.permissionErrors > 0}\n        <span class=\"status-warning\">{indexStatus.permissionErrors.toLocaleString()} permission errors</span>\n      {/if}\n      {#if indexStatus.message}\n        <span class={indexStatus.isCatchup ? 'index-progress' : 'status-error'}>{indexStatus.message}</span>\n      {/if}\n    </div>\n    <div class=\"status-right\">\n      <button class=\"status-btn theme-btn\" on:click={cycleTheme} title=\"Switch theme\">\n        {theme === 'dark' ? '☀ Light' : '◑ Dark'}\n      </button>\n      <button\n        class=\"status-btn rebuild-btn\"\n        on:click={resetIndex}\n        disabled={indexStatus.state === 'Indexing'}\n        title={indexStatus.state === 'Indexing' ? 'Cannot reset while indexing is in progress.' : 'Reset and rebuild the index.'}\n      >\n        <svg class=\"rebuild-icon\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n          <path d=\"M23 4v6h-6\"/><path d=\"M20.49 15a9 9 0 1 1-2.12-9.36L23 10\"/>\n        </svg>\n        Rebuild Index\n      </button>\n    </div>\n  </footer>\n\n  {#if contextMenu.visible}\n    <div class=\"context-menu\" style={`left:${contextMenu.x}px;top:${contextMenu.y}px;`}>\n      <button on:click={() => (closeContextMenu(), openSelected())}>Open</button>\n      <button on:click={async () => { closeContextMenu(); const e = primaryEntry(); if (e) await invoke('quick_look', { path: e.path }); }}>Quick Look</button>\n      <button on:click={() => (closeContextMenu(), openWithFallback())}>Open With... (Reveal in Finder)</button>\n      <button on:click={() => (closeContextMenu(), revealSelected())}>Reveal in Finder</button>\n      <button on:click={() => (closeContextMenu(), copySelectedPaths())}>Copy Path</button>\n      <button on:click={() => (closeContextMenu(), trashSelected())}>Move to Trash</button>\n      {#if selectedIndices.size === 1}\n        <button on:click={() => (closeContextMenu(), startRename())}>Rename</button>\n      {/if}\n    </div>\n  {/if}\n\n  {#if toast}\n    <div class=\"toast\">{toast}</div>\n  {/if}\n</div>\n\n<style>\n  :global(:root) {\n    color-scheme: light dark;\n    --bg-app: transparent;\n    --text-primary: #0d1826;\n    --text-muted: #48596c;\n    --bar-grad-top: rgba(255, 255, 255, 0.48);\n    --bar-grad-bottom: rgba(248, 250, 253, 0.42);\n    --surface-header: rgba(252, 252, 255, 0.40);\n    --surface: rgba(255, 255, 255, 0.22);\n    --border-soft: rgba(0, 0, 0, 0.07);\n    --border-input: rgba(0, 0, 0, 0.13);\n    --focus-ring: #6f96e6;\n    --row-border: rgba(0, 0, 0, 0.032);\n    --row-hover: rgba(0, 0, 0, 0.06);\n    --row-selected: rgba(0, 0, 0, 0.12);\n    --button-bg: rgba(255, 255, 255, 0.62);\n    --button-border: rgba(0, 0, 0, 0.10);\n    --button-text: #2c3e50;\n    --menu-bg: rgba(240, 241, 248, 0.90);\n    --menu-border: rgba(0, 0, 0, 0.06);\n    --menu-hover: rgba(255, 255, 255, 0.62);\n    --menu-text: #1a2a38;\n    --error-text: #b64545;\n    --warning-text: #8f6500;\n    --toast-bg: rgba(18, 22, 32, 0.90);\n    --toast-text: #ffffff;\n  }\n\n  @media (prefers-color-scheme: dark) {\n    :global(:root) {\n      --bg-app: transparent;\n      --text-primary: #e6e6ea;\n      --text-muted: #9494a4;\n      --bar-grad-top: rgba(38, 38, 46, 0.52);\n      --bar-grad-bottom: rgba(30, 30, 38, 0.46);\n      --surface-header: rgba(32, 32, 40, 0.46);\n      --surface: rgba(18, 18, 26, 0.32);\n      --border-soft: rgba(255, 255, 255, 0.065);\n      --border-input: rgba(255, 255, 255, 0.14);\n      --focus-ring: #5b8bd9;\n      --row-border: rgba(255, 255, 255, 0.026);\n      --row-hover: rgba(255, 255, 255, 0.08);\n      --row-selected: rgba(255, 255, 255, 0.14);\n      --button-bg: rgba(255, 255, 255, 0.072);\n      --button-border: rgba(255, 255, 255, 0.11);\n      --button-text: #d6d6e0;\n      --menu-bg: rgba(36, 36, 46, 0.90);\n      --menu-border: rgba(255, 255, 255, 0.066);\n      --menu-hover: rgba(255, 255, 255, 0.062);\n      --menu-text: #e0e0e8;\n      --error-text: #ff9d9d;\n      --warning-text: #e0c670;\n      --toast-bg: rgba(10, 10, 16, 0.93);\n      --toast-text: #f2f2f6;\n    }\n  }\n\n  /* ── Theme: Dark ──────────────────────────────────────────────── */\n  :global([data-theme=\"dark\"]) {\n    color-scheme: dark;\n    --bg-app: #1E1E21;\n    --text-primary: #E2E8F0;\n    --text-muted: #94A3B8;\n    --bar-grad-top: #1E1E21;\n    --bar-grad-bottom: #1E1E21;\n    --surface-header: #1E1E21;\n    --surface: #1E1E21;\n    --bg-input: #161618;\n    --border-soft: #2A2A2D;\n    --border-input: rgba(255, 255, 255, 0.06);\n    --focus-ring: #4DA8FF;\n    --accent: #4DA8FF;\n    --row-border: rgba(255, 255, 255, 0.02);\n    --row-hover: #282828;\n    --row-selected: rgba(77, 168, 255, 0.10);\n    --button-bg: rgba(255, 255, 255, 0.05);\n    --button-border: #2A2A2D;\n    --button-text: #94A3B8;\n    --menu-bg: #252528;\n    --menu-border: #2A2A2D;\n    --menu-hover: rgba(255, 255, 255, 0.04);\n    --menu-text: #E2E8F0;\n    --error-text: #ff9d9d;\n    --warning-text: #e0c670;\n    --toast-bg: rgba(10, 10, 16, 0.93);\n    --toast-text: #f2f2f6;\n  }\n\n  /* ── Theme: Light ─────────────────────────────────────────────── */\n  :global([data-theme=\"light\"]) {\n    color-scheme: light;\n    --bg-app: #F5F5F7;\n    --text-primary: #1C1C1E;\n    --text-muted: #6E6E7A;\n    --bar-grad-top: #F5F5F7;\n    --bar-grad-bottom: #F5F5F7;\n    --surface-header: #F5F5F7;\n    --surface: #F5F5F7;\n    --bg-input: #FFFFFF;\n    --border-soft: #D1D1D6;\n    --border-input: rgba(0, 0, 0, 0.10);\n    --focus-ring: #3A8BF5;\n    --accent: #3A8BF5;\n    --row-border: rgba(0, 0, 0, 0.04);\n    --row-hover: rgba(0, 0, 0, 0.04);\n    --row-selected: rgba(58, 139, 245, 0.10);\n    --button-bg: #FFFFFF;\n    --button-border: #D1D1D6;\n    --button-text: #3C3C43;\n    --menu-bg: #FFFFFF;\n    --menu-border: #D1D1D6;\n    --menu-hover: rgba(0, 0, 0, 0.05);\n    --menu-text: #1C1C1E;\n    --error-text: #D93025;\n    --warning-text: #B45309;\n    --toast-bg: rgba(255, 255, 255, 0.95);\n    --toast-text: #1C1C1E;\n  }\n\n  /* ── Themed element overrides ─────────────────────────────────── */\n  :global([data-theme]) {\n    background: var(--bg-app);\n  }\n\n  /* Search bar: flat, no gradient, no separator */\n  :global([data-theme]) .search-bar {\n    height: 44px;\n    padding: 0 16px;\n    background: var(--bg-app);\n    border-bottom: none;\n  }\n\n  :global([data-theme]) .search-input {\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n    font-family: 'JetBrains Mono', 'SF Mono', monospace;\n    font-size: 12px;\n    height: 34px;\n    border-radius: 8px;\n  }\n\n  /* Table header: flat bg, 16px edge padding */\n  :global([data-theme]) .table-header {\n    background: var(--bg-app);\n  }\n\n  :global([data-theme]) .col-button {\n    padding: 0 8px;\n  }\n\n  :global([data-theme]) .col.name .col-button {\n    padding-left: 16px;\n  }\n\n  /* Row cells: JetBrains Mono, 16px outer edges */\n  :global([data-theme]) .cell {\n    font-family: 'JetBrains Mono', monospace;\n  }\n\n  :global([data-theme]) .cell.name {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    padding-left: 16px;\n    font-size: 12px;\n    color: var(--text-primary);\n  }\n\n  :global([data-theme]) .cell.path {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.size {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.modified {\n    padding-right: 16px;\n    font-size: 11px;\n    white-space: nowrap;\n  }\n\n  :global([data-theme]) .row.selected {\n    box-shadow: inset 3px 0 0 var(--accent);\n  }\n\n  /* Dim path/size/date cells in themed mode */\n  :global([data-theme]) .cell.path,\n  :global([data-theme]) .cell.size,\n  :global([data-theme]) .cell.modified {\n    color: var(--text-muted);\n  }\n\n  :global(:root) {\n    background: transparent;\n  }\n\n  :global(html, body) {\n    margin: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    background: transparent;\n    color: var(--text-primary);\n    font-family: Inter, 'SF Pro Text', 'Segoe UI', Helvetica, Arial, sans-serif;\n  }\n\n  :global(#app) {\n    width: 100%;\n    height: 100%;\n  }\n\n  .app-shell {\n    display: grid;\n    grid-template-rows: auto auto 1fr auto;\n    height: 100%;\n    min-width: 0;\n  }\n\n  .title-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 44px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    cursor: default;\n    flex-shrink: 0;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-left {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-center {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-right {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-icon {\n    width: 14px;\n    height: 14px;\n    fill: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .title-text {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 13px;\n    font-weight: 500;\n    color: var(--text-primary);\n    letter-spacing: -0.01em;\n  }\n\n  .search-bar {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding: 8px;\n    background: linear-gradient(180deg, var(--bar-grad-top) 0%, var(--bar-grad-bottom) 100%);\n    border-bottom: 1px solid var(--border-soft);\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .search-input {\n    display: block;\n    box-sizing: border-box;\n    width: 100%;\n    min-width: 0;\n    flex: 1 1 auto;\n    height: 36px;\n    border: 1px solid var(--border-input);\n    border-radius: 14px;\n    padding: 0 10px;\n    font-size: 14px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    backdrop-filter: blur(12px) saturate(160%);\n    -webkit-backdrop-filter: blur(12px) saturate(160%);\n  }\n\n  .search-input::placeholder {\n    color: var(--text-muted);\n    opacity: 0.85;\n    font-size: 12px;\n  }\n\n  .search-input:focus {\n    outline: none;\n    border-color: var(--focus-ring);\n    box-shadow: 0 0 0 2px rgba(125, 169, 255, 0.25);\n  }\n\n  .table-area {\n    display: grid;\n    grid-template-rows: auto 1fr;\n    min-height: 0;\n    min-width: 0;\n  }\n\n  .table-header-track,\n  .row {\n    display: grid;\n    grid-template-columns: var(--col-name) var(--col-path) var(--col-size) var(--col-modified);\n    align-items: center;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .table-header {\n    height: 32px;\n    border-bottom: 1px solid var(--border-soft);\n    background: var(--surface-header);\n    user-select: none;\n    overflow: hidden;\n    flex-shrink: 0;\n  }\n\n  .table-header-track {\n    height: 100%;\n    transform: translateX(var(--header-offset, 0px));\n    will-change: transform;\n  }\n\n  .table-header .col {\n    position: relative;\n    min-width: 0;\n    height: 100%;\n  }\n\n  .col-button {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n    gap: 4px;\n    box-sizing: border-box;\n    padding: 0 8px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 11px;\n    font-weight: 600;\n    line-height: 1;\n    color: var(--text-muted);\n    text-align: left;\n    margin: 0;\n    border: none;\n    background: transparent;\n    cursor: pointer;\n  }\n\n  .sort-icon {\n    width: 10px;\n    height: 10px;\n    flex-shrink: 0;\n    color: var(--accent);\n  }\n\n  .col-resizer {\n    position: absolute;\n    top: 0;\n    right: -4px;\n    width: 8px;\n    height: 100%;\n    border: none;\n    padding: 0;\n    background: transparent;\n    cursor: col-resize;\n    z-index: 30;\n  }\n\n  .col-resizer::after {\n    content: '';\n    position: absolute;\n    top: 7px;\n    bottom: 7px;\n    left: 50%;\n    width: 1px;\n    transform: translateX(-50%);\n    background: var(--border-soft);\n    opacity: 0;\n    transition: opacity 0.15s ease;\n  }\n\n  .table-header .col:hover .col-resizer::after,\n  .col-resizer.active::after {\n    opacity: 1;\n  }\n\n  .table-body {\n    overflow: auto;\n    min-height: 0;\n    min-width: 0;\n    background: var(--surface);\n  }\n\n  .spacer {\n    position: relative;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .rows {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .row {\n    height: 30px;\n    border-bottom: 1px solid var(--row-border);\n    cursor: default;\n    -webkit-user-select: none;\n    user-select: none;\n    outline: none;\n  }\n\n  .row:hover {\n    background: var(--row-hover);\n  }\n\n  .row.selected {\n    background: var(--row-selected);\n  }\n\n  .cell {\n    padding: 0 8px;\n    font-size: 12px;\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    min-width: 0;\n  }\n\n  .cell.size {\n    text-align: right;\n    font-variant-numeric: tabular-nums;\n  }\n\n  .ellipsis {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n\n  .hl {\n    background: none;\n    color: inherit;\n    font-weight: 700;\n  }\n\n  .file-icon {\n    width: 16px;\n    height: 16px;\n    flex: 0 0 auto;\n  }\n\n  .row.renaming {\n    height: auto;\n    min-height: 30px;\n    align-items: start;\n  }\n\n  .row.renaming .cell.name {\n    align-items: start;\n  }\n\n  .rename-wrapper {\n    display: grid;\n    flex: 1;\n    min-width: 0;\n    margin-left: calc(-1.5px - 5px);\n  }\n\n  .rename-sizer {\n    grid-area: 1 / 1;\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 12px;\n    padding: 2px 5px;\n    border: 1.5px solid transparent;\n    visibility: hidden;\n    white-space: pre-wrap;\n    word-break: break-word;\n  }\n\n  .rename-input {\n    grid-area: 1 / 1;\n    width: 100%;\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 12px;\n    padding: 2px 5px;\n    border: 1.5px solid var(--focus-ring);\n    border-radius: 4px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    outline: none;\n    resize: none;\n    overflow: hidden;\n  }\n\n  .status-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 32px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    border-top: 1px solid var(--border-soft);\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 11px;\n    color: var(--text-muted);\n    white-space: nowrap;\n    overflow: hidden;\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .status-left {\n    display: flex;\n    align-items: center;\n    gap: 16px;\n    overflow: hidden;\n    min-width: 0;\n  }\n\n  .status-right {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    flex-shrink: 0;\n  }\n\n  .status-btn {\n    border: 1px solid var(--button-border);\n    border-radius: 5px;\n    background: var(--button-bg);\n    color: var(--button-text);\n    font-size: 11px;\n    height: 22px;\n    padding: 0 8px;\n    cursor: pointer;\n  }\n\n  .status-btn:hover {\n    filter: brightness(1.06);\n  }\n\n  .status-btn:disabled {\n    opacity: 0.55;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .status-state {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n  }\n\n  .state-dot {\n    width: 6px;\n    height: 6px;\n    border-radius: 50%;\n    flex-shrink: 0;\n  }\n\n  .state-dot.ready { background: #28C840; }\n  .state-dot.indexing { background: #FEBC2E; }\n  .state-dot.error { background: #FF5F57; }\n\n  .rebuild-btn {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 10px;\n    font-weight: 500;\n    background: var(--button-bg);\n    border: 1px solid var(--button-border);\n    border-radius: 4px;\n    color: var(--button-text);\n    height: 22px;\n    padding: 0 10px;\n    cursor: pointer;\n  }\n\n  .rebuild-btn:hover {\n    filter: brightness(1.1);\n  }\n\n  .rebuild-btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .rebuild-icon {\n    width: 11px;\n    height: 11px;\n    color: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .status-error {\n    color: var(--error-text);\n  }\n\n  .status-warning {\n    color: var(--warning-text);\n  }\n\n  .status-spotlight {\n    color: #f59e0b;\n    font-weight: 600;\n  }\n\n  .context-menu {\n    position: fixed;\n    z-index: 200;\n    width: 220px;\n    border: 1px solid var(--menu-border);\n    border-radius: 10px;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.16), inset 0 0 0 0.5px rgba(255, 255, 255, 0.18);\n    background: var(--menu-bg);\n    backdrop-filter: blur(28px) saturate(180%);\n    -webkit-backdrop-filter: blur(28px) saturate(180%);\n    overflow: hidden;\n  }\n\n  .context-menu button {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    padding: 8px 10px;\n    font-size: 12px;\n    color: var(--menu-text);\n  }\n\n  .context-menu button:hover {\n    background: var(--menu-hover);\n  }\n\n  .toast {\n    position: fixed;\n    right: 14px;\n    bottom: 18px;\n    background: var(--toast-bg);\n    color: var(--toast-text);\n    border-radius: 10px;\n    padding: 9px 12px;\n    font-size: 12px;\n    z-index: 250;\n    backdrop-filter: blur(20px) saturate(180%);\n    -webkit-backdrop-filter: blur(20px) saturate(180%);\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);\n  }\n</style>\n","structuredPatch":[{"oldStart":2049,"oldLines":47,"newStart":2049,"newLines":19,"lines":["     flex: 0 0 auto;","   }"," ","-  .row.renaming {","-    height: auto;","-    min-height: 30px;","-    align-items: start;","-  }","-","-  .row.renaming .cell.name {","-    align-items: start;","-  }","-","-  .rename-wrapper {","-    display: grid;","+  .rename-input {","     flex: 1;","     min-width: 0;","-    margin-left: calc(-1.5px - 5px);","-  }","-","-  .rename-sizer {","-    grid-area: 1 / 1;","-    font-family: 'JetBrains Mono', monospace;","+    height: 22px;","+    font-family: Inter, 'SF Pro Text', sans-serif;","     font-size: 12px;","-    padding: 2px 5px;","-    border: 1.5px solid transparent;","-    visibility: hidden;","-    white-space: pre-wrap;","-    word-break: break-word;","-  }","-","-  .rename-input {","-    grid-area: 1 / 1;","-    width: 100%;","-    font-family: 'JetBrains Mono', monospace;","-    font-size: 12px;","-    padding: 2px 5px;","+    padding: 0 6px;","     border: 1.5px solid var(--focus-ring);","     border-radius: 4px;","     background: var(--bg-input, var(--surface));","     color: var(--text-primary);","     outline: none;","-    resize: none;","-    overflow: hidden;","+    box-shadow: 0 1px 6px rgba(0, 0, 0, 0.18), 0 0 0 3px rgba(77, 168, 255, 0.12);","   }"," ","   .status-bar {"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"379d143e-9f22-434c-9af0-b682968cc083"}
{"parentUuid":"e25a9103-9cef-4bed-bf45-5b1f784f35fc","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","message":{"model":"claude-sonnet-4-6","id":"msg_015YyRHNu2d9mPHT4CRvh9o1","type":"message","role":"assistant","content":[{"type":"text","text":"변경 사항:\n\n1. **`<textarea>` → `<input type=\"text\">`** — 단일 라인 입력으로 교체, `rename-wrapper`/`rename-sizer` 제거\n2. **`.row.renaming { height: auto; ... }` 제거** — row 높이가 30px로 고정 유지\n3. **`.rename-input` 재설계** — `flex: 1`, `height: 22px`로 row 내 inline 배치, 약간의 `box-shadow`로 Finder 스타일 overlay 느낌 부여\n\n이제 rename 시 리스트 항목 높이가 변하지 않고, 파일명 위치에 고정 높이 input이 인라인으로 나타납니다."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":691,"cache_read_input_tokens":68241,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":691},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMMnHYeywRye4TCPN9qG","type":"assistant","uuid":"646709c8-45ce-4f46-8ee8-b4f42c863b4d","timestamp":"2026-02-21T14:18:40.927Z"}
{"parentUuid":"646709c8-45ce-4f46-8ee8-b4f42c863b4d","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"entire hooks claude-code stop"},"parentToolUseID":"86b22fb2-737c-4d6b-b4df-1f4262061fa0","toolUseID":"86b22fb2-737c-4d6b-b4df-1f4262061fa0","timestamp":"2026-02-21T14:18:41.005Z","uuid":"dd9758db-b603-40b6-9392-de6bb9c510f1"}
{"parentUuid":"dd9758db-b603-40b6-9392-de6bb9c510f1","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"system","subtype":"stop_hook_summary","hookCount":1,"hookInfos":[{"command":"entire hooks claude-code stop","durationMs":1797}],"hookErrors":[],"preventedContinuation":false,"stopReason":"","hasOutput":true,"level":"suggestion","timestamp":"2026-02-21T14:18:42.803Z","uuid":"97ce5b9e-7504-48de-af81-cbcdd898e793","toolUseID":"86b22fb2-737c-4d6b-b4df-1f4262061fa0"}
{"parentUuid":"97ce5b9e-7504-48de-af81-cbcdd898e793","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"system","subtype":"turn_duration","durationMs":81643,"timestamp":"2026-02-21T14:18:42.805Z","uuid":"0fcf8afb-3edc-4115-aad9-f8a56fe3b8e7","isMeta":false}
{"type":"file-history-snapshot","messageId":"5d9df080-6bfc-4085-9832-dc03d4036f0f","snapshot":{"messageId":"5d9df080-6bfc-4085-9832-dc03d4036f0f","trackedFileBackups":{"src/App.svelte":{"backupFileName":"f2ffc3f5647f6015@v2","version":2,"backupTime":"2026-02-21T14:19:32.276Z"}},"timestamp":"2026-02-21T14:19:32.276Z"},"isSnapshotUpdate":false}
{"parentUuid":"0fcf8afb-3edc-4115-aad9-f8a56fe3b8e7","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"user","message":{"role":"user","content":"따로 뜨는 입력창이 multi line으로 뜨고 list의 height에는 영향을 주지 않게 바꿔줘"},"uuid":"5d9df080-6bfc-4085-9832-dc03d4036f0f","timestamp":"2026-02-21T14:19:30.008Z","permissionMode":"bypassPermissions"}
{"parentUuid":"5d9df080-6bfc-4085-9832-dc03d4036f0f","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"user","message":{"role":"user","content":[{"type":"text","text":"[Request interrupted by user]"}]},"uuid":"4dbadf84-e5c4-477f-90da-907c63d79fe7","timestamp":"2026-02-21T14:19:43.510Z"}
{"type":"file-history-snapshot","messageId":"fbd21bd1-a554-4c84-baaa-666dbe4832ad","snapshot":{"messageId":"fbd21bd1-a554-4c84-baaa-666dbe4832ad","trackedFileBackups":{"src/App.svelte":{"backupFileName":"f2ffc3f5647f6015@v2","version":2,"backupTime":"2026-02-21T14:19:32.276Z"}},"timestamp":"2026-02-21T14:20:17.528Z"},"isSnapshotUpdate":false}
{"parentUuid":"4dbadf84-e5c4-477f-90da-907c63d79fe7","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"user","message":{"role":"user","content":"따로 뜨는 입력창이 multi line으로 뜨고 list의 height에는 영향을 주지 않게 바꿔줘. 그리고 다른 라인의 텍스트와 수정하려는 텍스트의 align이 맞게 해줘"},"uuid":"fbd21bd1-a554-4c84-baaa-666dbe4832ad","timestamp":"2026-02-21T14:20:15.356Z","permissionMode":"bypassPermissions"}
{"parentUuid":"fbd21bd1-a554-4c84-baaa-666dbe4832ad","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","message":{"model":"claude-sonnet-4-6","id":"msg_01Azd56Kepb7QvKYVngqcR5o","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user wants:\n1. A separate floating popup input that appears for renaming (not inline in the row)\n2. The list item height should NOT change\n3. The floating input should support multi-line text\n4. The text alignment in the floating input should match the text position in the row\n\nSo the approach is:\n- Keep the row at fixed 30px height, just show the filename text normally (but maybe hidden or dimmed while editing)\n- Show an absolutely positioned overlay/popup input that appears over the name cell\n- The popup should be positioned to align with the filename text in the row\n- It should be a textarea (multi-line capable)\n- It should NOT affect the row height at all\n\n\n- When rename starts, I'll grab the bounding rectangle of the name cell to get its exact position on screen\n- Then position a fixed or absolutely positioned textarea overlay at those coordinates so it aligns perfectly with where the text was\n- I need to account for the icon and padding within the cell to get the text's actual starting position\n- Using `getBoundingClientRect()` on the name cell would give me the exact overlay position, but in a virtual scroll context I'd need to calculate it based on row index, row height, and scroll offset instead\n- For the left position, I can either calculate the padding and icon spacing manually or just query the DOM when rename starts to get the actual cell position\n- I'm setting up state to track the overlay's visibility and position, then in the rename handler I'll find the name cell element and extract its bounding rect to position the overlay correctly\n- The key insight is to grab the row element before setting the editing state since it's already in the DOM, calculate where the text starts, then show the overlay at that exact position\n- For the template, I'll keep the filename text visible in the cell and layer the fixed overlay on top of it, with a textarea inside the overlay for editing\n\nUpdating the HTML structure...\n\nStill writing the rename function... I need to reconsider the alignment approach—the overlay textarea should have its text start at the same horizontal position as the filename in the list row, and since the textarea can expand vertically while the row stays fixed, I'll position it to float on top of the row.\n\nLooking at how macOS Finder handles this, the rename input appears directly over the filename and can expand downward without shifting the rows below. I'll use `position: fixed` to achieve this, calculating the row's position from the DOM when rename starts, then rendering the overlay textarea as a separate element outside the table so it can layer on top properly.\n\nSetting up the overlay positioning logic... Setting up the rename state with the entry details and draft name, then waiting for the DOM to update before focusing the input and selecting the filename without the extension so the user can type the new name right away.\n\nNow I'm moving the rename input out of the table row and into a fixed overlay positioned above the cell, with a textarea that binds to the draft name and handles the editing interactions.\n\nStill writing styles...\n\nNow I'm thinking through how to handle the multi-line textarea behavior—whether to use the newer `field-sizing: content` property for automatic resizing or fall back to a JavaScript approach that listens to input events and adjusts the height dynamically. keep it simple: use a textarea with auto-resize. The overlay itself won't affect the list.\n\nI'm setting up the auto-resize logic for the textarea and binding it to input events. The user wants a multi-line textarea that expands as needed.\n\nNow I'm thinking about positioning the overlay so the textarea aligns with the row's text vertically. I'll position the overlay at the row's top and use padding to match where the text sits in the original row, so the first line of the textarea lines up perfectly with the row text. I'm settling on a simpler approach: position the overlay at the row's top and give the textarea padding-top of 6px to vertically center its text with the row's content, then implement the changes to the rename function.\n\nExtracting the overlay position from the DOM...\n\nNow I'm setting up the editing state with the entry's path and name, then focusing the rename input and selecting the filename without the extension so the user can edit just the name part.\n\nI'm also noticing a potential issue with the virtual scrolling implementation—if the user scrolls while renaming, the fixed overlay will stay in place while the row moves underneath it, which could create a confusing UX.\n\nI think the cleanest approach is to cancel the rename operation whenever the user scrolls, so I'll add that to the scroll handler. I also need to make sure the overlay is positioned inside the app shell with fixed positioning so it layers correctly above everything else, and I should handle the input element reference properly when the rename is cancelled.\n\nNow I'm planning out the full implementation: I'll add state for tracking the overlay position, create a function to auto-resize the input based on text content, update the `startRename` function to calculate where the overlay should appear, then modify the template to remove the inline rename input from the row and replace it with a fixed overlay positioned above the table, and finally adjust the styles accordingly. Writing the template markup...\n\nThe user wants the textarea text to align horizontally with the filename text in other rows, so I need to calculate the exact left position based on the `.ellipsis` span's position and account for the textarea's padding to ensure the visible text lines up properly. the textarea starts at `overlay.left + 5 = textLeft`, which aligns with the row text. So I need to position the overlay at `textLeft - 6.5` to account for the border and padding, though I'll round that to `-6` for simplicity. Actually, let me step back—I'm overcomplicating the math here. I should just set the overlay directly at `textLeft` and remove the textarea's left padding entirely, but that might look off visually without any spacing from the border.\n\nAlternatively, I could accept a slight ~7px misalignment since it won't be very noticeable. Or I could use a negative margin to compensate, though that affects the width calculation. The cleaner approach is to define a constant for the offset and subtract it when positioning the overlay.\n\nCalculating overlay position with offset... Writing the rename overlay logic... Setting up the text selection for the rename input so it highlights the filename without the extension, then I need to add a cancel handler to the scroll event to close the rename overlay when the user scrolls, and update the template to always show the rename input overlay instead of conditionally rendering it. Still writing styles...\n\nNow I'm working through the vertical alignment—the row is 30px tall with text centered around 15px from the top, and I need to position the textarea to match that baseline while accounting for padding. I'm checking the vertical alignment—if the overlay top aligns with the row top, the text centers are about 1.5px off, which is acceptable. I'll set the textarea padding to 6px vertically and 4px horizontally, then trigger the auto-resize function after marking the input as active. For the initial height, a single line should be around 33px (lineHeight plus padding and border), which will extend slightly past the 30px row height and overlap the next row—that's the Finder-style behavior I'm going for.\n\nActually, I should start the textarea at the row height and let it grow from there. I'm writing a function that sets the height to auto first, then measures the scrollHeight and applies that as the new height, ensuring it never shrinks below the row height.\n\nStill writing resize logic... to '0' then scrollHeight gives the content height. This is cleaner.\n\nI have a solid plan now. The main changes are adding a `renameOverlay` state variable, an `autoResizeRenameInput` function to handle dynamic sizing, updating `startRename` to position the overlay correctly, canceling scroll during rename, restructuring the template to remove the inline rename input, and adding the overlay block in the app-shell along with the necessary CSS updates.\n\nNow I'm reviewing the current `startRename` function and the row template structure to understand exactly what needs to change. Writing the template markup...","signature":"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"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":93,"cache_read_input_tokens":69198,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":93},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMMuooGZZHFWhmSdfwyt","type":"assistant","uuid":"3660da4b-b193-4328-8268-390a3e0b3fb5","timestamp":"2026-02-21T14:22:29.851Z"}
{"parentUuid":"3660da4b-b193-4328-8268-390a3e0b3fb5","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","message":{"model":"claude-sonnet-4-6","id":"msg_01Azd56Kepb7QvKYVngqcR5o","type":"message","role":"assistant","content":[{"type":"text","text":"현재 코드를 보면 이전 편집으로 `<input type=\"text\">` inline 방식이 됐습니다. 이번엔 완전히 다른 방식으로 바꾸겠습니다 — row는 항상 고정 height, rename 시 `position: fixed` textarea overlay가 텍스트 위치에 맞게 띄워지는 구조입니다."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":93,"cache_read_input_tokens":69198,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":93},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMMuooGZZHFWhmSdfwyt","type":"assistant","uuid":"ccbea4e7-249d-4fc6-8a99-5785ad426c18","timestamp":"2026-02-21T14:22:31.912Z"}
{"parentUuid":"ccbea4e7-249d-4fc6-8a99-5785ad426c18","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","message":{"model":"claude-sonnet-4-6","id":"msg_01Azd56Kepb7QvKYVngqcR5o","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Xb6NonwCUsZLwNoKy3MBAS","name":"Read","input":{"file_path":"/Users/al02402336/everything/src/App.svelte","offset":933,"limit":30},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":93,"cache_read_input_tokens":69198,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":93},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMMuooGZZHFWhmSdfwyt","type":"assistant","uuid":"dd66b573-1ab3-4e40-bcb9-d2f324fd182f","timestamp":"2026-02-21T14:22:32.962Z"}
{"parentUuid":"dd66b573-1ab3-4e40-bcb9-d2f324fd182f","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01Xb6NonwCUsZLwNoKy3MBAS","toolUseID":"toolu_01Xb6NonwCUsZLwNoKy3MBAS","timestamp":"2026-02-21T14:22:32.973Z","uuid":"c45c2674-c160-4760-9059-85e7a76e754a"}
{"parentUuid":"dd66b573-1ab3-4e40-bcb9-d2f324fd182f","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Xb6NonwCUsZLwNoKy3MBAS","type":"tool_result","content":"   933→  async function startRename() {\n   934→    if (isMultiSelected()) {\n   935→      return;\n   936→    }\n   937→\n   938→    const idx = lastSelectedIndex;\n   939→    if (idx < 0 || !results[idx]) {\n   940→      return;\n   941→    }\n   942→\n   943→    const entry = results[idx];\n   944→    editing = {\n   945→      active: true,\n   946→      path: entry.path,\n   947→      index: idx,\n   948→      draftName: entry.name\n   949→    };\n   950→\n   951→    await tick();\n   952→\n   953→    if (renameInputEl) {\n   954→      renameInputEl.focus();\n   955→      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n   956→      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n   957→      renameInputEl.setSelectionRange(0, selectionEnd);\n   958→    }\n   959→  }\n   960→\n   961→  function cancelRename() {\n   962→    editing = {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"4ca8f6c1-823d-439d-9902-90bf8f7d7c1b","timestamp":"2026-02-21T14:22:32.972Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src/App.svelte","content":"  async function startRename() {\n    if (isMultiSelected()) {\n      return;\n    }\n\n    const idx = lastSelectedIndex;\n    if (idx < 0 || !results[idx]) {\n      return;\n    }\n\n    const entry = results[idx];\n    editing = {\n      active: true,\n      path: entry.path,\n      index: idx,\n      draftName: entry.name\n    };\n\n    await tick();\n\n    if (renameInputEl) {\n      renameInputEl.focus();\n      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n      renameInputEl.setSelectionRange(0, selectionEnd);\n    }\n  }\n\n  function cancelRename() {\n    editing = {","numLines":30,"startLine":933,"totalLines":2225}},"sourceToolAssistantUUID":"dd66b573-1ab3-4e40-bcb9-d2f324fd182f"}
{"parentUuid":"4ca8f6c1-823d-439d-9902-90bf8f7d7c1b","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","message":{"model":"claude-sonnet-4-6","id":"msg_01V6f3rWVgomGWomMz42j1QM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016hb12FChVXpuvY3tLmn1KQ","name":"Read","input":{"file_path":"/Users/al02402336/everything/src/App.svelte","offset":1461,"limit":55},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":9535,"cache_read_input_tokens":69291,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":9535},"output_tokens":18,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMN5ntE8adZbMxrvbNDb","type":"assistant","uuid":"3a14ab38-4522-4143-b642-ffc212e97a49","timestamp":"2026-02-21T14:22:35.761Z"}
{"parentUuid":"3a14ab38-4522-4143-b642-ffc212e97a49","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_016hb12FChVXpuvY3tLmn1KQ","toolUseID":"toolu_016hb12FChVXpuvY3tLmn1KQ","timestamp":"2026-02-21T14:22:35.777Z","uuid":"71e98510-b9e5-444e-8748-d95bb1af8e26"}
{"parentUuid":"3a14ab38-4522-4143-b642-ffc212e97a49","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016hb12FChVXpuvY3tLmn1KQ","type":"tool_result","content":"  1461→    <div\n  1462→      class=\"table-body\"\n  1463→      bind:this={tableContainer}\n  1464→      on:scroll={() => {\n  1465→        scrollTop = tableContainer.scrollTop;\n  1466→        headerScrollLeft = tableContainer.scrollLeft;\n  1467→        const scrollBottom = scrollTop + tableContainer.clientHeight;\n  1468→        if (scrollBottom >= totalHeight - rowHeight * 10) {\n  1469→          void loadMore();\n  1470→        }\n  1471→      }}\n  1472→    >\n  1473→      <div class=\"spacer\" style={`height:${totalHeight}px`}>\n  1474→        <div class=\"rows\" style={`transform: translateY(${translateY}px);`}>\n  1475→          {#each visibleRows as entry, localIndex}\n  1476→            {@const index = startIndex + localIndex}\n  1477→            <div\n  1478→              class=\"row {selectedIndices.has(index) ? 'selected' : ''} {editing.active && editing.index === index ? 'renaming' : ''}\"\n  1479→              on:mousedown={(event) => handleRowMouseDown(event, index)}\n  1480→              on:click={(event) => handleRowClick(event, index)}\n  1481→              on:keydown={(event) => handleRowA11yKeydown(event, index)}\n  1482→              on:dblclick={() => handleRowDoubleClick(index)}\n  1483→              on:contextmenu={(event) => handleRowContextMenu(event, index)}\n  1484→              role=\"row\"\n  1485→              tabindex=\"0\"\n  1486→            >\n  1487→              <div class=\"cell name\">\n  1488→                <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n  1489→\n  1490→                {#if editing.active && editing.index === index}\n  1491→                  <input\n  1492→                    bind:this={renameInputEl}\n  1493→                    class=\"rename-input\"\n  1494→                    type=\"text\"\n  1495→                    bind:value={editing.draftName}\n  1496→                    on:click|stopPropagation\n  1497→                    on:blur={commitRename}\n  1498→                  />\n  1499→                {:else}\n  1500→                  <span class=\"ellipsis\">{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n  1501→                {/if}\n  1502→              </div>\n  1503→              <div class=\"cell path\"><span class=\"ellipsis\">{displayPath(entry.dir)}</span></div>\n  1504→              <div class=\"cell size\">{formatSize(entry)}</div>\n  1505→              <div class=\"cell modified\">{formatModified(entry)}</div>\n  1506→            </div>\n  1507→          {/each}\n  1508→        </div>\n  1509→      </div>\n  1510→    </div>\n  1511→  </section>\n  1512→\n  1513→  <footer class=\"status-bar\">\n  1514→    <div class=\"status-left\">\n  1515→      <span class=\"status-state\">\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"b0aed1ec-583d-43e3-9c41-8afc6bbec494","timestamp":"2026-02-21T14:22:35.775Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/al02402336/everything/src/App.svelte","content":"    <div\n      class=\"table-body\"\n      bind:this={tableContainer}\n      on:scroll={() => {\n        scrollTop = tableContainer.scrollTop;\n        headerScrollLeft = tableContainer.scrollLeft;\n        const scrollBottom = scrollTop + tableContainer.clientHeight;\n        if (scrollBottom >= totalHeight - rowHeight * 10) {\n          void loadMore();\n        }\n      }}\n    >\n      <div class=\"spacer\" style={`height:${totalHeight}px`}>\n        <div class=\"rows\" style={`transform: translateY(${translateY}px);`}>\n          {#each visibleRows as entry, localIndex}\n            {@const index = startIndex + localIndex}\n            <div\n              class=\"row {selectedIndices.has(index) ? 'selected' : ''} {editing.active && editing.index === index ? 'renaming' : ''}\"\n              on:mousedown={(event) => handleRowMouseDown(event, index)}\n              on:click={(event) => handleRowClick(event, index)}\n              on:keydown={(event) => handleRowA11yKeydown(event, index)}\n              on:dblclick={() => handleRowDoubleClick(index)}\n              on:contextmenu={(event) => handleRowContextMenu(event, index)}\n              role=\"row\"\n              tabindex=\"0\"\n            >\n              <div class=\"cell name\">\n                <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n\n                {#if editing.active && editing.index === index}\n                  <input\n                    bind:this={renameInputEl}\n                    class=\"rename-input\"\n                    type=\"text\"\n                    bind:value={editing.draftName}\n                    on:click|stopPropagation\n                    on:blur={commitRename}\n                  />\n                {:else}\n                  <span class=\"ellipsis\">{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n                {/if}\n              </div>\n              <div class=\"cell path\"><span class=\"ellipsis\">{displayPath(entry.dir)}</span></div>\n              <div class=\"cell size\">{formatSize(entry)}</div>\n              <div class=\"cell modified\">{formatModified(entry)}</div>\n            </div>\n          {/each}\n        </div>\n      </div>\n    </div>\n  </section>\n\n  <footer class=\"status-bar\">\n    <div class=\"status-left\">\n      <span class=\"status-state\">","numLines":55,"startLine":1461,"totalLines":2225}},"sourceToolAssistantUUID":"3a14ab38-4522-4143-b642-ffc212e97a49"}
{"parentUuid":"b0aed1ec-583d-43e3-9c41-8afc6bbec494","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","message":{"model":"claude-sonnet-4-6","id":"msg_01GHQAesVLb34ovS7a1nn8ij","type":"message","role":"assistant","content":[{"type":"text","text":"이제 모든 변경을 한 번에 적용합니다."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1065,"cache_read_input_tokens":78826,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1065},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMN5ztYW5dvNcMnWaUVq","type":"assistant","uuid":"f7c378eb-298d-4f96-a8b3-e7715f39f4e9","timestamp":"2026-02-21T14:22:37.872Z"}
{"parentUuid":"f7c378eb-298d-4f96-a8b3-e7715f39f4e9","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","message":{"model":"claude-sonnet-4-6","id":"msg_01GHQAesVLb34ovS7a1nn8ij","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VR1vqWawjJtNHSmxSxFHXw","name":"Edit","input":{"replace_all":false,"file_path":"/Users/al02402336/everything/src/App.svelte","old_string":"  let editing = {\n    active: false,\n    path: '',\n    index: -1,\n    draftName: ''\n  };","new_string":"  let editing = {\n    active: false,\n    path: '',\n    index: -1,\n    draftName: ''\n  };\n\n  let renameOverlay = { top: 0, left: 0, width: 0 };"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1065,"cache_read_input_tokens":78826,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1065},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMN5ztYW5dvNcMnWaUVq","type":"assistant","uuid":"50c01ccc-975b-43c8-a652-ad185375aad3","timestamp":"2026-02-21T14:22:39.414Z"}
{"parentUuid":"50c01ccc-975b-43c8-a652-ad185375aad3","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01VR1vqWawjJtNHSmxSxFHXw","toolUseID":"toolu_01VR1vqWawjJtNHSmxSxFHXw","timestamp":"2026-02-21T14:22:39.423Z","uuid":"10d82b75-8ee8-4193-a16e-f1e3b674337c"}
{"parentUuid":"50c01ccc-975b-43c8-a652-ad185375aad3","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VR1vqWawjJtNHSmxSxFHXw","type":"tool_result","content":"The file /Users/al02402336/everything/src/App.svelte has been updated successfully."}]},"uuid":"8ebc4a73-ce6d-4b6e-a8e2-87cb917ee4b0","timestamp":"2026-02-21T14:22:39.422Z","toolUseResult":{"filePath":"/Users/al02402336/everything/src/App.svelte","oldString":"  let editing = {\n    active: false,\n    path: '',\n    index: -1,\n    draftName: ''\n  };","newString":"  let editing = {\n    active: false,\n    path: '',\n    index: -1,\n    draftName: ''\n  };\n\n  let renameOverlay = { top: 0, left: 0, width: 0 };","originalFile":"<script>\n  import { onDestroy, onMount, tick } from 'svelte';\n  import { invoke } from '@tauri-apps/api/core';\n  import { listen } from '@tauri-apps/api/event';\n  import { getCurrentWindow } from '@tauri-apps/api/window';\n  import { startDrag } from '@crabnebula/tauri-plugin-drag';\n\n  const rowHeight = 30;\n  const PAGE_SIZE = 500;\n  let homePrefix = '';\n  const COL_WIDTHS_KEY = 'REDACTED';\n  const THEME_KEY = 'everything-theme';\n  const columnKeys = ['name', 'path', 'size', 'modified'];\n  const minColumnWidth = {\n    name: 180,\n    path: 240,\n    size: 75,\n    modified: 150\n  };\n  const defaultColumnRatios = {\n    name: 0.3,\n    path: 0.45,\n    size: 0.1\n  };\n\n  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || 'dark'; } catch { return 'dark'; } })();\n  function cycleTheme() {\n    theme = theme === 'dark' ? 'light' : 'dark';\n    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n  }\n\n  let query = '';\n  let results = [];\n  let totalResults = 0;\n  let totalResultsKnown = false;\n\n  let dbLatencyMs = null;\n  let dbLastQuery = '';\n  let searchModeLabel = '';\n  let selectedIndices = new Set();\n  let selectionAnchor = -1;\n  let lastSelectedIndex = -1;\n  let editing = {\n    active: false,\n    path: '',\n    index: -1,\n    draftName: ''\n  };\n\n  let indexStatus = {\n    state: 'Indexing',\n    entriesCount: 0,\n    lastUpdated: null,\n    permissionErrors: 0,\n    message: null,\n    isCatchup: false\n  };\n\n  let indexingStartTime = null;\n  let indexingElapsed = '';\n  let indexingFinishedAt = '';\n\n  let sortBy = 'name';\n  let sortDir = 'asc';\n\n  let hasMore = true;\n  let loadingMore = false;\n  let searchGeneration = 0;\n\n  let scanned = 0;\n\n  let searchInputEl;\n  let renameInputEl;\n  let tableAreaEl;\n  let tableContainer;\n  let tableResizeObserver = null;\n  let viewportResizeRaf = null;\n  let scrollTop = 0;\n  let headerScrollLeft = 0;\n  let viewportHeight = 520;\n  let lastTableWidth = 0;\n  let resizingColumn = '';\n  let resizeCleanup = null;\n  let colWidths = {\n    name: 250,\n    path: 350,\n    size: 75,\n    modified: 150\n  };\n\n  let contextMenu = {\n    visible: false,\n    x: 0,\n    y: 0\n  };\n\n  let platform = '';\n  let toast = '';\n  let searchTimer;\n  let lastSearchFiredAt = 0;\n  let toastTimer;\n  let statusRefreshTimer;\n  let elapsedTimer;\n  let statusRefreshInFlight = false;\n  let lastReadyCount = 0;\n\n  const iconCache = new Map();\n  const iconLoading = new Set();\n\n  let highlightCache = new Map();\n  let highlightCacheQuery = '';\n\n  const folderFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='1' y='4' width='14' height='10' rx='2' fill='#d9b34f'/><rect x='1' y='2' width='6' height='4' rx='1' fill='#e6ca7a'/></svg>`\n    );\n  const fileFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='3' y='1' width='10' height='14' rx='1.5' fill='#b4bec9'/><rect x='5' y='5' width='6' height='1.2' fill='#8d98a5'/><rect x='5' y='8' width='6' height='1.2' fill='#8d98a5'/></svg>`\n    );\n\n  $: totalHeight = results.length * rowHeight;\n  $: startIndex = Math.max(0, Math.floor(scrollTop / rowHeight) - 10);\n  $: visibleCount = Math.ceil(viewportHeight / rowHeight) + 20;\n  $: endIndex = Math.min(results.length, startIndex + visibleCount);\n  $: visibleRows = results.slice(startIndex, endIndex);\n  $: translateY = startIndex * rowHeight;\n  $: tableMinWidth = colWidths.name + colWidths.path + colWidths.size + colWidths.modified;\n  $: tableGridStyle = `--col-name:${colWidths.name}px;--col-path:${colWidths.path}px;--col-size:${colWidths.size}px;--col-modified:${colWidths.modified}px;--table-min-width:${tableMinWidth}px;--header-offset:${-headerScrollLeft}px;`;\n\n  $: {\n    for (const entry of visibleRows) {\n      void ensureIcon(entry);\n    }\n  }\n\n  function showToast(message) {\n    toast = message;\n    clearTimeout(toastTimer);\n    toastTimer = setTimeout(() => {\n      toast = '';\n    }, 3000);\n  }\n\n  function bytesToBase64(bytes) {\n    let binary = '';\n    const chunk = 0x8000;\n    for (let i = 0; i < bytes.length; i += chunk) {\n      const part = bytes.subarray(i, i + chunk);\n      binary += String.fromCharCode(...part);\n    }\n    return btoa(binary);\n  }\n\n  function highlightSegments(name, q) {\n    q = (q || '').trim();\n    if (!q) return [{ text: name, hl: false }];\n\n    // Reset cache when query changes\n    if (q !== highlightCacheQuery) {\n      highlightCache = new Map();\n      highlightCacheQuery = q;\n    }\n\n    // Check cache\n    const cached = highlightCache.get(name);\n    if (cached) return cached;\n\n    if (q.includes('/')) q = q.slice(q.lastIndexOf('/') + 1);\n    q = q.replace(/[*?]/g, '');\n    const terms = q.split(/\\s+/).filter(Boolean);\n    if (terms.length === 0) return [{ text: name, hl: false }];\n\n    const lower = name.toLowerCase();\n    const marks = new Uint8Array(name.length);\n    for (const t of terms) {\n      const tl = t.toLowerCase();\n      let idx = lower.indexOf(tl);\n      while (idx !== -1) {\n        for (let i = idx; i < idx + tl.length; i++) marks[i] = 1;\n        idx = lower.indexOf(tl, idx + 1);\n      }\n    }\n\n    const segs = [];\n    let i = 0;\n    while (i < name.length) {\n      const m = marks[i];\n      let j = i + 1;\n      while (j < name.length && marks[j] === m) j++;\n      segs.push({ text: name.slice(i, j), hl: m === 1 });\n      i = j;\n    }\n\n    highlightCache.set(name, segs);\n    return segs;\n  }\n\n  const perFileIconExts = new Set(['exe', 'lnk', 'ico', 'url', 'scr', 'appx']);\n\n  function iconKey(entry) {\n    if (entry.isDir) return '__folder__';\n    const ext = (entry.ext || '').toLowerCase();\n    if (perFileIconExts.has(ext)) return entry.path;\n    return ext || '__file__';\n  }\n\n  function iconFor(entry) {\n    return iconCache.get(iconKey(entry)) || (entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n  }\n\n  async function ensureIcon(entry) {\n    const key = iconKey(entry);\n    if (iconCache.has(key) || iconLoading.has(key)) {\n      return;\n    }\n\n    iconLoading.add(key);\n    try {\n      const bytes = await invoke('get_file_icon', {\n        path: entry.path,\n        ext: entry.isDir ? 'folder' : entry.ext || '',\n      });\n      if (Array.isArray(bytes) && bytes.length > 0) {\n        const image = `data:image/png;base64,${bytesToBase64(Uint8Array.from(bytes))}`;\n        iconCache.set(key, image);\n      } else {\n        iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n      }\n    } catch {\n      iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n    } finally {\n      iconLoading.delete(key);\n    }\n  }\n\n  function syncColumnWidthsToContainer() {\n    const width = tableContainer?.clientWidth || tableAreaEl?.clientWidth;\n    if (!width || lastTableWidth !== 0) {\n      return;\n    }\n\n    const saved = loadColWidths();\n    if (saved) {\n      const total = columnKeys.reduce((s, k) => s + saved[k], 0);\n      if (Math.abs(total - width) > 2) {\n        const scale = (width - saved.modified) / (total - saved.modified);\n        let scaledName = Math.max(minColumnWidth.name, Math.round(saved.name * scale));\n        let scaledSize = Math.max(minColumnWidth.size, Math.round(saved.size * scale));\n        let rawPath = width - saved.modified - scaledName - scaledSize;\n        if (rawPath < minColumnWidth.path) {\n          const shortfall = minColumnWidth.path - rawPath;\n          const nameReduction = Math.min(shortfall, scaledName - minColumnWidth.name);\n          scaledName -= nameReduction;\n          const remaining = shortfall - nameReduction;\n          if (remaining > 0) {\n            scaledSize -= Math.min(remaining, scaledSize - minColumnWidth.size);\n          }\n          rawPath = width - saved.modified - scaledName - scaledSize;\n        }\n        const scaledPath = Math.max(minColumnWidth.path, rawPath);\n        colWidths = { name: scaledName, path: scaledPath, size: scaledSize, modified: saved.modified };\n      } else {\n        colWidths = saved;\n      }\n    } else {\n      const fixedModified = minColumnWidth.modified;\n      const rest = width - fixedModified;\n      const ratioSum = defaultColumnRatios.name + defaultColumnRatios.path + defaultColumnRatios.size;\n      colWidths = {\n        name: Math.max(minColumnWidth.name, Math.round(rest * defaultColumnRatios.name / ratioSum)),\n        path: Math.max(minColumnWidth.path, Math.round(rest * defaultColumnRatios.path / ratioSum)),\n        size: Math.max(minColumnWidth.size, Math.round(rest * defaultColumnRatios.size / ratioSum)),\n        modified: fixedModified\n      };\n    }\n    lastTableWidth = width;\n  }\n\n  function loadColWidths() {\n    try {\n      const raw = localStorage.getItem(COL_WIDTHS_KEY);\n      if (!raw) return null;\n      const parsed = JSON.parse(raw);\n      for (const key of columnKeys) {\n        if (typeof parsed[key] !== 'number' || parsed[key] < (minColumnWidth[key] || 0)) return null;\n      }\n      return parsed;\n    } catch {\n      return null;\n    }\n  }\n\n  function saveColWidths() {\n    localStorage.setItem(COL_WIDTHS_KEY, JSON.stringify(colWidths));\n  }\n\n  function updateViewportHeight() {\n    viewportHeight = tableContainer?.clientHeight || 520;\n    syncColumnWidthsToContainer();\n  }\n\n  function scheduleViewportHeightUpdate() {\n    if (viewportResizeRaf !== null) {\n      return;\n    }\n    viewportResizeRaf = requestAnimationFrame(() => {\n      viewportResizeRaf = null;\n      updateViewportHeight();\n    });\n  }\n\n  function startColumnResize(event, leftKey) {\n    event.preventDefault();\n    event.stopPropagation();\n\n    const index = columnKeys.indexOf(leftKey);\n    if (index < 0 || index >= columnKeys.length - 1) {\n      return;\n    }\n\n    const startX = event.clientX;\n    const startLeft = colWidths[leftKey];\n    const rightKey = columnKeys[index + 1];\n    const startRight = colWidths[rightKey];\n\n    resizeCleanup?.();\n    resizingColumn = leftKey;\n\n    const onMove = (moveEvent) => {\n      const delta = Math.round(moveEvent.clientX - startX);\n      if (leftKey === 'name') {\n        // Two-column trade: name and path swap space, each respects its minimum\n        const nextLeft = Math.max(\n          minColumnWidth[leftKey],\n          Math.min(startLeft + delta, startLeft + startRight - minColumnWidth[rightKey])\n        );\n        const nextRight = startLeft + startRight - nextLeft;\n        colWidths = { ...colWidths, [leftKey]: nextLeft, [rightKey]: nextRight };\n      } else {\n        // path splitter: path grows unconstrained (allows horizontal scroll on right drag)\n        const nextLeft = Math.max(minColumnWidth[leftKey], startLeft + delta);\n        colWidths = { ...colWidths, [leftKey]: nextLeft };\n      }\n    };\n\n    const onUp = () => {\n      cleanup();\n    };\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      document.body.style.cursor = '';\n      document.body.style.userSelect = '';\n      resizingColumn = '';\n      saveColWidths();\n      if (resizeCleanup === cleanup) {\n        resizeCleanup = null;\n      }\n    };\n\n    resizeCleanup = cleanup;\n    document.body.style.cursor = 'col-resize';\n    document.body.style.userSelect = 'none';\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  function selectedPaths() {\n    const sorted = [...selectedIndices].sort((a, b) => a - b);\n    return sorted.map((idx) => results[idx]).filter(Boolean).map((entry) => entry.path);\n  }\n\n  function clearSelection() {\n    selectedIndices = new Set();\n    selectionAnchor = -1;\n    lastSelectedIndex = -1;\n  }\n\n  function selectSingle(index) {\n    selectedIndices = new Set([index]);\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectToggle(index) {\n    const next = new Set(selectedIndices);\n    if (next.has(index)) {\n      next.delete(index);\n    } else {\n      next.add(index);\n    }\n    selectedIndices = next;\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectRange(index) {\n    const anchor = selectionAnchor >= 0 ? selectionAnchor : index;\n    const [from, to] = [Math.min(anchor, index), Math.max(anchor, index)];\n    const next = new Set();\n    for (let i = from; i <= to; i += 1) {\n      next.add(i);\n    }\n    selectedIndices = next;\n    lastSelectedIndex = index;\n  }\n\n  function primaryEntry() {\n    const idx = lastSelectedIndex >= 0 ? lastSelectedIndex : -1;\n    return idx >= 0 ? results[idx] : null;\n  }\n\n  async function refreshStatus() {\n    if (statusRefreshInFlight) {\n      return;\n    }\n    statusRefreshInFlight = true;\n    try {\n      const status = await invoke('get_index_status');\n      const prevState = indexStatus.state;\n      indexStatus = {\n        state: status.state,\n        entriesCount: status.entriesCount,\n        lastUpdated: status.lastUpdated,\n        permissionErrors: status.permissionErrors ?? 0,\n        message: status.message\n      };\n      if (status.state === 'Indexing' && prevState !== 'Indexing') {\n        startElapsedTimer();\n      } else if (status.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n      if (typeof status.scanned === 'number') {\n        scanned = status.scanned;\n      }\n      if (status.state === 'Ready' && prevState !== 'Ready') {\n        scheduleSearch();\n      }\n    } catch (err) {\n      showToast(`Failed to get status: ${String(err)}`);\n    } finally {\n      statusRefreshInFlight = false;\n    }\n  }\n\n  function scheduleSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const scheduledGen = searchGeneration;\n    clearTimeout(searchTimer);\n\n    const now = performance.now();\n    if (now - lastSearchFiredAt >= 200) {\n      // Leading edge: fire immediately if enough time has passed\n      lastSearchFiredAt = now;\n      void runSearch(preserveScroll);\n    } else {\n      // Trailing edge: debounce\n      searchTimer = setTimeout(() => {\n        if (scheduledGen !== searchGeneration) {\n          return;\n        }\n        lastSearchFiredAt = performance.now();\n        void runSearch(preserveScroll);\n      }, 200);\n    }\n  }\n\n  async function runSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const gen = searchGeneration;\n    const searchQuery = query;\n    const searchSortBy = sortBy;\n    const searchSortDir = sortDir;\n    const startedAt = performance.now();\n    try {\n      const keepPaths = new Set(selectedPaths());\n      const next = await invoke('search', {\n        query: searchQuery,\n        limit: PAGE_SIZE,\n        offset: 0,\n        sortBy: searchSortBy,\n        sortDir: searchSortDir\n      });\n\n      if (gen !== searchGeneration) return;\n\n      dbLatencyMs = Math.round(performance.now() - startedAt);\n      dbLastQuery = searchQuery;\n      const entries = Array.isArray(next.entries) ? next.entries : [];\n      searchModeLabel = next.modeLabel || '';\n      results = entries;\n      if (next.totalCount > 0) {\n        totalResults = next.totalCount;\n        totalResultsKnown = true;\n      } else {\n        totalResults = entries.length;\n        totalResultsKnown = false;\n      }\n      hasMore = totalResultsKnown ? results.length < totalResults : entries.length >= PAGE_SIZE;\n      if (!preserveScroll && tableContainer) tableContainer.scrollTop = 0;\n\n      const restored = new Set();\n      for (let i = 0; i < results.length; i += 1) {\n        if (keepPaths.has(results[i].path)) {\n          restored.add(i);\n        }\n      }\n      selectedIndices = restored;\n\n      updateViewportHeight();\n    } catch (err) {\n      if (gen !== searchGeneration) return;\n      showToast(`Search failed: ${String(err)}`);\n    }\n  }\n\n  async function loadMore() {\n    if (!hasMore || loadingMore) return;\n    const gen = searchGeneration;\n    loadingMore = true;\n    try {\n      const batch = await invoke('search', {\n        query,\n        limit: PAGE_SIZE,\n        offset: results.length,\n        sortBy: sortBy,\n        sortDir: sortDir\n      });\n      if (gen !== searchGeneration) return;\n      const arr = Array.isArray(batch.entries) ? batch.entries : [];\n      if (arr.length > 0) results = [...results, ...arr];\n      hasMore = totalResultsKnown ? results.length < totalResults : arr.length >= PAGE_SIZE;\n    } catch (err) {\n      showToast(`Failed to load more: ${String(err)}`);\n    } finally {\n      loadingMore = false;\n    }\n  }\n\n  function moveSelection(delta, withRange = false) {\n    if (results.length === 0) {\n      return;\n    }\n\n    const current = lastSelectedIndex >= 0 ? lastSelectedIndex : 0;\n    const next = Math.max(0, Math.min(results.length - 1, current + delta));\n\n    if (withRange) {\n      selectRange(next);\n    } else {\n      selectSingle(next);\n    }\n\n    const top = next * rowHeight;\n    const bottom = top + rowHeight;\n    if (top < scrollTop) {\n      tableContainer.scrollTop = top;\n    } else if (bottom > scrollTop + viewportHeight) {\n      tableContainer.scrollTop = bottom - viewportHeight;\n    }\n  }\n\n  function handleHeaderSort(column) {\n    if (sortBy === column) {\n      sortDir = sortDir === 'asc' ? 'desc' : 'asc';\n    } else {\n      sortBy = column;\n      sortDir = 'asc';\n    }\n    if (tableContainer) tableContainer.scrollTop = 0;\n    void runSearch();\n  }\n\n  function handleRowClick(event, index) {\n    contextMenu.visible = false;\n\n    if (event.shiftKey) {\n      selectRange(index);\n      return;\n    }\n\n    if (event.metaKey || event.ctrlKey) {\n      selectToggle(index);\n      return;\n    }\n\n    selectSingle(index);\n  }\n\n  function handleRowContextMenu(event, index) {\n    event.preventDefault();\n\n    if (!selectedIndices.has(index)) {\n      selectSingle(index);\n    }\n\n    if (platform === 'windows' || platform === 'macos') {\n      contextMenu.visible = false;\n      const paths = selectedPaths();\n      if (paths.length > 0) {\n        invoke('show_context_menu', {\n          paths,\n          x: event.clientX,\n          y: event.clientY,\n          singleSelection: selectedIndices.size === 1\n        });\n      }\n      return;\n    }\n\n    contextMenu = {\n      visible: true,\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n\n  function handleRowA11yKeydown(event, index) {\n    if (event.key === ' ' || event.key === 'Enter') {\n      event.preventDefault();\n      handleRowClick(event, index);\n    }\n  }\n\n  const DRAG_THRESHOLD = 5;\n  let dragCleanup = null;\n  const dragImgCache = new Map();\n\n  function dragPathsForIndex(index) {\n    const entry = results[index];\n    if (!entry) {\n      return [];\n    }\n\n    if (selectedIndices.has(index) && selectedIndices.size > 0) {\n      return selectedPaths();\n    }\n\n    return [entry.path];\n  }\n\n  function getDragIconEl(entry) {\n    const src = iconFor(entry);\n    let img = dragImgCache.get(src);\n    if (!img) {\n      img = new Image();\n      img.src = src;\n      dragImgCache.set(src, img);\n    }\n    return img.complete && img.naturalWidth > 0 ? img : null;\n  }\n\n  function fillRoundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function buildDragPreview(index) {\n    const entry = results[index];\n    if (!entry) return null;\n\n    const count = selectedIndices.has(index) ? selectedIndices.size : 1;\n    const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\n\n    const w = 260;\n    const h = 28;\n    const stackGap = count > 1 ? 4 : 0;\n\n    const canvas = document.createElement('canvas');\n    canvas.width = w;\n    canvas.height = h + stackGap;\n    const ctx = canvas.getContext('2d');\n\n    if (count > 1) {\n      ctx.globalAlpha = 0.35;\n      ctx.fillStyle = isDark ? '#5a6070' : '#b0c4de';\n      fillRoundRect(ctx, 3, 0, w - 3, h, 5);\n      ctx.globalAlpha = 1.0;\n    }\n\n    const ry = stackGap;\n    ctx.fillStyle = isDark ? 'rgba(58, 64, 74, 0.94)' : 'rgba(214, 231, 255, 0.94)';\n    fillRoundRect(ctx, 0, ry, w, h, 5);\n\n    ctx.strokeStyle = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';\n    ctx.lineWidth = 0.5;\n    ctx.beginPath();\n    ctx.moveTo(5, ry);\n    ctx.arcTo(w, ry, w, ry + h, 5);\n    ctx.arcTo(w, ry + h, 0, ry + h, 5);\n    ctx.arcTo(0, ry + h, 0, ry, 5);\n    ctx.arcTo(0, ry, w, ry, 5);\n    ctx.closePath();\n    ctx.stroke();\n\n    const iconEl = getDragIconEl(entry);\n    if (iconEl) {\n      ctx.drawImage(iconEl, 6, ry + 6, 16, 16);\n    } else {\n      ctx.fillStyle = entry.isDir ? '#d9b34f' : '#8d98a5';\n      fillRoundRect(ctx, 6, ry + 6, 16, 16, 2);\n    }\n\n    ctx.fillStyle = isDark ? '#e6e6e8' : '#1a1a1a';\n    ctx.font = '12px -apple-system, \"SF Pro Text\", system-ui, sans-serif';\n    ctx.textBaseline = 'middle';\n\n    let nameMaxW = w - 34;\n    if (count > 1) nameMaxW -= 34;\n\n    let name = entry.name;\n    if (ctx.measureText(name).width > nameMaxW) {\n      while (name.length > 4 && ctx.measureText(name + '\\u2026').width > nameMaxW) {\n        name = name.slice(0, -1);\n      }\n      name += '\\u2026';\n    }\n    ctx.fillText(name, 28, ry + h / 2 + 1);\n\n    if (count > 1) {\n      const badge = String(count);\n      ctx.font = 'bold 10px -apple-system, system-ui, sans-serif';\n      const tw = ctx.measureText(badge).width;\n      const bw = Math.max(20, tw + 10);\n      const bx = w - bw - 6;\n      const by = ry + (h - 18) / 2;\n\n      ctx.fillStyle = isDark ? '#5b8bd9' : '#007aff';\n      fillRoundRect(ctx, bx, by, bw, 18, 9);\n\n      ctx.fillStyle = '#ffffff';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(badge, bx + bw / 2, by + 9);\n    }\n\n    return canvas.toDataURL('image/png');\n  }\n\n  function handleRowMouseDown(event, index) {\n    if (event.button !== 0) return;\n    if (event.metaKey || event.ctrlKey || event.shiftKey) return;\n    if (editing.active) return;\n\n    const startX = event.clientX;\n    const startY = event.clientY;\n    let dragging = false;\n\n    dragCleanup?.();\n\n    const onMove = (e) => {\n      if (dragging) return;\n      const dx = e.clientX - startX;\n      const dy = e.clientY - startY;\n      if (dx * dx + dy * dy < DRAG_THRESHOLD * DRAG_THRESHOLD) return;\n\n      dragging = true;\n      cleanup();\n\n      if (!selectedIndices.has(index)) {\n        selectSingle(index);\n      }\n\n      const paths = dragPathsForIndex(index);\n      if (paths.length > 0) {\n        const icon = buildDragPreview(index);\n        startDrag({ item: paths, icon }).catch(() => {});\n      }\n    };\n\n    const onUp = () => cleanup();\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      if (dragCleanup === cleanup) dragCleanup = null;\n    };\n\n    dragCleanup = cleanup;\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  async function handleRowDoubleClick(index) {\n    if (!selectedIndices.has(index) || selectedIndices.size > 1) {\n      selectSingle(index);\n      await tick();\n    }\n    await invoke('open', { paths: [results[index].path] }).catch((err) => {\n      showToast(`Failed to open: ${String(err)}`);\n    });\n  }\n\n  function closeContextMenu() {\n    contextMenu = {\n      ...contextMenu,\n      visible: false\n    };\n  }\n\n  async function openSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('open', { paths });\n    } catch (err) {\n      showToast(`Failed to open: ${String(err)}`);\n    }\n  }\n\n  async function openWithFallback() {\n    const target = primaryEntry();\n    if (!target) {\n      return;\n    }\n\n    try {\n      await invoke('open_with', { path: target.path });\n    } catch (err) {\n      showToast(`Open With failed: ${String(err)}`);\n    }\n  }\n\n  async function revealSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('reveal_in_finder', { paths });\n    } catch (err) {\n      showToast(`Failed to reveal in Finder: ${String(err)}`);\n    }\n  }\n\n  async function copySelectedPaths() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_paths', { paths });\n      showToast(`Copied ${paths.length} path(s)`);\n    } catch (err) {\n      showToast(`Failed to copy path: ${String(err)}`);\n    }\n  }\n\n  async function copyFiles() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_files', { paths });\n      showToast(`Copied ${paths.length} item(s)`);\n    } catch (err) {\n      showToast(`Failed to copy: ${String(err)}`);\n    }\n  }\n\n  async function trashSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    const message =\n      paths.length === 1\n        ? 'Move selected item to Trash?'\n        : `Move ${paths.length} items to Trash?`;\n\n    if (!window.confirm(message)) {\n      return;\n    }\n\n    try {\n      await invoke('move_to_trash', { paths });\n      showToast('Moved to Trash.');\n      clearSelection();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to move to Trash: ${String(err)}`);\n    }\n  }\n\n  async function resetIndex() {\n    if (indexStatus.state === 'Indexing') {\n      showToast('Indexing in progress. Please try again after it completes.');\n      return;\n    }\n\n    results = [];\n    totalResults = 0;\n    totalResultsKnown = false;\n    clearSelection();\n    scanned = 0;\n    dbLatencyMs = null;\n    dbLastQuery = '';\n    indexStatus = { ...indexStatus, state: 'Indexing', entriesCount: 0, message: null };\n    indexingStartTime = Date.now();\n    indexingElapsed = '';\n    indexingFinishedAt = '';\n\n    try {\n      await invoke('reset_index');\n    } catch (err) {\n      showToast(`Failed to reset index: ${String(err)}`);\n      await refreshStatus();\n    }\n  }\n\n  function isMultiSelected() {\n    return selectedIndices.size > 1;\n  }\n\n  async function startRename() {\n    if (isMultiSelected()) {\n      return;\n    }\n\n    const idx = lastSelectedIndex;\n    if (idx < 0 || !results[idx]) {\n      return;\n    }\n\n    const entry = results[idx];\n    editing = {\n      active: true,\n      path: entry.path,\n      index: idx,\n      draftName: entry.name\n    };\n\n    await tick();\n\n    if (renameInputEl) {\n      renameInputEl.focus();\n      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n      renameInputEl.setSelectionRange(0, selectionEnd);\n    }\n  }\n\n  function cancelRename() {\n    editing = {\n      active: false,\n      path: '',\n      index: -1,\n      draftName: ''\n    };\n  }\n\n  async function commitRename() {\n    if (!editing.active || editing.index < 0 || !results[editing.index]) {\n      return;\n    }\n\n    const current = results[editing.index];\n    const nextName = editing.draftName;\n\n    try {\n      await invoke('rename', {\n        path: current.path,\n        newName: nextName\n      });\n      cancelRename();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to rename: ${String(err)}`);\n      await tick();\n      renameInputEl?.focus();\n    }\n  }\n\n  function onGlobalClick() {\n    closeContextMenu();\n  }\n\n  function onTitleBarMouseDown(event) {\n    if (event.button !== 0) {\n      return;\n    }\n\n    const activeElement = document.activeElement;\n    if (activeElement instanceof HTMLElement && isTextInputTarget(activeElement)) {\n      activeElement.blur();\n    }\n  }\n\n  async function focusSearch() {\n    await getCurrentWindow().show();\n    await getCurrentWindow().setFocus();\n    searchInputEl?.focus();\n    searchInputEl?.select();\n  }\n\n  function isTextInputTarget(target) {\n    return (\n      target instanceof HTMLInputElement ||\n      target instanceof HTMLTextAreaElement ||\n      target?.isContentEditable\n    );\n  }\n\n  async function handleKeydown(event) {\n    const isMetaSelectAll = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'a';\n    const isMetaCopy = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c';\n    const target = event.target;\n    const isTextInput = isTextInputTarget(target);\n\n    if (isMetaCopy && isTextInput) {\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      if (isTextInput) {\n        event.preventDefault();\n        if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n          target.select();\n        }\n        return;\n      }\n    }\n\n    if (editing.active) {\n      if (event.key === 'Enter') {\n        event.preventDefault();\n        await commitRename();\n        return;\n      }\n\n      if (event.key === 'Escape') {\n        event.preventDefault();\n        cancelRename();\n        searchInputEl?.focus();\n        return;\n      }\n      return;\n    }\n\n    if (event.key === 'Escape') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      return;\n    }\n\n    if (event.key === 'ArrowDown') {\n      event.preventDefault();\n      moveSelection(1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'ArrowUp') {\n      event.preventDefault();\n      moveSelection(-1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageDown') {\n      event.preventDefault();\n      moveSelection(Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageUp') {\n      event.preventDefault();\n      moveSelection(-Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'Enter') {\n      event.preventDefault();\n      if (platform === 'windows') {\n        await openSelected();\n      } else {\n        await startRename();\n      }\n      return;\n    }\n\n    if (event.key === 'F2') {\n      event.preventDefault();\n      await startRename();\n      return;\n    }\n\n    if (event.key === ' ' && !isTextInput) {\n      event.preventDefault();\n      const entry = primaryEntry();\n      if (entry) {\n        await invoke('quick_look', { path: entry.path });\n      }\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'f') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      searchInputEl?.select();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'o') {\n      event.preventDefault();\n      await openSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {\n      event.preventDefault();\n      await revealSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c') {\n      event.preventDefault();\n      await copySelectedPaths();\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      event.preventDefault();\n      selectedIndices = new Set(Array.from({ length: results.length }, (_, i) => i));\n      return;\n    }\n\n    if (event.key === 'Delete' || ((event.metaKey || event.ctrlKey) && event.key === 'Backspace')) {\n      if (!isTextInput) {\n        event.preventDefault();\n        await trashSelected();\n      }\n      return;\n    }\n  }\n\n  function formatSize(entry) {\n    if (entry.isDir || entry.size == null) return '';\n    const bytes = entry.size;\n    if (bytes < 1024) return `${bytes} B`;\n    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n    return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n  }\n\n  function formatModified(entry) {\n    if (!entry.mtime) {\n      return '';\n    }\n\n    const d = new Date(entry.mtime * 1000);\n    const pad = (n) => String(n).padStart(2, '0');\n    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;\n  }\n\n  function formatLastUpdated(timestamp) {\n    if (!timestamp) {\n      return '-';\n    }\n\n    return new Date(timestamp * 1000).toLocaleString();\n  }\n\n  function formatElapsed(ms) {\n    const totalSec = Math.floor(ms / 1000);\n    const min = Math.floor(totalSec / 60);\n    const sec = totalSec % 60;\n    return min > 0 ? `${min}m ${sec}s` : `${sec}s`;\n  }\n\n  function updateElapsed() {\n    if (indexingStartTime && indexStatus.state === 'Indexing') {\n      indexingElapsed = formatElapsed(Date.now() - indexingStartTime);\n    }\n  }\n\n  function startElapsedTimer() {\n    clearInterval(elapsedTimer);\n    indexingStartTime = Date.now();\n    indexingElapsed = '0s';\n    indexingFinishedAt = '';\n    elapsedTimer = setInterval(updateElapsed, 1000);\n  }\n\n  function stopElapsedTimer() {\n    clearInterval(elapsedTimer);\n    if (indexingStartTime) {\n      const elapsed = Date.now() - indexingStartTime;\n      indexingFinishedAt = `${formatElapsed(elapsed)}`;\n    }\n    indexingStartTime = null;\n    indexingElapsed = '';\n  }\n\n  function displayPath(path) {\n    if (!path) {\n      return path;\n    }\n\n    if (!homePrefix) {\n      return path;\n    }\n\n    if (path === homePrefix) {\n      return '~';\n    }\n\n    if (path.startsWith(`${homePrefix}/`)) {\n      return `~${path.slice(homePrefix.length)}`;\n    }\n\n    return path;\n  }\n\n  let unlistenFns = [];\n\n  onMount(async () => {\n    const t0 = performance.now();\n    const ms = () => Math.round(performance.now() - t0);\n    const DEBUG_STARTUP = false;\n    const flog = DEBUG_STARTUP ? (msg) => invoke('frontend_log', { msg }).catch(() => {}) : () => {};\n\n    flog(`[startup/fe] onMount entered`);\n\n    updateViewportHeight();\n    flog(`[startup/fe] +${ms()}ms updateViewportHeight done`);\n\n    platform = await invoke('get_platform');\n    flog(`[startup/fe] +${ms()}ms get_platform done`);\n\n    const unlistenProgress = await listen('index_progress', (event) => {\n      scanned = event.payload.scanned;\n      if (indexStatus.state !== 'Indexing') {\n        indexStatus = {\n          ...indexStatus,\n          state: 'Indexing'\n        };\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_progress) registered`);\n\n    const unlistenState = await listen('index_state', (event) => {\n      flog(`[startup/fe] index_state event received: ${event.payload.state} at +${ms()}ms`);\n      const prevState = indexStatus.state;\n      indexStatus = {\n        ...indexStatus,\n        state: event.payload.state,\n        message: event.payload.message ?? null,\n        isCatchup: event.payload.isCatchup ?? false\n      };\n\n      if (event.payload.state === 'Indexing' && prevState !== 'Indexing') {\n        if (prevState === 'Ready') {\n          lastReadyCount = indexStatus.entriesCount;\n        }\n        startElapsedTimer();\n      } else if (event.payload.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n\n      if (event.payload.state === 'Ready') {\n        scheduleSearch();\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_state) registered`);\n\n    const unlistenUpdated = await listen('index_updated', (event) => {\n      indexStatus = {\n        ...indexStatus,\n        entriesCount: event.payload.entriesCount,\n        lastUpdated: event.payload.lastUpdated,\n        permissionErrors: event.payload.permissionErrors ?? indexStatus.permissionErrors\n      };\n\n      scheduleSearch(true);\n    });\n\n    const unlistenFocus = await listen('focus_search', () => {\n      void focusSearch();\n    });\n\n    const unlistenCtxMenuAction = await listen('context_menu_action', (event) => {\n      switch (event.payload) {\n        case 'open': void openSelected(); break;\n        case 'quick_look': {\n          const e = primaryEntry();\n          if (e) void invoke('quick_look', { path: e.path });\n          break;\n        }\n        case 'open_with': void openWithFallback(); break;\n        case 'reveal': void revealSelected(); break;\n        case 'copy_files': void copyFiles(); break;\n        case 'copy_path': void copySelectedPaths(); break;\n        case 'trash': void trashSelected(); break;\n        case 'rename': void startRename(); break;\n      }\n    });\n\n    unlistenFns = [unlistenProgress, unlistenState, unlistenUpdated, unlistenFocus, unlistenCtxMenuAction];\n    flog(`[startup/fe] +${ms()}ms all listeners registered`);\n\n    // Fetch backend state IMMEDIATELY after listeners are registered.\n    // Events emitted before listener registration are lost, so this\n    // is the only reliable way to get the current state.\n    await refreshStatus();\n    flog(`[startup/fe] +${ms()}ms refreshStatus done (state=${indexStatus.state})`);\n\n    // Show Svelte UI: remove skeleton, focus search input.\n    await tick();\n    document.getElementById('skeleton')?.remove();\n    await focusSearch();\n    flog(`[startup/fe] +${ms()}ms WINDOW VISIBLE — skeleton removed`);\n\n    try {\n      homePrefix = await invoke('get_home_dir');\n    } catch {\n      homePrefix = '';\n    }\n    flog(`[startup/fe] +${ms()}ms get_home_dir done`);\n\n    if (!localStorage.getItem('everything-fda-notice-v1')) {\n      showToast('macOS Full Disk Access permission may be required for full disk search.');\n      localStorage.setItem('everything-fda-notice-v1', '1');\n    }\n    flog(`[startup/fe] +${ms()}ms calling runSearch...`);\n    await runSearch();\n    flog(`[startup/fe] +${ms()}ms runSearch done`);\n\n    if (typeof ResizeObserver !== 'undefined') {\n      tableResizeObserver = new ResizeObserver(() => {\n        scheduleViewportHeightUpdate();\n      });\n      if (tableContainer) {\n        tableResizeObserver.observe(tableContainer);\n      } else if (tableAreaEl) {\n        tableResizeObserver.observe(tableAreaEl);\n      }\n    }\n\n    window.addEventListener('resize', scheduleViewportHeightUpdate);\n    window.addEventListener('click', onGlobalClick);\n    statusRefreshTimer = setInterval(() => {\n      if (indexStatus.state === 'Indexing') {\n        void refreshStatus();\n      }\n    }, 1000);\n    console.log(`[startup/fe] +${ms()}ms onMount complete`);\n  });\n\n  onDestroy(async () => {\n    clearTimeout(searchTimer);\n    clearTimeout(toastTimer);\n    clearInterval(statusRefreshTimer);\n    clearInterval(elapsedTimer);\n    resizeCleanup?.();\n\n    for (const unlisten of unlistenFns) {\n      unlisten();\n    }\n\n    tableResizeObserver?.disconnect();\n    tableResizeObserver = null;\n    if (viewportResizeRaf !== null) {\n      cancelAnimationFrame(viewportResizeRaf);\n      viewportResizeRaf = null;\n    }\n    window.removeEventListener('resize', scheduleViewportHeightUpdate);\n    window.removeEventListener('click', onGlobalClick);\n  });\n</script>\n\n<svelte:window on:keydown={handleKeydown} />\n\n<div class=\"app-shell\" data-theme={theme}>\n  <div class=\"title-bar\" role=\"presentation\" data-tauri-drag-region on:mousedown={onTitleBarMouseDown}>\n    <div class=\"title-left\"></div>\n    <div class=\"title-center\">\n      <svg class=\"title-icon\" viewBox=\"0 0 215 205\" fill-rule=\"evenodd\" aria-hidden=\"true\">\n        <path d=\"M85 0c46.9 0 85 38.1 85 85 0 20.1-7.2 38.5-19.2 52.7l40.7 40.8c5.8 5.8 5.8 15.2 0 21-5.8 5.8-15.2 5.8-21 0l-40.7-40.7c-13.6 9.7-30.4 15.2-44.8 15.2-46.9 0-85-42.1-85-89 0-46.9 38.1-85 85-85z m0 32c-29.3 0-53 23.7-53 53 0 29.3 23.7 53 53 53 29.3 0 53-23.7 53-53 0-29.3-23.7-53-53-53z\"/>\n      </svg>\n      <span class=\"title-text\">Everything</span>\n    </div>\n    <div class=\"title-right\"></div>\n  </div>\n\n  <header class=\"search-bar\">\n    <input\n      bind:this={searchInputEl}\n      class=\"search-input\"\n      type=\"text\"\n      bind:value={query}\n      on:input={scheduleSearch}\n      on:focus={clearSelection}\n      placeholder=\"Search file/folder names\"\n      autocomplete=\"off\"\n      spellcheck=\"false\"\n    />\n  </header>\n\n  <section class=\"table-area\" bind:this={tableAreaEl} style={tableGridStyle}>\n    <div class=\"table-header\">\n      <div class=\"table-header-track\">\n        <div class=\"col name\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('name')}>\n            Name{#if sortBy === 'name'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'name'}\n            on:mousedown={(event) => startColumnResize(event, 'name')}\n            aria-label=\"Resize Name column\"\n          />\n        </div>\n\n        <div class=\"col path\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('dir')}>\n            Path{#if sortBy === 'dir'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'path'}\n            on:mousedown={(event) => startColumnResize(event, 'path')}\n            aria-label=\"Resize Path column\"\n          />\n        </div>\n\n        <div class=\"col size\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('size')}>\n            Size{#if sortBy === 'size'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n\n        <div class=\"col modified\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('mtime')}>\n            Modified{#if sortBy === 'mtime'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n      </div>\n    </div>\n\n    <div\n      class=\"table-body\"\n      bind:this={tableContainer}\n      on:scroll={() => {\n        scrollTop = tableContainer.scrollTop;\n        headerScrollLeft = tableContainer.scrollLeft;\n        const scrollBottom = scrollTop + tableContainer.clientHeight;\n        if (scrollBottom >= totalHeight - rowHeight * 10) {\n          void loadMore();\n        }\n      }}\n    >\n      <div class=\"spacer\" style={`height:${totalHeight}px`}>\n        <div class=\"rows\" style={`transform: translateY(${translateY}px);`}>\n          {#each visibleRows as entry, localIndex}\n            {@const index = startIndex + localIndex}\n            <div\n              class=\"row {selectedIndices.has(index) ? 'selected' : ''} {editing.active && editing.index === index ? 'renaming' : ''}\"\n              on:mousedown={(event) => handleRowMouseDown(event, index)}\n              on:click={(event) => handleRowClick(event, index)}\n              on:keydown={(event) => handleRowA11yKeydown(event, index)}\n              on:dblclick={() => handleRowDoubleClick(index)}\n              on:contextmenu={(event) => handleRowContextMenu(event, index)}\n              role=\"row\"\n              tabindex=\"0\"\n            >\n              <div class=\"cell name\">\n                <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n\n                {#if editing.active && editing.index === index}\n                  <input\n                    bind:this={renameInputEl}\n                    class=\"rename-input\"\n                    type=\"text\"\n                    bind:value={editing.draftName}\n                    on:click|stopPropagation\n                    on:blur={commitRename}\n                  />\n                {:else}\n                  <span class=\"ellipsis\">{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n                {/if}\n              </div>\n              <div class=\"cell path\"><span class=\"ellipsis\">{displayPath(entry.dir)}</span></div>\n              <div class=\"cell size\">{formatSize(entry)}</div>\n              <div class=\"cell modified\">{formatModified(entry)}</div>\n            </div>\n          {/each}\n        </div>\n      </div>\n    </div>\n  </section>\n\n  <footer class=\"status-bar\">\n    <div class=\"status-left\">\n      <span class=\"status-state\">\n        <span class=\"state-dot {indexStatus.state === 'Indexing' ? 'indexing' : indexStatus.state === 'Error' ? 'error' : 'ready'}\"></span>\n        {#if indexStatus.state === 'Indexing'}\n          Indexing{#if lastReadyCount > 0} ({Math.min(99, Math.round((scanned / lastReadyCount) * 100))}%){/if}{#if indexingElapsed} · {indexingElapsed}{/if}\n          {#if !indexStatus.isCatchup}\n            · {scanned.toLocaleString()} scanned\n          {/if}\n        {:else}\n          Index: {indexStatus.state}\n        {/if}\n      </span>\n      <span>{indexStatus.entriesCount.toLocaleString()} entries</span>\n      {#if indexingFinishedAt && indexStatus.state !== 'Indexing'}\n        <span>in {indexingFinishedAt}</span>\n      {/if}\n      {#if dbLatencyMs !== null && dbLastQuery}\n        <span>\"{dbLastQuery}\" {dbLatencyMs}ms · {totalResults} results</span>\n      {/if}\n      {#if searchModeLabel === 'spotlight' || searchModeLabel === 'spotlight_timeout'}\n        <span class=\"status-spotlight\">Spotlight fallback{#if searchModeLabel === 'spotlight_timeout'} (partial){/if}</span>\n      {/if}\n      {#if indexStatus.permissionErrors > 0}\n        <span class=\"status-warning\">{indexStatus.permissionErrors.toLocaleString()} permission errors</span>\n      {/if}\n      {#if indexStatus.message}\n        <span class={indexStatus.isCatchup ? 'index-progress' : 'status-error'}>{indexStatus.message}</span>\n      {/if}\n    </div>\n    <div class=\"status-right\">\n      <button class=\"status-btn theme-btn\" on:click={cycleTheme} title=\"Switch theme\">\n        {theme === 'dark' ? '☀ Light' : '◑ Dark'}\n      </button>\n      <button\n        class=\"status-btn rebuild-btn\"\n        on:click={resetIndex}\n        disabled={indexStatus.state === 'Indexing'}\n        title={indexStatus.state === 'Indexing' ? 'Cannot reset while indexing is in progress.' : 'Reset and rebuild the index.'}\n      >\n        <svg class=\"rebuild-icon\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n          <path d=\"M23 4v6h-6\"/><path d=\"M20.49 15a9 9 0 1 1-2.12-9.36L23 10\"/>\n        </svg>\n        Rebuild Index\n      </button>\n    </div>\n  </footer>\n\n  {#if contextMenu.visible}\n    <div class=\"context-menu\" style={`left:${contextMenu.x}px;top:${contextMenu.y}px;`}>\n      <button on:click={() => (closeContextMenu(), openSelected())}>Open</button>\n      <button on:click={async () => { closeContextMenu(); const e = primaryEntry(); if (e) await invoke('quick_look', { path: e.path }); }}>Quick Look</button>\n      <button on:click={() => (closeContextMenu(), openWithFallback())}>Open With... (Reveal in Finder)</button>\n      <button on:click={() => (closeContextMenu(), revealSelected())}>Reveal in Finder</button>\n      <button on:click={() => (closeContextMenu(), copySelectedPaths())}>Copy Path</button>\n      <button on:click={() => (closeContextMenu(), trashSelected())}>Move to Trash</button>\n      {#if selectedIndices.size === 1}\n        <button on:click={() => (closeContextMenu(), startRename())}>Rename</button>\n      {/if}\n    </div>\n  {/if}\n\n  {#if toast}\n    <div class=\"toast\">{toast}</div>\n  {/if}\n</div>\n\n<style>\n  :global(:root) {\n    color-scheme: light dark;\n    --bg-app: transparent;\n    --text-primary: #0d1826;\n    --text-muted: #48596c;\n    --bar-grad-top: rgba(255, 255, 255, 0.48);\n    --bar-grad-bottom: rgba(248, 250, 253, 0.42);\n    --surface-header: rgba(252, 252, 255, 0.40);\n    --surface: rgba(255, 255, 255, 0.22);\n    --border-soft: rgba(0, 0, 0, 0.07);\n    --border-input: rgba(0, 0, 0, 0.13);\n    --focus-ring: #6f96e6;\n    --row-border: rgba(0, 0, 0, 0.032);\n    --row-hover: rgba(0, 0, 0, 0.06);\n    --row-selected: rgba(0, 0, 0, 0.12);\n    --button-bg: rgba(255, 255, 255, 0.62);\n    --button-border: rgba(0, 0, 0, 0.10);\n    --button-text: #2c3e50;\n    --menu-bg: rgba(240, 241, 248, 0.90);\n    --menu-border: rgba(0, 0, 0, 0.06);\n    --menu-hover: rgba(255, 255, 255, 0.62);\n    --menu-text: #1a2a38;\n    --error-text: #b64545;\n    --warning-text: #8f6500;\n    --toast-bg: rgba(18, 22, 32, 0.90);\n    --toast-text: #ffffff;\n  }\n\n  @media (prefers-color-scheme: dark) {\n    :global(:root) {\n      --bg-app: transparent;\n      --text-primary: #e6e6ea;\n      --text-muted: #9494a4;\n      --bar-grad-top: rgba(38, 38, 46, 0.52);\n      --bar-grad-bottom: rgba(30, 30, 38, 0.46);\n      --surface-header: rgba(32, 32, 40, 0.46);\n      --surface: rgba(18, 18, 26, 0.32);\n      --border-soft: rgba(255, 255, 255, 0.065);\n      --border-input: rgba(255, 255, 255, 0.14);\n      --focus-ring: #5b8bd9;\n      --row-border: rgba(255, 255, 255, 0.026);\n      --row-hover: rgba(255, 255, 255, 0.08);\n      --row-selected: rgba(255, 255, 255, 0.14);\n      --button-bg: rgba(255, 255, 255, 0.072);\n      --button-border: rgba(255, 255, 255, 0.11);\n      --button-text: #d6d6e0;\n      --menu-bg: rgba(36, 36, 46, 0.90);\n      --menu-border: rgba(255, 255, 255, 0.066);\n      --menu-hover: rgba(255, 255, 255, 0.062);\n      --menu-text: #e0e0e8;\n      --error-text: #ff9d9d;\n      --warning-text: #e0c670;\n      --toast-bg: rgba(10, 10, 16, 0.93);\n      --toast-text: #f2f2f6;\n    }\n  }\n\n  /* ── Theme: Dark ──────────────────────────────────────────────── */\n  :global([data-theme=\"dark\"]) {\n    color-scheme: dark;\n    --bg-app: #1E1E21;\n    --text-primary: #E2E8F0;\n    --text-muted: #94A3B8;\n    --bar-grad-top: #1E1E21;\n    --bar-grad-bottom: #1E1E21;\n    --surface-header: #1E1E21;\n    --surface: #1E1E21;\n    --bg-input: #161618;\n    --border-soft: #2A2A2D;\n    --border-input: rgba(255, 255, 255, 0.06);\n    --focus-ring: #4DA8FF;\n    --accent: #4DA8FF;\n    --row-border: rgba(255, 255, 255, 0.02);\n    --row-hover: #282828;\n    --row-selected: rgba(77, 168, 255, 0.10);\n    --button-bg: rgba(255, 255, 255, 0.05);\n    --button-border: #2A2A2D;\n    --button-text: #94A3B8;\n    --menu-bg: #252528;\n    --menu-border: #2A2A2D;\n    --menu-hover: rgba(255, 255, 255, 0.04);\n    --menu-text: #E2E8F0;\n    --error-text: #ff9d9d;\n    --warning-text: #e0c670;\n    --toast-bg: rgba(10, 10, 16, 0.93);\n    --toast-text: #f2f2f6;\n  }\n\n  /* ── Theme: Light ─────────────────────────────────────────────── */\n  :global([data-theme=\"light\"]) {\n    color-scheme: light;\n    --bg-app: #F5F5F7;\n    --text-primary: #1C1C1E;\n    --text-muted: #6E6E7A;\n    --bar-grad-top: #F5F5F7;\n    --bar-grad-bottom: #F5F5F7;\n    --surface-header: #F5F5F7;\n    --surface: #F5F5F7;\n    --bg-input: #FFFFFF;\n    --border-soft: #D1D1D6;\n    --border-input: rgba(0, 0, 0, 0.10);\n    --focus-ring: #3A8BF5;\n    --accent: #3A8BF5;\n    --row-border: rgba(0, 0, 0, 0.04);\n    --row-hover: rgba(0, 0, 0, 0.04);\n    --row-selected: rgba(58, 139, 245, 0.10);\n    --button-bg: #FFFFFF;\n    --button-border: #D1D1D6;\n    --button-text: #3C3C43;\n    --menu-bg: #FFFFFF;\n    --menu-border: #D1D1D6;\n    --menu-hover: rgba(0, 0, 0, 0.05);\n    --menu-text: #1C1C1E;\n    --error-text: #D93025;\n    --warning-text: #B45309;\n    --toast-bg: rgba(255, 255, 255, 0.95);\n    --toast-text: #1C1C1E;\n  }\n\n  /* ── Themed element overrides ─────────────────────────────────── */\n  :global([data-theme]) {\n    background: var(--bg-app);\n  }\n\n  /* Search bar: flat, no gradient, no separator */\n  :global([data-theme]) .search-bar {\n    height: 44px;\n    padding: 0 16px;\n    background: var(--bg-app);\n    border-bottom: none;\n  }\n\n  :global([data-theme]) .search-input {\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n    font-family: 'JetBrains Mono', 'SF Mono', monospace;\n    font-size: 12px;\n    height: 34px;\n    border-radius: 8px;\n  }\n\n  /* Table header: flat bg, 16px edge padding */\n  :global([data-theme]) .table-header {\n    background: var(--bg-app);\n  }\n\n  :global([data-theme]) .col-button {\n    padding: 0 8px;\n  }\n\n  :global([data-theme]) .col.name .col-button {\n    padding-left: 16px;\n  }\n\n  /* Row cells: JetBrains Mono, 16px outer edges */\n  :global([data-theme]) .cell {\n    font-family: 'JetBrains Mono', monospace;\n  }\n\n  :global([data-theme]) .cell.name {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    padding-left: 16px;\n    font-size: 12px;\n    color: var(--text-primary);\n  }\n\n  :global([data-theme]) .cell.path {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.size {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.modified {\n    padding-right: 16px;\n    font-size: 11px;\n    white-space: nowrap;\n  }\n\n  :global([data-theme]) .row.selected {\n    box-shadow: inset 3px 0 0 var(--accent);\n  }\n\n  /* Dim path/size/date cells in themed mode */\n  :global([data-theme]) .cell.path,\n  :global([data-theme]) .cell.size,\n  :global([data-theme]) .cell.modified {\n    color: var(--text-muted);\n  }\n\n  :global(:root) {\n    background: transparent;\n  }\n\n  :global(html, body) {\n    margin: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    background: transparent;\n    color: var(--text-primary);\n    font-family: Inter, 'SF Pro Text', 'Segoe UI', Helvetica, Arial, sans-serif;\n  }\n\n  :global(#app) {\n    width: 100%;\n    height: 100%;\n  }\n\n  .app-shell {\n    display: grid;\n    grid-template-rows: auto auto 1fr auto;\n    height: 100%;\n    min-width: 0;\n  }\n\n  .title-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 44px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    cursor: default;\n    flex-shrink: 0;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-left {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-center {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-right {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-icon {\n    width: 14px;\n    height: 14px;\n    fill: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .title-text {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 13px;\n    font-weight: 500;\n    color: var(--text-primary);\n    letter-spacing: -0.01em;\n  }\n\n  .search-bar {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding: 8px;\n    background: linear-gradient(180deg, var(--bar-grad-top) 0%, var(--bar-grad-bottom) 100%);\n    border-bottom: 1px solid var(--border-soft);\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .search-input {\n    display: block;\n    box-sizing: border-box;\n    width: 100%;\n    min-width: 0;\n    flex: 1 1 auto;\n    height: 36px;\n    border: 1px solid var(--border-input);\n    border-radius: 14px;\n    padding: 0 10px;\n    font-size: 14px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    backdrop-filter: blur(12px) saturate(160%);\n    -webkit-backdrop-filter: blur(12px) saturate(160%);\n  }\n\n  .search-input::placeholder {\n    color: var(--text-muted);\n    opacity: 0.85;\n    font-size: 12px;\n  }\n\n  .search-input:focus {\n    outline: none;\n    border-color: var(--focus-ring);\n    box-shadow: 0 0 0 2px rgba(125, 169, 255, 0.25);\n  }\n\n  .table-area {\n    display: grid;\n    grid-template-rows: auto 1fr;\n    min-height: 0;\n    min-width: 0;\n  }\n\n  .table-header-track,\n  .row {\n    display: grid;\n    grid-template-columns: var(--col-name) var(--col-path) var(--col-size) var(--col-modified);\n    align-items: center;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .table-header {\n    height: 32px;\n    border-bottom: 1px solid var(--border-soft);\n    background: var(--surface-header);\n    user-select: none;\n    overflow: hidden;\n    flex-shrink: 0;\n  }\n\n  .table-header-track {\n    height: 100%;\n    transform: translateX(var(--header-offset, 0px));\n    will-change: transform;\n  }\n\n  .table-header .col {\n    position: relative;\n    min-width: 0;\n    height: 100%;\n  }\n\n  .col-button {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n    gap: 4px;\n    box-sizing: border-box;\n    padding: 0 8px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 11px;\n    font-weight: 600;\n    line-height: 1;\n    color: var(--text-muted);\n    text-align: left;\n    margin: 0;\n    border: none;\n    background: transparent;\n    cursor: pointer;\n  }\n\n  .sort-icon {\n    width: 10px;\n    height: 10px;\n    flex-shrink: 0;\n    color: var(--accent);\n  }\n\n  .col-resizer {\n    position: absolute;\n    top: 0;\n    right: -4px;\n    width: 8px;\n    height: 100%;\n    border: none;\n    padding: 0;\n    background: transparent;\n    cursor: col-resize;\n    z-index: 30;\n  }\n\n  .col-resizer::after {\n    content: '';\n    position: absolute;\n    top: 7px;\n    bottom: 7px;\n    left: 50%;\n    width: 1px;\n    transform: translateX(-50%);\n    background: var(--border-soft);\n    opacity: 0;\n    transition: opacity 0.15s ease;\n  }\n\n  .table-header .col:hover .col-resizer::after,\n  .col-resizer.active::after {\n    opacity: 1;\n  }\n\n  .table-body {\n    overflow: auto;\n    min-height: 0;\n    min-width: 0;\n    background: var(--surface);\n  }\n\n  .spacer {\n    position: relative;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .rows {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .row {\n    height: 30px;\n    border-bottom: 1px solid var(--row-border);\n    cursor: default;\n    -webkit-user-select: none;\n    user-select: none;\n    outline: none;\n  }\n\n  .row:hover {\n    background: var(--row-hover);\n  }\n\n  .row.selected {\n    background: var(--row-selected);\n  }\n\n  .cell {\n    padding: 0 8px;\n    font-size: 12px;\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    min-width: 0;\n  }\n\n  .cell.size {\n    text-align: right;\n    font-variant-numeric: tabular-nums;\n  }\n\n  .ellipsis {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n\n  .hl {\n    background: none;\n    color: inherit;\n    font-weight: 700;\n  }\n\n  .file-icon {\n    width: 16px;\n    height: 16px;\n    flex: 0 0 auto;\n  }\n\n  .rename-input {\n    flex: 1;\n    min-width: 0;\n    height: 22px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 12px;\n    padding: 0 6px;\n    border: 1.5px solid var(--focus-ring);\n    border-radius: 4px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    outline: none;\n    box-shadow: 0 1px 6px rgba(0, 0, 0, 0.18), 0 0 0 3px rgba(77, 168, 255, 0.12);\n  }\n\n  .status-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 32px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    border-top: 1px solid var(--border-soft);\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 11px;\n    color: var(--text-muted);\n    white-space: nowrap;\n    overflow: hidden;\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .status-left {\n    display: flex;\n    align-items: center;\n    gap: 16px;\n    overflow: hidden;\n    min-width: 0;\n  }\n\n  .status-right {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    flex-shrink: 0;\n  }\n\n  .status-btn {\n    border: 1px solid var(--button-border);\n    border-radius: 5px;\n    background: var(--button-bg);\n    color: var(--button-text);\n    font-size: 11px;\n    height: 22px;\n    padding: 0 8px;\n    cursor: pointer;\n  }\n\n  .status-btn:hover {\n    filter: brightness(1.06);\n  }\n\n  .status-btn:disabled {\n    opacity: 0.55;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .status-state {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n  }\n\n  .state-dot {\n    width: 6px;\n    height: 6px;\n    border-radius: 50%;\n    flex-shrink: 0;\n  }\n\n  .state-dot.ready { background: #28C840; }\n  .state-dot.indexing { background: #FEBC2E; }\n  .state-dot.error { background: #FF5F57; }\n\n  .rebuild-btn {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 10px;\n    font-weight: 500;\n    background: var(--button-bg);\n    border: 1px solid var(--button-border);\n    border-radius: 4px;\n    color: var(--button-text);\n    height: 22px;\n    padding: 0 10px;\n    cursor: pointer;\n  }\n\n  .rebuild-btn:hover {\n    filter: brightness(1.1);\n  }\n\n  .rebuild-btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .rebuild-icon {\n    width: 11px;\n    height: 11px;\n    color: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .status-error {\n    color: var(--error-text);\n  }\n\n  .status-warning {\n    color: var(--warning-text);\n  }\n\n  .status-spotlight {\n    color: #f59e0b;\n    font-weight: 600;\n  }\n\n  .context-menu {\n    position: fixed;\n    z-index: 200;\n    width: 220px;\n    border: 1px solid var(--menu-border);\n    border-radius: 10px;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.16), inset 0 0 0 0.5px rgba(255, 255, 255, 0.18);\n    background: var(--menu-bg);\n    backdrop-filter: blur(28px) saturate(180%);\n    -webkit-backdrop-filter: blur(28px) saturate(180%);\n    overflow: hidden;\n  }\n\n  .context-menu button {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    padding: 8px 10px;\n    font-size: 12px;\n    color: var(--menu-text);\n  }\n\n  .context-menu button:hover {\n    background: var(--menu-hover);\n  }\n\n  .toast {\n    position: fixed;\n    right: 14px;\n    bottom: 18px;\n    background: var(--toast-bg);\n    color: var(--toast-text);\n    border-radius: 10px;\n    padding: 9px 12px;\n    font-size: 12px;\n    z-index: 250;\n    backdrop-filter: blur(20px) saturate(180%);\n    -webkit-backdrop-filter: blur(20px) saturate(180%);\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);\n  }\n</style>\n","structuredPatch":[{"oldStart":47,"oldLines":6,"newStart":47,"newLines":8,"lines":["     draftName: ''","   };"," ","+  let renameOverlay = { top: 0, left: 0, width: 0 };","+","   let indexStatus = {","     state: 'Indexing',","     entriesCount: 0,"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"50c01ccc-975b-43c8-a652-ad185375aad3"}
{"parentUuid":"8ebc4a73-ce6d-4b6e-a8e2-87cb917ee4b0","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","message":{"model":"claude-sonnet-4-6","id":"msg_01QNxhFhCEGENemLJACMigAc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01S7ezsH89L3t4K7XdsugX4U","name":"Edit","input":{"replace_all":false,"file_path":"/Users/al02402336/everything/src/App.svelte","old_string":"  async function startRename() {\n    if (isMultiSelected()) {\n      return;\n    }\n\n    const idx = lastSelectedIndex;\n    if (idx < 0 || !results[idx]) {\n      return;\n    }\n\n    const entry = results[idx];\n    editing = {\n      active: true,\n      path: entry.path,\n      index: idx,\n      draftName: entry.name\n    };\n\n    await tick();\n\n    if (renameInputEl) {\n      renameInputEl.focus();\n      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n      renameInputEl.setSelectionRange(0, selectionEnd);\n    }\n  }","new_string":"  function autoResizeRenameInput() {\n    if (!renameInputEl) return;\n    renameInputEl.style.height = '0';\n    renameInputEl.style.height = renameInputEl.scrollHeight + 'px';\n  }\n\n  async function startRename() {\n    if (isMultiSelected()) {\n      return;\n    }\n\n    const idx = lastSelectedIndex;\n    if (idx < 0 || !results[idx]) {\n      return;\n    }\n\n    const entry = results[idx];\n\n    // Calculate overlay position from the row's name cell text span\n    const rowDomIndex = idx - startIndex;\n    const rowEls = tableContainer?.querySelectorAll('.row');\n    const rowEl = rowEls?.[rowDomIndex];\n    const nameCell = rowEl?.querySelector('.cell.name');\n\n    if (nameCell) {\n      const cellRect = nameCell.getBoundingClientRect();\n      const ellipsis = nameCell.querySelector('.ellipsis');\n      const textLeft = ellipsis ? ellipsis.getBoundingClientRect().left : cellRect.left + 38;\n      // Offset left by border(1.5) + padding-left(4) so text inside textarea aligns with row text\n      const pad = 6;\n      renameOverlay = {\n        top: cellRect.top,\n        left: textLeft - pad,\n        width: cellRect.right - textLeft + pad - 4\n      };\n    }\n\n    editing = {\n      active: true,\n      path: entry.path,\n      index: idx,\n      draftName: entry.name\n    };\n\n    await tick();\n\n    if (renameInputEl) {\n      autoResizeRenameInput();\n      renameInputEl.focus();\n      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n      renameInputEl.setSelectionRange(0, selectionEnd);\n    }\n  }"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":381,"cache_read_input_tokens":79891,"output_tokens":823,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":381,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYMN6GXdxLAj6865UHCJQ","type":"assistant","uuid":"dbcbc985-f74d-4b02-bb6b-c262867e9da0","timestamp":"2026-02-21T14:22:49.641Z"}
{"parentUuid":"dbcbc985-f74d-4b02-bb6b-c262867e9da0","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01S7ezsH89L3t4K7XdsugX4U","toolUseID":"toolu_01S7ezsH89L3t4K7XdsugX4U","timestamp":"2026-02-21T14:22:49.647Z","uuid":"16d386e0-64fb-4d80-8827-33c0fbcbcf59"}
{"parentUuid":"dbcbc985-f74d-4b02-bb6b-c262867e9da0","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01S7ezsH89L3t4K7XdsugX4U","type":"tool_result","content":"The file /Users/al02402336/everything/src/App.svelte has been updated successfully."}]},"uuid":"e2b251a3-af8f-4336-8d37-8b3d78a3e813","timestamp":"2026-02-21T14:22:49.647Z","toolUseResult":{"filePath":"/Users/al02402336/everything/src/App.svelte","oldString":"  async function startRename() {\n    if (isMultiSelected()) {\n      return;\n    }\n\n    const idx = lastSelectedIndex;\n    if (idx < 0 || !results[idx]) {\n      return;\n    }\n\n    const entry = results[idx];\n    editing = {\n      active: true,\n      path: entry.path,\n      index: idx,\n      draftName: entry.name\n    };\n\n    await tick();\n\n    if (renameInputEl) {\n      renameInputEl.focus();\n      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n      renameInputEl.setSelectionRange(0, selectionEnd);\n    }\n  }","newString":"  function autoResizeRenameInput() {\n    if (!renameInputEl) return;\n    renameInputEl.style.height = '0';\n    renameInputEl.style.height = renameInputEl.scrollHeight + 'px';\n  }\n\n  async function startRename() {\n    if (isMultiSelected()) {\n      return;\n    }\n\n    const idx = lastSelectedIndex;\n    if (idx < 0 || !results[idx]) {\n      return;\n    }\n\n    const entry = results[idx];\n\n    // Calculate overlay position from the row's name cell text span\n    const rowDomIndex = idx - startIndex;\n    const rowEls = tableContainer?.querySelectorAll('.row');\n    const rowEl = rowEls?.[rowDomIndex];\n    const nameCell = rowEl?.querySelector('.cell.name');\n\n    if (nameCell) {\n      const cellRect = nameCell.getBoundingClientRect();\n      const ellipsis = nameCell.querySelector('.ellipsis');\n      const textLeft = ellipsis ? ellipsis.getBoundingClientRect().left : cellRect.left + 38;\n      // Offset left by border(1.5) + padding-left(4) so text inside textarea aligns with row text\n      const pad = 6;\n      renameOverlay = {\n        top: cellRect.top,\n        left: textLeft - pad,\n        width: cellRect.right - textLeft + pad - 4\n      };\n    }\n\n    editing = {\n      active: true,\n      path: entry.path,\n      index: idx,\n      draftName: entry.name\n    };\n\n    await tick();\n\n    if (renameInputEl) {\n      autoResizeRenameInput();\n      renameInputEl.focus();\n      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n      renameInputEl.setSelectionRange(0, selectionEnd);\n    }\n  }","originalFile":"<script>\n  import { onDestroy, onMount, tick } from 'svelte';\n  import { invoke } from '@tauri-apps/api/core';\n  import { listen } from '@tauri-apps/api/event';\n  import { getCurrentWindow } from '@tauri-apps/api/window';\n  import { startDrag } from '@crabnebula/tauri-plugin-drag';\n\n  const rowHeight = 30;\n  const PAGE_SIZE = 500;\n  let homePrefix = '';\n  const COL_WIDTHS_KEY = 'REDACTED';\n  const THEME_KEY = 'everything-theme';\n  const columnKeys = ['name', 'path', 'size', 'modified'];\n  const minColumnWidth = {\n    name: 180,\n    path: 240,\n    size: 75,\n    modified: 150\n  };\n  const defaultColumnRatios = {\n    name: 0.3,\n    path: 0.45,\n    size: 0.1\n  };\n\n  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || 'dark'; } catch { return 'dark'; } })();\n  function cycleTheme() {\n    theme = theme === 'dark' ? 'light' : 'dark';\n    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n  }\n\n  let query = '';\n  let results = [];\n  let totalResults = 0;\n  let totalResultsKnown = false;\n\n  let dbLatencyMs = null;\n  let dbLastQuery = '';\n  let searchModeLabel = '';\n  let selectedIndices = new Set();\n  let selectionAnchor = -1;\n  let lastSelectedIndex = -1;\n  let editing = {\n    active: false,\n    path: '',\n    index: -1,\n    draftName: ''\n  };\n\n  let renameOverlay = { top: 0, left: 0, width: 0 };\n\n  let indexStatus = {\n    state: 'Indexing',\n    entriesCount: 0,\n    lastUpdated: null,\n    permissionErrors: 0,\n    message: null,\n    isCatchup: false\n  };\n\n  let indexingStartTime = null;\n  let indexingElapsed = '';\n  let indexingFinishedAt = '';\n\n  let sortBy = 'name';\n  let sortDir = 'asc';\n\n  let hasMore = true;\n  let loadingMore = false;\n  let searchGeneration = 0;\n\n  let scanned = 0;\n\n  let searchInputEl;\n  let renameInputEl;\n  let tableAreaEl;\n  let tableContainer;\n  let tableResizeObserver = null;\n  let viewportResizeRaf = null;\n  let scrollTop = 0;\n  let headerScrollLeft = 0;\n  let viewportHeight = 520;\n  let lastTableWidth = 0;\n  let resizingColumn = '';\n  let resizeCleanup = null;\n  let colWidths = {\n    name: 250,\n    path: 350,\n    size: 75,\n    modified: 150\n  };\n\n  let contextMenu = {\n    visible: false,\n    x: 0,\n    y: 0\n  };\n\n  let platform = '';\n  let toast = '';\n  let searchTimer;\n  let lastSearchFiredAt = 0;\n  let toastTimer;\n  let statusRefreshTimer;\n  let elapsedTimer;\n  let statusRefreshInFlight = false;\n  let lastReadyCount = 0;\n\n  const iconCache = new Map();\n  const iconLoading = new Set();\n\n  let highlightCache = new Map();\n  let highlightCacheQuery = '';\n\n  const folderFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='1' y='4' width='14' height='10' rx='2' fill='#d9b34f'/><rect x='1' y='2' width='6' height='4' rx='1' fill='#e6ca7a'/></svg>`\n    );\n  const fileFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='3' y='1' width='10' height='14' rx='1.5' fill='#b4bec9'/><rect x='5' y='5' width='6' height='1.2' fill='#8d98a5'/><rect x='5' y='8' width='6' height='1.2' fill='#8d98a5'/></svg>`\n    );\n\n  $: totalHeight = results.length * rowHeight;\n  $: startIndex = Math.max(0, Math.floor(scrollTop / rowHeight) - 10);\n  $: visibleCount = Math.ceil(viewportHeight / rowHeight) + 20;\n  $: endIndex = Math.min(results.length, startIndex + visibleCount);\n  $: visibleRows = results.slice(startIndex, endIndex);\n  $: translateY = startIndex * rowHeight;\n  $: tableMinWidth = colWidths.name + colWidths.path + colWidths.size + colWidths.modified;\n  $: tableGridStyle = `--col-name:${colWidths.name}px;--col-path:${colWidths.path}px;--col-size:${colWidths.size}px;--col-modified:${colWidths.modified}px;--table-min-width:${tableMinWidth}px;--header-offset:${-headerScrollLeft}px;`;\n\n  $: {\n    for (const entry of visibleRows) {\n      void ensureIcon(entry);\n    }\n  }\n\n  function showToast(message) {\n    toast = message;\n    clearTimeout(toastTimer);\n    toastTimer = setTimeout(() => {\n      toast = '';\n    }, 3000);\n  }\n\n  function bytesToBase64(bytes) {\n    let binary = '';\n    const chunk = 0x8000;\n    for (let i = 0; i < bytes.length; i += chunk) {\n      const part = bytes.subarray(i, i + chunk);\n      binary += String.fromCharCode(...part);\n    }\n    return btoa(binary);\n  }\n\n  function highlightSegments(name, q) {\n    q = (q || '').trim();\n    if (!q) return [{ text: name, hl: false }];\n\n    // Reset cache when query changes\n    if (q !== highlightCacheQuery) {\n      highlightCache = new Map();\n      highlightCacheQuery = q;\n    }\n\n    // Check cache\n    const cached = highlightCache.get(name);\n    if (cached) return cached;\n\n    if (q.includes('/')) q = q.slice(q.lastIndexOf('/') + 1);\n    q = q.replace(/[*?]/g, '');\n    const terms = q.split(/\\s+/).filter(Boolean);\n    if (terms.length === 0) return [{ text: name, hl: false }];\n\n    const lower = name.toLowerCase();\n    const marks = new Uint8Array(name.length);\n    for (const t of terms) {\n      const tl = t.toLowerCase();\n      let idx = lower.indexOf(tl);\n      while (idx !== -1) {\n        for (let i = idx; i < idx + tl.length; i++) marks[i] = 1;\n        idx = lower.indexOf(tl, idx + 1);\n      }\n    }\n\n    const segs = [];\n    let i = 0;\n    while (i < name.length) {\n      const m = marks[i];\n      let j = i + 1;\n      while (j < name.length && marks[j] === m) j++;\n      segs.push({ text: name.slice(i, j), hl: m === 1 });\n      i = j;\n    }\n\n    highlightCache.set(name, segs);\n    return segs;\n  }\n\n  const perFileIconExts = new Set(['exe', 'lnk', 'ico', 'url', 'scr', 'appx']);\n\n  function iconKey(entry) {\n    if (entry.isDir) return '__folder__';\n    const ext = (entry.ext || '').toLowerCase();\n    if (perFileIconExts.has(ext)) return entry.path;\n    return ext || '__file__';\n  }\n\n  function iconFor(entry) {\n    return iconCache.get(iconKey(entry)) || (entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n  }\n\n  async function ensureIcon(entry) {\n    const key = iconKey(entry);\n    if (iconCache.has(key) || iconLoading.has(key)) {\n      return;\n    }\n\n    iconLoading.add(key);\n    try {\n      const bytes = await invoke('get_file_icon', {\n        path: entry.path,\n        ext: entry.isDir ? 'folder' : entry.ext || '',\n      });\n      if (Array.isArray(bytes) && bytes.length > 0) {\n        const image = `data:image/png;base64,${bytesToBase64(Uint8Array.from(bytes))}`;\n        iconCache.set(key, image);\n      } else {\n        iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n      }\n    } catch {\n      iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n    } finally {\n      iconLoading.delete(key);\n    }\n  }\n\n  function syncColumnWidthsToContainer() {\n    const width = tableContainer?.clientWidth || tableAreaEl?.clientWidth;\n    if (!width || lastTableWidth !== 0) {\n      return;\n    }\n\n    const saved = loadColWidths();\n    if (saved) {\n      const total = columnKeys.reduce((s, k) => s + saved[k], 0);\n      if (Math.abs(total - width) > 2) {\n        const scale = (width - saved.modified) / (total - saved.modified);\n        let scaledName = Math.max(minColumnWidth.name, Math.round(saved.name * scale));\n        let scaledSize = Math.max(minColumnWidth.size, Math.round(saved.size * scale));\n        let rawPath = width - saved.modified - scaledName - scaledSize;\n        if (rawPath < minColumnWidth.path) {\n          const shortfall = minColumnWidth.path - rawPath;\n          const nameReduction = Math.min(shortfall, scaledName - minColumnWidth.name);\n          scaledName -= nameReduction;\n          const remaining = shortfall - nameReduction;\n          if (remaining > 0) {\n            scaledSize -= Math.min(remaining, scaledSize - minColumnWidth.size);\n          }\n          rawPath = width - saved.modified - scaledName - scaledSize;\n        }\n        const scaledPath = Math.max(minColumnWidth.path, rawPath);\n        colWidths = { name: scaledName, path: scaledPath, size: scaledSize, modified: saved.modified };\n      } else {\n        colWidths = saved;\n      }\n    } else {\n      const fixedModified = minColumnWidth.modified;\n      const rest = width - fixedModified;\n      const ratioSum = defaultColumnRatios.name + defaultColumnRatios.path + defaultColumnRatios.size;\n      colWidths = {\n        name: Math.max(minColumnWidth.name, Math.round(rest * defaultColumnRatios.name / ratioSum)),\n        path: Math.max(minColumnWidth.path, Math.round(rest * defaultColumnRatios.path / ratioSum)),\n        size: Math.max(minColumnWidth.size, Math.round(rest * defaultColumnRatios.size / ratioSum)),\n        modified: fixedModified\n      };\n    }\n    lastTableWidth = width;\n  }\n\n  function loadColWidths() {\n    try {\n      const raw = localStorage.getItem(COL_WIDTHS_KEY);\n      if (!raw) return null;\n      const parsed = JSON.parse(raw);\n      for (const key of columnKeys) {\n        if (typeof parsed[key] !== 'number' || parsed[key] < (minColumnWidth[key] || 0)) return null;\n      }\n      return parsed;\n    } catch {\n      return null;\n    }\n  }\n\n  function saveColWidths() {\n    localStorage.setItem(COL_WIDTHS_KEY, JSON.stringify(colWidths));\n  }\n\n  function updateViewportHeight() {\n    viewportHeight = tableContainer?.clientHeight || 520;\n    syncColumnWidthsToContainer();\n  }\n\n  function scheduleViewportHeightUpdate() {\n    if (viewportResizeRaf !== null) {\n      return;\n    }\n    viewportResizeRaf = requestAnimationFrame(() => {\n      viewportResizeRaf = null;\n      updateViewportHeight();\n    });\n  }\n\n  function startColumnResize(event, leftKey) {\n    event.preventDefault();\n    event.stopPropagation();\n\n    const index = columnKeys.indexOf(leftKey);\n    if (index < 0 || index >= columnKeys.length - 1) {\n      return;\n    }\n\n    const startX = event.clientX;\n    const startLeft = colWidths[leftKey];\n    const rightKey = columnKeys[index + 1];\n    const startRight = colWidths[rightKey];\n\n    resizeCleanup?.();\n    resizingColumn = leftKey;\n\n    const onMove = (moveEvent) => {\n      const delta = Math.round(moveEvent.clientX - startX);\n      if (leftKey === 'name') {\n        // Two-column trade: name and path swap space, each respects its minimum\n        const nextLeft = Math.max(\n          minColumnWidth[leftKey],\n          Math.min(startLeft + delta, startLeft + startRight - minColumnWidth[rightKey])\n        );\n        const nextRight = startLeft + startRight - nextLeft;\n        colWidths = { ...colWidths, [leftKey]: nextLeft, [rightKey]: nextRight };\n      } else {\n        // path splitter: path grows unconstrained (allows horizontal scroll on right drag)\n        const nextLeft = Math.max(minColumnWidth[leftKey], startLeft + delta);\n        colWidths = { ...colWidths, [leftKey]: nextLeft };\n      }\n    };\n\n    const onUp = () => {\n      cleanup();\n    };\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      document.body.style.cursor = '';\n      document.body.style.userSelect = '';\n      resizingColumn = '';\n      saveColWidths();\n      if (resizeCleanup === cleanup) {\n        resizeCleanup = null;\n      }\n    };\n\n    resizeCleanup = cleanup;\n    document.body.style.cursor = 'col-resize';\n    document.body.style.userSelect = 'none';\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  function selectedPaths() {\n    const sorted = [...selectedIndices].sort((a, b) => a - b);\n    return sorted.map((idx) => results[idx]).filter(Boolean).map((entry) => entry.path);\n  }\n\n  function clearSelection() {\n    selectedIndices = new Set();\n    selectionAnchor = -1;\n    lastSelectedIndex = -1;\n  }\n\n  function selectSingle(index) {\n    selectedIndices = new Set([index]);\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectToggle(index) {\n    const next = new Set(selectedIndices);\n    if (next.has(index)) {\n      next.delete(index);\n    } else {\n      next.add(index);\n    }\n    selectedIndices = next;\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectRange(index) {\n    const anchor = selectionAnchor >= 0 ? selectionAnchor : index;\n    const [from, to] = [Math.min(anchor, index), Math.max(anchor, index)];\n    const next = new Set();\n    for (let i = from; i <= to; i += 1) {\n      next.add(i);\n    }\n    selectedIndices = next;\n    lastSelectedIndex = index;\n  }\n\n  function primaryEntry() {\n    const idx = lastSelectedIndex >= 0 ? lastSelectedIndex : -1;\n    return idx >= 0 ? results[idx] : null;\n  }\n\n  async function refreshStatus() {\n    if (statusRefreshInFlight) {\n      return;\n    }\n    statusRefreshInFlight = true;\n    try {\n      const status = await invoke('get_index_status');\n      const prevState = indexStatus.state;\n      indexStatus = {\n        state: status.state,\n        entriesCount: status.entriesCount,\n        lastUpdated: status.lastUpdated,\n        permissionErrors: status.permissionErrors ?? 0,\n        message: status.message\n      };\n      if (status.state === 'Indexing' && prevState !== 'Indexing') {\n        startElapsedTimer();\n      } else if (status.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n      if (typeof status.scanned === 'number') {\n        scanned = status.scanned;\n      }\n      if (status.state === 'Ready' && prevState !== 'Ready') {\n        scheduleSearch();\n      }\n    } catch (err) {\n      showToast(`Failed to get status: ${String(err)}`);\n    } finally {\n      statusRefreshInFlight = false;\n    }\n  }\n\n  function scheduleSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const scheduledGen = searchGeneration;\n    clearTimeout(searchTimer);\n\n    const now = performance.now();\n    if (now - lastSearchFiredAt >= 200) {\n      // Leading edge: fire immediately if enough time has passed\n      lastSearchFiredAt = now;\n      void runSearch(preserveScroll);\n    } else {\n      // Trailing edge: debounce\n      searchTimer = setTimeout(() => {\n        if (scheduledGen !== searchGeneration) {\n          return;\n        }\n        lastSearchFiredAt = performance.now();\n        void runSearch(preserveScroll);\n      }, 200);\n    }\n  }\n\n  async function runSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const gen = searchGeneration;\n    const searchQuery = query;\n    const searchSortBy = sortBy;\n    const searchSortDir = sortDir;\n    const startedAt = performance.now();\n    try {\n      const keepPaths = new Set(selectedPaths());\n      const next = await invoke('search', {\n        query: searchQuery,\n        limit: PAGE_SIZE,\n        offset: 0,\n        sortBy: searchSortBy,\n        sortDir: searchSortDir\n      });\n\n      if (gen !== searchGeneration) return;\n\n      dbLatencyMs = Math.round(performance.now() - startedAt);\n      dbLastQuery = searchQuery;\n      const entries = Array.isArray(next.entries) ? next.entries : [];\n      searchModeLabel = next.modeLabel || '';\n      results = entries;\n      if (next.totalCount > 0) {\n        totalResults = next.totalCount;\n        totalResultsKnown = true;\n      } else {\n        totalResults = entries.length;\n        totalResultsKnown = false;\n      }\n      hasMore = totalResultsKnown ? results.length < totalResults : entries.length >= PAGE_SIZE;\n      if (!preserveScroll && tableContainer) tableContainer.scrollTop = 0;\n\n      const restored = new Set();\n      for (let i = 0; i < results.length; i += 1) {\n        if (keepPaths.has(results[i].path)) {\n          restored.add(i);\n        }\n      }\n      selectedIndices = restored;\n\n      updateViewportHeight();\n    } catch (err) {\n      if (gen !== searchGeneration) return;\n      showToast(`Search failed: ${String(err)}`);\n    }\n  }\n\n  async function loadMore() {\n    if (!hasMore || loadingMore) return;\n    const gen = searchGeneration;\n    loadingMore = true;\n    try {\n      const batch = await invoke('search', {\n        query,\n        limit: PAGE_SIZE,\n        offset: results.length,\n        sortBy: sortBy,\n        sortDir: sortDir\n      });\n      if (gen !== searchGeneration) return;\n      const arr = Array.isArray(batch.entries) ? batch.entries : [];\n      if (arr.length > 0) results = [...results, ...arr];\n      hasMore = totalResultsKnown ? results.length < totalResults : arr.length >= PAGE_SIZE;\n    } catch (err) {\n      showToast(`Failed to load more: ${String(err)}`);\n    } finally {\n      loadingMore = false;\n    }\n  }\n\n  function moveSelection(delta, withRange = false) {\n    if (results.length === 0) {\n      return;\n    }\n\n    const current = lastSelectedIndex >= 0 ? lastSelectedIndex : 0;\n    const next = Math.max(0, Math.min(results.length - 1, current + delta));\n\n    if (withRange) {\n      selectRange(next);\n    } else {\n      selectSingle(next);\n    }\n\n    const top = next * rowHeight;\n    const bottom = top + rowHeight;\n    if (top < scrollTop) {\n      tableContainer.scrollTop = top;\n    } else if (bottom > scrollTop + viewportHeight) {\n      tableContainer.scrollTop = bottom - viewportHeight;\n    }\n  }\n\n  function handleHeaderSort(column) {\n    if (sortBy === column) {\n      sortDir = sortDir === 'asc' ? 'desc' : 'asc';\n    } else {\n      sortBy = column;\n      sortDir = 'asc';\n    }\n    if (tableContainer) tableContainer.scrollTop = 0;\n    void runSearch();\n  }\n\n  function handleRowClick(event, index) {\n    contextMenu.visible = false;\n\n    if (event.shiftKey) {\n      selectRange(index);\n      return;\n    }\n\n    if (event.metaKey || event.ctrlKey) {\n      selectToggle(index);\n      return;\n    }\n\n    selectSingle(index);\n  }\n\n  function handleRowContextMenu(event, index) {\n    event.preventDefault();\n\n    if (!selectedIndices.has(index)) {\n      selectSingle(index);\n    }\n\n    if (platform === 'windows' || platform === 'macos') {\n      contextMenu.visible = false;\n      const paths = selectedPaths();\n      if (paths.length > 0) {\n        invoke('show_context_menu', {\n          paths,\n          x: event.clientX,\n          y: event.clientY,\n          singleSelection: selectedIndices.size === 1\n        });\n      }\n      return;\n    }\n\n    contextMenu = {\n      visible: true,\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n\n  function handleRowA11yKeydown(event, index) {\n    if (event.key === ' ' || event.key === 'Enter') {\n      event.preventDefault();\n      handleRowClick(event, index);\n    }\n  }\n\n  const DRAG_THRESHOLD = 5;\n  let dragCleanup = null;\n  const dragImgCache = new Map();\n\n  function dragPathsForIndex(index) {\n    const entry = results[index];\n    if (!entry) {\n      return [];\n    }\n\n    if (selectedIndices.has(index) && selectedIndices.size > 0) {\n      return selectedPaths();\n    }\n\n    return [entry.path];\n  }\n\n  function getDragIconEl(entry) {\n    const src = iconFor(entry);\n    let img = dragImgCache.get(src);\n    if (!img) {\n      img = new Image();\n      img.src = src;\n      dragImgCache.set(src, img);\n    }\n    return img.complete && img.naturalWidth > 0 ? img : null;\n  }\n\n  function fillRoundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function buildDragPreview(index) {\n    const entry = results[index];\n    if (!entry) return null;\n\n    const count = selectedIndices.has(index) ? selectedIndices.size : 1;\n    const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\n\n    const w = 260;\n    const h = 28;\n    const stackGap = count > 1 ? 4 : 0;\n\n    const canvas = document.createElement('canvas');\n    canvas.width = w;\n    canvas.height = h + stackGap;\n    const ctx = canvas.getContext('2d');\n\n    if (count > 1) {\n      ctx.globalAlpha = 0.35;\n      ctx.fillStyle = isDark ? '#5a6070' : '#b0c4de';\n      fillRoundRect(ctx, 3, 0, w - 3, h, 5);\n      ctx.globalAlpha = 1.0;\n    }\n\n    const ry = stackGap;\n    ctx.fillStyle = isDark ? 'rgba(58, 64, 74, 0.94)' : 'rgba(214, 231, 255, 0.94)';\n    fillRoundRect(ctx, 0, ry, w, h, 5);\n\n    ctx.strokeStyle = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';\n    ctx.lineWidth = 0.5;\n    ctx.beginPath();\n    ctx.moveTo(5, ry);\n    ctx.arcTo(w, ry, w, ry + h, 5);\n    ctx.arcTo(w, ry + h, 0, ry + h, 5);\n    ctx.arcTo(0, ry + h, 0, ry, 5);\n    ctx.arcTo(0, ry, w, ry, 5);\n    ctx.closePath();\n    ctx.stroke();\n\n    const iconEl = getDragIconEl(entry);\n    if (iconEl) {\n      ctx.drawImage(iconEl, 6, ry + 6, 16, 16);\n    } else {\n      ctx.fillStyle = entry.isDir ? '#d9b34f' : '#8d98a5';\n      fillRoundRect(ctx, 6, ry + 6, 16, 16, 2);\n    }\n\n    ctx.fillStyle = isDark ? '#e6e6e8' : '#1a1a1a';\n    ctx.font = '12px -apple-system, \"SF Pro Text\", system-ui, sans-serif';\n    ctx.textBaseline = 'middle';\n\n    let nameMaxW = w - 34;\n    if (count > 1) nameMaxW -= 34;\n\n    let name = entry.name;\n    if (ctx.measureText(name).width > nameMaxW) {\n      while (name.length > 4 && ctx.measureText(name + '\\u2026').width > nameMaxW) {\n        name = name.slice(0, -1);\n      }\n      name += '\\u2026';\n    }\n    ctx.fillText(name, 28, ry + h / 2 + 1);\n\n    if (count > 1) {\n      const badge = String(count);\n      ctx.font = 'bold 10px -apple-system, system-ui, sans-serif';\n      const tw = ctx.measureText(badge).width;\n      const bw = Math.max(20, tw + 10);\n      const bx = w - bw - 6;\n      const by = ry + (h - 18) / 2;\n\n      ctx.fillStyle = isDark ? '#5b8bd9' : '#007aff';\n      fillRoundRect(ctx, bx, by, bw, 18, 9);\n\n      ctx.fillStyle = '#ffffff';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(badge, bx + bw / 2, by + 9);\n    }\n\n    return canvas.toDataURL('image/png');\n  }\n\n  function handleRowMouseDown(event, index) {\n    if (event.button !== 0) return;\n    if (event.metaKey || event.ctrlKey || event.shiftKey) return;\n    if (editing.active) return;\n\n    const startX = event.clientX;\n    const startY = event.clientY;\n    let dragging = false;\n\n    dragCleanup?.();\n\n    const onMove = (e) => {\n      if (dragging) return;\n      const dx = e.clientX - startX;\n      const dy = e.clientY - startY;\n      if (dx * dx + dy * dy < DRAG_THRESHOLD * DRAG_THRESHOLD) return;\n\n      dragging = true;\n      cleanup();\n\n      if (!selectedIndices.has(index)) {\n        selectSingle(index);\n      }\n\n      const paths = dragPathsForIndex(index);\n      if (paths.length > 0) {\n        const icon = buildDragPreview(index);\n        startDrag({ item: paths, icon }).catch(() => {});\n      }\n    };\n\n    const onUp = () => cleanup();\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      if (dragCleanup === cleanup) dragCleanup = null;\n    };\n\n    dragCleanup = cleanup;\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  async function handleRowDoubleClick(index) {\n    if (!selectedIndices.has(index) || selectedIndices.size > 1) {\n      selectSingle(index);\n      await tick();\n    }\n    await invoke('open', { paths: [results[index].path] }).catch((err) => {\n      showToast(`Failed to open: ${String(err)}`);\n    });\n  }\n\n  function closeContextMenu() {\n    contextMenu = {\n      ...contextMenu,\n      visible: false\n    };\n  }\n\n  async function openSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('open', { paths });\n    } catch (err) {\n      showToast(`Failed to open: ${String(err)}`);\n    }\n  }\n\n  async function openWithFallback() {\n    const target = primaryEntry();\n    if (!target) {\n      return;\n    }\n\n    try {\n      await invoke('open_with', { path: target.path });\n    } catch (err) {\n      showToast(`Open With failed: ${String(err)}`);\n    }\n  }\n\n  async function revealSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('reveal_in_finder', { paths });\n    } catch (err) {\n      showToast(`Failed to reveal in Finder: ${String(err)}`);\n    }\n  }\n\n  async function copySelectedPaths() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_paths', { paths });\n      showToast(`Copied ${paths.length} path(s)`);\n    } catch (err) {\n      showToast(`Failed to copy path: ${String(err)}`);\n    }\n  }\n\n  async function copyFiles() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_files', { paths });\n      showToast(`Copied ${paths.length} item(s)`);\n    } catch (err) {\n      showToast(`Failed to copy: ${String(err)}`);\n    }\n  }\n\n  async function trashSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    const message =\n      paths.length === 1\n        ? 'Move selected item to Trash?'\n        : `Move ${paths.length} items to Trash?`;\n\n    if (!window.confirm(message)) {\n      return;\n    }\n\n    try {\n      await invoke('move_to_trash', { paths });\n      showToast('Moved to Trash.');\n      clearSelection();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to move to Trash: ${String(err)}`);\n    }\n  }\n\n  async function resetIndex() {\n    if (indexStatus.state === 'Indexing') {\n      showToast('Indexing in progress. Please try again after it completes.');\n      return;\n    }\n\n    results = [];\n    totalResults = 0;\n    totalResultsKnown = false;\n    clearSelection();\n    scanned = 0;\n    dbLatencyMs = null;\n    dbLastQuery = '';\n    indexStatus = { ...indexStatus, state: 'Indexing', entriesCount: 0, message: null };\n    indexingStartTime = Date.now();\n    indexingElapsed = '';\n    indexingFinishedAt = '';\n\n    try {\n      await invoke('reset_index');\n    } catch (err) {\n      showToast(`Failed to reset index: ${String(err)}`);\n      await refreshStatus();\n    }\n  }\n\n  function isMultiSelected() {\n    return selectedIndices.size > 1;\n  }\n\n  async function startRename() {\n    if (isMultiSelected()) {\n      return;\n    }\n\n    const idx = lastSelectedIndex;\n    if (idx < 0 || !results[idx]) {\n      return;\n    }\n\n    const entry = results[idx];\n    editing = {\n      active: true,\n      path: entry.path,\n      index: idx,\n      draftName: entry.name\n    };\n\n    await tick();\n\n    if (renameInputEl) {\n      renameInputEl.focus();\n      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n      renameInputEl.setSelectionRange(0, selectionEnd);\n    }\n  }\n\n  function cancelRename() {\n    editing = {\n      active: false,\n      path: '',\n      index: -1,\n      draftName: ''\n    };\n  }\n\n  async function commitRename() {\n    if (!editing.active || editing.index < 0 || !results[editing.index]) {\n      return;\n    }\n\n    const current = results[editing.index];\n    const nextName = editing.draftName;\n\n    try {\n      await invoke('rename', {\n        path: current.path,\n        newName: nextName\n      });\n      cancelRename();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to rename: ${String(err)}`);\n      await tick();\n      renameInputEl?.focus();\n    }\n  }\n\n  function onGlobalClick() {\n    closeContextMenu();\n  }\n\n  function onTitleBarMouseDown(event) {\n    if (event.button !== 0) {\n      return;\n    }\n\n    const activeElement = document.activeElement;\n    if (activeElement instanceof HTMLElement && isTextInputTarget(activeElement)) {\n      activeElement.blur();\n    }\n  }\n\n  async function focusSearch() {\n    await getCurrentWindow().show();\n    await getCurrentWindow().setFocus();\n    searchInputEl?.focus();\n    searchInputEl?.select();\n  }\n\n  function isTextInputTarget(target) {\n    return (\n      target instanceof HTMLInputElement ||\n      target instanceof HTMLTextAreaElement ||\n      target?.isContentEditable\n    );\n  }\n\n  async function handleKeydown(event) {\n    const isMetaSelectAll = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'a';\n    const isMetaCopy = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c';\n    const target = event.target;\n    const isTextInput = isTextInputTarget(target);\n\n    if (isMetaCopy && isTextInput) {\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      if (isTextInput) {\n        event.preventDefault();\n        if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n          target.select();\n        }\n        return;\n      }\n    }\n\n    if (editing.active) {\n      if (event.key === 'Enter') {\n        event.preventDefault();\n        await commitRename();\n        return;\n      }\n\n      if (event.key === 'Escape') {\n        event.preventDefault();\n        cancelRename();\n        searchInputEl?.focus();\n        return;\n      }\n      return;\n    }\n\n    if (event.key === 'Escape') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      return;\n    }\n\n    if (event.key === 'ArrowDown') {\n      event.preventDefault();\n      moveSelection(1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'ArrowUp') {\n      event.preventDefault();\n      moveSelection(-1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageDown') {\n      event.preventDefault();\n      moveSelection(Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageUp') {\n      event.preventDefault();\n      moveSelection(-Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'Enter') {\n      event.preventDefault();\n      if (platform === 'windows') {\n        await openSelected();\n      } else {\n        await startRename();\n      }\n      return;\n    }\n\n    if (event.key === 'F2') {\n      event.preventDefault();\n      await startRename();\n      return;\n    }\n\n    if (event.key === ' ' && !isTextInput) {\n      event.preventDefault();\n      const entry = primaryEntry();\n      if (entry) {\n        await invoke('quick_look', { path: entry.path });\n      }\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'f') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      searchInputEl?.select();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'o') {\n      event.preventDefault();\n      await openSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {\n      event.preventDefault();\n      await revealSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c') {\n      event.preventDefault();\n      await copySelectedPaths();\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      event.preventDefault();\n      selectedIndices = new Set(Array.from({ length: results.length }, (_, i) => i));\n      return;\n    }\n\n    if (event.key === 'Delete' || ((event.metaKey || event.ctrlKey) && event.key === 'Backspace')) {\n      if (!isTextInput) {\n        event.preventDefault();\n        await trashSelected();\n      }\n      return;\n    }\n  }\n\n  function formatSize(entry) {\n    if (entry.isDir || entry.size == null) return '';\n    const bytes = entry.size;\n    if (bytes < 1024) return `${bytes} B`;\n    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n    return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n  }\n\n  function formatModified(entry) {\n    if (!entry.mtime) {\n      return '';\n    }\n\n    const d = new Date(entry.mtime * 1000);\n    const pad = (n) => String(n).padStart(2, '0');\n    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;\n  }\n\n  function formatLastUpdated(timestamp) {\n    if (!timestamp) {\n      return '-';\n    }\n\n    return new Date(timestamp * 1000).toLocaleString();\n  }\n\n  function formatElapsed(ms) {\n    const totalSec = Math.floor(ms / 1000);\n    const min = Math.floor(totalSec / 60);\n    const sec = totalSec % 60;\n    return min > 0 ? `${min}m ${sec}s` : `${sec}s`;\n  }\n\n  function updateElapsed() {\n    if (indexingStartTime && indexStatus.state === 'Indexing') {\n      indexingElapsed = formatElapsed(Date.now() - indexingStartTime);\n    }\n  }\n\n  function startElapsedTimer() {\n    clearInterval(elapsedTimer);\n    indexingStartTime = Date.now();\n    indexingElapsed = '0s';\n    indexingFinishedAt = '';\n    elapsedTimer = setInterval(updateElapsed, 1000);\n  }\n\n  function stopElapsedTimer() {\n    clearInterval(elapsedTimer);\n    if (indexingStartTime) {\n      const elapsed = Date.now() - indexingStartTime;\n      indexingFinishedAt = `${formatElapsed(elapsed)}`;\n    }\n    indexingStartTime = null;\n    indexingElapsed = '';\n  }\n\n  function displayPath(path) {\n    if (!path) {\n      return path;\n    }\n\n    if (!homePrefix) {\n      return path;\n    }\n\n    if (path === homePrefix) {\n      return '~';\n    }\n\n    if (path.startsWith(`${homePrefix}/`)) {\n      return `~${path.slice(homePrefix.length)}`;\n    }\n\n    return path;\n  }\n\n  let unlistenFns = [];\n\n  onMount(async () => {\n    const t0 = performance.now();\n    const ms = () => Math.round(performance.now() - t0);\n    const DEBUG_STARTUP = false;\n    const flog = DEBUG_STARTUP ? (msg) => invoke('frontend_log', { msg }).catch(() => {}) : () => {};\n\n    flog(`[startup/fe] onMount entered`);\n\n    updateViewportHeight();\n    flog(`[startup/fe] +${ms()}ms updateViewportHeight done`);\n\n    platform = await invoke('get_platform');\n    flog(`[startup/fe] +${ms()}ms get_platform done`);\n\n    const unlistenProgress = await listen('index_progress', (event) => {\n      scanned = event.payload.scanned;\n      if (indexStatus.state !== 'Indexing') {\n        indexStatus = {\n          ...indexStatus,\n          state: 'Indexing'\n        };\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_progress) registered`);\n\n    const unlistenState = await listen('index_state', (event) => {\n      flog(`[startup/fe] index_state event received: ${event.payload.state} at +${ms()}ms`);\n      const prevState = indexStatus.state;\n      indexStatus = {\n        ...indexStatus,\n        state: event.payload.state,\n        message: event.payload.message ?? null,\n        isCatchup: event.payload.isCatchup ?? false\n      };\n\n      if (event.payload.state === 'Indexing' && prevState !== 'Indexing') {\n        if (prevState === 'Ready') {\n          lastReadyCount = indexStatus.entriesCount;\n        }\n        startElapsedTimer();\n      } else if (event.payload.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n\n      if (event.payload.state === 'Ready') {\n        scheduleSearch();\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_state) registered`);\n\n    const unlistenUpdated = await listen('index_updated', (event) => {\n      indexStatus = {\n        ...indexStatus,\n        entriesCount: event.payload.entriesCount,\n        lastUpdated: event.payload.lastUpdated,\n        permissionErrors: event.payload.permissionErrors ?? indexStatus.permissionErrors\n      };\n\n      scheduleSearch(true);\n    });\n\n    const unlistenFocus = await listen('focus_search', () => {\n      void focusSearch();\n    });\n\n    const unlistenCtxMenuAction = await listen('context_menu_action', (event) => {\n      switch (event.payload) {\n        case 'open': void openSelected(); break;\n        case 'quick_look': {\n          const e = primaryEntry();\n          if (e) void invoke('quick_look', { path: e.path });\n          break;\n        }\n        case 'open_with': void openWithFallback(); break;\n        case 'reveal': void revealSelected(); break;\n        case 'copy_files': void copyFiles(); break;\n        case 'copy_path': void copySelectedPaths(); break;\n        case 'trash': void trashSelected(); break;\n        case 'rename': void startRename(); break;\n      }\n    });\n\n    unlistenFns = [unlistenProgress, unlistenState, unlistenUpdated, unlistenFocus, unlistenCtxMenuAction];\n    flog(`[startup/fe] +${ms()}ms all listeners registered`);\n\n    // Fetch backend state IMMEDIATELY after listeners are registered.\n    // Events emitted before listener registration are lost, so this\n    // is the only reliable way to get the current state.\n    await refreshStatus();\n    flog(`[startup/fe] +${ms()}ms refreshStatus done (state=${indexStatus.state})`);\n\n    // Show Svelte UI: remove skeleton, focus search input.\n    await tick();\n    document.getElementById('skeleton')?.remove();\n    await focusSearch();\n    flog(`[startup/fe] +${ms()}ms WINDOW VISIBLE — skeleton removed`);\n\n    try {\n      homePrefix = await invoke('get_home_dir');\n    } catch {\n      homePrefix = '';\n    }\n    flog(`[startup/fe] +${ms()}ms get_home_dir done`);\n\n    if (!localStorage.getItem('everything-fda-notice-v1')) {\n      showToast('macOS Full Disk Access permission may be required for full disk search.');\n      localStorage.setItem('everything-fda-notice-v1', '1');\n    }\n    flog(`[startup/fe] +${ms()}ms calling runSearch...`);\n    await runSearch();\n    flog(`[startup/fe] +${ms()}ms runSearch done`);\n\n    if (typeof ResizeObserver !== 'undefined') {\n      tableResizeObserver = new ResizeObserver(() => {\n        scheduleViewportHeightUpdate();\n      });\n      if (tableContainer) {\n        tableResizeObserver.observe(tableContainer);\n      } else if (tableAreaEl) {\n        tableResizeObserver.observe(tableAreaEl);\n      }\n    }\n\n    window.addEventListener('resize', scheduleViewportHeightUpdate);\n    window.addEventListener('click', onGlobalClick);\n    statusRefreshTimer = setInterval(() => {\n      if (indexStatus.state === 'Indexing') {\n        void refreshStatus();\n      }\n    }, 1000);\n    console.log(`[startup/fe] +${ms()}ms onMount complete`);\n  });\n\n  onDestroy(async () => {\n    clearTimeout(searchTimer);\n    clearTimeout(toastTimer);\n    clearInterval(statusRefreshTimer);\n    clearInterval(elapsedTimer);\n    resizeCleanup?.();\n\n    for (const unlisten of unlistenFns) {\n      unlisten();\n    }\n\n    tableResizeObserver?.disconnect();\n    tableResizeObserver = null;\n    if (viewportResizeRaf !== null) {\n      cancelAnimationFrame(viewportResizeRaf);\n      viewportResizeRaf = null;\n    }\n    window.removeEventListener('resize', scheduleViewportHeightUpdate);\n    window.removeEventListener('click', onGlobalClick);\n  });\n</script>\n\n<svelte:window on:keydown={handleKeydown} />\n\n<div class=\"app-shell\" data-theme={theme}>\n  <div class=\"title-bar\" role=\"presentation\" data-tauri-drag-region on:mousedown={onTitleBarMouseDown}>\n    <div class=\"title-left\"></div>\n    <div class=\"title-center\">\n      <svg class=\"title-icon\" viewBox=\"0 0 215 205\" fill-rule=\"evenodd\" aria-hidden=\"true\">\n        <path d=\"M85 0c46.9 0 85 38.1 85 85 0 20.1-7.2 38.5-19.2 52.7l40.7 40.8c5.8 5.8 5.8 15.2 0 21-5.8 5.8-15.2 5.8-21 0l-40.7-40.7c-13.6 9.7-30.4 15.2-44.8 15.2-46.9 0-85-42.1-85-89 0-46.9 38.1-85 85-85z m0 32c-29.3 0-53 23.7-53 53 0 29.3 23.7 53 53 53 29.3 0 53-23.7 53-53 0-29.3-23.7-53-53-53z\"/>\n      </svg>\n      <span class=\"title-text\">Everything</span>\n    </div>\n    <div class=\"title-right\"></div>\n  </div>\n\n  <header class=\"search-bar\">\n    <input\n      bind:this={searchInputEl}\n      class=\"search-input\"\n      type=\"text\"\n      bind:value={query}\n      on:input={scheduleSearch}\n      on:focus={clearSelection}\n      placeholder=\"Search file/folder names\"\n      autocomplete=\"off\"\n      spellcheck=\"false\"\n    />\n  </header>\n\n  <section class=\"table-area\" bind:this={tableAreaEl} style={tableGridStyle}>\n    <div class=\"table-header\">\n      <div class=\"table-header-track\">\n        <div class=\"col name\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('name')}>\n            Name{#if sortBy === 'name'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'name'}\n            on:mousedown={(event) => startColumnResize(event, 'name')}\n            aria-label=\"Resize Name column\"\n          />\n        </div>\n\n        <div class=\"col path\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('dir')}>\n            Path{#if sortBy === 'dir'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'path'}\n            on:mousedown={(event) => startColumnResize(event, 'path')}\n            aria-label=\"Resize Path column\"\n          />\n        </div>\n\n        <div class=\"col size\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('size')}>\n            Size{#if sortBy === 'size'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n\n        <div class=\"col modified\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('mtime')}>\n            Modified{#if sortBy === 'mtime'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n      </div>\n    </div>\n\n    <div\n      class=\"table-body\"\n      bind:this={tableContainer}\n      on:scroll={() => {\n        scrollTop = tableContainer.scrollTop;\n        headerScrollLeft = tableContainer.scrollLeft;\n        const scrollBottom = scrollTop + tableContainer.clientHeight;\n        if (scrollBottom >= totalHeight - rowHeight * 10) {\n          void loadMore();\n        }\n      }}\n    >\n      <div class=\"spacer\" style={`height:${totalHeight}px`}>\n        <div class=\"rows\" style={`transform: translateY(${translateY}px);`}>\n          {#each visibleRows as entry, localIndex}\n            {@const index = startIndex + localIndex}\n            <div\n              class=\"row {selectedIndices.has(index) ? 'selected' : ''} {editing.active && editing.index === index ? 'renaming' : ''}\"\n              on:mousedown={(event) => handleRowMouseDown(event, index)}\n              on:click={(event) => handleRowClick(event, index)}\n              on:keydown={(event) => handleRowA11yKeydown(event, index)}\n              on:dblclick={() => handleRowDoubleClick(index)}\n              on:contextmenu={(event) => handleRowContextMenu(event, index)}\n              role=\"row\"\n              tabindex=\"0\"\n            >\n              <div class=\"cell name\">\n                <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n\n                {#if editing.active && editing.index === index}\n                  <input\n                    bind:this={renameInputEl}\n                    class=\"rename-input\"\n                    type=\"text\"\n                    bind:value={editing.draftName}\n                    on:click|stopPropagation\n                    on:blur={commitRename}\n                  />\n                {:else}\n                  <span class=\"ellipsis\">{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n                {/if}\n              </div>\n              <div class=\"cell path\"><span class=\"ellipsis\">{displayPath(entry.dir)}</span></div>\n              <div class=\"cell size\">{formatSize(entry)}</div>\n              <div class=\"cell modified\">{formatModified(entry)}</div>\n            </div>\n          {/each}\n        </div>\n      </div>\n    </div>\n  </section>\n\n  <footer class=\"status-bar\">\n    <div class=\"status-left\">\n      <span class=\"status-state\">\n        <span class=\"state-dot {indexStatus.state === 'Indexing' ? 'indexing' : indexStatus.state === 'Error' ? 'error' : 'ready'}\"></span>\n        {#if indexStatus.state === 'Indexing'}\n          Indexing{#if lastReadyCount > 0} ({Math.min(99, Math.round((scanned / lastReadyCount) * 100))}%){/if}{#if indexingElapsed} · {indexingElapsed}{/if}\n          {#if !indexStatus.isCatchup}\n            · {scanned.toLocaleString()} scanned\n          {/if}\n        {:else}\n          Index: {indexStatus.state}\n        {/if}\n      </span>\n      <span>{indexStatus.entriesCount.toLocaleString()} entries</span>\n      {#if indexingFinishedAt && indexStatus.state !== 'Indexing'}\n        <span>in {indexingFinishedAt}</span>\n      {/if}\n      {#if dbLatencyMs !== null && dbLastQuery}\n        <span>\"{dbLastQuery}\" {dbLatencyMs}ms · {totalResults} results</span>\n      {/if}\n      {#if searchModeLabel === 'spotlight' || searchModeLabel === 'spotlight_timeout'}\n        <span class=\"status-spotlight\">Spotlight fallback{#if searchModeLabel === 'spotlight_timeout'} (partial){/if}</span>\n      {/if}\n      {#if indexStatus.permissionErrors > 0}\n        <span class=\"status-warning\">{indexStatus.permissionErrors.toLocaleString()} permission errors</span>\n      {/if}\n      {#if indexStatus.message}\n        <span class={indexStatus.isCatchup ? 'index-progress' : 'status-error'}>{indexStatus.message}</span>\n      {/if}\n    </div>\n    <div class=\"status-right\">\n      <button class=\"status-btn theme-btn\" on:click={cycleTheme} title=\"Switch theme\">\n        {theme === 'dark' ? '☀ Light' : '◑ Dark'}\n      </button>\n      <button\n        class=\"status-btn rebuild-btn\"\n        on:click={resetIndex}\n        disabled={indexStatus.state === 'Indexing'}\n        title={indexStatus.state === 'Indexing' ? 'Cannot reset while indexing is in progress.' : 'Reset and rebuild the index.'}\n      >\n        <svg class=\"rebuild-icon\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n          <path d=\"M23 4v6h-6\"/><path d=\"M20.49 15a9 9 0 1 1-2.12-9.36L23 10\"/>\n        </svg>\n        Rebuild Index\n      </button>\n    </div>\n  </footer>\n\n  {#if contextMenu.visible}\n    <div class=\"context-menu\" style={`left:${contextMenu.x}px;top:${contextMenu.y}px;`}>\n      <button on:click={() => (closeContextMenu(), openSelected())}>Open</button>\n      <button on:click={async () => { closeContextMenu(); const e = primaryEntry(); if (e) await invoke('quick_look', { path: e.path }); }}>Quick Look</button>\n      <button on:click={() => (closeContextMenu(), openWithFallback())}>Open With... (Reveal in Finder)</button>\n      <button on:click={() => (closeContextMenu(), revealSelected())}>Reveal in Finder</button>\n      <button on:click={() => (closeContextMenu(), copySelectedPaths())}>Copy Path</button>\n      <button on:click={() => (closeContextMenu(), trashSelected())}>Move to Trash</button>\n      {#if selectedIndices.size === 1}\n        <button on:click={() => (closeContextMenu(), startRename())}>Rename</button>\n      {/if}\n    </div>\n  {/if}\n\n  {#if toast}\n    <div class=\"toast\">{toast}</div>\n  {/if}\n</div>\n\n<style>\n  :global(:root) {\n    color-scheme: light dark;\n    --bg-app: transparent;\n    --text-primary: #0d1826;\n    --text-muted: #48596c;\n    --bar-grad-top: rgba(255, 255, 255, 0.48);\n    --bar-grad-bottom: rgba(248, 250, 253, 0.42);\n    --surface-header: rgba(252, 252, 255, 0.40);\n    --surface: rgba(255, 255, 255, 0.22);\n    --border-soft: rgba(0, 0, 0, 0.07);\n    --border-input: rgba(0, 0, 0, 0.13);\n    --focus-ring: #6f96e6;\n    --row-border: rgba(0, 0, 0, 0.032);\n    --row-hover: rgba(0, 0, 0, 0.06);\n    --row-selected: rgba(0, 0, 0, 0.12);\n    --button-bg: rgba(255, 255, 255, 0.62);\n    --button-border: rgba(0, 0, 0, 0.10);\n    --button-text: #2c3e50;\n    --menu-bg: rgba(240, 241, 248, 0.90);\n    --menu-border: rgba(0, 0, 0, 0.06);\n    --menu-hover: rgba(255, 255, 255, 0.62);\n    --menu-text: #1a2a38;\n    --error-text: #b64545;\n    --warning-text: #8f6500;\n    --toast-bg: rgba(18, 22, 32, 0.90);\n    --toast-text: #ffffff;\n  }\n\n  @media (prefers-color-scheme: dark) {\n    :global(:root) {\n      --bg-app: transparent;\n      --text-primary: #e6e6ea;\n      --text-muted: #9494a4;\n      --bar-grad-top: rgba(38, 38, 46, 0.52);\n      --bar-grad-bottom: rgba(30, 30, 38, 0.46);\n      --surface-header: rgba(32, 32, 40, 0.46);\n      --surface: rgba(18, 18, 26, 0.32);\n      --border-soft: rgba(255, 255, 255, 0.065);\n      --border-input: rgba(255, 255, 255, 0.14);\n      --focus-ring: #5b8bd9;\n      --row-border: rgba(255, 255, 255, 0.026);\n      --row-hover: rgba(255, 255, 255, 0.08);\n      --row-selected: rgba(255, 255, 255, 0.14);\n      --button-bg: rgba(255, 255, 255, 0.072);\n      --button-border: rgba(255, 255, 255, 0.11);\n      --button-text: #d6d6e0;\n      --menu-bg: rgba(36, 36, 46, 0.90);\n      --menu-border: rgba(255, 255, 255, 0.066);\n      --menu-hover: rgba(255, 255, 255, 0.062);\n      --menu-text: #e0e0e8;\n      --error-text: #ff9d9d;\n      --warning-text: #e0c670;\n      --toast-bg: rgba(10, 10, 16, 0.93);\n      --toast-text: #f2f2f6;\n    }\n  }\n\n  /* ── Theme: Dark ──────────────────────────────────────────────── */\n  :global([data-theme=\"dark\"]) {\n    color-scheme: dark;\n    --bg-app: #1E1E21;\n    --text-primary: #E2E8F0;\n    --text-muted: #94A3B8;\n    --bar-grad-top: #1E1E21;\n    --bar-grad-bottom: #1E1E21;\n    --surface-header: #1E1E21;\n    --surface: #1E1E21;\n    --bg-input: #161618;\n    --border-soft: #2A2A2D;\n    --border-input: rgba(255, 255, 255, 0.06);\n    --focus-ring: #4DA8FF;\n    --accent: #4DA8FF;\n    --row-border: rgba(255, 255, 255, 0.02);\n    --row-hover: #282828;\n    --row-selected: rgba(77, 168, 255, 0.10);\n    --button-bg: rgba(255, 255, 255, 0.05);\n    --button-border: #2A2A2D;\n    --button-text: #94A3B8;\n    --menu-bg: #252528;\n    --menu-border: #2A2A2D;\n    --menu-hover: rgba(255, 255, 255, 0.04);\n    --menu-text: #E2E8F0;\n    --error-text: #ff9d9d;\n    --warning-text: #e0c670;\n    --toast-bg: rgba(10, 10, 16, 0.93);\n    --toast-text: #f2f2f6;\n  }\n\n  /* ── Theme: Light ─────────────────────────────────────────────── */\n  :global([data-theme=\"light\"]) {\n    color-scheme: light;\n    --bg-app: #F5F5F7;\n    --text-primary: #1C1C1E;\n    --text-muted: #6E6E7A;\n    --bar-grad-top: #F5F5F7;\n    --bar-grad-bottom: #F5F5F7;\n    --surface-header: #F5F5F7;\n    --surface: #F5F5F7;\n    --bg-input: #FFFFFF;\n    --border-soft: #D1D1D6;\n    --border-input: rgba(0, 0, 0, 0.10);\n    --focus-ring: #3A8BF5;\n    --accent: #3A8BF5;\n    --row-border: rgba(0, 0, 0, 0.04);\n    --row-hover: rgba(0, 0, 0, 0.04);\n    --row-selected: rgba(58, 139, 245, 0.10);\n    --button-bg: #FFFFFF;\n    --button-border: #D1D1D6;\n    --button-text: #3C3C43;\n    --menu-bg: #FFFFFF;\n    --menu-border: #D1D1D6;\n    --menu-hover: rgba(0, 0, 0, 0.05);\n    --menu-text: #1C1C1E;\n    --error-text: #D93025;\n    --warning-text: #B45309;\n    --toast-bg: rgba(255, 255, 255, 0.95);\n    --toast-text: #1C1C1E;\n  }\n\n  /* ── Themed element overrides ─────────────────────────────────── */\n  :global([data-theme]) {\n    background: var(--bg-app);\n  }\n\n  /* Search bar: flat, no gradient, no separator */\n  :global([data-theme]) .search-bar {\n    height: 44px;\n    padding: 0 16px;\n    background: var(--bg-app);\n    border-bottom: none;\n  }\n\n  :global([data-theme]) .search-input {\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n    font-family: 'JetBrains Mono', 'SF Mono', monospace;\n    font-size: 12px;\n    height: 34px;\n    border-radius: 8px;\n  }\n\n  /* Table header: flat bg, 16px edge padding */\n  :global([data-theme]) .table-header {\n    background: var(--bg-app);\n  }\n\n  :global([data-theme]) .col-button {\n    padding: 0 8px;\n  }\n\n  :global([data-theme]) .col.name .col-button {\n    padding-left: 16px;\n  }\n\n  /* Row cells: JetBrains Mono, 16px outer edges */\n  :global([data-theme]) .cell {\n    font-family: 'JetBrains Mono', monospace;\n  }\n\n  :global([data-theme]) .cell.name {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    padding-left: 16px;\n    font-size: 12px;\n    color: var(--text-primary);\n  }\n\n  :global([data-theme]) .cell.path {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.size {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.modified {\n    padding-right: 16px;\n    font-size: 11px;\n    white-space: nowrap;\n  }\n\n  :global([data-theme]) .row.selected {\n    box-shadow: inset 3px 0 0 var(--accent);\n  }\n\n  /* Dim path/size/date cells in themed mode */\n  :global([data-theme]) .cell.path,\n  :global([data-theme]) .cell.size,\n  :global([data-theme]) .cell.modified {\n    color: var(--text-muted);\n  }\n\n  :global(:root) {\n    background: transparent;\n  }\n\n  :global(html, body) {\n    margin: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    background: transparent;\n    color: var(--text-primary);\n    font-family: Inter, 'SF Pro Text', 'Segoe UI', Helvetica, Arial, sans-serif;\n  }\n\n  :global(#app) {\n    width: 100%;\n    height: 100%;\n  }\n\n  .app-shell {\n    display: grid;\n    grid-template-rows: auto auto 1fr auto;\n    height: 100%;\n    min-width: 0;\n  }\n\n  .title-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 44px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    cursor: default;\n    flex-shrink: 0;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-left {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-center {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-right {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-icon {\n    width: 14px;\n    height: 14px;\n    fill: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .title-text {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 13px;\n    font-weight: 500;\n    color: var(--text-primary);\n    letter-spacing: -0.01em;\n  }\n\n  .search-bar {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding: 8px;\n    background: linear-gradient(180deg, var(--bar-grad-top) 0%, var(--bar-grad-bottom) 100%);\n    border-bottom: 1px solid var(--border-soft);\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .search-input {\n    display: block;\n    box-sizing: border-box;\n    width: 100%;\n    min-width: 0;\n    flex: 1 1 auto;\n    height: 36px;\n    border: 1px solid var(--border-input);\n    border-radius: 14px;\n    padding: 0 10px;\n    font-size: 14px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    backdrop-filter: blur(12px) saturate(160%);\n    -webkit-backdrop-filter: blur(12px) saturate(160%);\n  }\n\n  .search-input::placeholder {\n    color: var(--text-muted);\n    opacity: 0.85;\n    font-size: 12px;\n  }\n\n  .search-input:focus {\n    outline: none;\n    border-color: var(--focus-ring);\n    box-shadow: 0 0 0 2px rgba(125, 169, 255, 0.25);\n  }\n\n  .table-area {\n    display: grid;\n    grid-template-rows: auto 1fr;\n    min-height: 0;\n    min-width: 0;\n  }\n\n  .table-header-track,\n  .row {\n    display: grid;\n    grid-template-columns: var(--col-name) var(--col-path) var(--col-size) var(--col-modified);\n    align-items: center;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .table-header {\n    height: 32px;\n    border-bottom: 1px solid var(--border-soft);\n    background: var(--surface-header);\n    user-select: none;\n    overflow: hidden;\n    flex-shrink: 0;\n  }\n\n  .table-header-track {\n    height: 100%;\n    transform: translateX(var(--header-offset, 0px));\n    will-change: transform;\n  }\n\n  .table-header .col {\n    position: relative;\n    min-width: 0;\n    height: 100%;\n  }\n\n  .col-button {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n    gap: 4px;\n    box-sizing: border-box;\n    padding: 0 8px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 11px;\n    font-weight: 600;\n    line-height: 1;\n    color: var(--text-muted);\n    text-align: left;\n    margin: 0;\n    border: none;\n    background: transparent;\n    cursor: pointer;\n  }\n\n  .sort-icon {\n    width: 10px;\n    height: 10px;\n    flex-shrink: 0;\n    color: var(--accent);\n  }\n\n  .col-resizer {\n    position: absolute;\n    top: 0;\n    right: -4px;\n    width: 8px;\n    height: 100%;\n    border: none;\n    padding: 0;\n    background: transparent;\n    cursor: col-resize;\n    z-index: 30;\n  }\n\n  .col-resizer::after {\n    content: '';\n    position: absolute;\n    top: 7px;\n    bottom: 7px;\n    left: 50%;\n    width: 1px;\n    transform: translateX(-50%);\n    background: var(--border-soft);\n    opacity: 0;\n    transition: opacity 0.15s ease;\n  }\n\n  .table-header .col:hover .col-resizer::after,\n  .col-resizer.active::after {\n    opacity: 1;\n  }\n\n  .table-body {\n    overflow: auto;\n    min-height: 0;\n    min-width: 0;\n    background: var(--surface);\n  }\n\n  .spacer {\n    position: relative;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .rows {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .row {\n    height: 30px;\n    border-bottom: 1px solid var(--row-border);\n    cursor: default;\n    -webkit-user-select: none;\n    user-select: none;\n    outline: none;\n  }\n\n  .row:hover {\n    background: var(--row-hover);\n  }\n\n  .row.selected {\n    background: var(--row-selected);\n  }\n\n  .cell {\n    padding: 0 8px;\n    font-size: 12px;\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    min-width: 0;\n  }\n\n  .cell.size {\n    text-align: right;\n    font-variant-numeric: tabular-nums;\n  }\n\n  .ellipsis {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n\n  .hl {\n    background: none;\n    color: inherit;\n    font-weight: 700;\n  }\n\n  .file-icon {\n    width: 16px;\n    height: 16px;\n    flex: 0 0 auto;\n  }\n\n  .rename-input {\n    flex: 1;\n    min-width: 0;\n    height: 22px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 12px;\n    padding: 0 6px;\n    border: 1.5px solid var(--focus-ring);\n    border-radius: 4px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    outline: none;\n    box-shadow: 0 1px 6px rgba(0, 0, 0, 0.18), 0 0 0 3px rgba(77, 168, 255, 0.12);\n  }\n\n  .status-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 32px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    border-top: 1px solid var(--border-soft);\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 11px;\n    color: var(--text-muted);\n    white-space: nowrap;\n    overflow: hidden;\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .status-left {\n    display: flex;\n    align-items: center;\n    gap: 16px;\n    overflow: hidden;\n    min-width: 0;\n  }\n\n  .status-right {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    flex-shrink: 0;\n  }\n\n  .status-btn {\n    border: 1px solid var(--button-border);\n    border-radius: 5px;\n    background: var(--button-bg);\n    color: var(--button-text);\n    font-size: 11px;\n    height: 22px;\n    padding: 0 8px;\n    cursor: pointer;\n  }\n\n  .status-btn:hover {\n    filter: brightness(1.06);\n  }\n\n  .status-btn:disabled {\n    opacity: 0.55;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .status-state {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n  }\n\n  .state-dot {\n    width: 6px;\n    height: 6px;\n    border-radius: 50%;\n    flex-shrink: 0;\n  }\n\n  .state-dot.ready { background: #28C840; }\n  .state-dot.indexing { background: #FEBC2E; }\n  .state-dot.error { background: #FF5F57; }\n\n  .rebuild-btn {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 10px;\n    font-weight: 500;\n    background: var(--button-bg);\n    border: 1px solid var(--button-border);\n    border-radius: 4px;\n    color: var(--button-text);\n    height: 22px;\n    padding: 0 10px;\n    cursor: pointer;\n  }\n\n  .rebuild-btn:hover {\n    filter: brightness(1.1);\n  }\n\n  .rebuild-btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .rebuild-icon {\n    width: 11px;\n    height: 11px;\n    color: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .status-error {\n    color: var(--error-text);\n  }\n\n  .status-warning {\n    color: var(--warning-text);\n  }\n\n  .status-spotlight {\n    color: #f59e0b;\n    font-weight: 600;\n  }\n\n  .context-menu {\n    position: fixed;\n    z-index: 200;\n    width: 220px;\n    border: 1px solid var(--menu-border);\n    border-radius: 10px;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.16), inset 0 0 0 0.5px rgba(255, 255, 255, 0.18);\n    background: var(--menu-bg);\n    backdrop-filter: blur(28px) saturate(180%);\n    -webkit-backdrop-filter: blur(28px) saturate(180%);\n    overflow: hidden;\n  }\n\n  .context-menu button {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    padding: 8px 10px;\n    font-size: 12px;\n    color: var(--menu-text);\n  }\n\n  .context-menu button:hover {\n    background: var(--menu-hover);\n  }\n\n  .toast {\n    position: fixed;\n    right: 14px;\n    bottom: 18px;\n    background: var(--toast-bg);\n    color: var(--toast-text);\n    border-radius: 10px;\n    padding: 9px 12px;\n    font-size: 12px;\n    z-index: 250;\n    backdrop-filter: blur(20px) saturate(180%);\n    -webkit-backdrop-filter: blur(20px) saturate(180%);\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);\n  }\n</style>\n","structuredPatch":[{"oldStart":932,"oldLines":6,"newStart":932,"newLines":12,"lines":["     return selectedIndices.size > 1;","   }"," ","+  function autoResizeRenameInput() {","+    if (!renameInputEl) return;","+    renameInputEl.style.height = '0';","+    renameInputEl.style.height = renameInputEl.scrollHeight + 'px';","+  }","+","   async function startRename() {","     if (isMultiSelected()) {","       return;"]},{"oldStart":943,"oldLines":6,"newStart":949,"newLines":26,"lines":["     }"," ","     const entry = results[idx];","+","+    // Calculate overlay position from the row's name cell text span","+    const rowDomIndex = idx - startIndex;","+    const rowEls = tableContainer?.querySelectorAll('.row');","+    const rowEl = rowEls?.[rowDomIndex];","+    const nameCell = rowEl?.querySelector('.cell.name');","+","+    if (nameCell) {","+      const cellRect = nameCell.getBoundingClientRect();","+      const ellipsis = nameCell.querySelector('.ellipsis');","+      const textLeft = ellipsis ? ellipsis.getBoundingClientRect().left : cellRect.left + 38;","+      // Offset left by border(1.5) + padding-left(4) so text inside textarea aligns with row text","+      const pad = 6;","+      renameOverlay = {","+        top: cellRect.top,","+        left: textLeft - pad,","+        width: cellRect.right - textLeft + pad - 4","+      };","+    }","+","     editing = {","       active: true,","       path: entry.path,"]},{"oldStart":953,"oldLines":6,"newStart":979,"newLines":7,"lines":["     await tick();"," ","     if (renameInputEl) {","+      autoResizeRenameInput();","       renameInputEl.focus();","       const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;","       const selectionEnd = extPos > 0 ? extPos : entry.name.length;"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"dbcbc985-f74d-4b02-bb6b-c262867e9da0"}
{"parentUuid":"e2b251a3-af8f-4336-8d37-8b3d78a3e813","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","message":{"model":"claude-sonnet-4-6","id":"msg_016cMwQMtfFtm912Dk5p5rh6","type":"message","role":"assistant","content":[{"type":"text","text":"스크롤 시 rename 취소 추가:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":857,"cache_read_input_tokens":80272,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":857},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMN721nhWTaEtUiL6D36","type":"assistant","uuid":"b7551524-30e0-4c89-8044-a55f70022e5d","timestamp":"2026-02-21T14:22:52.753Z"}
{"parentUuid":"b7551524-30e0-4c89-8044-a55f70022e5d","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","message":{"model":"claude-sonnet-4-6","id":"msg_016cMwQMtfFtm912Dk5p5rh6","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013Rcz5uEKRQmS3B23tqJtXe","name":"Edit","input":{"replace_all":false,"file_path":"/Users/al02402336/everything/src/App.svelte","old_string":"      on:scroll={() => {\n        scrollTop = tableContainer.scrollTop;\n        headerScrollLeft = tableContainer.scrollLeft;\n        const scrollBottom = scrollTop + tableContainer.clientHeight;\n        if (scrollBottom >= totalHeight - rowHeight * 10) {\n          void loadMore();\n        }\n      }}","new_string":"      on:scroll={() => {\n        scrollTop = tableContainer.scrollTop;\n        headerScrollLeft = tableContainer.scrollLeft;\n        if (editing.active) cancelRename();\n        const scrollBottom = scrollTop + tableContainer.clientHeight;\n        if (scrollBottom >= totalHeight - rowHeight * 10) {\n          void loadMore();\n        }\n      }}"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":857,"cache_read_input_tokens":80272,"output_tokens":297,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":857,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYMN721nhWTaEtUiL6D36","type":"assistant","uuid":"f8986709-18ae-4991-8e7b-e35cf5c0ec10","timestamp":"2026-02-21T14:22:55.284Z"}
{"parentUuid":"f8986709-18ae-4991-8e7b-e35cf5c0ec10","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_013Rcz5uEKRQmS3B23tqJtXe","toolUseID":"toolu_013Rcz5uEKRQmS3B23tqJtXe","timestamp":"2026-02-21T14:22:55.292Z","uuid":"f6fb6566-d46c-4868-9dc1-4cf9e98915ca"}
{"parentUuid":"f8986709-18ae-4991-8e7b-e35cf5c0ec10","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013Rcz5uEKRQmS3B23tqJtXe","type":"tool_result","content":"The file /Users/al02402336/everything/src/App.svelte has been updated successfully."}]},"uuid":"f6c41367-792e-4288-80f7-4f0d81ebe9c3","timestamp":"2026-02-21T14:22:55.291Z","toolUseResult":{"filePath":"/Users/al02402336/everything/src/App.svelte","oldString":"      on:scroll={() => {\n        scrollTop = tableContainer.scrollTop;\n        headerScrollLeft = tableContainer.scrollLeft;\n        const scrollBottom = scrollTop + tableContainer.clientHeight;\n        if (scrollBottom >= totalHeight - rowHeight * 10) {\n          void loadMore();\n        }\n      }}","newString":"      on:scroll={() => {\n        scrollTop = tableContainer.scrollTop;\n        headerScrollLeft = tableContainer.scrollLeft;\n        if (editing.active) cancelRename();\n        const scrollBottom = scrollTop + tableContainer.clientHeight;\n        if (scrollBottom >= totalHeight - rowHeight * 10) {\n          void loadMore();\n        }\n      }}","originalFile":"<script>\n  import { onDestroy, onMount, tick } from 'svelte';\n  import { invoke } from '@tauri-apps/api/core';\n  import { listen } from '@tauri-apps/api/event';\n  import { getCurrentWindow } from '@tauri-apps/api/window';\n  import { startDrag } from '@crabnebula/tauri-plugin-drag';\n\n  const rowHeight = 30;\n  const PAGE_SIZE = 500;\n  let homePrefix = '';\n  const COL_WIDTHS_KEY = 'REDACTED';\n  const THEME_KEY = 'everything-theme';\n  const columnKeys = ['name', 'path', 'size', 'modified'];\n  const minColumnWidth = {\n    name: 180,\n    path: 240,\n    size: 75,\n    modified: 150\n  };\n  const defaultColumnRatios = {\n    name: 0.3,\n    path: 0.45,\n    size: 0.1\n  };\n\n  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || 'dark'; } catch { return 'dark'; } })();\n  function cycleTheme() {\n    theme = theme === 'dark' ? 'light' : 'dark';\n    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n  }\n\n  let query = '';\n  let results = [];\n  let totalResults = 0;\n  let totalResultsKnown = false;\n\n  let dbLatencyMs = null;\n  let dbLastQuery = '';\n  let searchModeLabel = '';\n  let selectedIndices = new Set();\n  let selectionAnchor = -1;\n  let lastSelectedIndex = -1;\n  let editing = {\n    active: false,\n    path: '',\n    index: -1,\n    draftName: ''\n  };\n\n  let renameOverlay = { top: 0, left: 0, width: 0 };\n\n  let indexStatus = {\n    state: 'Indexing',\n    entriesCount: 0,\n    lastUpdated: null,\n    permissionErrors: 0,\n    message: null,\n    isCatchup: false\n  };\n\n  let indexingStartTime = null;\n  let indexingElapsed = '';\n  let indexingFinishedAt = '';\n\n  let sortBy = 'name';\n  let sortDir = 'asc';\n\n  let hasMore = true;\n  let loadingMore = false;\n  let searchGeneration = 0;\n\n  let scanned = 0;\n\n  let searchInputEl;\n  let renameInputEl;\n  let tableAreaEl;\n  let tableContainer;\n  let tableResizeObserver = null;\n  let viewportResizeRaf = null;\n  let scrollTop = 0;\n  let headerScrollLeft = 0;\n  let viewportHeight = 520;\n  let lastTableWidth = 0;\n  let resizingColumn = '';\n  let resizeCleanup = null;\n  let colWidths = {\n    name: 250,\n    path: 350,\n    size: 75,\n    modified: 150\n  };\n\n  let contextMenu = {\n    visible: false,\n    x: 0,\n    y: 0\n  };\n\n  let platform = '';\n  let toast = '';\n  let searchTimer;\n  let lastSearchFiredAt = 0;\n  let toastTimer;\n  let statusRefreshTimer;\n  let elapsedTimer;\n  let statusRefreshInFlight = false;\n  let lastReadyCount = 0;\n\n  const iconCache = new Map();\n  const iconLoading = new Set();\n\n  let highlightCache = new Map();\n  let highlightCacheQuery = '';\n\n  const folderFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='1' y='4' width='14' height='10' rx='2' fill='#d9b34f'/><rect x='1' y='2' width='6' height='4' rx='1' fill='#e6ca7a'/></svg>`\n    );\n  const fileFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='3' y='1' width='10' height='14' rx='1.5' fill='#b4bec9'/><rect x='5' y='5' width='6' height='1.2' fill='#8d98a5'/><rect x='5' y='8' width='6' height='1.2' fill='#8d98a5'/></svg>`\n    );\n\n  $: totalHeight = results.length * rowHeight;\n  $: startIndex = Math.max(0, Math.floor(scrollTop / rowHeight) - 10);\n  $: visibleCount = Math.ceil(viewportHeight / rowHeight) + 20;\n  $: endIndex = Math.min(results.length, startIndex + visibleCount);\n  $: visibleRows = results.slice(startIndex, endIndex);\n  $: translateY = startIndex * rowHeight;\n  $: tableMinWidth = colWidths.name + colWidths.path + colWidths.size + colWidths.modified;\n  $: tableGridStyle = `--col-name:${colWidths.name}px;--col-path:${colWidths.path}px;--col-size:${colWidths.size}px;--col-modified:${colWidths.modified}px;--table-min-width:${tableMinWidth}px;--header-offset:${-headerScrollLeft}px;`;\n\n  $: {\n    for (const entry of visibleRows) {\n      void ensureIcon(entry);\n    }\n  }\n\n  function showToast(message) {\n    toast = message;\n    clearTimeout(toastTimer);\n    toastTimer = setTimeout(() => {\n      toast = '';\n    }, 3000);\n  }\n\n  function bytesToBase64(bytes) {\n    let binary = '';\n    const chunk = 0x8000;\n    for (let i = 0; i < bytes.length; i += chunk) {\n      const part = bytes.subarray(i, i + chunk);\n      binary += String.fromCharCode(...part);\n    }\n    return btoa(binary);\n  }\n\n  function highlightSegments(name, q) {\n    q = (q || '').trim();\n    if (!q) return [{ text: name, hl: false }];\n\n    // Reset cache when query changes\n    if (q !== highlightCacheQuery) {\n      highlightCache = new Map();\n      highlightCacheQuery = q;\n    }\n\n    // Check cache\n    const cached = highlightCache.get(name);\n    if (cached) return cached;\n\n    if (q.includes('/')) q = q.slice(q.lastIndexOf('/') + 1);\n    q = q.replace(/[*?]/g, '');\n    const terms = q.split(/\\s+/).filter(Boolean);\n    if (terms.length === 0) return [{ text: name, hl: false }];\n\n    const lower = name.toLowerCase();\n    const marks = new Uint8Array(name.length);\n    for (const t of terms) {\n      const tl = t.toLowerCase();\n      let idx = lower.indexOf(tl);\n      while (idx !== -1) {\n        for (let i = idx; i < idx + tl.length; i++) marks[i] = 1;\n        idx = lower.indexOf(tl, idx + 1);\n      }\n    }\n\n    const segs = [];\n    let i = 0;\n    while (i < name.length) {\n      const m = marks[i];\n      let j = i + 1;\n      while (j < name.length && marks[j] === m) j++;\n      segs.push({ text: name.slice(i, j), hl: m === 1 });\n      i = j;\n    }\n\n    highlightCache.set(name, segs);\n    return segs;\n  }\n\n  const perFileIconExts = new Set(['exe', 'lnk', 'ico', 'url', 'scr', 'appx']);\n\n  function iconKey(entry) {\n    if (entry.isDir) return '__folder__';\n    const ext = (entry.ext || '').toLowerCase();\n    if (perFileIconExts.has(ext)) return entry.path;\n    return ext || '__file__';\n  }\n\n  function iconFor(entry) {\n    return iconCache.get(iconKey(entry)) || (entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n  }\n\n  async function ensureIcon(entry) {\n    const key = iconKey(entry);\n    if (iconCache.has(key) || iconLoading.has(key)) {\n      return;\n    }\n\n    iconLoading.add(key);\n    try {\n      const bytes = await invoke('get_file_icon', {\n        path: entry.path,\n        ext: entry.isDir ? 'folder' : entry.ext || '',\n      });\n      if (Array.isArray(bytes) && bytes.length > 0) {\n        const image = `data:image/png;base64,${bytesToBase64(Uint8Array.from(bytes))}`;\n        iconCache.set(key, image);\n      } else {\n        iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n      }\n    } catch {\n      iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n    } finally {\n      iconLoading.delete(key);\n    }\n  }\n\n  function syncColumnWidthsToContainer() {\n    const width = tableContainer?.clientWidth || tableAreaEl?.clientWidth;\n    if (!width || lastTableWidth !== 0) {\n      return;\n    }\n\n    const saved = loadColWidths();\n    if (saved) {\n      const total = columnKeys.reduce((s, k) => s + saved[k], 0);\n      if (Math.abs(total - width) > 2) {\n        const scale = (width - saved.modified) / (total - saved.modified);\n        let scaledName = Math.max(minColumnWidth.name, Math.round(saved.name * scale));\n        let scaledSize = Math.max(minColumnWidth.size, Math.round(saved.size * scale));\n        let rawPath = width - saved.modified - scaledName - scaledSize;\n        if (rawPath < minColumnWidth.path) {\n          const shortfall = minColumnWidth.path - rawPath;\n          const nameReduction = Math.min(shortfall, scaledName - minColumnWidth.name);\n          scaledName -= nameReduction;\n          const remaining = shortfall - nameReduction;\n          if (remaining > 0) {\n            scaledSize -= Math.min(remaining, scaledSize - minColumnWidth.size);\n          }\n          rawPath = width - saved.modified - scaledName - scaledSize;\n        }\n        const scaledPath = Math.max(minColumnWidth.path, rawPath);\n        colWidths = { name: scaledName, path: scaledPath, size: scaledSize, modified: saved.modified };\n      } else {\n        colWidths = saved;\n      }\n    } else {\n      const fixedModified = minColumnWidth.modified;\n      const rest = width - fixedModified;\n      const ratioSum = defaultColumnRatios.name + defaultColumnRatios.path + defaultColumnRatios.size;\n      colWidths = {\n        name: Math.max(minColumnWidth.name, Math.round(rest * defaultColumnRatios.name / ratioSum)),\n        path: Math.max(minColumnWidth.path, Math.round(rest * defaultColumnRatios.path / ratioSum)),\n        size: Math.max(minColumnWidth.size, Math.round(rest * defaultColumnRatios.size / ratioSum)),\n        modified: fixedModified\n      };\n    }\n    lastTableWidth = width;\n  }\n\n  function loadColWidths() {\n    try {\n      const raw = localStorage.getItem(COL_WIDTHS_KEY);\n      if (!raw) return null;\n      const parsed = JSON.parse(raw);\n      for (const key of columnKeys) {\n        if (typeof parsed[key] !== 'number' || parsed[key] < (minColumnWidth[key] || 0)) return null;\n      }\n      return parsed;\n    } catch {\n      return null;\n    }\n  }\n\n  function saveColWidths() {\n    localStorage.setItem(COL_WIDTHS_KEY, JSON.stringify(colWidths));\n  }\n\n  function updateViewportHeight() {\n    viewportHeight = tableContainer?.clientHeight || 520;\n    syncColumnWidthsToContainer();\n  }\n\n  function scheduleViewportHeightUpdate() {\n    if (viewportResizeRaf !== null) {\n      return;\n    }\n    viewportResizeRaf = requestAnimationFrame(() => {\n      viewportResizeRaf = null;\n      updateViewportHeight();\n    });\n  }\n\n  function startColumnResize(event, leftKey) {\n    event.preventDefault();\n    event.stopPropagation();\n\n    const index = columnKeys.indexOf(leftKey);\n    if (index < 0 || index >= columnKeys.length - 1) {\n      return;\n    }\n\n    const startX = event.clientX;\n    const startLeft = colWidths[leftKey];\n    const rightKey = columnKeys[index + 1];\n    const startRight = colWidths[rightKey];\n\n    resizeCleanup?.();\n    resizingColumn = leftKey;\n\n    const onMove = (moveEvent) => {\n      const delta = Math.round(moveEvent.clientX - startX);\n      if (leftKey === 'name') {\n        // Two-column trade: name and path swap space, each respects its minimum\n        const nextLeft = Math.max(\n          minColumnWidth[leftKey],\n          Math.min(startLeft + delta, startLeft + startRight - minColumnWidth[rightKey])\n        );\n        const nextRight = startLeft + startRight - nextLeft;\n        colWidths = { ...colWidths, [leftKey]: nextLeft, [rightKey]: nextRight };\n      } else {\n        // path splitter: path grows unconstrained (allows horizontal scroll on right drag)\n        const nextLeft = Math.max(minColumnWidth[leftKey], startLeft + delta);\n        colWidths = { ...colWidths, [leftKey]: nextLeft };\n      }\n    };\n\n    const onUp = () => {\n      cleanup();\n    };\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      document.body.style.cursor = '';\n      document.body.style.userSelect = '';\n      resizingColumn = '';\n      saveColWidths();\n      if (resizeCleanup === cleanup) {\n        resizeCleanup = null;\n      }\n    };\n\n    resizeCleanup = cleanup;\n    document.body.style.cursor = 'col-resize';\n    document.body.style.userSelect = 'none';\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  function selectedPaths() {\n    const sorted = [...selectedIndices].sort((a, b) => a - b);\n    return sorted.map((idx) => results[idx]).filter(Boolean).map((entry) => entry.path);\n  }\n\n  function clearSelection() {\n    selectedIndices = new Set();\n    selectionAnchor = -1;\n    lastSelectedIndex = -1;\n  }\n\n  function selectSingle(index) {\n    selectedIndices = new Set([index]);\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectToggle(index) {\n    const next = new Set(selectedIndices);\n    if (next.has(index)) {\n      next.delete(index);\n    } else {\n      next.add(index);\n    }\n    selectedIndices = next;\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectRange(index) {\n    const anchor = selectionAnchor >= 0 ? selectionAnchor : index;\n    const [from, to] = [Math.min(anchor, index), Math.max(anchor, index)];\n    const next = new Set();\n    for (let i = from; i <= to; i += 1) {\n      next.add(i);\n    }\n    selectedIndices = next;\n    lastSelectedIndex = index;\n  }\n\n  function primaryEntry() {\n    const idx = lastSelectedIndex >= 0 ? lastSelectedIndex : -1;\n    return idx >= 0 ? results[idx] : null;\n  }\n\n  async function refreshStatus() {\n    if (statusRefreshInFlight) {\n      return;\n    }\n    statusRefreshInFlight = true;\n    try {\n      const status = await invoke('get_index_status');\n      const prevState = indexStatus.state;\n      indexStatus = {\n        state: status.state,\n        entriesCount: status.entriesCount,\n        lastUpdated: status.lastUpdated,\n        permissionErrors: status.permissionErrors ?? 0,\n        message: status.message\n      };\n      if (status.state === 'Indexing' && prevState !== 'Indexing') {\n        startElapsedTimer();\n      } else if (status.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n      if (typeof status.scanned === 'number') {\n        scanned = status.scanned;\n      }\n      if (status.state === 'Ready' && prevState !== 'Ready') {\n        scheduleSearch();\n      }\n    } catch (err) {\n      showToast(`Failed to get status: ${String(err)}`);\n    } finally {\n      statusRefreshInFlight = false;\n    }\n  }\n\n  function scheduleSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const scheduledGen = searchGeneration;\n    clearTimeout(searchTimer);\n\n    const now = performance.now();\n    if (now - lastSearchFiredAt >= 200) {\n      // Leading edge: fire immediately if enough time has passed\n      lastSearchFiredAt = now;\n      void runSearch(preserveScroll);\n    } else {\n      // Trailing edge: debounce\n      searchTimer = setTimeout(() => {\n        if (scheduledGen !== searchGeneration) {\n          return;\n        }\n        lastSearchFiredAt = performance.now();\n        void runSearch(preserveScroll);\n      }, 200);\n    }\n  }\n\n  async function runSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const gen = searchGeneration;\n    const searchQuery = query;\n    const searchSortBy = sortBy;\n    const searchSortDir = sortDir;\n    const startedAt = performance.now();\n    try {\n      const keepPaths = new Set(selectedPaths());\n      const next = await invoke('search', {\n        query: searchQuery,\n        limit: PAGE_SIZE,\n        offset: 0,\n        sortBy: searchSortBy,\n        sortDir: searchSortDir\n      });\n\n      if (gen !== searchGeneration) return;\n\n      dbLatencyMs = Math.round(performance.now() - startedAt);\n      dbLastQuery = searchQuery;\n      const entries = Array.isArray(next.entries) ? next.entries : [];\n      searchModeLabel = next.modeLabel || '';\n      results = entries;\n      if (next.totalCount > 0) {\n        totalResults = next.totalCount;\n        totalResultsKnown = true;\n      } else {\n        totalResults = entries.length;\n        totalResultsKnown = false;\n      }\n      hasMore = totalResultsKnown ? results.length < totalResults : entries.length >= PAGE_SIZE;\n      if (!preserveScroll && tableContainer) tableContainer.scrollTop = 0;\n\n      const restored = new Set();\n      for (let i = 0; i < results.length; i += 1) {\n        if (keepPaths.has(results[i].path)) {\n          restored.add(i);\n        }\n      }\n      selectedIndices = restored;\n\n      updateViewportHeight();\n    } catch (err) {\n      if (gen !== searchGeneration) return;\n      showToast(`Search failed: ${String(err)}`);\n    }\n  }\n\n  async function loadMore() {\n    if (!hasMore || loadingMore) return;\n    const gen = searchGeneration;\n    loadingMore = true;\n    try {\n      const batch = await invoke('search', {\n        query,\n        limit: PAGE_SIZE,\n        offset: results.length,\n        sortBy: sortBy,\n        sortDir: sortDir\n      });\n      if (gen !== searchGeneration) return;\n      const arr = Array.isArray(batch.entries) ? batch.entries : [];\n      if (arr.length > 0) results = [...results, ...arr];\n      hasMore = totalResultsKnown ? results.length < totalResults : arr.length >= PAGE_SIZE;\n    } catch (err) {\n      showToast(`Failed to load more: ${String(err)}`);\n    } finally {\n      loadingMore = false;\n    }\n  }\n\n  function moveSelection(delta, withRange = false) {\n    if (results.length === 0) {\n      return;\n    }\n\n    const current = lastSelectedIndex >= 0 ? lastSelectedIndex : 0;\n    const next = Math.max(0, Math.min(results.length - 1, current + delta));\n\n    if (withRange) {\n      selectRange(next);\n    } else {\n      selectSingle(next);\n    }\n\n    const top = next * rowHeight;\n    const bottom = top + rowHeight;\n    if (top < scrollTop) {\n      tableContainer.scrollTop = top;\n    } else if (bottom > scrollTop + viewportHeight) {\n      tableContainer.scrollTop = bottom - viewportHeight;\n    }\n  }\n\n  function handleHeaderSort(column) {\n    if (sortBy === column) {\n      sortDir = sortDir === 'asc' ? 'desc' : 'asc';\n    } else {\n      sortBy = column;\n      sortDir = 'asc';\n    }\n    if (tableContainer) tableContainer.scrollTop = 0;\n    void runSearch();\n  }\n\n  function handleRowClick(event, index) {\n    contextMenu.visible = false;\n\n    if (event.shiftKey) {\n      selectRange(index);\n      return;\n    }\n\n    if (event.metaKey || event.ctrlKey) {\n      selectToggle(index);\n      return;\n    }\n\n    selectSingle(index);\n  }\n\n  function handleRowContextMenu(event, index) {\n    event.preventDefault();\n\n    if (!selectedIndices.has(index)) {\n      selectSingle(index);\n    }\n\n    if (platform === 'windows' || platform === 'macos') {\n      contextMenu.visible = false;\n      const paths = selectedPaths();\n      if (paths.length > 0) {\n        invoke('show_context_menu', {\n          paths,\n          x: event.clientX,\n          y: event.clientY,\n          singleSelection: selectedIndices.size === 1\n        });\n      }\n      return;\n    }\n\n    contextMenu = {\n      visible: true,\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n\n  function handleRowA11yKeydown(event, index) {\n    if (event.key === ' ' || event.key === 'Enter') {\n      event.preventDefault();\n      handleRowClick(event, index);\n    }\n  }\n\n  const DRAG_THRESHOLD = 5;\n  let dragCleanup = null;\n  const dragImgCache = new Map();\n\n  function dragPathsForIndex(index) {\n    const entry = results[index];\n    if (!entry) {\n      return [];\n    }\n\n    if (selectedIndices.has(index) && selectedIndices.size > 0) {\n      return selectedPaths();\n    }\n\n    return [entry.path];\n  }\n\n  function getDragIconEl(entry) {\n    const src = iconFor(entry);\n    let img = dragImgCache.get(src);\n    if (!img) {\n      img = new Image();\n      img.src = src;\n      dragImgCache.set(src, img);\n    }\n    return img.complete && img.naturalWidth > 0 ? img : null;\n  }\n\n  function fillRoundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function buildDragPreview(index) {\n    const entry = results[index];\n    if (!entry) return null;\n\n    const count = selectedIndices.has(index) ? selectedIndices.size : 1;\n    const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\n\n    const w = 260;\n    const h = 28;\n    const stackGap = count > 1 ? 4 : 0;\n\n    const canvas = document.createElement('canvas');\n    canvas.width = w;\n    canvas.height = h + stackGap;\n    const ctx = canvas.getContext('2d');\n\n    if (count > 1) {\n      ctx.globalAlpha = 0.35;\n      ctx.fillStyle = isDark ? '#5a6070' : '#b0c4de';\n      fillRoundRect(ctx, 3, 0, w - 3, h, 5);\n      ctx.globalAlpha = 1.0;\n    }\n\n    const ry = stackGap;\n    ctx.fillStyle = isDark ? 'rgba(58, 64, 74, 0.94)' : 'rgba(214, 231, 255, 0.94)';\n    fillRoundRect(ctx, 0, ry, w, h, 5);\n\n    ctx.strokeStyle = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';\n    ctx.lineWidth = 0.5;\n    ctx.beginPath();\n    ctx.moveTo(5, ry);\n    ctx.arcTo(w, ry, w, ry + h, 5);\n    ctx.arcTo(w, ry + h, 0, ry + h, 5);\n    ctx.arcTo(0, ry + h, 0, ry, 5);\n    ctx.arcTo(0, ry, w, ry, 5);\n    ctx.closePath();\n    ctx.stroke();\n\n    const iconEl = getDragIconEl(entry);\n    if (iconEl) {\n      ctx.drawImage(iconEl, 6, ry + 6, 16, 16);\n    } else {\n      ctx.fillStyle = entry.isDir ? '#d9b34f' : '#8d98a5';\n      fillRoundRect(ctx, 6, ry + 6, 16, 16, 2);\n    }\n\n    ctx.fillStyle = isDark ? '#e6e6e8' : '#1a1a1a';\n    ctx.font = '12px -apple-system, \"SF Pro Text\", system-ui, sans-serif';\n    ctx.textBaseline = 'middle';\n\n    let nameMaxW = w - 34;\n    if (count > 1) nameMaxW -= 34;\n\n    let name = entry.name;\n    if (ctx.measureText(name).width > nameMaxW) {\n      while (name.length > 4 && ctx.measureText(name + '\\u2026').width > nameMaxW) {\n        name = name.slice(0, -1);\n      }\n      name += '\\u2026';\n    }\n    ctx.fillText(name, 28, ry + h / 2 + 1);\n\n    if (count > 1) {\n      const badge = String(count);\n      ctx.font = 'bold 10px -apple-system, system-ui, sans-serif';\n      const tw = ctx.measureText(badge).width;\n      const bw = Math.max(20, tw + 10);\n      const bx = w - bw - 6;\n      const by = ry + (h - 18) / 2;\n\n      ctx.fillStyle = isDark ? '#5b8bd9' : '#007aff';\n      fillRoundRect(ctx, bx, by, bw, 18, 9);\n\n      ctx.fillStyle = '#ffffff';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(badge, bx + bw / 2, by + 9);\n    }\n\n    return canvas.toDataURL('image/png');\n  }\n\n  function handleRowMouseDown(event, index) {\n    if (event.button !== 0) return;\n    if (event.metaKey || event.ctrlKey || event.shiftKey) return;\n    if (editing.active) return;\n\n    const startX = event.clientX;\n    const startY = event.clientY;\n    let dragging = false;\n\n    dragCleanup?.();\n\n    const onMove = (e) => {\n      if (dragging) return;\n      const dx = e.clientX - startX;\n      const dy = e.clientY - startY;\n      if (dx * dx + dy * dy < DRAG_THRESHOLD * DRAG_THRESHOLD) return;\n\n      dragging = true;\n      cleanup();\n\n      if (!selectedIndices.has(index)) {\n        selectSingle(index);\n      }\n\n      const paths = dragPathsForIndex(index);\n      if (paths.length > 0) {\n        const icon = buildDragPreview(index);\n        startDrag({ item: paths, icon }).catch(() => {});\n      }\n    };\n\n    const onUp = () => cleanup();\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      if (dragCleanup === cleanup) dragCleanup = null;\n    };\n\n    dragCleanup = cleanup;\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  async function handleRowDoubleClick(index) {\n    if (!selectedIndices.has(index) || selectedIndices.size > 1) {\n      selectSingle(index);\n      await tick();\n    }\n    await invoke('open', { paths: [results[index].path] }).catch((err) => {\n      showToast(`Failed to open: ${String(err)}`);\n    });\n  }\n\n  function closeContextMenu() {\n    contextMenu = {\n      ...contextMenu,\n      visible: false\n    };\n  }\n\n  async function openSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('open', { paths });\n    } catch (err) {\n      showToast(`Failed to open: ${String(err)}`);\n    }\n  }\n\n  async function openWithFallback() {\n    const target = primaryEntry();\n    if (!target) {\n      return;\n    }\n\n    try {\n      await invoke('open_with', { path: target.path });\n    } catch (err) {\n      showToast(`Open With failed: ${String(err)}`);\n    }\n  }\n\n  async function revealSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('reveal_in_finder', { paths });\n    } catch (err) {\n      showToast(`Failed to reveal in Finder: ${String(err)}`);\n    }\n  }\n\n  async function copySelectedPaths() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_paths', { paths });\n      showToast(`Copied ${paths.length} path(s)`);\n    } catch (err) {\n      showToast(`Failed to copy path: ${String(err)}`);\n    }\n  }\n\n  async function copyFiles() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_files', { paths });\n      showToast(`Copied ${paths.length} item(s)`);\n    } catch (err) {\n      showToast(`Failed to copy: ${String(err)}`);\n    }\n  }\n\n  async function trashSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    const message =\n      paths.length === 1\n        ? 'Move selected item to Trash?'\n        : `Move ${paths.length} items to Trash?`;\n\n    if (!window.confirm(message)) {\n      return;\n    }\n\n    try {\n      await invoke('move_to_trash', { paths });\n      showToast('Moved to Trash.');\n      clearSelection();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to move to Trash: ${String(err)}`);\n    }\n  }\n\n  async function resetIndex() {\n    if (indexStatus.state === 'Indexing') {\n      showToast('Indexing in progress. Please try again after it completes.');\n      return;\n    }\n\n    results = [];\n    totalResults = 0;\n    totalResultsKnown = false;\n    clearSelection();\n    scanned = 0;\n    dbLatencyMs = null;\n    dbLastQuery = '';\n    indexStatus = { ...indexStatus, state: 'Indexing', entriesCount: 0, message: null };\n    indexingStartTime = Date.now();\n    indexingElapsed = '';\n    indexingFinishedAt = '';\n\n    try {\n      await invoke('reset_index');\n    } catch (err) {\n      showToast(`Failed to reset index: ${String(err)}`);\n      await refreshStatus();\n    }\n  }\n\n  function isMultiSelected() {\n    return selectedIndices.size > 1;\n  }\n\n  function autoResizeRenameInput() {\n    if (!renameInputEl) return;\n    renameInputEl.style.height = '0';\n    renameInputEl.style.height = renameInputEl.scrollHeight + 'px';\n  }\n\n  async function startRename() {\n    if (isMultiSelected()) {\n      return;\n    }\n\n    const idx = lastSelectedIndex;\n    if (idx < 0 || !results[idx]) {\n      return;\n    }\n\n    const entry = results[idx];\n\n    // Calculate overlay position from the row's name cell text span\n    const rowDomIndex = idx - startIndex;\n    const rowEls = tableContainer?.querySelectorAll('.row');\n    const rowEl = rowEls?.[rowDomIndex];\n    const nameCell = rowEl?.querySelector('.cell.name');\n\n    if (nameCell) {\n      const cellRect = nameCell.getBoundingClientRect();\n      const ellipsis = nameCell.querySelector('.ellipsis');\n      const textLeft = ellipsis ? ellipsis.getBoundingClientRect().left : cellRect.left + 38;\n      // Offset left by border(1.5) + padding-left(4) so text inside textarea aligns with row text\n      const pad = 6;\n      renameOverlay = {\n        top: cellRect.top,\n        left: textLeft - pad,\n        width: cellRect.right - textLeft + pad - 4\n      };\n    }\n\n    editing = {\n      active: true,\n      path: entry.path,\n      index: idx,\n      draftName: entry.name\n    };\n\n    await tick();\n\n    if (renameInputEl) {\n      autoResizeRenameInput();\n      renameInputEl.focus();\n      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n      renameInputEl.setSelectionRange(0, selectionEnd);\n    }\n  }\n\n  function cancelRename() {\n    editing = {\n      active: false,\n      path: '',\n      index: -1,\n      draftName: ''\n    };\n  }\n\n  async function commitRename() {\n    if (!editing.active || editing.index < 0 || !results[editing.index]) {\n      return;\n    }\n\n    const current = results[editing.index];\n    const nextName = editing.draftName;\n\n    try {\n      await invoke('rename', {\n        path: current.path,\n        newName: nextName\n      });\n      cancelRename();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to rename: ${String(err)}`);\n      await tick();\n      renameInputEl?.focus();\n    }\n  }\n\n  function onGlobalClick() {\n    closeContextMenu();\n  }\n\n  function onTitleBarMouseDown(event) {\n    if (event.button !== 0) {\n      return;\n    }\n\n    const activeElement = document.activeElement;\n    if (activeElement instanceof HTMLElement && isTextInputTarget(activeElement)) {\n      activeElement.blur();\n    }\n  }\n\n  async function focusSearch() {\n    await getCurrentWindow().show();\n    await getCurrentWindow().setFocus();\n    searchInputEl?.focus();\n    searchInputEl?.select();\n  }\n\n  function isTextInputTarget(target) {\n    return (\n      target instanceof HTMLInputElement ||\n      target instanceof HTMLTextAreaElement ||\n      target?.isContentEditable\n    );\n  }\n\n  async function handleKeydown(event) {\n    const isMetaSelectAll = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'a';\n    const isMetaCopy = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c';\n    const target = event.target;\n    const isTextInput = isTextInputTarget(target);\n\n    if (isMetaCopy && isTextInput) {\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      if (isTextInput) {\n        event.preventDefault();\n        if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n          target.select();\n        }\n        return;\n      }\n    }\n\n    if (editing.active) {\n      if (event.key === 'Enter') {\n        event.preventDefault();\n        await commitRename();\n        return;\n      }\n\n      if (event.key === 'Escape') {\n        event.preventDefault();\n        cancelRename();\n        searchInputEl?.focus();\n        return;\n      }\n      return;\n    }\n\n    if (event.key === 'Escape') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      return;\n    }\n\n    if (event.key === 'ArrowDown') {\n      event.preventDefault();\n      moveSelection(1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'ArrowUp') {\n      event.preventDefault();\n      moveSelection(-1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageDown') {\n      event.preventDefault();\n      moveSelection(Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageUp') {\n      event.preventDefault();\n      moveSelection(-Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'Enter') {\n      event.preventDefault();\n      if (platform === 'windows') {\n        await openSelected();\n      } else {\n        await startRename();\n      }\n      return;\n    }\n\n    if (event.key === 'F2') {\n      event.preventDefault();\n      await startRename();\n      return;\n    }\n\n    if (event.key === ' ' && !isTextInput) {\n      event.preventDefault();\n      const entry = primaryEntry();\n      if (entry) {\n        await invoke('quick_look', { path: entry.path });\n      }\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'f') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      searchInputEl?.select();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'o') {\n      event.preventDefault();\n      await openSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {\n      event.preventDefault();\n      await revealSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c') {\n      event.preventDefault();\n      await copySelectedPaths();\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      event.preventDefault();\n      selectedIndices = new Set(Array.from({ length: results.length }, (_, i) => i));\n      return;\n    }\n\n    if (event.key === 'Delete' || ((event.metaKey || event.ctrlKey) && event.key === 'Backspace')) {\n      if (!isTextInput) {\n        event.preventDefault();\n        await trashSelected();\n      }\n      return;\n    }\n  }\n\n  function formatSize(entry) {\n    if (entry.isDir || entry.size == null) return '';\n    const bytes = entry.size;\n    if (bytes < 1024) return `${bytes} B`;\n    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n    return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n  }\n\n  function formatModified(entry) {\n    if (!entry.mtime) {\n      return '';\n    }\n\n    const d = new Date(entry.mtime * 1000);\n    const pad = (n) => String(n).padStart(2, '0');\n    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;\n  }\n\n  function formatLastUpdated(timestamp) {\n    if (!timestamp) {\n      return '-';\n    }\n\n    return new Date(timestamp * 1000).toLocaleString();\n  }\n\n  function formatElapsed(ms) {\n    const totalSec = Math.floor(ms / 1000);\n    const min = Math.floor(totalSec / 60);\n    const sec = totalSec % 60;\n    return min > 0 ? `${min}m ${sec}s` : `${sec}s`;\n  }\n\n  function updateElapsed() {\n    if (indexingStartTime && indexStatus.state === 'Indexing') {\n      indexingElapsed = formatElapsed(Date.now() - indexingStartTime);\n    }\n  }\n\n  function startElapsedTimer() {\n    clearInterval(elapsedTimer);\n    indexingStartTime = Date.now();\n    indexingElapsed = '0s';\n    indexingFinishedAt = '';\n    elapsedTimer = setInterval(updateElapsed, 1000);\n  }\n\n  function stopElapsedTimer() {\n    clearInterval(elapsedTimer);\n    if (indexingStartTime) {\n      const elapsed = Date.now() - indexingStartTime;\n      indexingFinishedAt = `${formatElapsed(elapsed)}`;\n    }\n    indexingStartTime = null;\n    indexingElapsed = '';\n  }\n\n  function displayPath(path) {\n    if (!path) {\n      return path;\n    }\n\n    if (!homePrefix) {\n      return path;\n    }\n\n    if (path === homePrefix) {\n      return '~';\n    }\n\n    if (path.startsWith(`${homePrefix}/`)) {\n      return `~${path.slice(homePrefix.length)}`;\n    }\n\n    return path;\n  }\n\n  let unlistenFns = [];\n\n  onMount(async () => {\n    const t0 = performance.now();\n    const ms = () => Math.round(performance.now() - t0);\n    const DEBUG_STARTUP = false;\n    const flog = DEBUG_STARTUP ? (msg) => invoke('frontend_log', { msg }).catch(() => {}) : () => {};\n\n    flog(`[startup/fe] onMount entered`);\n\n    updateViewportHeight();\n    flog(`[startup/fe] +${ms()}ms updateViewportHeight done`);\n\n    platform = await invoke('get_platform');\n    flog(`[startup/fe] +${ms()}ms get_platform done`);\n\n    const unlistenProgress = await listen('index_progress', (event) => {\n      scanned = event.payload.scanned;\n      if (indexStatus.state !== 'Indexing') {\n        indexStatus = {\n          ...indexStatus,\n          state: 'Indexing'\n        };\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_progress) registered`);\n\n    const unlistenState = await listen('index_state', (event) => {\n      flog(`[startup/fe] index_state event received: ${event.payload.state} at +${ms()}ms`);\n      const prevState = indexStatus.state;\n      indexStatus = {\n        ...indexStatus,\n        state: event.payload.state,\n        message: event.payload.message ?? null,\n        isCatchup: event.payload.isCatchup ?? false\n      };\n\n      if (event.payload.state === 'Indexing' && prevState !== 'Indexing') {\n        if (prevState === 'Ready') {\n          lastReadyCount = indexStatus.entriesCount;\n        }\n        startElapsedTimer();\n      } else if (event.payload.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n\n      if (event.payload.state === 'Ready') {\n        scheduleSearch();\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_state) registered`);\n\n    const unlistenUpdated = await listen('index_updated', (event) => {\n      indexStatus = {\n        ...indexStatus,\n        entriesCount: event.payload.entriesCount,\n        lastUpdated: event.payload.lastUpdated,\n        permissionErrors: event.payload.permissionErrors ?? indexStatus.permissionErrors\n      };\n\n      scheduleSearch(true);\n    });\n\n    const unlistenFocus = await listen('focus_search', () => {\n      void focusSearch();\n    });\n\n    const unlistenCtxMenuAction = await listen('context_menu_action', (event) => {\n      switch (event.payload) {\n        case 'open': void openSelected(); break;\n        case 'quick_look': {\n          const e = primaryEntry();\n          if (e) void invoke('quick_look', { path: e.path });\n          break;\n        }\n        case 'open_with': void openWithFallback(); break;\n        case 'reveal': void revealSelected(); break;\n        case 'copy_files': void copyFiles(); break;\n        case 'copy_path': void copySelectedPaths(); break;\n        case 'trash': void trashSelected(); break;\n        case 'rename': void startRename(); break;\n      }\n    });\n\n    unlistenFns = [unlistenProgress, unlistenState, unlistenUpdated, unlistenFocus, unlistenCtxMenuAction];\n    flog(`[startup/fe] +${ms()}ms all listeners registered`);\n\n    // Fetch backend state IMMEDIATELY after listeners are registered.\n    // Events emitted before listener registration are lost, so this\n    // is the only reliable way to get the current state.\n    await refreshStatus();\n    flog(`[startup/fe] +${ms()}ms refreshStatus done (state=${indexStatus.state})`);\n\n    // Show Svelte UI: remove skeleton, focus search input.\n    await tick();\n    document.getElementById('skeleton')?.remove();\n    await focusSearch();\n    flog(`[startup/fe] +${ms()}ms WINDOW VISIBLE — skeleton removed`);\n\n    try {\n      homePrefix = await invoke('get_home_dir');\n    } catch {\n      homePrefix = '';\n    }\n    flog(`[startup/fe] +${ms()}ms get_home_dir done`);\n\n    if (!localStorage.getItem('everything-fda-notice-v1')) {\n      showToast('macOS Full Disk Access permission may be required for full disk search.');\n      localStorage.setItem('everything-fda-notice-v1', '1');\n    }\n    flog(`[startup/fe] +${ms()}ms calling runSearch...`);\n    await runSearch();\n    flog(`[startup/fe] +${ms()}ms runSearch done`);\n\n    if (typeof ResizeObserver !== 'undefined') {\n      tableResizeObserver = new ResizeObserver(() => {\n        scheduleViewportHeightUpdate();\n      });\n      if (tableContainer) {\n        tableResizeObserver.observe(tableContainer);\n      } else if (tableAreaEl) {\n        tableResizeObserver.observe(tableAreaEl);\n      }\n    }\n\n    window.addEventListener('resize', scheduleViewportHeightUpdate);\n    window.addEventListener('click', onGlobalClick);\n    statusRefreshTimer = setInterval(() => {\n      if (indexStatus.state === 'Indexing') {\n        void refreshStatus();\n      }\n    }, 1000);\n    console.log(`[startup/fe] +${ms()}ms onMount complete`);\n  });\n\n  onDestroy(async () => {\n    clearTimeout(searchTimer);\n    clearTimeout(toastTimer);\n    clearInterval(statusRefreshTimer);\n    clearInterval(elapsedTimer);\n    resizeCleanup?.();\n\n    for (const unlisten of unlistenFns) {\n      unlisten();\n    }\n\n    tableResizeObserver?.disconnect();\n    tableResizeObserver = null;\n    if (viewportResizeRaf !== null) {\n      cancelAnimationFrame(viewportResizeRaf);\n      viewportResizeRaf = null;\n    }\n    window.removeEventListener('resize', scheduleViewportHeightUpdate);\n    window.removeEventListener('click', onGlobalClick);\n  });\n</script>\n\n<svelte:window on:keydown={handleKeydown} />\n\n<div class=\"app-shell\" data-theme={theme}>\n  <div class=\"title-bar\" role=\"presentation\" data-tauri-drag-region on:mousedown={onTitleBarMouseDown}>\n    <div class=\"title-left\"></div>\n    <div class=\"title-center\">\n      <svg class=\"title-icon\" viewBox=\"0 0 215 205\" fill-rule=\"evenodd\" aria-hidden=\"true\">\n        <path d=\"M85 0c46.9 0 85 38.1 85 85 0 20.1-7.2 38.5-19.2 52.7l40.7 40.8c5.8 5.8 5.8 15.2 0 21-5.8 5.8-15.2 5.8-21 0l-40.7-40.7c-13.6 9.7-30.4 15.2-44.8 15.2-46.9 0-85-42.1-85-89 0-46.9 38.1-85 85-85z m0 32c-29.3 0-53 23.7-53 53 0 29.3 23.7 53 53 53 29.3 0 53-23.7 53-53 0-29.3-23.7-53-53-53z\"/>\n      </svg>\n      <span class=\"title-text\">Everything</span>\n    </div>\n    <div class=\"title-right\"></div>\n  </div>\n\n  <header class=\"search-bar\">\n    <input\n      bind:this={searchInputEl}\n      class=\"search-input\"\n      type=\"text\"\n      bind:value={query}\n      on:input={scheduleSearch}\n      on:focus={clearSelection}\n      placeholder=\"Search file/folder names\"\n      autocomplete=\"off\"\n      spellcheck=\"false\"\n    />\n  </header>\n\n  <section class=\"table-area\" bind:this={tableAreaEl} style={tableGridStyle}>\n    <div class=\"table-header\">\n      <div class=\"table-header-track\">\n        <div class=\"col name\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('name')}>\n            Name{#if sortBy === 'name'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'name'}\n            on:mousedown={(event) => startColumnResize(event, 'name')}\n            aria-label=\"Resize Name column\"\n          />\n        </div>\n\n        <div class=\"col path\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('dir')}>\n            Path{#if sortBy === 'dir'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'path'}\n            on:mousedown={(event) => startColumnResize(event, 'path')}\n            aria-label=\"Resize Path column\"\n          />\n        </div>\n\n        <div class=\"col size\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('size')}>\n            Size{#if sortBy === 'size'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n\n        <div class=\"col modified\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('mtime')}>\n            Modified{#if sortBy === 'mtime'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n      </div>\n    </div>\n\n    <div\n      class=\"table-body\"\n      bind:this={tableContainer}\n      on:scroll={() => {\n        scrollTop = tableContainer.scrollTop;\n        headerScrollLeft = tableContainer.scrollLeft;\n        const scrollBottom = scrollTop + tableContainer.clientHeight;\n        if (scrollBottom >= totalHeight - rowHeight * 10) {\n          void loadMore();\n        }\n      }}\n    >\n      <div class=\"spacer\" style={`height:${totalHeight}px`}>\n        <div class=\"rows\" style={`transform: translateY(${translateY}px);`}>\n          {#each visibleRows as entry, localIndex}\n            {@const index = startIndex + localIndex}\n            <div\n              class=\"row {selectedIndices.has(index) ? 'selected' : ''} {editing.active && editing.index === index ? 'renaming' : ''}\"\n              on:mousedown={(event) => handleRowMouseDown(event, index)}\n              on:click={(event) => handleRowClick(event, index)}\n              on:keydown={(event) => handleRowA11yKeydown(event, index)}\n              on:dblclick={() => handleRowDoubleClick(index)}\n              on:contextmenu={(event) => handleRowContextMenu(event, index)}\n              role=\"row\"\n              tabindex=\"0\"\n            >\n              <div class=\"cell name\">\n                <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n\n                {#if editing.active && editing.index === index}\n                  <input\n                    bind:this={renameInputEl}\n                    class=\"rename-input\"\n                    type=\"text\"\n                    bind:value={editing.draftName}\n                    on:click|stopPropagation\n                    on:blur={commitRename}\n                  />\n                {:else}\n                  <span class=\"ellipsis\">{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n                {/if}\n              </div>\n              <div class=\"cell path\"><span class=\"ellipsis\">{displayPath(entry.dir)}</span></div>\n              <div class=\"cell size\">{formatSize(entry)}</div>\n              <div class=\"cell modified\">{formatModified(entry)}</div>\n            </div>\n          {/each}\n        </div>\n      </div>\n    </div>\n  </section>\n\n  <footer class=\"status-bar\">\n    <div class=\"status-left\">\n      <span class=\"status-state\">\n        <span class=\"state-dot {indexStatus.state === 'Indexing' ? 'indexing' : indexStatus.state === 'Error' ? 'error' : 'ready'}\"></span>\n        {#if indexStatus.state === 'Indexing'}\n          Indexing{#if lastReadyCount > 0} ({Math.min(99, Math.round((scanned / lastReadyCount) * 100))}%){/if}{#if indexingElapsed} · {indexingElapsed}{/if}\n          {#if !indexStatus.isCatchup}\n            · {scanned.toLocaleString()} scanned\n          {/if}\n        {:else}\n          Index: {indexStatus.state}\n        {/if}\n      </span>\n      <span>{indexStatus.entriesCount.toLocaleString()} entries</span>\n      {#if indexingFinishedAt && indexStatus.state !== 'Indexing'}\n        <span>in {indexingFinishedAt}</span>\n      {/if}\n      {#if dbLatencyMs !== null && dbLastQuery}\n        <span>\"{dbLastQuery}\" {dbLatencyMs}ms · {totalResults} results</span>\n      {/if}\n      {#if searchModeLabel === 'spotlight' || searchModeLabel === 'spotlight_timeout'}\n        <span class=\"status-spotlight\">Spotlight fallback{#if searchModeLabel === 'spotlight_timeout'} (partial){/if}</span>\n      {/if}\n      {#if indexStatus.permissionErrors > 0}\n        <span class=\"status-warning\">{indexStatus.permissionErrors.toLocaleString()} permission errors</span>\n      {/if}\n      {#if indexStatus.message}\n        <span class={indexStatus.isCatchup ? 'index-progress' : 'status-error'}>{indexStatus.message}</span>\n      {/if}\n    </div>\n    <div class=\"status-right\">\n      <button class=\"status-btn theme-btn\" on:click={cycleTheme} title=\"Switch theme\">\n        {theme === 'dark' ? '☀ Light' : '◑ Dark'}\n      </button>\n      <button\n        class=\"status-btn rebuild-btn\"\n        on:click={resetIndex}\n        disabled={indexStatus.state === 'Indexing'}\n        title={indexStatus.state === 'Indexing' ? 'Cannot reset while indexing is in progress.' : 'Reset and rebuild the index.'}\n      >\n        <svg class=\"rebuild-icon\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n          <path d=\"M23 4v6h-6\"/><path d=\"M20.49 15a9 9 0 1 1-2.12-9.36L23 10\"/>\n        </svg>\n        Rebuild Index\n      </button>\n    </div>\n  </footer>\n\n  {#if contextMenu.visible}\n    <div class=\"context-menu\" style={`left:${contextMenu.x}px;top:${contextMenu.y}px;`}>\n      <button on:click={() => (closeContextMenu(), openSelected())}>Open</button>\n      <button on:click={async () => { closeContextMenu(); const e = primaryEntry(); if (e) await invoke('quick_look', { path: e.path }); }}>Quick Look</button>\n      <button on:click={() => (closeContextMenu(), openWithFallback())}>Open With... (Reveal in Finder)</button>\n      <button on:click={() => (closeContextMenu(), revealSelected())}>Reveal in Finder</button>\n      <button on:click={() => (closeContextMenu(), copySelectedPaths())}>Copy Path</button>\n      <button on:click={() => (closeContextMenu(), trashSelected())}>Move to Trash</button>\n      {#if selectedIndices.size === 1}\n        <button on:click={() => (closeContextMenu(), startRename())}>Rename</button>\n      {/if}\n    </div>\n  {/if}\n\n  {#if toast}\n    <div class=\"toast\">{toast}</div>\n  {/if}\n</div>\n\n<style>\n  :global(:root) {\n    color-scheme: light dark;\n    --bg-app: transparent;\n    --text-primary: #0d1826;\n    --text-muted: #48596c;\n    --bar-grad-top: rgba(255, 255, 255, 0.48);\n    --bar-grad-bottom: rgba(248, 250, 253, 0.42);\n    --surface-header: rgba(252, 252, 255, 0.40);\n    --surface: rgba(255, 255, 255, 0.22);\n    --border-soft: rgba(0, 0, 0, 0.07);\n    --border-input: rgba(0, 0, 0, 0.13);\n    --focus-ring: #6f96e6;\n    --row-border: rgba(0, 0, 0, 0.032);\n    --row-hover: rgba(0, 0, 0, 0.06);\n    --row-selected: rgba(0, 0, 0, 0.12);\n    --button-bg: rgba(255, 255, 255, 0.62);\n    --button-border: rgba(0, 0, 0, 0.10);\n    --button-text: #2c3e50;\n    --menu-bg: rgba(240, 241, 248, 0.90);\n    --menu-border: rgba(0, 0, 0, 0.06);\n    --menu-hover: rgba(255, 255, 255, 0.62);\n    --menu-text: #1a2a38;\n    --error-text: #b64545;\n    --warning-text: #8f6500;\n    --toast-bg: rgba(18, 22, 32, 0.90);\n    --toast-text: #ffffff;\n  }\n\n  @media (prefers-color-scheme: dark) {\n    :global(:root) {\n      --bg-app: transparent;\n      --text-primary: #e6e6ea;\n      --text-muted: #9494a4;\n      --bar-grad-top: rgba(38, 38, 46, 0.52);\n      --bar-grad-bottom: rgba(30, 30, 38, 0.46);\n      --surface-header: rgba(32, 32, 40, 0.46);\n      --surface: rgba(18, 18, 26, 0.32);\n      --border-soft: rgba(255, 255, 255, 0.065);\n      --border-input: rgba(255, 255, 255, 0.14);\n      --focus-ring: #5b8bd9;\n      --row-border: rgba(255, 255, 255, 0.026);\n      --row-hover: rgba(255, 255, 255, 0.08);\n      --row-selected: rgba(255, 255, 255, 0.14);\n      --button-bg: rgba(255, 255, 255, 0.072);\n      --button-border: rgba(255, 255, 255, 0.11);\n      --button-text: #d6d6e0;\n      --menu-bg: rgba(36, 36, 46, 0.90);\n      --menu-border: rgba(255, 255, 255, 0.066);\n      --menu-hover: rgba(255, 255, 255, 0.062);\n      --menu-text: #e0e0e8;\n      --error-text: #ff9d9d;\n      --warning-text: #e0c670;\n      --toast-bg: rgba(10, 10, 16, 0.93);\n      --toast-text: #f2f2f6;\n    }\n  }\n\n  /* ── Theme: Dark ──────────────────────────────────────────────── */\n  :global([data-theme=\"dark\"]) {\n    color-scheme: dark;\n    --bg-app: #1E1E21;\n    --text-primary: #E2E8F0;\n    --text-muted: #94A3B8;\n    --bar-grad-top: #1E1E21;\n    --bar-grad-bottom: #1E1E21;\n    --surface-header: #1E1E21;\n    --surface: #1E1E21;\n    --bg-input: #161618;\n    --border-soft: #2A2A2D;\n    --border-input: rgba(255, 255, 255, 0.06);\n    --focus-ring: #4DA8FF;\n    --accent: #4DA8FF;\n    --row-border: rgba(255, 255, 255, 0.02);\n    --row-hover: #282828;\n    --row-selected: rgba(77, 168, 255, 0.10);\n    --button-bg: rgba(255, 255, 255, 0.05);\n    --button-border: #2A2A2D;\n    --button-text: #94A3B8;\n    --menu-bg: #252528;\n    --menu-border: #2A2A2D;\n    --menu-hover: rgba(255, 255, 255, 0.04);\n    --menu-text: #E2E8F0;\n    --error-text: #ff9d9d;\n    --warning-text: #e0c670;\n    --toast-bg: rgba(10, 10, 16, 0.93);\n    --toast-text: #f2f2f6;\n  }\n\n  /* ── Theme: Light ─────────────────────────────────────────────── */\n  :global([data-theme=\"light\"]) {\n    color-scheme: light;\n    --bg-app: #F5F5F7;\n    --text-primary: #1C1C1E;\n    --text-muted: #6E6E7A;\n    --bar-grad-top: #F5F5F7;\n    --bar-grad-bottom: #F5F5F7;\n    --surface-header: #F5F5F7;\n    --surface: #F5F5F7;\n    --bg-input: #FFFFFF;\n    --border-soft: #D1D1D6;\n    --border-input: rgba(0, 0, 0, 0.10);\n    --focus-ring: #3A8BF5;\n    --accent: #3A8BF5;\n    --row-border: rgba(0, 0, 0, 0.04);\n    --row-hover: rgba(0, 0, 0, 0.04);\n    --row-selected: rgba(58, 139, 245, 0.10);\n    --button-bg: #FFFFFF;\n    --button-border: #D1D1D6;\n    --button-text: #3C3C43;\n    --menu-bg: #FFFFFF;\n    --menu-border: #D1D1D6;\n    --menu-hover: rgba(0, 0, 0, 0.05);\n    --menu-text: #1C1C1E;\n    --error-text: #D93025;\n    --warning-text: #B45309;\n    --toast-bg: rgba(255, 255, 255, 0.95);\n    --toast-text: #1C1C1E;\n  }\n\n  /* ── Themed element overrides ─────────────────────────────────── */\n  :global([data-theme]) {\n    background: var(--bg-app);\n  }\n\n  /* Search bar: flat, no gradient, no separator */\n  :global([data-theme]) .search-bar {\n    height: 44px;\n    padding: 0 16px;\n    background: var(--bg-app);\n    border-bottom: none;\n  }\n\n  :global([data-theme]) .search-input {\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n    font-family: 'JetBrains Mono', 'SF Mono', monospace;\n    font-size: 12px;\n    height: 34px;\n    border-radius: 8px;\n  }\n\n  /* Table header: flat bg, 16px edge padding */\n  :global([data-theme]) .table-header {\n    background: var(--bg-app);\n  }\n\n  :global([data-theme]) .col-button {\n    padding: 0 8px;\n  }\n\n  :global([data-theme]) .col.name .col-button {\n    padding-left: 16px;\n  }\n\n  /* Row cells: JetBrains Mono, 16px outer edges */\n  :global([data-theme]) .cell {\n    font-family: 'JetBrains Mono', monospace;\n  }\n\n  :global([data-theme]) .cell.name {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    padding-left: 16px;\n    font-size: 12px;\n    color: var(--text-primary);\n  }\n\n  :global([data-theme]) .cell.path {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.size {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.modified {\n    padding-right: 16px;\n    font-size: 11px;\n    white-space: nowrap;\n  }\n\n  :global([data-theme]) .row.selected {\n    box-shadow: inset 3px 0 0 var(--accent);\n  }\n\n  /* Dim path/size/date cells in themed mode */\n  :global([data-theme]) .cell.path,\n  :global([data-theme]) .cell.size,\n  :global([data-theme]) .cell.modified {\n    color: var(--text-muted);\n  }\n\n  :global(:root) {\n    background: transparent;\n  }\n\n  :global(html, body) {\n    margin: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    background: transparent;\n    color: var(--text-primary);\n    font-family: Inter, 'SF Pro Text', 'Segoe UI', Helvetica, Arial, sans-serif;\n  }\n\n  :global(#app) {\n    width: 100%;\n    height: 100%;\n  }\n\n  .app-shell {\n    display: grid;\n    grid-template-rows: auto auto 1fr auto;\n    height: 100%;\n    min-width: 0;\n  }\n\n  .title-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 44px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    cursor: default;\n    flex-shrink: 0;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-left {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-center {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-right {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-icon {\n    width: 14px;\n    height: 14px;\n    fill: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .title-text {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 13px;\n    font-weight: 500;\n    color: var(--text-primary);\n    letter-spacing: -0.01em;\n  }\n\n  .search-bar {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding: 8px;\n    background: linear-gradient(180deg, var(--bar-grad-top) 0%, var(--bar-grad-bottom) 100%);\n    border-bottom: 1px solid var(--border-soft);\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .search-input {\n    display: block;\n    box-sizing: border-box;\n    width: 100%;\n    min-width: 0;\n    flex: 1 1 auto;\n    height: 36px;\n    border: 1px solid var(--border-input);\n    border-radius: 14px;\n    padding: 0 10px;\n    font-size: 14px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    backdrop-filter: blur(12px) saturate(160%);\n    -webkit-backdrop-filter: blur(12px) saturate(160%);\n  }\n\n  .search-input::placeholder {\n    color: var(--text-muted);\n    opacity: 0.85;\n    font-size: 12px;\n  }\n\n  .search-input:focus {\n    outline: none;\n    border-color: var(--focus-ring);\n    box-shadow: 0 0 0 2px rgba(125, 169, 255, 0.25);\n  }\n\n  .table-area {\n    display: grid;\n    grid-template-rows: auto 1fr;\n    min-height: 0;\n    min-width: 0;\n  }\n\n  .table-header-track,\n  .row {\n    display: grid;\n    grid-template-columns: var(--col-name) var(--col-path) var(--col-size) var(--col-modified);\n    align-items: center;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .table-header {\n    height: 32px;\n    border-bottom: 1px solid var(--border-soft);\n    background: var(--surface-header);\n    user-select: none;\n    overflow: hidden;\n    flex-shrink: 0;\n  }\n\n  .table-header-track {\n    height: 100%;\n    transform: translateX(var(--header-offset, 0px));\n    will-change: transform;\n  }\n\n  .table-header .col {\n    position: relative;\n    min-width: 0;\n    height: 100%;\n  }\n\n  .col-button {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n    gap: 4px;\n    box-sizing: border-box;\n    padding: 0 8px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 11px;\n    font-weight: 600;\n    line-height: 1;\n    color: var(--text-muted);\n    text-align: left;\n    margin: 0;\n    border: none;\n    background: transparent;\n    cursor: pointer;\n  }\n\n  .sort-icon {\n    width: 10px;\n    height: 10px;\n    flex-shrink: 0;\n    color: var(--accent);\n  }\n\n  .col-resizer {\n    position: absolute;\n    top: 0;\n    right: -4px;\n    width: 8px;\n    height: 100%;\n    border: none;\n    padding: 0;\n    background: transparent;\n    cursor: col-resize;\n    z-index: 30;\n  }\n\n  .col-resizer::after {\n    content: '';\n    position: absolute;\n    top: 7px;\n    bottom: 7px;\n    left: 50%;\n    width: 1px;\n    transform: translateX(-50%);\n    background: var(--border-soft);\n    opacity: 0;\n    transition: opacity 0.15s ease;\n  }\n\n  .table-header .col:hover .col-resizer::after,\n  .col-resizer.active::after {\n    opacity: 1;\n  }\n\n  .table-body {\n    overflow: auto;\n    min-height: 0;\n    min-width: 0;\n    background: var(--surface);\n  }\n\n  .spacer {\n    position: relative;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .rows {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .row {\n    height: 30px;\n    border-bottom: 1px solid var(--row-border);\n    cursor: default;\n    -webkit-user-select: none;\n    user-select: none;\n    outline: none;\n  }\n\n  .row:hover {\n    background: var(--row-hover);\n  }\n\n  .row.selected {\n    background: var(--row-selected);\n  }\n\n  .cell {\n    padding: 0 8px;\n    font-size: 12px;\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    min-width: 0;\n  }\n\n  .cell.size {\n    text-align: right;\n    font-variant-numeric: tabular-nums;\n  }\n\n  .ellipsis {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n\n  .hl {\n    background: none;\n    color: inherit;\n    font-weight: 700;\n  }\n\n  .file-icon {\n    width: 16px;\n    height: 16px;\n    flex: 0 0 auto;\n  }\n\n  .rename-input {\n    flex: 1;\n    min-width: 0;\n    height: 22px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 12px;\n    padding: 0 6px;\n    border: 1.5px solid var(--focus-ring);\n    border-radius: 4px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    outline: none;\n    box-shadow: 0 1px 6px rgba(0, 0, 0, 0.18), 0 0 0 3px rgba(77, 168, 255, 0.12);\n  }\n\n  .status-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 32px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    border-top: 1px solid var(--border-soft);\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 11px;\n    color: var(--text-muted);\n    white-space: nowrap;\n    overflow: hidden;\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .status-left {\n    display: flex;\n    align-items: center;\n    gap: 16px;\n    overflow: hidden;\n    min-width: 0;\n  }\n\n  .status-right {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    flex-shrink: 0;\n  }\n\n  .status-btn {\n    border: 1px solid var(--button-border);\n    border-radius: 5px;\n    background: var(--button-bg);\n    color: var(--button-text);\n    font-size: 11px;\n    height: 22px;\n    padding: 0 8px;\n    cursor: pointer;\n  }\n\n  .status-btn:hover {\n    filter: brightness(1.06);\n  }\n\n  .status-btn:disabled {\n    opacity: 0.55;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .status-state {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n  }\n\n  .state-dot {\n    width: 6px;\n    height: 6px;\n    border-radius: 50%;\n    flex-shrink: 0;\n  }\n\n  .state-dot.ready { background: #28C840; }\n  .state-dot.indexing { background: #FEBC2E; }\n  .state-dot.error { background: #FF5F57; }\n\n  .rebuild-btn {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 10px;\n    font-weight: 500;\n    background: var(--button-bg);\n    border: 1px solid var(--button-border);\n    border-radius: 4px;\n    color: var(--button-text);\n    height: 22px;\n    padding: 0 10px;\n    cursor: pointer;\n  }\n\n  .rebuild-btn:hover {\n    filter: brightness(1.1);\n  }\n\n  .rebuild-btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .rebuild-icon {\n    width: 11px;\n    height: 11px;\n    color: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .status-error {\n    color: var(--error-text);\n  }\n\n  .status-warning {\n    color: var(--warning-text);\n  }\n\n  .status-spotlight {\n    color: #f59e0b;\n    font-weight: 600;\n  }\n\n  .context-menu {\n    position: fixed;\n    z-index: 200;\n    width: 220px;\n    border: 1px solid var(--menu-border);\n    border-radius: 10px;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.16), inset 0 0 0 0.5px rgba(255, 255, 255, 0.18);\n    background: var(--menu-bg);\n    backdrop-filter: blur(28px) saturate(180%);\n    -webkit-backdrop-filter: blur(28px) saturate(180%);\n    overflow: hidden;\n  }\n\n  .context-menu button {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    padding: 8px 10px;\n    font-size: 12px;\n    color: var(--menu-text);\n  }\n\n  .context-menu button:hover {\n    background: var(--menu-hover);\n  }\n\n  .toast {\n    position: fixed;\n    right: 14px;\n    bottom: 18px;\n    background: var(--toast-bg);\n    color: var(--toast-text);\n    border-radius: 10px;\n    padding: 9px 12px;\n    font-size: 12px;\n    z-index: 250;\n    backdrop-filter: blur(20px) saturate(180%);\n    -webkit-backdrop-filter: blur(20px) saturate(180%);\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);\n  }\n</style>\n","structuredPatch":[{"oldStart":1493,"oldLines":6,"newStart":1493,"newLines":7,"lines":["       on:scroll={() => {","         scrollTop = tableContainer.scrollTop;","         headerScrollLeft = tableContainer.scrollLeft;","+        if (editing.active) cancelRename();","         const scrollBottom = scrollTop + tableContainer.clientHeight;","         if (scrollBottom >= totalHeight - rowHeight * 10) {","           void loadMore();"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"f8986709-18ae-4991-8e7b-e35cf5c0ec10"}
{"parentUuid":"f6c41367-792e-4288-80f7-4f0d81ebe9c3","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","message":{"model":"claude-sonnet-4-6","id":"msg_01QmdE3LENKncqJcJK8NmbFJ","type":"message","role":"assistant","content":[{"type":"text","text":"row 내부의 rename input 제거 — 항상 텍스트만 표시, renaming 중인 row는 텍스트 희미하게:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":331,"cache_read_input_tokens":81129,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":331},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMN7SMWhZjCASDF9rLqo","type":"assistant","uuid":"d9e795e0-0c28-4fdb-aaef-f2be6f03ae01","timestamp":"2026-02-21T14:22:58.347Z"}
{"parentUuid":"d9e795e0-0c28-4fdb-aaef-f2be6f03ae01","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","message":{"model":"claude-sonnet-4-6","id":"msg_01QmdE3LENKncqJcJK8NmbFJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BdL3AEsbWe8KZb9ojUoRiN","name":"Edit","input":{"replace_all":false,"file_path":"/Users/al02402336/everything/src/App.svelte","old_string":"            <div\n              class=\"row {selectedIndices.has(index) ? 'selected' : ''} {editing.active && editing.index === index ? 'renaming' : ''}\"\n              on:mousedown={(event) => handleRowMouseDown(event, index)}\n              on:click={(event) => handleRowClick(event, index)}\n              on:keydown={(event) => handleRowA11yKeydown(event, index)}\n              on:dblclick={() => handleRowDoubleClick(index)}\n              on:contextmenu={(event) => handleRowContextMenu(event, index)}\n              role=\"row\"\n              tabindex=\"0\"\n            >\n              <div class=\"cell name\">\n                <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n\n                {#if editing.active && editing.index === index}\n                  <input\n                    bind:this={renameInputEl}\n                    class=\"rename-input\"\n                    type=\"text\"\n                    bind:value={editing.draftName}\n                    on:click|stopPropagation\n                    on:blur={commitRename}\n                  />\n                {:else}\n                  <span class=\"ellipsis\">{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n                {/if}\n              </div>","new_string":"            <div\n              class=\"row {selectedIndices.has(index) ? 'selected' : ''}\"\n              on:mousedown={(event) => handleRowMouseDown(event, index)}\n              on:click={(event) => handleRowClick(event, index)}\n              on:keydown={(event) => handleRowA11yKeydown(event, index)}\n              on:dblclick={() => handleRowDoubleClick(index)}\n              on:contextmenu={(event) => handleRowContextMenu(event, index)}\n              role=\"row\"\n              tabindex=\"0\"\n            >\n              <div class=\"cell name\">\n                <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n                <span class=\"ellipsis\" class:name-editing={editing.active && editing.index === index}>{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n              </div>"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":331,"cache_read_input_tokens":81129,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":331},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMN7SMWhZjCASDF9rLqo","type":"assistant","uuid":"7824066d-c61a-4ef3-89e0-4bcd611630cc","timestamp":"2026-02-21T14:23:04.729Z"}
{"parentUuid":"7824066d-c61a-4ef3-89e0-4bcd611630cc","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01BdL3AEsbWe8KZb9ojUoRiN","toolUseID":"toolu_01BdL3AEsbWe8KZb9ojUoRiN","timestamp":"2026-02-21T14:23:04.736Z","uuid":"1f4bee91-3c9d-4399-924c-018b17a9ce91"}
{"parentUuid":"7824066d-c61a-4ef3-89e0-4bcd611630cc","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BdL3AEsbWe8KZb9ojUoRiN","type":"tool_result","content":"The file /Users/al02402336/everything/src/App.svelte has been updated successfully."}]},"uuid":"2e22789b-9102-4d0d-93b1-c1ea3a5af313","timestamp":"2026-02-21T14:23:04.736Z","toolUseResult":{"filePath":"/Users/al02402336/everything/src/App.svelte","oldString":"            <div\n              class=\"row {selectedIndices.has(index) ? 'selected' : ''} {editing.active && editing.index === index ? 'renaming' : ''}\"\n              on:mousedown={(event) => handleRowMouseDown(event, index)}\n              on:click={(event) => handleRowClick(event, index)}\n              on:keydown={(event) => handleRowA11yKeydown(event, index)}\n              on:dblclick={() => handleRowDoubleClick(index)}\n              on:contextmenu={(event) => handleRowContextMenu(event, index)}\n              role=\"row\"\n              tabindex=\"0\"\n            >\n              <div class=\"cell name\">\n                <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n\n                {#if editing.active && editing.index === index}\n                  <input\n                    bind:this={renameInputEl}\n                    class=\"rename-input\"\n                    type=\"text\"\n                    bind:value={editing.draftName}\n                    on:click|stopPropagation\n                    on:blur={commitRename}\n                  />\n                {:else}\n                  <span class=\"ellipsis\">{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n                {/if}\n              </div>","newString":"            <div\n              class=\"row {selectedIndices.has(index) ? 'selected' : ''}\"\n              on:mousedown={(event) => handleRowMouseDown(event, index)}\n              on:click={(event) => handleRowClick(event, index)}\n              on:keydown={(event) => handleRowA11yKeydown(event, index)}\n              on:dblclick={() => handleRowDoubleClick(index)}\n              on:contextmenu={(event) => handleRowContextMenu(event, index)}\n              role=\"row\"\n              tabindex=\"0\"\n            >\n              <div class=\"cell name\">\n                <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n                <span class=\"ellipsis\" class:name-editing={editing.active && editing.index === index}>{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n              </div>","originalFile":"<script>\n  import { onDestroy, onMount, tick } from 'svelte';\n  import { invoke } from '@tauri-apps/api/core';\n  import { listen } from '@tauri-apps/api/event';\n  import { getCurrentWindow } from '@tauri-apps/api/window';\n  import { startDrag } from '@crabnebula/tauri-plugin-drag';\n\n  const rowHeight = 30;\n  const PAGE_SIZE = 500;\n  let homePrefix = '';\n  const COL_WIDTHS_KEY = 'REDACTED';\n  const THEME_KEY = 'everything-theme';\n  const columnKeys = ['name', 'path', 'size', 'modified'];\n  const minColumnWidth = {\n    name: 180,\n    path: 240,\n    size: 75,\n    modified: 150\n  };\n  const defaultColumnRatios = {\n    name: 0.3,\n    path: 0.45,\n    size: 0.1\n  };\n\n  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || 'dark'; } catch { return 'dark'; } })();\n  function cycleTheme() {\n    theme = theme === 'dark' ? 'light' : 'dark';\n    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n  }\n\n  let query = '';\n  let results = [];\n  let totalResults = 0;\n  let totalResultsKnown = false;\n\n  let dbLatencyMs = null;\n  let dbLastQuery = '';\n  let searchModeLabel = '';\n  let selectedIndices = new Set();\n  let selectionAnchor = -1;\n  let lastSelectedIndex = -1;\n  let editing = {\n    active: false,\n    path: '',\n    index: -1,\n    draftName: ''\n  };\n\n  let renameOverlay = { top: 0, left: 0, width: 0 };\n\n  let indexStatus = {\n    state: 'Indexing',\n    entriesCount: 0,\n    lastUpdated: null,\n    permissionErrors: 0,\n    message: null,\n    isCatchup: false\n  };\n\n  let indexingStartTime = null;\n  let indexingElapsed = '';\n  let indexingFinishedAt = '';\n\n  let sortBy = 'name';\n  let sortDir = 'asc';\n\n  let hasMore = true;\n  let loadingMore = false;\n  let searchGeneration = 0;\n\n  let scanned = 0;\n\n  let searchInputEl;\n  let renameInputEl;\n  let tableAreaEl;\n  let tableContainer;\n  let tableResizeObserver = null;\n  let viewportResizeRaf = null;\n  let scrollTop = 0;\n  let headerScrollLeft = 0;\n  let viewportHeight = 520;\n  let lastTableWidth = 0;\n  let resizingColumn = '';\n  let resizeCleanup = null;\n  let colWidths = {\n    name: 250,\n    path: 350,\n    size: 75,\n    modified: 150\n  };\n\n  let contextMenu = {\n    visible: false,\n    x: 0,\n    y: 0\n  };\n\n  let platform = '';\n  let toast = '';\n  let searchTimer;\n  let lastSearchFiredAt = 0;\n  let toastTimer;\n  let statusRefreshTimer;\n  let elapsedTimer;\n  let statusRefreshInFlight = false;\n  let lastReadyCount = 0;\n\n  const iconCache = new Map();\n  const iconLoading = new Set();\n\n  let highlightCache = new Map();\n  let highlightCacheQuery = '';\n\n  const folderFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='1' y='4' width='14' height='10' rx='2' fill='#d9b34f'/><rect x='1' y='2' width='6' height='4' rx='1' fill='#e6ca7a'/></svg>`\n    );\n  const fileFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='3' y='1' width='10' height='14' rx='1.5' fill='#b4bec9'/><rect x='5' y='5' width='6' height='1.2' fill='#8d98a5'/><rect x='5' y='8' width='6' height='1.2' fill='#8d98a5'/></svg>`\n    );\n\n  $: totalHeight = results.length * rowHeight;\n  $: startIndex = Math.max(0, Math.floor(scrollTop / rowHeight) - 10);\n  $: visibleCount = Math.ceil(viewportHeight / rowHeight) + 20;\n  $: endIndex = Math.min(results.length, startIndex + visibleCount);\n  $: visibleRows = results.slice(startIndex, endIndex);\n  $: translateY = startIndex * rowHeight;\n  $: tableMinWidth = colWidths.name + colWidths.path + colWidths.size + colWidths.modified;\n  $: tableGridStyle = `--col-name:${colWidths.name}px;--col-path:${colWidths.path}px;--col-size:${colWidths.size}px;--col-modified:${colWidths.modified}px;--table-min-width:${tableMinWidth}px;--header-offset:${-headerScrollLeft}px;`;\n\n  $: {\n    for (const entry of visibleRows) {\n      void ensureIcon(entry);\n    }\n  }\n\n  function showToast(message) {\n    toast = message;\n    clearTimeout(toastTimer);\n    toastTimer = setTimeout(() => {\n      toast = '';\n    }, 3000);\n  }\n\n  function bytesToBase64(bytes) {\n    let binary = '';\n    const chunk = 0x8000;\n    for (let i = 0; i < bytes.length; i += chunk) {\n      const part = bytes.subarray(i, i + chunk);\n      binary += String.fromCharCode(...part);\n    }\n    return btoa(binary);\n  }\n\n  function highlightSegments(name, q) {\n    q = (q || '').trim();\n    if (!q) return [{ text: name, hl: false }];\n\n    // Reset cache when query changes\n    if (q !== highlightCacheQuery) {\n      highlightCache = new Map();\n      highlightCacheQuery = q;\n    }\n\n    // Check cache\n    const cached = highlightCache.get(name);\n    if (cached) return cached;\n\n    if (q.includes('/')) q = q.slice(q.lastIndexOf('/') + 1);\n    q = q.replace(/[*?]/g, '');\n    const terms = q.split(/\\s+/).filter(Boolean);\n    if (terms.length === 0) return [{ text: name, hl: false }];\n\n    const lower = name.toLowerCase();\n    const marks = new Uint8Array(name.length);\n    for (const t of terms) {\n      const tl = t.toLowerCase();\n      let idx = lower.indexOf(tl);\n      while (idx !== -1) {\n        for (let i = idx; i < idx + tl.length; i++) marks[i] = 1;\n        idx = lower.indexOf(tl, idx + 1);\n      }\n    }\n\n    const segs = [];\n    let i = 0;\n    while (i < name.length) {\n      const m = marks[i];\n      let j = i + 1;\n      while (j < name.length && marks[j] === m) j++;\n      segs.push({ text: name.slice(i, j), hl: m === 1 });\n      i = j;\n    }\n\n    highlightCache.set(name, segs);\n    return segs;\n  }\n\n  const perFileIconExts = new Set(['exe', 'lnk', 'ico', 'url', 'scr', 'appx']);\n\n  function iconKey(entry) {\n    if (entry.isDir) return '__folder__';\n    const ext = (entry.ext || '').toLowerCase();\n    if (perFileIconExts.has(ext)) return entry.path;\n    return ext || '__file__';\n  }\n\n  function iconFor(entry) {\n    return iconCache.get(iconKey(entry)) || (entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n  }\n\n  async function ensureIcon(entry) {\n    const key = iconKey(entry);\n    if (iconCache.has(key) || iconLoading.has(key)) {\n      return;\n    }\n\n    iconLoading.add(key);\n    try {\n      const bytes = await invoke('get_file_icon', {\n        path: entry.path,\n        ext: entry.isDir ? 'folder' : entry.ext || '',\n      });\n      if (Array.isArray(bytes) && bytes.length > 0) {\n        const image = `data:image/png;base64,${bytesToBase64(Uint8Array.from(bytes))}`;\n        iconCache.set(key, image);\n      } else {\n        iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n      }\n    } catch {\n      iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n    } finally {\n      iconLoading.delete(key);\n    }\n  }\n\n  function syncColumnWidthsToContainer() {\n    const width = tableContainer?.clientWidth || tableAreaEl?.clientWidth;\n    if (!width || lastTableWidth !== 0) {\n      return;\n    }\n\n    const saved = loadColWidths();\n    if (saved) {\n      const total = columnKeys.reduce((s, k) => s + saved[k], 0);\n      if (Math.abs(total - width) > 2) {\n        const scale = (width - saved.modified) / (total - saved.modified);\n        let scaledName = Math.max(minColumnWidth.name, Math.round(saved.name * scale));\n        let scaledSize = Math.max(minColumnWidth.size, Math.round(saved.size * scale));\n        let rawPath = width - saved.modified - scaledName - scaledSize;\n        if (rawPath < minColumnWidth.path) {\n          const shortfall = minColumnWidth.path - rawPath;\n          const nameReduction = Math.min(shortfall, scaledName - minColumnWidth.name);\n          scaledName -= nameReduction;\n          const remaining = shortfall - nameReduction;\n          if (remaining > 0) {\n            scaledSize -= Math.min(remaining, scaledSize - minColumnWidth.size);\n          }\n          rawPath = width - saved.modified - scaledName - scaledSize;\n        }\n        const scaledPath = Math.max(minColumnWidth.path, rawPath);\n        colWidths = { name: scaledName, path: scaledPath, size: scaledSize, modified: saved.modified };\n      } else {\n        colWidths = saved;\n      }\n    } else {\n      const fixedModified = minColumnWidth.modified;\n      const rest = width - fixedModified;\n      const ratioSum = defaultColumnRatios.name + defaultColumnRatios.path + defaultColumnRatios.size;\n      colWidths = {\n        name: Math.max(minColumnWidth.name, Math.round(rest * defaultColumnRatios.name / ratioSum)),\n        path: Math.max(minColumnWidth.path, Math.round(rest * defaultColumnRatios.path / ratioSum)),\n        size: Math.max(minColumnWidth.size, Math.round(rest * defaultColumnRatios.size / ratioSum)),\n        modified: fixedModified\n      };\n    }\n    lastTableWidth = width;\n  }\n\n  function loadColWidths() {\n    try {\n      const raw = localStorage.getItem(COL_WIDTHS_KEY);\n      if (!raw) return null;\n      const parsed = JSON.parse(raw);\n      for (const key of columnKeys) {\n        if (typeof parsed[key] !== 'number' || parsed[key] < (minColumnWidth[key] || 0)) return null;\n      }\n      return parsed;\n    } catch {\n      return null;\n    }\n  }\n\n  function saveColWidths() {\n    localStorage.setItem(COL_WIDTHS_KEY, JSON.stringify(colWidths));\n  }\n\n  function updateViewportHeight() {\n    viewportHeight = tableContainer?.clientHeight || 520;\n    syncColumnWidthsToContainer();\n  }\n\n  function scheduleViewportHeightUpdate() {\n    if (viewportResizeRaf !== null) {\n      return;\n    }\n    viewportResizeRaf = requestAnimationFrame(() => {\n      viewportResizeRaf = null;\n      updateViewportHeight();\n    });\n  }\n\n  function startColumnResize(event, leftKey) {\n    event.preventDefault();\n    event.stopPropagation();\n\n    const index = columnKeys.indexOf(leftKey);\n    if (index < 0 || index >= columnKeys.length - 1) {\n      return;\n    }\n\n    const startX = event.clientX;\n    const startLeft = colWidths[leftKey];\n    const rightKey = columnKeys[index + 1];\n    const startRight = colWidths[rightKey];\n\n    resizeCleanup?.();\n    resizingColumn = leftKey;\n\n    const onMove = (moveEvent) => {\n      const delta = Math.round(moveEvent.clientX - startX);\n      if (leftKey === 'name') {\n        // Two-column trade: name and path swap space, each respects its minimum\n        const nextLeft = Math.max(\n          minColumnWidth[leftKey],\n          Math.min(startLeft + delta, startLeft + startRight - minColumnWidth[rightKey])\n        );\n        const nextRight = startLeft + startRight - nextLeft;\n        colWidths = { ...colWidths, [leftKey]: nextLeft, [rightKey]: nextRight };\n      } else {\n        // path splitter: path grows unconstrained (allows horizontal scroll on right drag)\n        const nextLeft = Math.max(minColumnWidth[leftKey], startLeft + delta);\n        colWidths = { ...colWidths, [leftKey]: nextLeft };\n      }\n    };\n\n    const onUp = () => {\n      cleanup();\n    };\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      document.body.style.cursor = '';\n      document.body.style.userSelect = '';\n      resizingColumn = '';\n      saveColWidths();\n      if (resizeCleanup === cleanup) {\n        resizeCleanup = null;\n      }\n    };\n\n    resizeCleanup = cleanup;\n    document.body.style.cursor = 'col-resize';\n    document.body.style.userSelect = 'none';\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  function selectedPaths() {\n    const sorted = [...selectedIndices].sort((a, b) => a - b);\n    return sorted.map((idx) => results[idx]).filter(Boolean).map((entry) => entry.path);\n  }\n\n  function clearSelection() {\n    selectedIndices = new Set();\n    selectionAnchor = -1;\n    lastSelectedIndex = -1;\n  }\n\n  function selectSingle(index) {\n    selectedIndices = new Set([index]);\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectToggle(index) {\n    const next = new Set(selectedIndices);\n    if (next.has(index)) {\n      next.delete(index);\n    } else {\n      next.add(index);\n    }\n    selectedIndices = next;\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectRange(index) {\n    const anchor = selectionAnchor >= 0 ? selectionAnchor : index;\n    const [from, to] = [Math.min(anchor, index), Math.max(anchor, index)];\n    const next = new Set();\n    for (let i = from; i <= to; i += 1) {\n      next.add(i);\n    }\n    selectedIndices = next;\n    lastSelectedIndex = index;\n  }\n\n  function primaryEntry() {\n    const idx = lastSelectedIndex >= 0 ? lastSelectedIndex : -1;\n    return idx >= 0 ? results[idx] : null;\n  }\n\n  async function refreshStatus() {\n    if (statusRefreshInFlight) {\n      return;\n    }\n    statusRefreshInFlight = true;\n    try {\n      const status = await invoke('get_index_status');\n      const prevState = indexStatus.state;\n      indexStatus = {\n        state: status.state,\n        entriesCount: status.entriesCount,\n        lastUpdated: status.lastUpdated,\n        permissionErrors: status.permissionErrors ?? 0,\n        message: status.message\n      };\n      if (status.state === 'Indexing' && prevState !== 'Indexing') {\n        startElapsedTimer();\n      } else if (status.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n      if (typeof status.scanned === 'number') {\n        scanned = status.scanned;\n      }\n      if (status.state === 'Ready' && prevState !== 'Ready') {\n        scheduleSearch();\n      }\n    } catch (err) {\n      showToast(`Failed to get status: ${String(err)}`);\n    } finally {\n      statusRefreshInFlight = false;\n    }\n  }\n\n  function scheduleSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const scheduledGen = searchGeneration;\n    clearTimeout(searchTimer);\n\n    const now = performance.now();\n    if (now - lastSearchFiredAt >= 200) {\n      // Leading edge: fire immediately if enough time has passed\n      lastSearchFiredAt = now;\n      void runSearch(preserveScroll);\n    } else {\n      // Trailing edge: debounce\n      searchTimer = setTimeout(() => {\n        if (scheduledGen !== searchGeneration) {\n          return;\n        }\n        lastSearchFiredAt = performance.now();\n        void runSearch(preserveScroll);\n      }, 200);\n    }\n  }\n\n  async function runSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const gen = searchGeneration;\n    const searchQuery = query;\n    const searchSortBy = sortBy;\n    const searchSortDir = sortDir;\n    const startedAt = performance.now();\n    try {\n      const keepPaths = new Set(selectedPaths());\n      const next = await invoke('search', {\n        query: searchQuery,\n        limit: PAGE_SIZE,\n        offset: 0,\n        sortBy: searchSortBy,\n        sortDir: searchSortDir\n      });\n\n      if (gen !== searchGeneration) return;\n\n      dbLatencyMs = Math.round(performance.now() - startedAt);\n      dbLastQuery = searchQuery;\n      const entries = Array.isArray(next.entries) ? next.entries : [];\n      searchModeLabel = next.modeLabel || '';\n      results = entries;\n      if (next.totalCount > 0) {\n        totalResults = next.totalCount;\n        totalResultsKnown = true;\n      } else {\n        totalResults = entries.length;\n        totalResultsKnown = false;\n      }\n      hasMore = totalResultsKnown ? results.length < totalResults : entries.length >= PAGE_SIZE;\n      if (!preserveScroll && tableContainer) tableContainer.scrollTop = 0;\n\n      const restored = new Set();\n      for (let i = 0; i < results.length; i += 1) {\n        if (keepPaths.has(results[i].path)) {\n          restored.add(i);\n        }\n      }\n      selectedIndices = restored;\n\n      updateViewportHeight();\n    } catch (err) {\n      if (gen !== searchGeneration) return;\n      showToast(`Search failed: ${String(err)}`);\n    }\n  }\n\n  async function loadMore() {\n    if (!hasMore || loadingMore) return;\n    const gen = searchGeneration;\n    loadingMore = true;\n    try {\n      const batch = await invoke('search', {\n        query,\n        limit: PAGE_SIZE,\n        offset: results.length,\n        sortBy: sortBy,\n        sortDir: sortDir\n      });\n      if (gen !== searchGeneration) return;\n      const arr = Array.isArray(batch.entries) ? batch.entries : [];\n      if (arr.length > 0) results = [...results, ...arr];\n      hasMore = totalResultsKnown ? results.length < totalResults : arr.length >= PAGE_SIZE;\n    } catch (err) {\n      showToast(`Failed to load more: ${String(err)}`);\n    } finally {\n      loadingMore = false;\n    }\n  }\n\n  function moveSelection(delta, withRange = false) {\n    if (results.length === 0) {\n      return;\n    }\n\n    const current = lastSelectedIndex >= 0 ? lastSelectedIndex : 0;\n    const next = Math.max(0, Math.min(results.length - 1, current + delta));\n\n    if (withRange) {\n      selectRange(next);\n    } else {\n      selectSingle(next);\n    }\n\n    const top = next * rowHeight;\n    const bottom = top + rowHeight;\n    if (top < scrollTop) {\n      tableContainer.scrollTop = top;\n    } else if (bottom > scrollTop + viewportHeight) {\n      tableContainer.scrollTop = bottom - viewportHeight;\n    }\n  }\n\n  function handleHeaderSort(column) {\n    if (sortBy === column) {\n      sortDir = sortDir === 'asc' ? 'desc' : 'asc';\n    } else {\n      sortBy = column;\n      sortDir = 'asc';\n    }\n    if (tableContainer) tableContainer.scrollTop = 0;\n    void runSearch();\n  }\n\n  function handleRowClick(event, index) {\n    contextMenu.visible = false;\n\n    if (event.shiftKey) {\n      selectRange(index);\n      return;\n    }\n\n    if (event.metaKey || event.ctrlKey) {\n      selectToggle(index);\n      return;\n    }\n\n    selectSingle(index);\n  }\n\n  function handleRowContextMenu(event, index) {\n    event.preventDefault();\n\n    if (!selectedIndices.has(index)) {\n      selectSingle(index);\n    }\n\n    if (platform === 'windows' || platform === 'macos') {\n      contextMenu.visible = false;\n      const paths = selectedPaths();\n      if (paths.length > 0) {\n        invoke('show_context_menu', {\n          paths,\n          x: event.clientX,\n          y: event.clientY,\n          singleSelection: selectedIndices.size === 1\n        });\n      }\n      return;\n    }\n\n    contextMenu = {\n      visible: true,\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n\n  function handleRowA11yKeydown(event, index) {\n    if (event.key === ' ' || event.key === 'Enter') {\n      event.preventDefault();\n      handleRowClick(event, index);\n    }\n  }\n\n  const DRAG_THRESHOLD = 5;\n  let dragCleanup = null;\n  const dragImgCache = new Map();\n\n  function dragPathsForIndex(index) {\n    const entry = results[index];\n    if (!entry) {\n      return [];\n    }\n\n    if (selectedIndices.has(index) && selectedIndices.size > 0) {\n      return selectedPaths();\n    }\n\n    return [entry.path];\n  }\n\n  function getDragIconEl(entry) {\n    const src = iconFor(entry);\n    let img = dragImgCache.get(src);\n    if (!img) {\n      img = new Image();\n      img.src = src;\n      dragImgCache.set(src, img);\n    }\n    return img.complete && img.naturalWidth > 0 ? img : null;\n  }\n\n  function fillRoundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function buildDragPreview(index) {\n    const entry = results[index];\n    if (!entry) return null;\n\n    const count = selectedIndices.has(index) ? selectedIndices.size : 1;\n    const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\n\n    const w = 260;\n    const h = 28;\n    const stackGap = count > 1 ? 4 : 0;\n\n    const canvas = document.createElement('canvas');\n    canvas.width = w;\n    canvas.height = h + stackGap;\n    const ctx = canvas.getContext('2d');\n\n    if (count > 1) {\n      ctx.globalAlpha = 0.35;\n      ctx.fillStyle = isDark ? '#5a6070' : '#b0c4de';\n      fillRoundRect(ctx, 3, 0, w - 3, h, 5);\n      ctx.globalAlpha = 1.0;\n    }\n\n    const ry = stackGap;\n    ctx.fillStyle = isDark ? 'rgba(58, 64, 74, 0.94)' : 'rgba(214, 231, 255, 0.94)';\n    fillRoundRect(ctx, 0, ry, w, h, 5);\n\n    ctx.strokeStyle = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';\n    ctx.lineWidth = 0.5;\n    ctx.beginPath();\n    ctx.moveTo(5, ry);\n    ctx.arcTo(w, ry, w, ry + h, 5);\n    ctx.arcTo(w, ry + h, 0, ry + h, 5);\n    ctx.arcTo(0, ry + h, 0, ry, 5);\n    ctx.arcTo(0, ry, w, ry, 5);\n    ctx.closePath();\n    ctx.stroke();\n\n    const iconEl = getDragIconEl(entry);\n    if (iconEl) {\n      ctx.drawImage(iconEl, 6, ry + 6, 16, 16);\n    } else {\n      ctx.fillStyle = entry.isDir ? '#d9b34f' : '#8d98a5';\n      fillRoundRect(ctx, 6, ry + 6, 16, 16, 2);\n    }\n\n    ctx.fillStyle = isDark ? '#e6e6e8' : '#1a1a1a';\n    ctx.font = '12px -apple-system, \"SF Pro Text\", system-ui, sans-serif';\n    ctx.textBaseline = 'middle';\n\n    let nameMaxW = w - 34;\n    if (count > 1) nameMaxW -= 34;\n\n    let name = entry.name;\n    if (ctx.measureText(name).width > nameMaxW) {\n      while (name.length > 4 && ctx.measureText(name + '\\u2026').width > nameMaxW) {\n        name = name.slice(0, -1);\n      }\n      name += '\\u2026';\n    }\n    ctx.fillText(name, 28, ry + h / 2 + 1);\n\n    if (count > 1) {\n      const badge = String(count);\n      ctx.font = 'bold 10px -apple-system, system-ui, sans-serif';\n      const tw = ctx.measureText(badge).width;\n      const bw = Math.max(20, tw + 10);\n      const bx = w - bw - 6;\n      const by = ry + (h - 18) / 2;\n\n      ctx.fillStyle = isDark ? '#5b8bd9' : '#007aff';\n      fillRoundRect(ctx, bx, by, bw, 18, 9);\n\n      ctx.fillStyle = '#ffffff';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(badge, bx + bw / 2, by + 9);\n    }\n\n    return canvas.toDataURL('image/png');\n  }\n\n  function handleRowMouseDown(event, index) {\n    if (event.button !== 0) return;\n    if (event.metaKey || event.ctrlKey || event.shiftKey) return;\n    if (editing.active) return;\n\n    const startX = event.clientX;\n    const startY = event.clientY;\n    let dragging = false;\n\n    dragCleanup?.();\n\n    const onMove = (e) => {\n      if (dragging) return;\n      const dx = e.clientX - startX;\n      const dy = e.clientY - startY;\n      if (dx * dx + dy * dy < DRAG_THRESHOLD * DRAG_THRESHOLD) return;\n\n      dragging = true;\n      cleanup();\n\n      if (!selectedIndices.has(index)) {\n        selectSingle(index);\n      }\n\n      const paths = dragPathsForIndex(index);\n      if (paths.length > 0) {\n        const icon = buildDragPreview(index);\n        startDrag({ item: paths, icon }).catch(() => {});\n      }\n    };\n\n    const onUp = () => cleanup();\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      if (dragCleanup === cleanup) dragCleanup = null;\n    };\n\n    dragCleanup = cleanup;\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  async function handleRowDoubleClick(index) {\n    if (!selectedIndices.has(index) || selectedIndices.size > 1) {\n      selectSingle(index);\n      await tick();\n    }\n    await invoke('open', { paths: [results[index].path] }).catch((err) => {\n      showToast(`Failed to open: ${String(err)}`);\n    });\n  }\n\n  function closeContextMenu() {\n    contextMenu = {\n      ...contextMenu,\n      visible: false\n    };\n  }\n\n  async function openSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('open', { paths });\n    } catch (err) {\n      showToast(`Failed to open: ${String(err)}`);\n    }\n  }\n\n  async function openWithFallback() {\n    const target = primaryEntry();\n    if (!target) {\n      return;\n    }\n\n    try {\n      await invoke('open_with', { path: target.path });\n    } catch (err) {\n      showToast(`Open With failed: ${String(err)}`);\n    }\n  }\n\n  async function revealSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('reveal_in_finder', { paths });\n    } catch (err) {\n      showToast(`Failed to reveal in Finder: ${String(err)}`);\n    }\n  }\n\n  async function copySelectedPaths() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_paths', { paths });\n      showToast(`Copied ${paths.length} path(s)`);\n    } catch (err) {\n      showToast(`Failed to copy path: ${String(err)}`);\n    }\n  }\n\n  async function copyFiles() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_files', { paths });\n      showToast(`Copied ${paths.length} item(s)`);\n    } catch (err) {\n      showToast(`Failed to copy: ${String(err)}`);\n    }\n  }\n\n  async function trashSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    const message =\n      paths.length === 1\n        ? 'Move selected item to Trash?'\n        : `Move ${paths.length} items to Trash?`;\n\n    if (!window.confirm(message)) {\n      return;\n    }\n\n    try {\n      await invoke('move_to_trash', { paths });\n      showToast('Moved to Trash.');\n      clearSelection();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to move to Trash: ${String(err)}`);\n    }\n  }\n\n  async function resetIndex() {\n    if (indexStatus.state === 'Indexing') {\n      showToast('Indexing in progress. Please try again after it completes.');\n      return;\n    }\n\n    results = [];\n    totalResults = 0;\n    totalResultsKnown = false;\n    clearSelection();\n    scanned = 0;\n    dbLatencyMs = null;\n    dbLastQuery = '';\n    indexStatus = { ...indexStatus, state: 'Indexing', entriesCount: 0, message: null };\n    indexingStartTime = Date.now();\n    indexingElapsed = '';\n    indexingFinishedAt = '';\n\n    try {\n      await invoke('reset_index');\n    } catch (err) {\n      showToast(`Failed to reset index: ${String(err)}`);\n      await refreshStatus();\n    }\n  }\n\n  function isMultiSelected() {\n    return selectedIndices.size > 1;\n  }\n\n  function autoResizeRenameInput() {\n    if (!renameInputEl) return;\n    renameInputEl.style.height = '0';\n    renameInputEl.style.height = renameInputEl.scrollHeight + 'px';\n  }\n\n  async function startRename() {\n    if (isMultiSelected()) {\n      return;\n    }\n\n    const idx = lastSelectedIndex;\n    if (idx < 0 || !results[idx]) {\n      return;\n    }\n\n    const entry = results[idx];\n\n    // Calculate overlay position from the row's name cell text span\n    const rowDomIndex = idx - startIndex;\n    const rowEls = tableContainer?.querySelectorAll('.row');\n    const rowEl = rowEls?.[rowDomIndex];\n    const nameCell = rowEl?.querySelector('.cell.name');\n\n    if (nameCell) {\n      const cellRect = nameCell.getBoundingClientRect();\n      const ellipsis = nameCell.querySelector('.ellipsis');\n      const textLeft = ellipsis ? ellipsis.getBoundingClientRect().left : cellRect.left + 38;\n      // Offset left by border(1.5) + padding-left(4) so text inside textarea aligns with row text\n      const pad = 6;\n      renameOverlay = {\n        top: cellRect.top,\n        left: textLeft - pad,\n        width: cellRect.right - textLeft + pad - 4\n      };\n    }\n\n    editing = {\n      active: true,\n      path: entry.path,\n      index: idx,\n      draftName: entry.name\n    };\n\n    await tick();\n\n    if (renameInputEl) {\n      autoResizeRenameInput();\n      renameInputEl.focus();\n      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n      renameInputEl.setSelectionRange(0, selectionEnd);\n    }\n  }\n\n  function cancelRename() {\n    editing = {\n      active: false,\n      path: '',\n      index: -1,\n      draftName: ''\n    };\n  }\n\n  async function commitRename() {\n    if (!editing.active || editing.index < 0 || !results[editing.index]) {\n      return;\n    }\n\n    const current = results[editing.index];\n    const nextName = editing.draftName;\n\n    try {\n      await invoke('rename', {\n        path: current.path,\n        newName: nextName\n      });\n      cancelRename();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to rename: ${String(err)}`);\n      await tick();\n      renameInputEl?.focus();\n    }\n  }\n\n  function onGlobalClick() {\n    closeContextMenu();\n  }\n\n  function onTitleBarMouseDown(event) {\n    if (event.button !== 0) {\n      return;\n    }\n\n    const activeElement = document.activeElement;\n    if (activeElement instanceof HTMLElement && isTextInputTarget(activeElement)) {\n      activeElement.blur();\n    }\n  }\n\n  async function focusSearch() {\n    await getCurrentWindow().show();\n    await getCurrentWindow().setFocus();\n    searchInputEl?.focus();\n    searchInputEl?.select();\n  }\n\n  function isTextInputTarget(target) {\n    return (\n      target instanceof HTMLInputElement ||\n      target instanceof HTMLTextAreaElement ||\n      target?.isContentEditable\n    );\n  }\n\n  async function handleKeydown(event) {\n    const isMetaSelectAll = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'a';\n    const isMetaCopy = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c';\n    const target = event.target;\n    const isTextInput = isTextInputTarget(target);\n\n    if (isMetaCopy && isTextInput) {\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      if (isTextInput) {\n        event.preventDefault();\n        if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n          target.select();\n        }\n        return;\n      }\n    }\n\n    if (editing.active) {\n      if (event.key === 'Enter') {\n        event.preventDefault();\n        await commitRename();\n        return;\n      }\n\n      if (event.key === 'Escape') {\n        event.preventDefault();\n        cancelRename();\n        searchInputEl?.focus();\n        return;\n      }\n      return;\n    }\n\n    if (event.key === 'Escape') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      return;\n    }\n\n    if (event.key === 'ArrowDown') {\n      event.preventDefault();\n      moveSelection(1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'ArrowUp') {\n      event.preventDefault();\n      moveSelection(-1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageDown') {\n      event.preventDefault();\n      moveSelection(Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageUp') {\n      event.preventDefault();\n      moveSelection(-Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'Enter') {\n      event.preventDefault();\n      if (platform === 'windows') {\n        await openSelected();\n      } else {\n        await startRename();\n      }\n      return;\n    }\n\n    if (event.key === 'F2') {\n      event.preventDefault();\n      await startRename();\n      return;\n    }\n\n    if (event.key === ' ' && !isTextInput) {\n      event.preventDefault();\n      const entry = primaryEntry();\n      if (entry) {\n        await invoke('quick_look', { path: entry.path });\n      }\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'f') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      searchInputEl?.select();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'o') {\n      event.preventDefault();\n      await openSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {\n      event.preventDefault();\n      await revealSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c') {\n      event.preventDefault();\n      await copySelectedPaths();\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      event.preventDefault();\n      selectedIndices = new Set(Array.from({ length: results.length }, (_, i) => i));\n      return;\n    }\n\n    if (event.key === 'Delete' || ((event.metaKey || event.ctrlKey) && event.key === 'Backspace')) {\n      if (!isTextInput) {\n        event.preventDefault();\n        await trashSelected();\n      }\n      return;\n    }\n  }\n\n  function formatSize(entry) {\n    if (entry.isDir || entry.size == null) return '';\n    const bytes = entry.size;\n    if (bytes < 1024) return `${bytes} B`;\n    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n    return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n  }\n\n  function formatModified(entry) {\n    if (!entry.mtime) {\n      return '';\n    }\n\n    const d = new Date(entry.mtime * 1000);\n    const pad = (n) => String(n).padStart(2, '0');\n    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;\n  }\n\n  function formatLastUpdated(timestamp) {\n    if (!timestamp) {\n      return '-';\n    }\n\n    return new Date(timestamp * 1000).toLocaleString();\n  }\n\n  function formatElapsed(ms) {\n    const totalSec = Math.floor(ms / 1000);\n    const min = Math.floor(totalSec / 60);\n    const sec = totalSec % 60;\n    return min > 0 ? `${min}m ${sec}s` : `${sec}s`;\n  }\n\n  function updateElapsed() {\n    if (indexingStartTime && indexStatus.state === 'Indexing') {\n      indexingElapsed = formatElapsed(Date.now() - indexingStartTime);\n    }\n  }\n\n  function startElapsedTimer() {\n    clearInterval(elapsedTimer);\n    indexingStartTime = Date.now();\n    indexingElapsed = '0s';\n    indexingFinishedAt = '';\n    elapsedTimer = setInterval(updateElapsed, 1000);\n  }\n\n  function stopElapsedTimer() {\n    clearInterval(elapsedTimer);\n    if (indexingStartTime) {\n      const elapsed = Date.now() - indexingStartTime;\n      indexingFinishedAt = `${formatElapsed(elapsed)}`;\n    }\n    indexingStartTime = null;\n    indexingElapsed = '';\n  }\n\n  function displayPath(path) {\n    if (!path) {\n      return path;\n    }\n\n    if (!homePrefix) {\n      return path;\n    }\n\n    if (path === homePrefix) {\n      return '~';\n    }\n\n    if (path.startsWith(`${homePrefix}/`)) {\n      return `~${path.slice(homePrefix.length)}`;\n    }\n\n    return path;\n  }\n\n  let unlistenFns = [];\n\n  onMount(async () => {\n    const t0 = performance.now();\n    const ms = () => Math.round(performance.now() - t0);\n    const DEBUG_STARTUP = false;\n    const flog = DEBUG_STARTUP ? (msg) => invoke('frontend_log', { msg }).catch(() => {}) : () => {};\n\n    flog(`[startup/fe] onMount entered`);\n\n    updateViewportHeight();\n    flog(`[startup/fe] +${ms()}ms updateViewportHeight done`);\n\n    platform = await invoke('get_platform');\n    flog(`[startup/fe] +${ms()}ms get_platform done`);\n\n    const unlistenProgress = await listen('index_progress', (event) => {\n      scanned = event.payload.scanned;\n      if (indexStatus.state !== 'Indexing') {\n        indexStatus = {\n          ...indexStatus,\n          state: 'Indexing'\n        };\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_progress) registered`);\n\n    const unlistenState = await listen('index_state', (event) => {\n      flog(`[startup/fe] index_state event received: ${event.payload.state} at +${ms()}ms`);\n      const prevState = indexStatus.state;\n      indexStatus = {\n        ...indexStatus,\n        state: event.payload.state,\n        message: event.payload.message ?? null,\n        isCatchup: event.payload.isCatchup ?? false\n      };\n\n      if (event.payload.state === 'Indexing' && prevState !== 'Indexing') {\n        if (prevState === 'Ready') {\n          lastReadyCount = indexStatus.entriesCount;\n        }\n        startElapsedTimer();\n      } else if (event.payload.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n\n      if (event.payload.state === 'Ready') {\n        scheduleSearch();\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_state) registered`);\n\n    const unlistenUpdated = await listen('index_updated', (event) => {\n      indexStatus = {\n        ...indexStatus,\n        entriesCount: event.payload.entriesCount,\n        lastUpdated: event.payload.lastUpdated,\n        permissionErrors: event.payload.permissionErrors ?? indexStatus.permissionErrors\n      };\n\n      scheduleSearch(true);\n    });\n\n    const unlistenFocus = await listen('focus_search', () => {\n      void focusSearch();\n    });\n\n    const unlistenCtxMenuAction = await listen('context_menu_action', (event) => {\n      switch (event.payload) {\n        case 'open': void openSelected(); break;\n        case 'quick_look': {\n          const e = primaryEntry();\n          if (e) void invoke('quick_look', { path: e.path });\n          break;\n        }\n        case 'open_with': void openWithFallback(); break;\n        case 'reveal': void revealSelected(); break;\n        case 'copy_files': void copyFiles(); break;\n        case 'copy_path': void copySelectedPaths(); break;\n        case 'trash': void trashSelected(); break;\n        case 'rename': void startRename(); break;\n      }\n    });\n\n    unlistenFns = [unlistenProgress, unlistenState, unlistenUpdated, unlistenFocus, unlistenCtxMenuAction];\n    flog(`[startup/fe] +${ms()}ms all listeners registered`);\n\n    // Fetch backend state IMMEDIATELY after listeners are registered.\n    // Events emitted before listener registration are lost, so this\n    // is the only reliable way to get the current state.\n    await refreshStatus();\n    flog(`[startup/fe] +${ms()}ms refreshStatus done (state=${indexStatus.state})`);\n\n    // Show Svelte UI: remove skeleton, focus search input.\n    await tick();\n    document.getElementById('skeleton')?.remove();\n    await focusSearch();\n    flog(`[startup/fe] +${ms()}ms WINDOW VISIBLE — skeleton removed`);\n\n    try {\n      homePrefix = await invoke('get_home_dir');\n    } catch {\n      homePrefix = '';\n    }\n    flog(`[startup/fe] +${ms()}ms get_home_dir done`);\n\n    if (!localStorage.getItem('everything-fda-notice-v1')) {\n      showToast('macOS Full Disk Access permission may be required for full disk search.');\n      localStorage.setItem('everything-fda-notice-v1', '1');\n    }\n    flog(`[startup/fe] +${ms()}ms calling runSearch...`);\n    await runSearch();\n    flog(`[startup/fe] +${ms()}ms runSearch done`);\n\n    if (typeof ResizeObserver !== 'undefined') {\n      tableResizeObserver = new ResizeObserver(() => {\n        scheduleViewportHeightUpdate();\n      });\n      if (tableContainer) {\n        tableResizeObserver.observe(tableContainer);\n      } else if (tableAreaEl) {\n        tableResizeObserver.observe(tableAreaEl);\n      }\n    }\n\n    window.addEventListener('resize', scheduleViewportHeightUpdate);\n    window.addEventListener('click', onGlobalClick);\n    statusRefreshTimer = setInterval(() => {\n      if (indexStatus.state === 'Indexing') {\n        void refreshStatus();\n      }\n    }, 1000);\n    console.log(`[startup/fe] +${ms()}ms onMount complete`);\n  });\n\n  onDestroy(async () => {\n    clearTimeout(searchTimer);\n    clearTimeout(toastTimer);\n    clearInterval(statusRefreshTimer);\n    clearInterval(elapsedTimer);\n    resizeCleanup?.();\n\n    for (const unlisten of unlistenFns) {\n      unlisten();\n    }\n\n    tableResizeObserver?.disconnect();\n    tableResizeObserver = null;\n    if (viewportResizeRaf !== null) {\n      cancelAnimationFrame(viewportResizeRaf);\n      viewportResizeRaf = null;\n    }\n    window.removeEventListener('resize', scheduleViewportHeightUpdate);\n    window.removeEventListener('click', onGlobalClick);\n  });\n</script>\n\n<svelte:window on:keydown={handleKeydown} />\n\n<div class=\"app-shell\" data-theme={theme}>\n  <div class=\"title-bar\" role=\"presentation\" data-tauri-drag-region on:mousedown={onTitleBarMouseDown}>\n    <div class=\"title-left\"></div>\n    <div class=\"title-center\">\n      <svg class=\"title-icon\" viewBox=\"0 0 215 205\" fill-rule=\"evenodd\" aria-hidden=\"true\">\n        <path d=\"M85 0c46.9 0 85 38.1 85 85 0 20.1-7.2 38.5-19.2 52.7l40.7 40.8c5.8 5.8 5.8 15.2 0 21-5.8 5.8-15.2 5.8-21 0l-40.7-40.7c-13.6 9.7-30.4 15.2-44.8 15.2-46.9 0-85-42.1-85-89 0-46.9 38.1-85 85-85z m0 32c-29.3 0-53 23.7-53 53 0 29.3 23.7 53 53 53 29.3 0 53-23.7 53-53 0-29.3-23.7-53-53-53z\"/>\n      </svg>\n      <span class=\"title-text\">Everything</span>\n    </div>\n    <div class=\"title-right\"></div>\n  </div>\n\n  <header class=\"search-bar\">\n    <input\n      bind:this={searchInputEl}\n      class=\"search-input\"\n      type=\"text\"\n      bind:value={query}\n      on:input={scheduleSearch}\n      on:focus={clearSelection}\n      placeholder=\"Search file/folder names\"\n      autocomplete=\"off\"\n      spellcheck=\"false\"\n    />\n  </header>\n\n  <section class=\"table-area\" bind:this={tableAreaEl} style={tableGridStyle}>\n    <div class=\"table-header\">\n      <div class=\"table-header-track\">\n        <div class=\"col name\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('name')}>\n            Name{#if sortBy === 'name'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'name'}\n            on:mousedown={(event) => startColumnResize(event, 'name')}\n            aria-label=\"Resize Name column\"\n          />\n        </div>\n\n        <div class=\"col path\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('dir')}>\n            Path{#if sortBy === 'dir'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'path'}\n            on:mousedown={(event) => startColumnResize(event, 'path')}\n            aria-label=\"Resize Path column\"\n          />\n        </div>\n\n        <div class=\"col size\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('size')}>\n            Size{#if sortBy === 'size'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n\n        <div class=\"col modified\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('mtime')}>\n            Modified{#if sortBy === 'mtime'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n      </div>\n    </div>\n\n    <div\n      class=\"table-body\"\n      bind:this={tableContainer}\n      on:scroll={() => {\n        scrollTop = tableContainer.scrollTop;\n        headerScrollLeft = tableContainer.scrollLeft;\n        if (editing.active) cancelRename();\n        const scrollBottom = scrollTop + tableContainer.clientHeight;\n        if (scrollBottom >= totalHeight - rowHeight * 10) {\n          void loadMore();\n        }\n      }}\n    >\n      <div class=\"spacer\" style={`height:${totalHeight}px`}>\n        <div class=\"rows\" style={`transform: translateY(${translateY}px);`}>\n          {#each visibleRows as entry, localIndex}\n            {@const index = startIndex + localIndex}\n            <div\n              class=\"row {selectedIndices.has(index) ? 'selected' : ''} {editing.active && editing.index === index ? 'renaming' : ''}\"\n              on:mousedown={(event) => handleRowMouseDown(event, index)}\n              on:click={(event) => handleRowClick(event, index)}\n              on:keydown={(event) => handleRowA11yKeydown(event, index)}\n              on:dblclick={() => handleRowDoubleClick(index)}\n              on:contextmenu={(event) => handleRowContextMenu(event, index)}\n              role=\"row\"\n              tabindex=\"0\"\n            >\n              <div class=\"cell name\">\n                <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n\n                {#if editing.active && editing.index === index}\n                  <input\n                    bind:this={renameInputEl}\n                    class=\"rename-input\"\n                    type=\"text\"\n                    bind:value={editing.draftName}\n                    on:click|stopPropagation\n                    on:blur={commitRename}\n                  />\n                {:else}\n                  <span class=\"ellipsis\">{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n                {/if}\n              </div>\n              <div class=\"cell path\"><span class=\"ellipsis\">{displayPath(entry.dir)}</span></div>\n              <div class=\"cell size\">{formatSize(entry)}</div>\n              <div class=\"cell modified\">{formatModified(entry)}</div>\n            </div>\n          {/each}\n        </div>\n      </div>\n    </div>\n  </section>\n\n  <footer class=\"status-bar\">\n    <div class=\"status-left\">\n      <span class=\"status-state\">\n        <span class=\"state-dot {indexStatus.state === 'Indexing' ? 'indexing' : indexStatus.state === 'Error' ? 'error' : 'ready'}\"></span>\n        {#if indexStatus.state === 'Indexing'}\n          Indexing{#if lastReadyCount > 0} ({Math.min(99, Math.round((scanned / lastReadyCount) * 100))}%){/if}{#if indexingElapsed} · {indexingElapsed}{/if}\n          {#if !indexStatus.isCatchup}\n            · {scanned.toLocaleString()} scanned\n          {/if}\n        {:else}\n          Index: {indexStatus.state}\n        {/if}\n      </span>\n      <span>{indexStatus.entriesCount.toLocaleString()} entries</span>\n      {#if indexingFinishedAt && indexStatus.state !== 'Indexing'}\n        <span>in {indexingFinishedAt}</span>\n      {/if}\n      {#if dbLatencyMs !== null && dbLastQuery}\n        <span>\"{dbLastQuery}\" {dbLatencyMs}ms · {totalResults} results</span>\n      {/if}\n      {#if searchModeLabel === 'spotlight' || searchModeLabel === 'spotlight_timeout'}\n        <span class=\"status-spotlight\">Spotlight fallback{#if searchModeLabel === 'spotlight_timeout'} (partial){/if}</span>\n      {/if}\n      {#if indexStatus.permissionErrors > 0}\n        <span class=\"status-warning\">{indexStatus.permissionErrors.toLocaleString()} permission errors</span>\n      {/if}\n      {#if indexStatus.message}\n        <span class={indexStatus.isCatchup ? 'index-progress' : 'status-error'}>{indexStatus.message}</span>\n      {/if}\n    </div>\n    <div class=\"status-right\">\n      <button class=\"status-btn theme-btn\" on:click={cycleTheme} title=\"Switch theme\">\n        {theme === 'dark' ? '☀ Light' : '◑ Dark'}\n      </button>\n      <button\n        class=\"status-btn rebuild-btn\"\n        on:click={resetIndex}\n        disabled={indexStatus.state === 'Indexing'}\n        title={indexStatus.state === 'Indexing' ? 'Cannot reset while indexing is in progress.' : 'Reset and rebuild the index.'}\n      >\n        <svg class=\"rebuild-icon\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n          <path d=\"M23 4v6h-6\"/><path d=\"M20.49 15a9 9 0 1 1-2.12-9.36L23 10\"/>\n        </svg>\n        Rebuild Index\n      </button>\n    </div>\n  </footer>\n\n  {#if contextMenu.visible}\n    <div class=\"context-menu\" style={`left:${contextMenu.x}px;top:${contextMenu.y}px;`}>\n      <button on:click={() => (closeContextMenu(), openSelected())}>Open</button>\n      <button on:click={async () => { closeContextMenu(); const e = primaryEntry(); if (e) await invoke('quick_look', { path: e.path }); }}>Quick Look</button>\n      <button on:click={() => (closeContextMenu(), openWithFallback())}>Open With... (Reveal in Finder)</button>\n      <button on:click={() => (closeContextMenu(), revealSelected())}>Reveal in Finder</button>\n      <button on:click={() => (closeContextMenu(), copySelectedPaths())}>Copy Path</button>\n      <button on:click={() => (closeContextMenu(), trashSelected())}>Move to Trash</button>\n      {#if selectedIndices.size === 1}\n        <button on:click={() => (closeContextMenu(), startRename())}>Rename</button>\n      {/if}\n    </div>\n  {/if}\n\n  {#if toast}\n    <div class=\"toast\">{toast}</div>\n  {/if}\n</div>\n\n<style>\n  :global(:root) {\n    color-scheme: light dark;\n    --bg-app: transparent;\n    --text-primary: #0d1826;\n    --text-muted: #48596c;\n    --bar-grad-top: rgba(255, 255, 255, 0.48);\n    --bar-grad-bottom: rgba(248, 250, 253, 0.42);\n    --surface-header: rgba(252, 252, 255, 0.40);\n    --surface: rgba(255, 255, 255, 0.22);\n    --border-soft: rgba(0, 0, 0, 0.07);\n    --border-input: rgba(0, 0, 0, 0.13);\n    --focus-ring: #6f96e6;\n    --row-border: rgba(0, 0, 0, 0.032);\n    --row-hover: rgba(0, 0, 0, 0.06);\n    --row-selected: rgba(0, 0, 0, 0.12);\n    --button-bg: rgba(255, 255, 255, 0.62);\n    --button-border: rgba(0, 0, 0, 0.10);\n    --button-text: #2c3e50;\n    --menu-bg: rgba(240, 241, 248, 0.90);\n    --menu-border: rgba(0, 0, 0, 0.06);\n    --menu-hover: rgba(255, 255, 255, 0.62);\n    --menu-text: #1a2a38;\n    --error-text: #b64545;\n    --warning-text: #8f6500;\n    --toast-bg: rgba(18, 22, 32, 0.90);\n    --toast-text: #ffffff;\n  }\n\n  @media (prefers-color-scheme: dark) {\n    :global(:root) {\n      --bg-app: transparent;\n      --text-primary: #e6e6ea;\n      --text-muted: #9494a4;\n      --bar-grad-top: rgba(38, 38, 46, 0.52);\n      --bar-grad-bottom: rgba(30, 30, 38, 0.46);\n      --surface-header: rgba(32, 32, 40, 0.46);\n      --surface: rgba(18, 18, 26, 0.32);\n      --border-soft: rgba(255, 255, 255, 0.065);\n      --border-input: rgba(255, 255, 255, 0.14);\n      --focus-ring: #5b8bd9;\n      --row-border: rgba(255, 255, 255, 0.026);\n      --row-hover: rgba(255, 255, 255, 0.08);\n      --row-selected: rgba(255, 255, 255, 0.14);\n      --button-bg: rgba(255, 255, 255, 0.072);\n      --button-border: rgba(255, 255, 255, 0.11);\n      --button-text: #d6d6e0;\n      --menu-bg: rgba(36, 36, 46, 0.90);\n      --menu-border: rgba(255, 255, 255, 0.066);\n      --menu-hover: rgba(255, 255, 255, 0.062);\n      --menu-text: #e0e0e8;\n      --error-text: #ff9d9d;\n      --warning-text: #e0c670;\n      --toast-bg: rgba(10, 10, 16, 0.93);\n      --toast-text: #f2f2f6;\n    }\n  }\n\n  /* ── Theme: Dark ──────────────────────────────────────────────── */\n  :global([data-theme=\"dark\"]) {\n    color-scheme: dark;\n    --bg-app: #1E1E21;\n    --text-primary: #E2E8F0;\n    --text-muted: #94A3B8;\n    --bar-grad-top: #1E1E21;\n    --bar-grad-bottom: #1E1E21;\n    --surface-header: #1E1E21;\n    --surface: #1E1E21;\n    --bg-input: #161618;\n    --border-soft: #2A2A2D;\n    --border-input: rgba(255, 255, 255, 0.06);\n    --focus-ring: #4DA8FF;\n    --accent: #4DA8FF;\n    --row-border: rgba(255, 255, 255, 0.02);\n    --row-hover: #282828;\n    --row-selected: rgba(77, 168, 255, 0.10);\n    --button-bg: rgba(255, 255, 255, 0.05);\n    --button-border: #2A2A2D;\n    --button-text: #94A3B8;\n    --menu-bg: #252528;\n    --menu-border: #2A2A2D;\n    --menu-hover: rgba(255, 255, 255, 0.04);\n    --menu-text: #E2E8F0;\n    --error-text: #ff9d9d;\n    --warning-text: #e0c670;\n    --toast-bg: rgba(10, 10, 16, 0.93);\n    --toast-text: #f2f2f6;\n  }\n\n  /* ── Theme: Light ─────────────────────────────────────────────── */\n  :global([data-theme=\"light\"]) {\n    color-scheme: light;\n    --bg-app: #F5F5F7;\n    --text-primary: #1C1C1E;\n    --text-muted: #6E6E7A;\n    --bar-grad-top: #F5F5F7;\n    --bar-grad-bottom: #F5F5F7;\n    --surface-header: #F5F5F7;\n    --surface: #F5F5F7;\n    --bg-input: #FFFFFF;\n    --border-soft: #D1D1D6;\n    --border-input: rgba(0, 0, 0, 0.10);\n    --focus-ring: #3A8BF5;\n    --accent: #3A8BF5;\n    --row-border: rgba(0, 0, 0, 0.04);\n    --row-hover: rgba(0, 0, 0, 0.04);\n    --row-selected: rgba(58, 139, 245, 0.10);\n    --button-bg: #FFFFFF;\n    --button-border: #D1D1D6;\n    --button-text: #3C3C43;\n    --menu-bg: #FFFFFF;\n    --menu-border: #D1D1D6;\n    --menu-hover: rgba(0, 0, 0, 0.05);\n    --menu-text: #1C1C1E;\n    --error-text: #D93025;\n    --warning-text: #B45309;\n    --toast-bg: rgba(255, 255, 255, 0.95);\n    --toast-text: #1C1C1E;\n  }\n\n  /* ── Themed element overrides ─────────────────────────────────── */\n  :global([data-theme]) {\n    background: var(--bg-app);\n  }\n\n  /* Search bar: flat, no gradient, no separator */\n  :global([data-theme]) .search-bar {\n    height: 44px;\n    padding: 0 16px;\n    background: var(--bg-app);\n    border-bottom: none;\n  }\n\n  :global([data-theme]) .search-input {\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n    font-family: 'JetBrains Mono', 'SF Mono', monospace;\n    font-size: 12px;\n    height: 34px;\n    border-radius: 8px;\n  }\n\n  /* Table header: flat bg, 16px edge padding */\n  :global([data-theme]) .table-header {\n    background: var(--bg-app);\n  }\n\n  :global([data-theme]) .col-button {\n    padding: 0 8px;\n  }\n\n  :global([data-theme]) .col.name .col-button {\n    padding-left: 16px;\n  }\n\n  /* Row cells: JetBrains Mono, 16px outer edges */\n  :global([data-theme]) .cell {\n    font-family: 'JetBrains Mono', monospace;\n  }\n\n  :global([data-theme]) .cell.name {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    padding-left: 16px;\n    font-size: 12px;\n    color: var(--text-primary);\n  }\n\n  :global([data-theme]) .cell.path {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.size {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.modified {\n    padding-right: 16px;\n    font-size: 11px;\n    white-space: nowrap;\n  }\n\n  :global([data-theme]) .row.selected {\n    box-shadow: inset 3px 0 0 var(--accent);\n  }\n\n  /* Dim path/size/date cells in themed mode */\n  :global([data-theme]) .cell.path,\n  :global([data-theme]) .cell.size,\n  :global([data-theme]) .cell.modified {\n    color: var(--text-muted);\n  }\n\n  :global(:root) {\n    background: transparent;\n  }\n\n  :global(html, body) {\n    margin: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    background: transparent;\n    color: var(--text-primary);\n    font-family: Inter, 'SF Pro Text', 'Segoe UI', Helvetica, Arial, sans-serif;\n  }\n\n  :global(#app) {\n    width: 100%;\n    height: 100%;\n  }\n\n  .app-shell {\n    display: grid;\n    grid-template-rows: auto auto 1fr auto;\n    height: 100%;\n    min-width: 0;\n  }\n\n  .title-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 44px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    cursor: default;\n    flex-shrink: 0;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-left {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-center {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-right {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-icon {\n    width: 14px;\n    height: 14px;\n    fill: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .title-text {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 13px;\n    font-weight: 500;\n    color: var(--text-primary);\n    letter-spacing: -0.01em;\n  }\n\n  .search-bar {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding: 8px;\n    background: linear-gradient(180deg, var(--bar-grad-top) 0%, var(--bar-grad-bottom) 100%);\n    border-bottom: 1px solid var(--border-soft);\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .search-input {\n    display: block;\n    box-sizing: border-box;\n    width: 100%;\n    min-width: 0;\n    flex: 1 1 auto;\n    height: 36px;\n    border: 1px solid var(--border-input);\n    border-radius: 14px;\n    padding: 0 10px;\n    font-size: 14px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    backdrop-filter: blur(12px) saturate(160%);\n    -webkit-backdrop-filter: blur(12px) saturate(160%);\n  }\n\n  .search-input::placeholder {\n    color: var(--text-muted);\n    opacity: 0.85;\n    font-size: 12px;\n  }\n\n  .search-input:focus {\n    outline: none;\n    border-color: var(--focus-ring);\n    box-shadow: 0 0 0 2px rgba(125, 169, 255, 0.25);\n  }\n\n  .table-area {\n    display: grid;\n    grid-template-rows: auto 1fr;\n    min-height: 0;\n    min-width: 0;\n  }\n\n  .table-header-track,\n  .row {\n    display: grid;\n    grid-template-columns: var(--col-name) var(--col-path) var(--col-size) var(--col-modified);\n    align-items: center;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .table-header {\n    height: 32px;\n    border-bottom: 1px solid var(--border-soft);\n    background: var(--surface-header);\n    user-select: none;\n    overflow: hidden;\n    flex-shrink: 0;\n  }\n\n  .table-header-track {\n    height: 100%;\n    transform: translateX(var(--header-offset, 0px));\n    will-change: transform;\n  }\n\n  .table-header .col {\n    position: relative;\n    min-width: 0;\n    height: 100%;\n  }\n\n  .col-button {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n    gap: 4px;\n    box-sizing: border-box;\n    padding: 0 8px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 11px;\n    font-weight: 600;\n    line-height: 1;\n    color: var(--text-muted);\n    text-align: left;\n    margin: 0;\n    border: none;\n    background: transparent;\n    cursor: pointer;\n  }\n\n  .sort-icon {\n    width: 10px;\n    height: 10px;\n    flex-shrink: 0;\n    color: var(--accent);\n  }\n\n  .col-resizer {\n    position: absolute;\n    top: 0;\n    right: -4px;\n    width: 8px;\n    height: 100%;\n    border: none;\n    padding: 0;\n    background: transparent;\n    cursor: col-resize;\n    z-index: 30;\n  }\n\n  .col-resizer::after {\n    content: '';\n    position: absolute;\n    top: 7px;\n    bottom: 7px;\n    left: 50%;\n    width: 1px;\n    transform: translateX(-50%);\n    background: var(--border-soft);\n    opacity: 0;\n    transition: opacity 0.15s ease;\n  }\n\n  .table-header .col:hover .col-resizer::after,\n  .col-resizer.active::after {\n    opacity: 1;\n  }\n\n  .table-body {\n    overflow: auto;\n    min-height: 0;\n    min-width: 0;\n    background: var(--surface);\n  }\n\n  .spacer {\n    position: relative;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .rows {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .row {\n    height: 30px;\n    border-bottom: 1px solid var(--row-border);\n    cursor: default;\n    -webkit-user-select: none;\n    user-select: none;\n    outline: none;\n  }\n\n  .row:hover {\n    background: var(--row-hover);\n  }\n\n  .row.selected {\n    background: var(--row-selected);\n  }\n\n  .cell {\n    padding: 0 8px;\n    font-size: 12px;\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    min-width: 0;\n  }\n\n  .cell.size {\n    text-align: right;\n    font-variant-numeric: tabular-nums;\n  }\n\n  .ellipsis {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n\n  .hl {\n    background: none;\n    color: inherit;\n    font-weight: 700;\n  }\n\n  .file-icon {\n    width: 16px;\n    height: 16px;\n    flex: 0 0 auto;\n  }\n\n  .rename-input {\n    flex: 1;\n    min-width: 0;\n    height: 22px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 12px;\n    padding: 0 6px;\n    border: 1.5px solid var(--focus-ring);\n    border-radius: 4px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    outline: none;\n    box-shadow: 0 1px 6px rgba(0, 0, 0, 0.18), 0 0 0 3px rgba(77, 168, 255, 0.12);\n  }\n\n  .status-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 32px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    border-top: 1px solid var(--border-soft);\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 11px;\n    color: var(--text-muted);\n    white-space: nowrap;\n    overflow: hidden;\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .status-left {\n    display: flex;\n    align-items: center;\n    gap: 16px;\n    overflow: hidden;\n    min-width: 0;\n  }\n\n  .status-right {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    flex-shrink: 0;\n  }\n\n  .status-btn {\n    border: 1px solid var(--button-border);\n    border-radius: 5px;\n    background: var(--button-bg);\n    color: var(--button-text);\n    font-size: 11px;\n    height: 22px;\n    padding: 0 8px;\n    cursor: pointer;\n  }\n\n  .status-btn:hover {\n    filter: brightness(1.06);\n  }\n\n  .status-btn:disabled {\n    opacity: 0.55;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .status-state {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n  }\n\n  .state-dot {\n    width: 6px;\n    height: 6px;\n    border-radius: 50%;\n    flex-shrink: 0;\n  }\n\n  .state-dot.ready { background: #28C840; }\n  .state-dot.indexing { background: #FEBC2E; }\n  .state-dot.error { background: #FF5F57; }\n\n  .rebuild-btn {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 10px;\n    font-weight: 500;\n    background: var(--button-bg);\n    border: 1px solid var(--button-border);\n    border-radius: 4px;\n    color: var(--button-text);\n    height: 22px;\n    padding: 0 10px;\n    cursor: pointer;\n  }\n\n  .rebuild-btn:hover {\n    filter: brightness(1.1);\n  }\n\n  .rebuild-btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .rebuild-icon {\n    width: 11px;\n    height: 11px;\n    color: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .status-error {\n    color: var(--error-text);\n  }\n\n  .status-warning {\n    color: var(--warning-text);\n  }\n\n  .status-spotlight {\n    color: #f59e0b;\n    font-weight: 600;\n  }\n\n  .context-menu {\n    position: fixed;\n    z-index: 200;\n    width: 220px;\n    border: 1px solid var(--menu-border);\n    border-radius: 10px;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.16), inset 0 0 0 0.5px rgba(255, 255, 255, 0.18);\n    background: var(--menu-bg);\n    backdrop-filter: blur(28px) saturate(180%);\n    -webkit-backdrop-filter: blur(28px) saturate(180%);\n    overflow: hidden;\n  }\n\n  .context-menu button {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    padding: 8px 10px;\n    font-size: 12px;\n    color: var(--menu-text);\n  }\n\n  .context-menu button:hover {\n    background: var(--menu-hover);\n  }\n\n  .toast {\n    position: fixed;\n    right: 14px;\n    bottom: 18px;\n    background: var(--toast-bg);\n    color: var(--toast-text);\n    border-radius: 10px;\n    padding: 9px 12px;\n    font-size: 12px;\n    z-index: 250;\n    backdrop-filter: blur(20px) saturate(180%);\n    -webkit-backdrop-filter: blur(20px) saturate(180%);\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);\n  }\n</style>\n","structuredPatch":[{"oldStart":1505,"oldLines":7,"newStart":1505,"newLines":7,"lines":["           {#each visibleRows as entry, localIndex}","             {@const index = startIndex + localIndex}","             <div","-              class=\"row {selectedIndices.has(index) ? 'selected' : ''} {editing.active && editing.index === index ? 'renaming' : ''}\"","+              class=\"row {selectedIndices.has(index) ? 'selected' : ''}\"","               on:mousedown={(event) => handleRowMouseDown(event, index)}","               on:click={(event) => handleRowClick(event, index)}","               on:keydown={(event) => handleRowA11yKeydown(event, index)}"]},{"oldStart":1516,"oldLines":19,"newStart":1516,"newLines":7,"lines":["             >","               <div class=\"cell name\">","                 <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />","-","-                {#if editing.active && editing.index === index}","-                  <input","-                    bind:this={renameInputEl}","-                    class=\"rename-input\"","-                    type=\"text\"","-                    bind:value={editing.draftName}","-                    on:click|stopPropagation","-                    on:blur={commitRename}","-                  />","-                {:else}","-                  <span class=\"ellipsis\">{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>","-                {/if}","+                <span class=\"ellipsis\" class:name-editing={editing.active && editing.index === index}>{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>","               </div>","               <div class=\"cell path\"><span class=\"ellipsis\">{displayPath(entry.dir)}</span></div>","               <div class=\"cell size\">{formatSize(entry)}</div>"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"7824066d-c61a-4ef3-89e0-4bcd611630cc"}
{"parentUuid":"2e22789b-9102-4d0d-93b1-c1ea3a5af313","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","message":{"model":"claude-sonnet-4-6","id":"msg_015pzHfX8e37v5Tj35jVokWP","type":"message","role":"assistant","content":[{"type":"text","text":"overlay를 app-shell에 추가 (context menu 앞에):"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":800,"cache_read_input_tokens":81460,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":800},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMN88mNX1acBqN3ds5PD","type":"assistant","uuid":"d85e5716-cfe0-4859-8d75-961c46f534af","timestamp":"2026-02-21T14:23:07.932Z"}
{"parentUuid":"d85e5716-cfe0-4859-8d75-961c46f534af","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","message":{"model":"claude-sonnet-4-6","id":"msg_015pzHfX8e37v5Tj35jVokWP","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01S4JcW8QXEKYFrkU6VktTKU","name":"Edit","input":{"replace_all":false,"file_path":"/Users/al02402336/everything/src/App.svelte","old_string":"  {#if contextMenu.visible}","new_string":"  {#if editing.active}\n    <div\n      class=\"rename-overlay\"\n      style=\"top:{renameOverlay.top}px; left:{renameOverlay.left}px; width:{renameOverlay.width}px;\"\n      role=\"presentation\"\n      on:mousedown|stopPropagation\n    >\n      <textarea\n        bind:this={renameInputEl}\n        class=\"rename-textarea\"\n        bind:value={editing.draftName}\n        on:input={autoResizeRenameInput}\n        on:click|stopPropagation\n        on:blur={commitRename}\n      />\n    </div>\n  {/if}\n\n  {#if contextMenu.visible}"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":800,"cache_read_input_tokens":81460,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":800},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMN88mNX1acBqN3ds5PD","type":"assistant","uuid":"5552d64c-318d-4db5-9656-f590369cf3e7","timestamp":"2026-02-21T14:23:10.940Z"}
{"parentUuid":"5552d64c-318d-4db5-9656-f590369cf3e7","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01S4JcW8QXEKYFrkU6VktTKU","toolUseID":"toolu_01S4JcW8QXEKYFrkU6VktTKU","timestamp":"2026-02-21T14:23:10.947Z","uuid":"1579500b-eaac-4a9a-8d36-4ff40fdeaeaa"}
{"parentUuid":"5552d64c-318d-4db5-9656-f590369cf3e7","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01S4JcW8QXEKYFrkU6VktTKU","type":"tool_result","content":"The file /Users/al02402336/everything/src/App.svelte has been updated successfully."}]},"uuid":"44f67237-694c-4274-95f5-f4306857e814","timestamp":"2026-02-21T14:23:10.946Z","toolUseResult":{"filePath":"/Users/al02402336/everything/src/App.svelte","oldString":"  {#if contextMenu.visible}","newString":"  {#if editing.active}\n    <div\n      class=\"rename-overlay\"\n      style=\"top:{renameOverlay.top}px; left:{renameOverlay.left}px; width:{renameOverlay.width}px;\"\n      role=\"presentation\"\n      on:mousedown|stopPropagation\n    >\n      <textarea\n        bind:this={renameInputEl}\n        class=\"rename-textarea\"\n        bind:value={editing.draftName}\n        on:input={autoResizeRenameInput}\n        on:click|stopPropagation\n        on:blur={commitRename}\n      />\n    </div>\n  {/if}\n\n  {#if contextMenu.visible}","originalFile":"<script>\n  import { onDestroy, onMount, tick } from 'svelte';\n  import { invoke } from '@tauri-apps/api/core';\n  import { listen } from '@tauri-apps/api/event';\n  import { getCurrentWindow } from '@tauri-apps/api/window';\n  import { startDrag } from '@crabnebula/tauri-plugin-drag';\n\n  const rowHeight = 30;\n  const PAGE_SIZE = 500;\n  let homePrefix = '';\n  const COL_WIDTHS_KEY = 'REDACTED';\n  const THEME_KEY = 'everything-theme';\n  const columnKeys = ['name', 'path', 'size', 'modified'];\n  const minColumnWidth = {\n    name: 180,\n    path: 240,\n    size: 75,\n    modified: 150\n  };\n  const defaultColumnRatios = {\n    name: 0.3,\n    path: 0.45,\n    size: 0.1\n  };\n\n  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || 'dark'; } catch { return 'dark'; } })();\n  function cycleTheme() {\n    theme = theme === 'dark' ? 'light' : 'dark';\n    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n  }\n\n  let query = '';\n  let results = [];\n  let totalResults = 0;\n  let totalResultsKnown = false;\n\n  let dbLatencyMs = null;\n  let dbLastQuery = '';\n  let searchModeLabel = '';\n  let selectedIndices = new Set();\n  let selectionAnchor = -1;\n  let lastSelectedIndex = -1;\n  let editing = {\n    active: false,\n    path: '',\n    index: -1,\n    draftName: ''\n  };\n\n  let renameOverlay = { top: 0, left: 0, width: 0 };\n\n  let indexStatus = {\n    state: 'Indexing',\n    entriesCount: 0,\n    lastUpdated: null,\n    permissionErrors: 0,\n    message: null,\n    isCatchup: false\n  };\n\n  let indexingStartTime = null;\n  let indexingElapsed = '';\n  let indexingFinishedAt = '';\n\n  let sortBy = 'name';\n  let sortDir = 'asc';\n\n  let hasMore = true;\n  let loadingMore = false;\n  let searchGeneration = 0;\n\n  let scanned = 0;\n\n  let searchInputEl;\n  let renameInputEl;\n  let tableAreaEl;\n  let tableContainer;\n  let tableResizeObserver = null;\n  let viewportResizeRaf = null;\n  let scrollTop = 0;\n  let headerScrollLeft = 0;\n  let viewportHeight = 520;\n  let lastTableWidth = 0;\n  let resizingColumn = '';\n  let resizeCleanup = null;\n  let colWidths = {\n    name: 250,\n    path: 350,\n    size: 75,\n    modified: 150\n  };\n\n  let contextMenu = {\n    visible: false,\n    x: 0,\n    y: 0\n  };\n\n  let platform = '';\n  let toast = '';\n  let searchTimer;\n  let lastSearchFiredAt = 0;\n  let toastTimer;\n  let statusRefreshTimer;\n  let elapsedTimer;\n  let statusRefreshInFlight = false;\n  let lastReadyCount = 0;\n\n  const iconCache = new Map();\n  const iconLoading = new Set();\n\n  let highlightCache = new Map();\n  let highlightCacheQuery = '';\n\n  const folderFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='1' y='4' width='14' height='10' rx='2' fill='#d9b34f'/><rect x='1' y='2' width='6' height='4' rx='1' fill='#e6ca7a'/></svg>`\n    );\n  const fileFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='3' y='1' width='10' height='14' rx='1.5' fill='#b4bec9'/><rect x='5' y='5' width='6' height='1.2' fill='#8d98a5'/><rect x='5' y='8' width='6' height='1.2' fill='#8d98a5'/></svg>`\n    );\n\n  $: totalHeight = results.length * rowHeight;\n  $: startIndex = Math.max(0, Math.floor(scrollTop / rowHeight) - 10);\n  $: visibleCount = Math.ceil(viewportHeight / rowHeight) + 20;\n  $: endIndex = Math.min(results.length, startIndex + visibleCount);\n  $: visibleRows = results.slice(startIndex, endIndex);\n  $: translateY = startIndex * rowHeight;\n  $: tableMinWidth = colWidths.name + colWidths.path + colWidths.size + colWidths.modified;\n  $: tableGridStyle = `--col-name:${colWidths.name}px;--col-path:${colWidths.path}px;--col-size:${colWidths.size}px;--col-modified:${colWidths.modified}px;--table-min-width:${tableMinWidth}px;--header-offset:${-headerScrollLeft}px;`;\n\n  $: {\n    for (const entry of visibleRows) {\n      void ensureIcon(entry);\n    }\n  }\n\n  function showToast(message) {\n    toast = message;\n    clearTimeout(toastTimer);\n    toastTimer = setTimeout(() => {\n      toast = '';\n    }, 3000);\n  }\n\n  function bytesToBase64(bytes) {\n    let binary = '';\n    const chunk = 0x8000;\n    for (let i = 0; i < bytes.length; i += chunk) {\n      const part = bytes.subarray(i, i + chunk);\n      binary += String.fromCharCode(...part);\n    }\n    return btoa(binary);\n  }\n\n  function highlightSegments(name, q) {\n    q = (q || '').trim();\n    if (!q) return [{ text: name, hl: false }];\n\n    // Reset cache when query changes\n    if (q !== highlightCacheQuery) {\n      highlightCache = new Map();\n      highlightCacheQuery = q;\n    }\n\n    // Check cache\n    const cached = highlightCache.get(name);\n    if (cached) return cached;\n\n    if (q.includes('/')) q = q.slice(q.lastIndexOf('/') + 1);\n    q = q.replace(/[*?]/g, '');\n    const terms = q.split(/\\s+/).filter(Boolean);\n    if (terms.length === 0) return [{ text: name, hl: false }];\n\n    const lower = name.toLowerCase();\n    const marks = new Uint8Array(name.length);\n    for (const t of terms) {\n      const tl = t.toLowerCase();\n      let idx = lower.indexOf(tl);\n      while (idx !== -1) {\n        for (let i = idx; i < idx + tl.length; i++) marks[i] = 1;\n        idx = lower.indexOf(tl, idx + 1);\n      }\n    }\n\n    const segs = [];\n    let i = 0;\n    while (i < name.length) {\n      const m = marks[i];\n      let j = i + 1;\n      while (j < name.length && marks[j] === m) j++;\n      segs.push({ text: name.slice(i, j), hl: m === 1 });\n      i = j;\n    }\n\n    highlightCache.set(name, segs);\n    return segs;\n  }\n\n  const perFileIconExts = new Set(['exe', 'lnk', 'ico', 'url', 'scr', 'appx']);\n\n  function iconKey(entry) {\n    if (entry.isDir) return '__folder__';\n    const ext = (entry.ext || '').toLowerCase();\n    if (perFileIconExts.has(ext)) return entry.path;\n    return ext || '__file__';\n  }\n\n  function iconFor(entry) {\n    return iconCache.get(iconKey(entry)) || (entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n  }\n\n  async function ensureIcon(entry) {\n    const key = iconKey(entry);\n    if (iconCache.has(key) || iconLoading.has(key)) {\n      return;\n    }\n\n    iconLoading.add(key);\n    try {\n      const bytes = await invoke('get_file_icon', {\n        path: entry.path,\n        ext: entry.isDir ? 'folder' : entry.ext || '',\n      });\n      if (Array.isArray(bytes) && bytes.length > 0) {\n        const image = `data:image/png;base64,${bytesToBase64(Uint8Array.from(bytes))}`;\n        iconCache.set(key, image);\n      } else {\n        iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n      }\n    } catch {\n      iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n    } finally {\n      iconLoading.delete(key);\n    }\n  }\n\n  function syncColumnWidthsToContainer() {\n    const width = tableContainer?.clientWidth || tableAreaEl?.clientWidth;\n    if (!width || lastTableWidth !== 0) {\n      return;\n    }\n\n    const saved = loadColWidths();\n    if (saved) {\n      const total = columnKeys.reduce((s, k) => s + saved[k], 0);\n      if (Math.abs(total - width) > 2) {\n        const scale = (width - saved.modified) / (total - saved.modified);\n        let scaledName = Math.max(minColumnWidth.name, Math.round(saved.name * scale));\n        let scaledSize = Math.max(minColumnWidth.size, Math.round(saved.size * scale));\n        let rawPath = width - saved.modified - scaledName - scaledSize;\n        if (rawPath < minColumnWidth.path) {\n          const shortfall = minColumnWidth.path - rawPath;\n          const nameReduction = Math.min(shortfall, scaledName - minColumnWidth.name);\n          scaledName -= nameReduction;\n          const remaining = shortfall - nameReduction;\n          if (remaining > 0) {\n            scaledSize -= Math.min(remaining, scaledSize - minColumnWidth.size);\n          }\n          rawPath = width - saved.modified - scaledName - scaledSize;\n        }\n        const scaledPath = Math.max(minColumnWidth.path, rawPath);\n        colWidths = { name: scaledName, path: scaledPath, size: scaledSize, modified: saved.modified };\n      } else {\n        colWidths = saved;\n      }\n    } else {\n      const fixedModified = minColumnWidth.modified;\n      const rest = width - fixedModified;\n      const ratioSum = defaultColumnRatios.name + defaultColumnRatios.path + defaultColumnRatios.size;\n      colWidths = {\n        name: Math.max(minColumnWidth.name, Math.round(rest * defaultColumnRatios.name / ratioSum)),\n        path: Math.max(minColumnWidth.path, Math.round(rest * defaultColumnRatios.path / ratioSum)),\n        size: Math.max(minColumnWidth.size, Math.round(rest * defaultColumnRatios.size / ratioSum)),\n        modified: fixedModified\n      };\n    }\n    lastTableWidth = width;\n  }\n\n  function loadColWidths() {\n    try {\n      const raw = localStorage.getItem(COL_WIDTHS_KEY);\n      if (!raw) return null;\n      const parsed = JSON.parse(raw);\n      for (const key of columnKeys) {\n        if (typeof parsed[key] !== 'number' || parsed[key] < (minColumnWidth[key] || 0)) return null;\n      }\n      return parsed;\n    } catch {\n      return null;\n    }\n  }\n\n  function saveColWidths() {\n    localStorage.setItem(COL_WIDTHS_KEY, JSON.stringify(colWidths));\n  }\n\n  function updateViewportHeight() {\n    viewportHeight = tableContainer?.clientHeight || 520;\n    syncColumnWidthsToContainer();\n  }\n\n  function scheduleViewportHeightUpdate() {\n    if (viewportResizeRaf !== null) {\n      return;\n    }\n    viewportResizeRaf = requestAnimationFrame(() => {\n      viewportResizeRaf = null;\n      updateViewportHeight();\n    });\n  }\n\n  function startColumnResize(event, leftKey) {\n    event.preventDefault();\n    event.stopPropagation();\n\n    const index = columnKeys.indexOf(leftKey);\n    if (index < 0 || index >= columnKeys.length - 1) {\n      return;\n    }\n\n    const startX = event.clientX;\n    const startLeft = colWidths[leftKey];\n    const rightKey = columnKeys[index + 1];\n    const startRight = colWidths[rightKey];\n\n    resizeCleanup?.();\n    resizingColumn = leftKey;\n\n    const onMove = (moveEvent) => {\n      const delta = Math.round(moveEvent.clientX - startX);\n      if (leftKey === 'name') {\n        // Two-column trade: name and path swap space, each respects its minimum\n        const nextLeft = Math.max(\n          minColumnWidth[leftKey],\n          Math.min(startLeft + delta, startLeft + startRight - minColumnWidth[rightKey])\n        );\n        const nextRight = startLeft + startRight - nextLeft;\n        colWidths = { ...colWidths, [leftKey]: nextLeft, [rightKey]: nextRight };\n      } else {\n        // path splitter: path grows unconstrained (allows horizontal scroll on right drag)\n        const nextLeft = Math.max(minColumnWidth[leftKey], startLeft + delta);\n        colWidths = { ...colWidths, [leftKey]: nextLeft };\n      }\n    };\n\n    const onUp = () => {\n      cleanup();\n    };\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      document.body.style.cursor = '';\n      document.body.style.userSelect = '';\n      resizingColumn = '';\n      saveColWidths();\n      if (resizeCleanup === cleanup) {\n        resizeCleanup = null;\n      }\n    };\n\n    resizeCleanup = cleanup;\n    document.body.style.cursor = 'col-resize';\n    document.body.style.userSelect = 'none';\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  function selectedPaths() {\n    const sorted = [...selectedIndices].sort((a, b) => a - b);\n    return sorted.map((idx) => results[idx]).filter(Boolean).map((entry) => entry.path);\n  }\n\n  function clearSelection() {\n    selectedIndices = new Set();\n    selectionAnchor = -1;\n    lastSelectedIndex = -1;\n  }\n\n  function selectSingle(index) {\n    selectedIndices = new Set([index]);\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectToggle(index) {\n    const next = new Set(selectedIndices);\n    if (next.has(index)) {\n      next.delete(index);\n    } else {\n      next.add(index);\n    }\n    selectedIndices = next;\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectRange(index) {\n    const anchor = selectionAnchor >= 0 ? selectionAnchor : index;\n    const [from, to] = [Math.min(anchor, index), Math.max(anchor, index)];\n    const next = new Set();\n    for (let i = from; i <= to; i += 1) {\n      next.add(i);\n    }\n    selectedIndices = next;\n    lastSelectedIndex = index;\n  }\n\n  function primaryEntry() {\n    const idx = lastSelectedIndex >= 0 ? lastSelectedIndex : -1;\n    return idx >= 0 ? results[idx] : null;\n  }\n\n  async function refreshStatus() {\n    if (statusRefreshInFlight) {\n      return;\n    }\n    statusRefreshInFlight = true;\n    try {\n      const status = await invoke('get_index_status');\n      const prevState = indexStatus.state;\n      indexStatus = {\n        state: status.state,\n        entriesCount: status.entriesCount,\n        lastUpdated: status.lastUpdated,\n        permissionErrors: status.permissionErrors ?? 0,\n        message: status.message\n      };\n      if (status.state === 'Indexing' && prevState !== 'Indexing') {\n        startElapsedTimer();\n      } else if (status.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n      if (typeof status.scanned === 'number') {\n        scanned = status.scanned;\n      }\n      if (status.state === 'Ready' && prevState !== 'Ready') {\n        scheduleSearch();\n      }\n    } catch (err) {\n      showToast(`Failed to get status: ${String(err)}`);\n    } finally {\n      statusRefreshInFlight = false;\n    }\n  }\n\n  function scheduleSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const scheduledGen = searchGeneration;\n    clearTimeout(searchTimer);\n\n    const now = performance.now();\n    if (now - lastSearchFiredAt >= 200) {\n      // Leading edge: fire immediately if enough time has passed\n      lastSearchFiredAt = now;\n      void runSearch(preserveScroll);\n    } else {\n      // Trailing edge: debounce\n      searchTimer = setTimeout(() => {\n        if (scheduledGen !== searchGeneration) {\n          return;\n        }\n        lastSearchFiredAt = performance.now();\n        void runSearch(preserveScroll);\n      }, 200);\n    }\n  }\n\n  async function runSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const gen = searchGeneration;\n    const searchQuery = query;\n    const searchSortBy = sortBy;\n    const searchSortDir = sortDir;\n    const startedAt = performance.now();\n    try {\n      const keepPaths = new Set(selectedPaths());\n      const next = await invoke('search', {\n        query: searchQuery,\n        limit: PAGE_SIZE,\n        offset: 0,\n        sortBy: searchSortBy,\n        sortDir: searchSortDir\n      });\n\n      if (gen !== searchGeneration) return;\n\n      dbLatencyMs = Math.round(performance.now() - startedAt);\n      dbLastQuery = searchQuery;\n      const entries = Array.isArray(next.entries) ? next.entries : [];\n      searchModeLabel = next.modeLabel || '';\n      results = entries;\n      if (next.totalCount > 0) {\n        totalResults = next.totalCount;\n        totalResultsKnown = true;\n      } else {\n        totalResults = entries.length;\n        totalResultsKnown = false;\n      }\n      hasMore = totalResultsKnown ? results.length < totalResults : entries.length >= PAGE_SIZE;\n      if (!preserveScroll && tableContainer) tableContainer.scrollTop = 0;\n\n      const restored = new Set();\n      for (let i = 0; i < results.length; i += 1) {\n        if (keepPaths.has(results[i].path)) {\n          restored.add(i);\n        }\n      }\n      selectedIndices = restored;\n\n      updateViewportHeight();\n    } catch (err) {\n      if (gen !== searchGeneration) return;\n      showToast(`Search failed: ${String(err)}`);\n    }\n  }\n\n  async function loadMore() {\n    if (!hasMore || loadingMore) return;\n    const gen = searchGeneration;\n    loadingMore = true;\n    try {\n      const batch = await invoke('search', {\n        query,\n        limit: PAGE_SIZE,\n        offset: results.length,\n        sortBy: sortBy,\n        sortDir: sortDir\n      });\n      if (gen !== searchGeneration) return;\n      const arr = Array.isArray(batch.entries) ? batch.entries : [];\n      if (arr.length > 0) results = [...results, ...arr];\n      hasMore = totalResultsKnown ? results.length < totalResults : arr.length >= PAGE_SIZE;\n    } catch (err) {\n      showToast(`Failed to load more: ${String(err)}`);\n    } finally {\n      loadingMore = false;\n    }\n  }\n\n  function moveSelection(delta, withRange = false) {\n    if (results.length === 0) {\n      return;\n    }\n\n    const current = lastSelectedIndex >= 0 ? lastSelectedIndex : 0;\n    const next = Math.max(0, Math.min(results.length - 1, current + delta));\n\n    if (withRange) {\n      selectRange(next);\n    } else {\n      selectSingle(next);\n    }\n\n    const top = next * rowHeight;\n    const bottom = top + rowHeight;\n    if (top < scrollTop) {\n      tableContainer.scrollTop = top;\n    } else if (bottom > scrollTop + viewportHeight) {\n      tableContainer.scrollTop = bottom - viewportHeight;\n    }\n  }\n\n  function handleHeaderSort(column) {\n    if (sortBy === column) {\n      sortDir = sortDir === 'asc' ? 'desc' : 'asc';\n    } else {\n      sortBy = column;\n      sortDir = 'asc';\n    }\n    if (tableContainer) tableContainer.scrollTop = 0;\n    void runSearch();\n  }\n\n  function handleRowClick(event, index) {\n    contextMenu.visible = false;\n\n    if (event.shiftKey) {\n      selectRange(index);\n      return;\n    }\n\n    if (event.metaKey || event.ctrlKey) {\n      selectToggle(index);\n      return;\n    }\n\n    selectSingle(index);\n  }\n\n  function handleRowContextMenu(event, index) {\n    event.preventDefault();\n\n    if (!selectedIndices.has(index)) {\n      selectSingle(index);\n    }\n\n    if (platform === 'windows' || platform === 'macos') {\n      contextMenu.visible = false;\n      const paths = selectedPaths();\n      if (paths.length > 0) {\n        invoke('show_context_menu', {\n          paths,\n          x: event.clientX,\n          y: event.clientY,\n          singleSelection: selectedIndices.size === 1\n        });\n      }\n      return;\n    }\n\n    contextMenu = {\n      visible: true,\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n\n  function handleRowA11yKeydown(event, index) {\n    if (event.key === ' ' || event.key === 'Enter') {\n      event.preventDefault();\n      handleRowClick(event, index);\n    }\n  }\n\n  const DRAG_THRESHOLD = 5;\n  let dragCleanup = null;\n  const dragImgCache = new Map();\n\n  function dragPathsForIndex(index) {\n    const entry = results[index];\n    if (!entry) {\n      return [];\n    }\n\n    if (selectedIndices.has(index) && selectedIndices.size > 0) {\n      return selectedPaths();\n    }\n\n    return [entry.path];\n  }\n\n  function getDragIconEl(entry) {\n    const src = iconFor(entry);\n    let img = dragImgCache.get(src);\n    if (!img) {\n      img = new Image();\n      img.src = src;\n      dragImgCache.set(src, img);\n    }\n    return img.complete && img.naturalWidth > 0 ? img : null;\n  }\n\n  function fillRoundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function buildDragPreview(index) {\n    const entry = results[index];\n    if (!entry) return null;\n\n    const count = selectedIndices.has(index) ? selectedIndices.size : 1;\n    const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\n\n    const w = 260;\n    const h = 28;\n    const stackGap = count > 1 ? 4 : 0;\n\n    const canvas = document.createElement('canvas');\n    canvas.width = w;\n    canvas.height = h + stackGap;\n    const ctx = canvas.getContext('2d');\n\n    if (count > 1) {\n      ctx.globalAlpha = 0.35;\n      ctx.fillStyle = isDark ? '#5a6070' : '#b0c4de';\n      fillRoundRect(ctx, 3, 0, w - 3, h, 5);\n      ctx.globalAlpha = 1.0;\n    }\n\n    const ry = stackGap;\n    ctx.fillStyle = isDark ? 'rgba(58, 64, 74, 0.94)' : 'rgba(214, 231, 255, 0.94)';\n    fillRoundRect(ctx, 0, ry, w, h, 5);\n\n    ctx.strokeStyle = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';\n    ctx.lineWidth = 0.5;\n    ctx.beginPath();\n    ctx.moveTo(5, ry);\n    ctx.arcTo(w, ry, w, ry + h, 5);\n    ctx.arcTo(w, ry + h, 0, ry + h, 5);\n    ctx.arcTo(0, ry + h, 0, ry, 5);\n    ctx.arcTo(0, ry, w, ry, 5);\n    ctx.closePath();\n    ctx.stroke();\n\n    const iconEl = getDragIconEl(entry);\n    if (iconEl) {\n      ctx.drawImage(iconEl, 6, ry + 6, 16, 16);\n    } else {\n      ctx.fillStyle = entry.isDir ? '#d9b34f' : '#8d98a5';\n      fillRoundRect(ctx, 6, ry + 6, 16, 16, 2);\n    }\n\n    ctx.fillStyle = isDark ? '#e6e6e8' : '#1a1a1a';\n    ctx.font = '12px -apple-system, \"SF Pro Text\", system-ui, sans-serif';\n    ctx.textBaseline = 'middle';\n\n    let nameMaxW = w - 34;\n    if (count > 1) nameMaxW -= 34;\n\n    let name = entry.name;\n    if (ctx.measureText(name).width > nameMaxW) {\n      while (name.length > 4 && ctx.measureText(name + '\\u2026').width > nameMaxW) {\n        name = name.slice(0, -1);\n      }\n      name += '\\u2026';\n    }\n    ctx.fillText(name, 28, ry + h / 2 + 1);\n\n    if (count > 1) {\n      const badge = String(count);\n      ctx.font = 'bold 10px -apple-system, system-ui, sans-serif';\n      const tw = ctx.measureText(badge).width;\n      const bw = Math.max(20, tw + 10);\n      const bx = w - bw - 6;\n      const by = ry + (h - 18) / 2;\n\n      ctx.fillStyle = isDark ? '#5b8bd9' : '#007aff';\n      fillRoundRect(ctx, bx, by, bw, 18, 9);\n\n      ctx.fillStyle = '#ffffff';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(badge, bx + bw / 2, by + 9);\n    }\n\n    return canvas.toDataURL('image/png');\n  }\n\n  function handleRowMouseDown(event, index) {\n    if (event.button !== 0) return;\n    if (event.metaKey || event.ctrlKey || event.shiftKey) return;\n    if (editing.active) return;\n\n    const startX = event.clientX;\n    const startY = event.clientY;\n    let dragging = false;\n\n    dragCleanup?.();\n\n    const onMove = (e) => {\n      if (dragging) return;\n      const dx = e.clientX - startX;\n      const dy = e.clientY - startY;\n      if (dx * dx + dy * dy < DRAG_THRESHOLD * DRAG_THRESHOLD) return;\n\n      dragging = true;\n      cleanup();\n\n      if (!selectedIndices.has(index)) {\n        selectSingle(index);\n      }\n\n      const paths = dragPathsForIndex(index);\n      if (paths.length > 0) {\n        const icon = buildDragPreview(index);\n        startDrag({ item: paths, icon }).catch(() => {});\n      }\n    };\n\n    const onUp = () => cleanup();\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      if (dragCleanup === cleanup) dragCleanup = null;\n    };\n\n    dragCleanup = cleanup;\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  async function handleRowDoubleClick(index) {\n    if (!selectedIndices.has(index) || selectedIndices.size > 1) {\n      selectSingle(index);\n      await tick();\n    }\n    await invoke('open', { paths: [results[index].path] }).catch((err) => {\n      showToast(`Failed to open: ${String(err)}`);\n    });\n  }\n\n  function closeContextMenu() {\n    contextMenu = {\n      ...contextMenu,\n      visible: false\n    };\n  }\n\n  async function openSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('open', { paths });\n    } catch (err) {\n      showToast(`Failed to open: ${String(err)}`);\n    }\n  }\n\n  async function openWithFallback() {\n    const target = primaryEntry();\n    if (!target) {\n      return;\n    }\n\n    try {\n      await invoke('open_with', { path: target.path });\n    } catch (err) {\n      showToast(`Open With failed: ${String(err)}`);\n    }\n  }\n\n  async function revealSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('reveal_in_finder', { paths });\n    } catch (err) {\n      showToast(`Failed to reveal in Finder: ${String(err)}`);\n    }\n  }\n\n  async function copySelectedPaths() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_paths', { paths });\n      showToast(`Copied ${paths.length} path(s)`);\n    } catch (err) {\n      showToast(`Failed to copy path: ${String(err)}`);\n    }\n  }\n\n  async function copyFiles() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_files', { paths });\n      showToast(`Copied ${paths.length} item(s)`);\n    } catch (err) {\n      showToast(`Failed to copy: ${String(err)}`);\n    }\n  }\n\n  async function trashSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    const message =\n      paths.length === 1\n        ? 'Move selected item to Trash?'\n        : `Move ${paths.length} items to Trash?`;\n\n    if (!window.confirm(message)) {\n      return;\n    }\n\n    try {\n      await invoke('move_to_trash', { paths });\n      showToast('Moved to Trash.');\n      clearSelection();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to move to Trash: ${String(err)}`);\n    }\n  }\n\n  async function resetIndex() {\n    if (indexStatus.state === 'Indexing') {\n      showToast('Indexing in progress. Please try again after it completes.');\n      return;\n    }\n\n    results = [];\n    totalResults = 0;\n    totalResultsKnown = false;\n    clearSelection();\n    scanned = 0;\n    dbLatencyMs = null;\n    dbLastQuery = '';\n    indexStatus = { ...indexStatus, state: 'Indexing', entriesCount: 0, message: null };\n    indexingStartTime = Date.now();\n    indexingElapsed = '';\n    indexingFinishedAt = '';\n\n    try {\n      await invoke('reset_index');\n    } catch (err) {\n      showToast(`Failed to reset index: ${String(err)}`);\n      await refreshStatus();\n    }\n  }\n\n  function isMultiSelected() {\n    return selectedIndices.size > 1;\n  }\n\n  function autoResizeRenameInput() {\n    if (!renameInputEl) return;\n    renameInputEl.style.height = '0';\n    renameInputEl.style.height = renameInputEl.scrollHeight + 'px';\n  }\n\n  async function startRename() {\n    if (isMultiSelected()) {\n      return;\n    }\n\n    const idx = lastSelectedIndex;\n    if (idx < 0 || !results[idx]) {\n      return;\n    }\n\n    const entry = results[idx];\n\n    // Calculate overlay position from the row's name cell text span\n    const rowDomIndex = idx - startIndex;\n    const rowEls = tableContainer?.querySelectorAll('.row');\n    const rowEl = rowEls?.[rowDomIndex];\n    const nameCell = rowEl?.querySelector('.cell.name');\n\n    if (nameCell) {\n      const cellRect = nameCell.getBoundingClientRect();\n      const ellipsis = nameCell.querySelector('.ellipsis');\n      const textLeft = ellipsis ? ellipsis.getBoundingClientRect().left : cellRect.left + 38;\n      // Offset left by border(1.5) + padding-left(4) so text inside textarea aligns with row text\n      const pad = 6;\n      renameOverlay = {\n        top: cellRect.top,\n        left: textLeft - pad,\n        width: cellRect.right - textLeft + pad - 4\n      };\n    }\n\n    editing = {\n      active: true,\n      path: entry.path,\n      index: idx,\n      draftName: entry.name\n    };\n\n    await tick();\n\n    if (renameInputEl) {\n      autoResizeRenameInput();\n      renameInputEl.focus();\n      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n      renameInputEl.setSelectionRange(0, selectionEnd);\n    }\n  }\n\n  function cancelRename() {\n    editing = {\n      active: false,\n      path: '',\n      index: -1,\n      draftName: ''\n    };\n  }\n\n  async function commitRename() {\n    if (!editing.active || editing.index < 0 || !results[editing.index]) {\n      return;\n    }\n\n    const current = results[editing.index];\n    const nextName = editing.draftName;\n\n    try {\n      await invoke('rename', {\n        path: current.path,\n        newName: nextName\n      });\n      cancelRename();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to rename: ${String(err)}`);\n      await tick();\n      renameInputEl?.focus();\n    }\n  }\n\n  function onGlobalClick() {\n    closeContextMenu();\n  }\n\n  function onTitleBarMouseDown(event) {\n    if (event.button !== 0) {\n      return;\n    }\n\n    const activeElement = document.activeElement;\n    if (activeElement instanceof HTMLElement && isTextInputTarget(activeElement)) {\n      activeElement.blur();\n    }\n  }\n\n  async function focusSearch() {\n    await getCurrentWindow().show();\n    await getCurrentWindow().setFocus();\n    searchInputEl?.focus();\n    searchInputEl?.select();\n  }\n\n  function isTextInputTarget(target) {\n    return (\n      target instanceof HTMLInputElement ||\n      target instanceof HTMLTextAreaElement ||\n      target?.isContentEditable\n    );\n  }\n\n  async function handleKeydown(event) {\n    const isMetaSelectAll = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'a';\n    const isMetaCopy = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c';\n    const target = event.target;\n    const isTextInput = isTextInputTarget(target);\n\n    if (isMetaCopy && isTextInput) {\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      if (isTextInput) {\n        event.preventDefault();\n        if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n          target.select();\n        }\n        return;\n      }\n    }\n\n    if (editing.active) {\n      if (event.key === 'Enter') {\n        event.preventDefault();\n        await commitRename();\n        return;\n      }\n\n      if (event.key === 'Escape') {\n        event.preventDefault();\n        cancelRename();\n        searchInputEl?.focus();\n        return;\n      }\n      return;\n    }\n\n    if (event.key === 'Escape') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      return;\n    }\n\n    if (event.key === 'ArrowDown') {\n      event.preventDefault();\n      moveSelection(1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'ArrowUp') {\n      event.preventDefault();\n      moveSelection(-1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageDown') {\n      event.preventDefault();\n      moveSelection(Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageUp') {\n      event.preventDefault();\n      moveSelection(-Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'Enter') {\n      event.preventDefault();\n      if (platform === 'windows') {\n        await openSelected();\n      } else {\n        await startRename();\n      }\n      return;\n    }\n\n    if (event.key === 'F2') {\n      event.preventDefault();\n      await startRename();\n      return;\n    }\n\n    if (event.key === ' ' && !isTextInput) {\n      event.preventDefault();\n      const entry = primaryEntry();\n      if (entry) {\n        await invoke('quick_look', { path: entry.path });\n      }\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'f') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      searchInputEl?.select();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'o') {\n      event.preventDefault();\n      await openSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {\n      event.preventDefault();\n      await revealSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c') {\n      event.preventDefault();\n      await copySelectedPaths();\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      event.preventDefault();\n      selectedIndices = new Set(Array.from({ length: results.length }, (_, i) => i));\n      return;\n    }\n\n    if (event.key === 'Delete' || ((event.metaKey || event.ctrlKey) && event.key === 'Backspace')) {\n      if (!isTextInput) {\n        event.preventDefault();\n        await trashSelected();\n      }\n      return;\n    }\n  }\n\n  function formatSize(entry) {\n    if (entry.isDir || entry.size == null) return '';\n    const bytes = entry.size;\n    if (bytes < 1024) return `${bytes} B`;\n    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n    return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n  }\n\n  function formatModified(entry) {\n    if (!entry.mtime) {\n      return '';\n    }\n\n    const d = new Date(entry.mtime * 1000);\n    const pad = (n) => String(n).padStart(2, '0');\n    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;\n  }\n\n  function formatLastUpdated(timestamp) {\n    if (!timestamp) {\n      return '-';\n    }\n\n    return new Date(timestamp * 1000).toLocaleString();\n  }\n\n  function formatElapsed(ms) {\n    const totalSec = Math.floor(ms / 1000);\n    const min = Math.floor(totalSec / 60);\n    const sec = totalSec % 60;\n    return min > 0 ? `${min}m ${sec}s` : `${sec}s`;\n  }\n\n  function updateElapsed() {\n    if (indexingStartTime && indexStatus.state === 'Indexing') {\n      indexingElapsed = formatElapsed(Date.now() - indexingStartTime);\n    }\n  }\n\n  function startElapsedTimer() {\n    clearInterval(elapsedTimer);\n    indexingStartTime = Date.now();\n    indexingElapsed = '0s';\n    indexingFinishedAt = '';\n    elapsedTimer = setInterval(updateElapsed, 1000);\n  }\n\n  function stopElapsedTimer() {\n    clearInterval(elapsedTimer);\n    if (indexingStartTime) {\n      const elapsed = Date.now() - indexingStartTime;\n      indexingFinishedAt = `${formatElapsed(elapsed)}`;\n    }\n    indexingStartTime = null;\n    indexingElapsed = '';\n  }\n\n  function displayPath(path) {\n    if (!path) {\n      return path;\n    }\n\n    if (!homePrefix) {\n      return path;\n    }\n\n    if (path === homePrefix) {\n      return '~';\n    }\n\n    if (path.startsWith(`${homePrefix}/`)) {\n      return `~${path.slice(homePrefix.length)}`;\n    }\n\n    return path;\n  }\n\n  let unlistenFns = [];\n\n  onMount(async () => {\n    const t0 = performance.now();\n    const ms = () => Math.round(performance.now() - t0);\n    const DEBUG_STARTUP = false;\n    const flog = DEBUG_STARTUP ? (msg) => invoke('frontend_log', { msg }).catch(() => {}) : () => {};\n\n    flog(`[startup/fe] onMount entered`);\n\n    updateViewportHeight();\n    flog(`[startup/fe] +${ms()}ms updateViewportHeight done`);\n\n    platform = await invoke('get_platform');\n    flog(`[startup/fe] +${ms()}ms get_platform done`);\n\n    const unlistenProgress = await listen('index_progress', (event) => {\n      scanned = event.payload.scanned;\n      if (indexStatus.state !== 'Indexing') {\n        indexStatus = {\n          ...indexStatus,\n          state: 'Indexing'\n        };\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_progress) registered`);\n\n    const unlistenState = await listen('index_state', (event) => {\n      flog(`[startup/fe] index_state event received: ${event.payload.state} at +${ms()}ms`);\n      const prevState = indexStatus.state;\n      indexStatus = {\n        ...indexStatus,\n        state: event.payload.state,\n        message: event.payload.message ?? null,\n        isCatchup: event.payload.isCatchup ?? false\n      };\n\n      if (event.payload.state === 'Indexing' && prevState !== 'Indexing') {\n        if (prevState === 'Ready') {\n          lastReadyCount = indexStatus.entriesCount;\n        }\n        startElapsedTimer();\n      } else if (event.payload.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n\n      if (event.payload.state === 'Ready') {\n        scheduleSearch();\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_state) registered`);\n\n    const unlistenUpdated = await listen('index_updated', (event) => {\n      indexStatus = {\n        ...indexStatus,\n        entriesCount: event.payload.entriesCount,\n        lastUpdated: event.payload.lastUpdated,\n        permissionErrors: event.payload.permissionErrors ?? indexStatus.permissionErrors\n      };\n\n      scheduleSearch(true);\n    });\n\n    const unlistenFocus = await listen('focus_search', () => {\n      void focusSearch();\n    });\n\n    const unlistenCtxMenuAction = await listen('context_menu_action', (event) => {\n      switch (event.payload) {\n        case 'open': void openSelected(); break;\n        case 'quick_look': {\n          const e = primaryEntry();\n          if (e) void invoke('quick_look', { path: e.path });\n          break;\n        }\n        case 'open_with': void openWithFallback(); break;\n        case 'reveal': void revealSelected(); break;\n        case 'copy_files': void copyFiles(); break;\n        case 'copy_path': void copySelectedPaths(); break;\n        case 'trash': void trashSelected(); break;\n        case 'rename': void startRename(); break;\n      }\n    });\n\n    unlistenFns = [unlistenProgress, unlistenState, unlistenUpdated, unlistenFocus, unlistenCtxMenuAction];\n    flog(`[startup/fe] +${ms()}ms all listeners registered`);\n\n    // Fetch backend state IMMEDIATELY after listeners are registered.\n    // Events emitted before listener registration are lost, so this\n    // is the only reliable way to get the current state.\n    await refreshStatus();\n    flog(`[startup/fe] +${ms()}ms refreshStatus done (state=${indexStatus.state})`);\n\n    // Show Svelte UI: remove skeleton, focus search input.\n    await tick();\n    document.getElementById('skeleton')?.remove();\n    await focusSearch();\n    flog(`[startup/fe] +${ms()}ms WINDOW VISIBLE — skeleton removed`);\n\n    try {\n      homePrefix = await invoke('get_home_dir');\n    } catch {\n      homePrefix = '';\n    }\n    flog(`[startup/fe] +${ms()}ms get_home_dir done`);\n\n    if (!localStorage.getItem('everything-fda-notice-v1')) {\n      showToast('macOS Full Disk Access permission may be required for full disk search.');\n      localStorage.setItem('everything-fda-notice-v1', '1');\n    }\n    flog(`[startup/fe] +${ms()}ms calling runSearch...`);\n    await runSearch();\n    flog(`[startup/fe] +${ms()}ms runSearch done`);\n\n    if (typeof ResizeObserver !== 'undefined') {\n      tableResizeObserver = new ResizeObserver(() => {\n        scheduleViewportHeightUpdate();\n      });\n      if (tableContainer) {\n        tableResizeObserver.observe(tableContainer);\n      } else if (tableAreaEl) {\n        tableResizeObserver.observe(tableAreaEl);\n      }\n    }\n\n    window.addEventListener('resize', scheduleViewportHeightUpdate);\n    window.addEventListener('click', onGlobalClick);\n    statusRefreshTimer = setInterval(() => {\n      if (indexStatus.state === 'Indexing') {\n        void refreshStatus();\n      }\n    }, 1000);\n    console.log(`[startup/fe] +${ms()}ms onMount complete`);\n  });\n\n  onDestroy(async () => {\n    clearTimeout(searchTimer);\n    clearTimeout(toastTimer);\n    clearInterval(statusRefreshTimer);\n    clearInterval(elapsedTimer);\n    resizeCleanup?.();\n\n    for (const unlisten of unlistenFns) {\n      unlisten();\n    }\n\n    tableResizeObserver?.disconnect();\n    tableResizeObserver = null;\n    if (viewportResizeRaf !== null) {\n      cancelAnimationFrame(viewportResizeRaf);\n      viewportResizeRaf = null;\n    }\n    window.removeEventListener('resize', scheduleViewportHeightUpdate);\n    window.removeEventListener('click', onGlobalClick);\n  });\n</script>\n\n<svelte:window on:keydown={handleKeydown} />\n\n<div class=\"app-shell\" data-theme={theme}>\n  <div class=\"title-bar\" role=\"presentation\" data-tauri-drag-region on:mousedown={onTitleBarMouseDown}>\n    <div class=\"title-left\"></div>\n    <div class=\"title-center\">\n      <svg class=\"title-icon\" viewBox=\"0 0 215 205\" fill-rule=\"evenodd\" aria-hidden=\"true\">\n        <path d=\"M85 0c46.9 0 85 38.1 85 85 0 20.1-7.2 38.5-19.2 52.7l40.7 40.8c5.8 5.8 5.8 15.2 0 21-5.8 5.8-15.2 5.8-21 0l-40.7-40.7c-13.6 9.7-30.4 15.2-44.8 15.2-46.9 0-85-42.1-85-89 0-46.9 38.1-85 85-85z m0 32c-29.3 0-53 23.7-53 53 0 29.3 23.7 53 53 53 29.3 0 53-23.7 53-53 0-29.3-23.7-53-53-53z\"/>\n      </svg>\n      <span class=\"title-text\">Everything</span>\n    </div>\n    <div class=\"title-right\"></div>\n  </div>\n\n  <header class=\"search-bar\">\n    <input\n      bind:this={searchInputEl}\n      class=\"search-input\"\n      type=\"text\"\n      bind:value={query}\n      on:input={scheduleSearch}\n      on:focus={clearSelection}\n      placeholder=\"Search file/folder names\"\n      autocomplete=\"off\"\n      spellcheck=\"false\"\n    />\n  </header>\n\n  <section class=\"table-area\" bind:this={tableAreaEl} style={tableGridStyle}>\n    <div class=\"table-header\">\n      <div class=\"table-header-track\">\n        <div class=\"col name\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('name')}>\n            Name{#if sortBy === 'name'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'name'}\n            on:mousedown={(event) => startColumnResize(event, 'name')}\n            aria-label=\"Resize Name column\"\n          />\n        </div>\n\n        <div class=\"col path\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('dir')}>\n            Path{#if sortBy === 'dir'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'path'}\n            on:mousedown={(event) => startColumnResize(event, 'path')}\n            aria-label=\"Resize Path column\"\n          />\n        </div>\n\n        <div class=\"col size\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('size')}>\n            Size{#if sortBy === 'size'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n\n        <div class=\"col modified\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('mtime')}>\n            Modified{#if sortBy === 'mtime'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n      </div>\n    </div>\n\n    <div\n      class=\"table-body\"\n      bind:this={tableContainer}\n      on:scroll={() => {\n        scrollTop = tableContainer.scrollTop;\n        headerScrollLeft = tableContainer.scrollLeft;\n        if (editing.active) cancelRename();\n        const scrollBottom = scrollTop + tableContainer.clientHeight;\n        if (scrollBottom >= totalHeight - rowHeight * 10) {\n          void loadMore();\n        }\n      }}\n    >\n      <div class=\"spacer\" style={`height:${totalHeight}px`}>\n        <div class=\"rows\" style={`transform: translateY(${translateY}px);`}>\n          {#each visibleRows as entry, localIndex}\n            {@const index = startIndex + localIndex}\n            <div\n              class=\"row {selectedIndices.has(index) ? 'selected' : ''}\"\n              on:mousedown={(event) => handleRowMouseDown(event, index)}\n              on:click={(event) => handleRowClick(event, index)}\n              on:keydown={(event) => handleRowA11yKeydown(event, index)}\n              on:dblclick={() => handleRowDoubleClick(index)}\n              on:contextmenu={(event) => handleRowContextMenu(event, index)}\n              role=\"row\"\n              tabindex=\"0\"\n            >\n              <div class=\"cell name\">\n                <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n                <span class=\"ellipsis\" class:name-editing={editing.active && editing.index === index}>{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n              </div>\n              <div class=\"cell path\"><span class=\"ellipsis\">{displayPath(entry.dir)}</span></div>\n              <div class=\"cell size\">{formatSize(entry)}</div>\n              <div class=\"cell modified\">{formatModified(entry)}</div>\n            </div>\n          {/each}\n        </div>\n      </div>\n    </div>\n  </section>\n\n  <footer class=\"status-bar\">\n    <div class=\"status-left\">\n      <span class=\"status-state\">\n        <span class=\"state-dot {indexStatus.state === 'Indexing' ? 'indexing' : indexStatus.state === 'Error' ? 'error' : 'ready'}\"></span>\n        {#if indexStatus.state === 'Indexing'}\n          Indexing{#if lastReadyCount > 0} ({Math.min(99, Math.round((scanned / lastReadyCount) * 100))}%){/if}{#if indexingElapsed} · {indexingElapsed}{/if}\n          {#if !indexStatus.isCatchup}\n            · {scanned.toLocaleString()} scanned\n          {/if}\n        {:else}\n          Index: {indexStatus.state}\n        {/if}\n      </span>\n      <span>{indexStatus.entriesCount.toLocaleString()} entries</span>\n      {#if indexingFinishedAt && indexStatus.state !== 'Indexing'}\n        <span>in {indexingFinishedAt}</span>\n      {/if}\n      {#if dbLatencyMs !== null && dbLastQuery}\n        <span>\"{dbLastQuery}\" {dbLatencyMs}ms · {totalResults} results</span>\n      {/if}\n      {#if searchModeLabel === 'spotlight' || searchModeLabel === 'spotlight_timeout'}\n        <span class=\"status-spotlight\">Spotlight fallback{#if searchModeLabel === 'spotlight_timeout'} (partial){/if}</span>\n      {/if}\n      {#if indexStatus.permissionErrors > 0}\n        <span class=\"status-warning\">{indexStatus.permissionErrors.toLocaleString()} permission errors</span>\n      {/if}\n      {#if indexStatus.message}\n        <span class={indexStatus.isCatchup ? 'index-progress' : 'status-error'}>{indexStatus.message}</span>\n      {/if}\n    </div>\n    <div class=\"status-right\">\n      <button class=\"status-btn theme-btn\" on:click={cycleTheme} title=\"Switch theme\">\n        {theme === 'dark' ? '☀ Light' : '◑ Dark'}\n      </button>\n      <button\n        class=\"status-btn rebuild-btn\"\n        on:click={resetIndex}\n        disabled={indexStatus.state === 'Indexing'}\n        title={indexStatus.state === 'Indexing' ? 'Cannot reset while indexing is in progress.' : 'Reset and rebuild the index.'}\n      >\n        <svg class=\"rebuild-icon\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n          <path d=\"M23 4v6h-6\"/><path d=\"M20.49 15a9 9 0 1 1-2.12-9.36L23 10\"/>\n        </svg>\n        Rebuild Index\n      </button>\n    </div>\n  </footer>\n\n  {#if contextMenu.visible}\n    <div class=\"context-menu\" style={`left:${contextMenu.x}px;top:${contextMenu.y}px;`}>\n      <button on:click={() => (closeContextMenu(), openSelected())}>Open</button>\n      <button on:click={async () => { closeContextMenu(); const e = primaryEntry(); if (e) await invoke('quick_look', { path: e.path }); }}>Quick Look</button>\n      <button on:click={() => (closeContextMenu(), openWithFallback())}>Open With... (Reveal in Finder)</button>\n      <button on:click={() => (closeContextMenu(), revealSelected())}>Reveal in Finder</button>\n      <button on:click={() => (closeContextMenu(), copySelectedPaths())}>Copy Path</button>\n      <button on:click={() => (closeContextMenu(), trashSelected())}>Move to Trash</button>\n      {#if selectedIndices.size === 1}\n        <button on:click={() => (closeContextMenu(), startRename())}>Rename</button>\n      {/if}\n    </div>\n  {/if}\n\n  {#if toast}\n    <div class=\"toast\">{toast}</div>\n  {/if}\n</div>\n\n<style>\n  :global(:root) {\n    color-scheme: light dark;\n    --bg-app: transparent;\n    --text-primary: #0d1826;\n    --text-muted: #48596c;\n    --bar-grad-top: rgba(255, 255, 255, 0.48);\n    --bar-grad-bottom: rgba(248, 250, 253, 0.42);\n    --surface-header: rgba(252, 252, 255, 0.40);\n    --surface: rgba(255, 255, 255, 0.22);\n    --border-soft: rgba(0, 0, 0, 0.07);\n    --border-input: rgba(0, 0, 0, 0.13);\n    --focus-ring: #6f96e6;\n    --row-border: rgba(0, 0, 0, 0.032);\n    --row-hover: rgba(0, 0, 0, 0.06);\n    --row-selected: rgba(0, 0, 0, 0.12);\n    --button-bg: rgba(255, 255, 255, 0.62);\n    --button-border: rgba(0, 0, 0, 0.10);\n    --button-text: #2c3e50;\n    --menu-bg: rgba(240, 241, 248, 0.90);\n    --menu-border: rgba(0, 0, 0, 0.06);\n    --menu-hover: rgba(255, 255, 255, 0.62);\n    --menu-text: #1a2a38;\n    --error-text: #b64545;\n    --warning-text: #8f6500;\n    --toast-bg: rgba(18, 22, 32, 0.90);\n    --toast-text: #ffffff;\n  }\n\n  @media (prefers-color-scheme: dark) {\n    :global(:root) {\n      --bg-app: transparent;\n      --text-primary: #e6e6ea;\n      --text-muted: #9494a4;\n      --bar-grad-top: rgba(38, 38, 46, 0.52);\n      --bar-grad-bottom: rgba(30, 30, 38, 0.46);\n      --surface-header: rgba(32, 32, 40, 0.46);\n      --surface: rgba(18, 18, 26, 0.32);\n      --border-soft: rgba(255, 255, 255, 0.065);\n      --border-input: rgba(255, 255, 255, 0.14);\n      --focus-ring: #5b8bd9;\n      --row-border: rgba(255, 255, 255, 0.026);\n      --row-hover: rgba(255, 255, 255, 0.08);\n      --row-selected: rgba(255, 255, 255, 0.14);\n      --button-bg: rgba(255, 255, 255, 0.072);\n      --button-border: rgba(255, 255, 255, 0.11);\n      --button-text: #d6d6e0;\n      --menu-bg: rgba(36, 36, 46, 0.90);\n      --menu-border: rgba(255, 255, 255, 0.066);\n      --menu-hover: rgba(255, 255, 255, 0.062);\n      --menu-text: #e0e0e8;\n      --error-text: #ff9d9d;\n      --warning-text: #e0c670;\n      --toast-bg: rgba(10, 10, 16, 0.93);\n      --toast-text: #f2f2f6;\n    }\n  }\n\n  /* ── Theme: Dark ──────────────────────────────────────────────── */\n  :global([data-theme=\"dark\"]) {\n    color-scheme: dark;\n    --bg-app: #1E1E21;\n    --text-primary: #E2E8F0;\n    --text-muted: #94A3B8;\n    --bar-grad-top: #1E1E21;\n    --bar-grad-bottom: #1E1E21;\n    --surface-header: #1E1E21;\n    --surface: #1E1E21;\n    --bg-input: #161618;\n    --border-soft: #2A2A2D;\n    --border-input: rgba(255, 255, 255, 0.06);\n    --focus-ring: #4DA8FF;\n    --accent: #4DA8FF;\n    --row-border: rgba(255, 255, 255, 0.02);\n    --row-hover: #282828;\n    --row-selected: rgba(77, 168, 255, 0.10);\n    --button-bg: rgba(255, 255, 255, 0.05);\n    --button-border: #2A2A2D;\n    --button-text: #94A3B8;\n    --menu-bg: #252528;\n    --menu-border: #2A2A2D;\n    --menu-hover: rgba(255, 255, 255, 0.04);\n    --menu-text: #E2E8F0;\n    --error-text: #ff9d9d;\n    --warning-text: #e0c670;\n    --toast-bg: rgba(10, 10, 16, 0.93);\n    --toast-text: #f2f2f6;\n  }\n\n  /* ── Theme: Light ─────────────────────────────────────────────── */\n  :global([data-theme=\"light\"]) {\n    color-scheme: light;\n    --bg-app: #F5F5F7;\n    --text-primary: #1C1C1E;\n    --text-muted: #6E6E7A;\n    --bar-grad-top: #F5F5F7;\n    --bar-grad-bottom: #F5F5F7;\n    --surface-header: #F5F5F7;\n    --surface: #F5F5F7;\n    --bg-input: #FFFFFF;\n    --border-soft: #D1D1D6;\n    --border-input: rgba(0, 0, 0, 0.10);\n    --focus-ring: #3A8BF5;\n    --accent: #3A8BF5;\n    --row-border: rgba(0, 0, 0, 0.04);\n    --row-hover: rgba(0, 0, 0, 0.04);\n    --row-selected: rgba(58, 139, 245, 0.10);\n    --button-bg: #FFFFFF;\n    --button-border: #D1D1D6;\n    --button-text: #3C3C43;\n    --menu-bg: #FFFFFF;\n    --menu-border: #D1D1D6;\n    --menu-hover: rgba(0, 0, 0, 0.05);\n    --menu-text: #1C1C1E;\n    --error-text: #D93025;\n    --warning-text: #B45309;\n    --toast-bg: rgba(255, 255, 255, 0.95);\n    --toast-text: #1C1C1E;\n  }\n\n  /* ── Themed element overrides ─────────────────────────────────── */\n  :global([data-theme]) {\n    background: var(--bg-app);\n  }\n\n  /* Search bar: flat, no gradient, no separator */\n  :global([data-theme]) .search-bar {\n    height: 44px;\n    padding: 0 16px;\n    background: var(--bg-app);\n    border-bottom: none;\n  }\n\n  :global([data-theme]) .search-input {\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n    font-family: 'JetBrains Mono', 'SF Mono', monospace;\n    font-size: 12px;\n    height: 34px;\n    border-radius: 8px;\n  }\n\n  /* Table header: flat bg, 16px edge padding */\n  :global([data-theme]) .table-header {\n    background: var(--bg-app);\n  }\n\n  :global([data-theme]) .col-button {\n    padding: 0 8px;\n  }\n\n  :global([data-theme]) .col.name .col-button {\n    padding-left: 16px;\n  }\n\n  /* Row cells: JetBrains Mono, 16px outer edges */\n  :global([data-theme]) .cell {\n    font-family: 'JetBrains Mono', monospace;\n  }\n\n  :global([data-theme]) .cell.name {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    padding-left: 16px;\n    font-size: 12px;\n    color: var(--text-primary);\n  }\n\n  :global([data-theme]) .cell.path {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.size {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.modified {\n    padding-right: 16px;\n    font-size: 11px;\n    white-space: nowrap;\n  }\n\n  :global([data-theme]) .row.selected {\n    box-shadow: inset 3px 0 0 var(--accent);\n  }\n\n  /* Dim path/size/date cells in themed mode */\n  :global([data-theme]) .cell.path,\n  :global([data-theme]) .cell.size,\n  :global([data-theme]) .cell.modified {\n    color: var(--text-muted);\n  }\n\n  :global(:root) {\n    background: transparent;\n  }\n\n  :global(html, body) {\n    margin: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    background: transparent;\n    color: var(--text-primary);\n    font-family: Inter, 'SF Pro Text', 'Segoe UI', Helvetica, Arial, sans-serif;\n  }\n\n  :global(#app) {\n    width: 100%;\n    height: 100%;\n  }\n\n  .app-shell {\n    display: grid;\n    grid-template-rows: auto auto 1fr auto;\n    height: 100%;\n    min-width: 0;\n  }\n\n  .title-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 44px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    cursor: default;\n    flex-shrink: 0;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-left {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-center {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-right {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-icon {\n    width: 14px;\n    height: 14px;\n    fill: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .title-text {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 13px;\n    font-weight: 500;\n    color: var(--text-primary);\n    letter-spacing: -0.01em;\n  }\n\n  .search-bar {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding: 8px;\n    background: linear-gradient(180deg, var(--bar-grad-top) 0%, var(--bar-grad-bottom) 100%);\n    border-bottom: 1px solid var(--border-soft);\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .search-input {\n    display: block;\n    box-sizing: border-box;\n    width: 100%;\n    min-width: 0;\n    flex: 1 1 auto;\n    height: 36px;\n    border: 1px solid var(--border-input);\n    border-radius: 14px;\n    padding: 0 10px;\n    font-size: 14px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    backdrop-filter: blur(12px) saturate(160%);\n    -webkit-backdrop-filter: blur(12px) saturate(160%);\n  }\n\n  .search-input::placeholder {\n    color: var(--text-muted);\n    opacity: 0.85;\n    font-size: 12px;\n  }\n\n  .search-input:focus {\n    outline: none;\n    border-color: var(--focus-ring);\n    box-shadow: 0 0 0 2px rgba(125, 169, 255, 0.25);\n  }\n\n  .table-area {\n    display: grid;\n    grid-template-rows: auto 1fr;\n    min-height: 0;\n    min-width: 0;\n  }\n\n  .table-header-track,\n  .row {\n    display: grid;\n    grid-template-columns: var(--col-name) var(--col-path) var(--col-size) var(--col-modified);\n    align-items: center;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .table-header {\n    height: 32px;\n    border-bottom: 1px solid var(--border-soft);\n    background: var(--surface-header);\n    user-select: none;\n    overflow: hidden;\n    flex-shrink: 0;\n  }\n\n  .table-header-track {\n    height: 100%;\n    transform: translateX(var(--header-offset, 0px));\n    will-change: transform;\n  }\n\n  .table-header .col {\n    position: relative;\n    min-width: 0;\n    height: 100%;\n  }\n\n  .col-button {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n    gap: 4px;\n    box-sizing: border-box;\n    padding: 0 8px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 11px;\n    font-weight: 600;\n    line-height: 1;\n    color: var(--text-muted);\n    text-align: left;\n    margin: 0;\n    border: none;\n    background: transparent;\n    cursor: pointer;\n  }\n\n  .sort-icon {\n    width: 10px;\n    height: 10px;\n    flex-shrink: 0;\n    color: var(--accent);\n  }\n\n  .col-resizer {\n    position: absolute;\n    top: 0;\n    right: -4px;\n    width: 8px;\n    height: 100%;\n    border: none;\n    padding: 0;\n    background: transparent;\n    cursor: col-resize;\n    z-index: 30;\n  }\n\n  .col-resizer::after {\n    content: '';\n    position: absolute;\n    top: 7px;\n    bottom: 7px;\n    left: 50%;\n    width: 1px;\n    transform: translateX(-50%);\n    background: var(--border-soft);\n    opacity: 0;\n    transition: opacity 0.15s ease;\n  }\n\n  .table-header .col:hover .col-resizer::after,\n  .col-resizer.active::after {\n    opacity: 1;\n  }\n\n  .table-body {\n    overflow: auto;\n    min-height: 0;\n    min-width: 0;\n    background: var(--surface);\n  }\n\n  .spacer {\n    position: relative;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .rows {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .row {\n    height: 30px;\n    border-bottom: 1px solid var(--row-border);\n    cursor: default;\n    -webkit-user-select: none;\n    user-select: none;\n    outline: none;\n  }\n\n  .row:hover {\n    background: var(--row-hover);\n  }\n\n  .row.selected {\n    background: var(--row-selected);\n  }\n\n  .cell {\n    padding: 0 8px;\n    font-size: 12px;\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    min-width: 0;\n  }\n\n  .cell.size {\n    text-align: right;\n    font-variant-numeric: tabular-nums;\n  }\n\n  .ellipsis {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n\n  .hl {\n    background: none;\n    color: inherit;\n    font-weight: 700;\n  }\n\n  .file-icon {\n    width: 16px;\n    height: 16px;\n    flex: 0 0 auto;\n  }\n\n  .rename-input {\n    flex: 1;\n    min-width: 0;\n    height: 22px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 12px;\n    padding: 0 6px;\n    border: 1.5px solid var(--focus-ring);\n    border-radius: 4px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    outline: none;\n    box-shadow: 0 1px 6px rgba(0, 0, 0, 0.18), 0 0 0 3px rgba(77, 168, 255, 0.12);\n  }\n\n  .status-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 32px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    border-top: 1px solid var(--border-soft);\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 11px;\n    color: var(--text-muted);\n    white-space: nowrap;\n    overflow: hidden;\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .status-left {\n    display: flex;\n    align-items: center;\n    gap: 16px;\n    overflow: hidden;\n    min-width: 0;\n  }\n\n  .status-right {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    flex-shrink: 0;\n  }\n\n  .status-btn {\n    border: 1px solid var(--button-border);\n    border-radius: 5px;\n    background: var(--button-bg);\n    color: var(--button-text);\n    font-size: 11px;\n    height: 22px;\n    padding: 0 8px;\n    cursor: pointer;\n  }\n\n  .status-btn:hover {\n    filter: brightness(1.06);\n  }\n\n  .status-btn:disabled {\n    opacity: 0.55;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .status-state {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n  }\n\n  .state-dot {\n    width: 6px;\n    height: 6px;\n    border-radius: 50%;\n    flex-shrink: 0;\n  }\n\n  .state-dot.ready { background: #28C840; }\n  .state-dot.indexing { background: #FEBC2E; }\n  .state-dot.error { background: #FF5F57; }\n\n  .rebuild-btn {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 10px;\n    font-weight: 500;\n    background: var(--button-bg);\n    border: 1px solid var(--button-border);\n    border-radius: 4px;\n    color: var(--button-text);\n    height: 22px;\n    padding: 0 10px;\n    cursor: pointer;\n  }\n\n  .rebuild-btn:hover {\n    filter: brightness(1.1);\n  }\n\n  .rebuild-btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .rebuild-icon {\n    width: 11px;\n    height: 11px;\n    color: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .status-error {\n    color: var(--error-text);\n  }\n\n  .status-warning {\n    color: var(--warning-text);\n  }\n\n  .status-spotlight {\n    color: #f59e0b;\n    font-weight: 600;\n  }\n\n  .context-menu {\n    position: fixed;\n    z-index: 200;\n    width: 220px;\n    border: 1px solid var(--menu-border);\n    border-radius: 10px;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.16), inset 0 0 0 0.5px rgba(255, 255, 255, 0.18);\n    background: var(--menu-bg);\n    backdrop-filter: blur(28px) saturate(180%);\n    -webkit-backdrop-filter: blur(28px) saturate(180%);\n    overflow: hidden;\n  }\n\n  .context-menu button {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    padding: 8px 10px;\n    font-size: 12px;\n    color: var(--menu-text);\n  }\n\n  .context-menu button:hover {\n    background: var(--menu-hover);\n  }\n\n  .toast {\n    position: fixed;\n    right: 14px;\n    bottom: 18px;\n    background: var(--toast-bg);\n    color: var(--toast-text);\n    border-radius: 10px;\n    padding: 9px 12px;\n    font-size: 12px;\n    z-index: 250;\n    backdrop-filter: blur(20px) saturate(180%);\n    -webkit-backdrop-filter: blur(20px) saturate(180%);\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);\n  }\n</style>\n","structuredPatch":[{"oldStart":1576,"oldLines":6,"newStart":1576,"newLines":24,"lines":["     </div>","   </footer>"," ","+  {#if editing.active}","+    <div","+      class=\"rename-overlay\"","+      style=\"top:{renameOverlay.top}px; left:{renameOverlay.left}px; width:{renameOverlay.width}px;\"","+      role=\"presentation\"","+      on:mousedown|stopPropagation","+    >","+      <textarea","+        bind:this={renameInputEl}","+        class=\"rename-textarea\"","+        bind:value={editing.draftName}","+        on:input={autoResizeRenameInput}","+        on:click|stopPropagation","+        on:blur={commitRename}","+      />","+    </div>","+  {/if}","+","   {#if contextMenu.visible}","     <div class=\"context-menu\" style={`left:${contextMenu.x}px;top:${contextMenu.y}px;`}>","       <button on:click={() => (closeContextMenu(), openSelected())}>Open</button>"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"5552d64c-318d-4db5-9656-f590369cf3e7"}
{"parentUuid":"44f67237-694c-4274-95f5-f4306857e814","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","message":{"model":"claude-sonnet-4-6","id":"msg_01YH9atgccTZsmyE9g4mqbUj","type":"message","role":"assistant","content":[{"type":"text","text":"CSS 업데이트 — 기존 renaming 관련 CSS 제거 후 새 overlay CSS 추가:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":356,"cache_read_input_tokens":82260,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":356},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMN8bAckpgcpm8LX3i6f","type":"assistant","uuid":"c1196bc3-8367-4b5a-a484-2472d7d1317e","timestamp":"2026-02-21T14:23:13.439Z"}
{"parentUuid":"c1196bc3-8367-4b5a-a484-2472d7d1317e","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","message":{"model":"claude-sonnet-4-6","id":"msg_01YH9atgccTZsmyE9g4mqbUj","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TXkugRxoRu7NTSoY2d68qf","name":"Edit","input":{"replace_all":false,"file_path":"/Users/al02402336/everything/src/App.svelte","old_string":"  .rename-input {\n    flex: 1;\n    min-width: 0;\n    height: 22px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 12px;\n    padding: 0 6px;\n    border: 1.5px solid var(--focus-ring);\n    border-radius: 4px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    outline: none;\n    box-shadow: 0 1px 6px rgba(0, 0, 0, 0.18), 0 0 0 3px rgba(77, 168, 255, 0.12);\n  }","new_string":"  .name-editing {\n    opacity: 0.25;\n  }\n\n  .rename-overlay {\n    position: fixed;\n    z-index: 100;\n    min-width: 120px;\n  }\n\n  .rename-textarea {\n    display: block;\n    width: 100%;\n    box-sizing: border-box;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 12px;\n    line-height: 18px;\n    padding: 6px 4px;\n    border: 1.5px solid var(--focus-ring);\n    border-radius: 4px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    outline: none;\n    resize: none;\n    overflow: hidden;\n    box-shadow: 0 2px 14px rgba(0, 0, 0, 0.22), 0 0 0 3px rgba(77, 168, 255, 0.13);\n  }"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":356,"cache_read_input_tokens":82260,"output_tokens":601,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":356,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYMN8bAckpgcpm8LX3i6f","type":"assistant","uuid":"80a31df2-827d-44ae-92f7-e66860d72fa1","timestamp":"2026-02-21T14:23:19.474Z"}
{"parentUuid":"80a31df2-827d-44ae-92f7-e66860d72fa1","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01TXkugRxoRu7NTSoY2d68qf","toolUseID":"toolu_01TXkugRxoRu7NTSoY2d68qf","timestamp":"2026-02-21T14:23:19.480Z","uuid":"7effe6ba-a485-4a64-a4ff-674e10dce9ef"}
{"parentUuid":"80a31df2-827d-44ae-92f7-e66860d72fa1","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TXkugRxoRu7NTSoY2d68qf","type":"tool_result","content":"The file /Users/al02402336/everything/src/App.svelte has been updated successfully."}]},"uuid":"316ca1ac-b882-41e1-bf6c-c113251d509a","timestamp":"2026-02-21T14:23:19.479Z","toolUseResult":{"filePath":"/Users/al02402336/everything/src/App.svelte","oldString":"  .rename-input {\n    flex: 1;\n    min-width: 0;\n    height: 22px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 12px;\n    padding: 0 6px;\n    border: 1.5px solid var(--focus-ring);\n    border-radius: 4px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    outline: none;\n    box-shadow: 0 1px 6px rgba(0, 0, 0, 0.18), 0 0 0 3px rgba(77, 168, 255, 0.12);\n  }","newString":"  .name-editing {\n    opacity: 0.25;\n  }\n\n  .rename-overlay {\n    position: fixed;\n    z-index: 100;\n    min-width: 120px;\n  }\n\n  .rename-textarea {\n    display: block;\n    width: 100%;\n    box-sizing: border-box;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 12px;\n    line-height: 18px;\n    padding: 6px 4px;\n    border: 1.5px solid var(--focus-ring);\n    border-radius: 4px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    outline: none;\n    resize: none;\n    overflow: hidden;\n    box-shadow: 0 2px 14px rgba(0, 0, 0, 0.22), 0 0 0 3px rgba(77, 168, 255, 0.13);\n  }","originalFile":"<script>\n  import { onDestroy, onMount, tick } from 'svelte';\n  import { invoke } from '@tauri-apps/api/core';\n  import { listen } from '@tauri-apps/api/event';\n  import { getCurrentWindow } from '@tauri-apps/api/window';\n  import { startDrag } from '@crabnebula/tauri-plugin-drag';\n\n  const rowHeight = 30;\n  const PAGE_SIZE = 500;\n  let homePrefix = '';\n  const COL_WIDTHS_KEY = 'REDACTED';\n  const THEME_KEY = 'everything-theme';\n  const columnKeys = ['name', 'path', 'size', 'modified'];\n  const minColumnWidth = {\n    name: 180,\n    path: 240,\n    size: 75,\n    modified: 150\n  };\n  const defaultColumnRatios = {\n    name: 0.3,\n    path: 0.45,\n    size: 0.1\n  };\n\n  let theme = (() => { try { return localStorage.getItem(THEME_KEY) || 'dark'; } catch { return 'dark'; } })();\n  function cycleTheme() {\n    theme = theme === 'dark' ? 'light' : 'dark';\n    try { localStorage.setItem(THEME_KEY, theme); } catch {}\n  }\n\n  let query = '';\n  let results = [];\n  let totalResults = 0;\n  let totalResultsKnown = false;\n\n  let dbLatencyMs = null;\n  let dbLastQuery = '';\n  let searchModeLabel = '';\n  let selectedIndices = new Set();\n  let selectionAnchor = -1;\n  let lastSelectedIndex = -1;\n  let editing = {\n    active: false,\n    path: '',\n    index: -1,\n    draftName: ''\n  };\n\n  let renameOverlay = { top: 0, left: 0, width: 0 };\n\n  let indexStatus = {\n    state: 'Indexing',\n    entriesCount: 0,\n    lastUpdated: null,\n    permissionErrors: 0,\n    message: null,\n    isCatchup: false\n  };\n\n  let indexingStartTime = null;\n  let indexingElapsed = '';\n  let indexingFinishedAt = '';\n\n  let sortBy = 'name';\n  let sortDir = 'asc';\n\n  let hasMore = true;\n  let loadingMore = false;\n  let searchGeneration = 0;\n\n  let scanned = 0;\n\n  let searchInputEl;\n  let renameInputEl;\n  let tableAreaEl;\n  let tableContainer;\n  let tableResizeObserver = null;\n  let viewportResizeRaf = null;\n  let scrollTop = 0;\n  let headerScrollLeft = 0;\n  let viewportHeight = 520;\n  let lastTableWidth = 0;\n  let resizingColumn = '';\n  let resizeCleanup = null;\n  let colWidths = {\n    name: 250,\n    path: 350,\n    size: 75,\n    modified: 150\n  };\n\n  let contextMenu = {\n    visible: false,\n    x: 0,\n    y: 0\n  };\n\n  let platform = '';\n  let toast = '';\n  let searchTimer;\n  let lastSearchFiredAt = 0;\n  let toastTimer;\n  let statusRefreshTimer;\n  let elapsedTimer;\n  let statusRefreshInFlight = false;\n  let lastReadyCount = 0;\n\n  const iconCache = new Map();\n  const iconLoading = new Set();\n\n  let highlightCache = new Map();\n  let highlightCacheQuery = '';\n\n  const folderFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='1' y='4' width='14' height='10' rx='2' fill='#d9b34f'/><rect x='1' y='2' width='6' height='4' rx='1' fill='#e6ca7a'/></svg>`\n    );\n  const fileFallbackIcon =\n    \"data:image/svg+xml;utf8,\" +\n    encodeURIComponent(\n      `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='3' y='1' width='10' height='14' rx='1.5' fill='#b4bec9'/><rect x='5' y='5' width='6' height='1.2' fill='#8d98a5'/><rect x='5' y='8' width='6' height='1.2' fill='#8d98a5'/></svg>`\n    );\n\n  $: totalHeight = results.length * rowHeight;\n  $: startIndex = Math.max(0, Math.floor(scrollTop / rowHeight) - 10);\n  $: visibleCount = Math.ceil(viewportHeight / rowHeight) + 20;\n  $: endIndex = Math.min(results.length, startIndex + visibleCount);\n  $: visibleRows = results.slice(startIndex, endIndex);\n  $: translateY = startIndex * rowHeight;\n  $: tableMinWidth = colWidths.name + colWidths.path + colWidths.size + colWidths.modified;\n  $: tableGridStyle = `--col-name:${colWidths.name}px;--col-path:${colWidths.path}px;--col-size:${colWidths.size}px;--col-modified:${colWidths.modified}px;--table-min-width:${tableMinWidth}px;--header-offset:${-headerScrollLeft}px;`;\n\n  $: {\n    for (const entry of visibleRows) {\n      void ensureIcon(entry);\n    }\n  }\n\n  function showToast(message) {\n    toast = message;\n    clearTimeout(toastTimer);\n    toastTimer = setTimeout(() => {\n      toast = '';\n    }, 3000);\n  }\n\n  function bytesToBase64(bytes) {\n    let binary = '';\n    const chunk = 0x8000;\n    for (let i = 0; i < bytes.length; i += chunk) {\n      const part = bytes.subarray(i, i + chunk);\n      binary += String.fromCharCode(...part);\n    }\n    return btoa(binary);\n  }\n\n  function highlightSegments(name, q) {\n    q = (q || '').trim();\n    if (!q) return [{ text: name, hl: false }];\n\n    // Reset cache when query changes\n    if (q !== highlightCacheQuery) {\n      highlightCache = new Map();\n      highlightCacheQuery = q;\n    }\n\n    // Check cache\n    const cached = highlightCache.get(name);\n    if (cached) return cached;\n\n    if (q.includes('/')) q = q.slice(q.lastIndexOf('/') + 1);\n    q = q.replace(/[*?]/g, '');\n    const terms = q.split(/\\s+/).filter(Boolean);\n    if (terms.length === 0) return [{ text: name, hl: false }];\n\n    const lower = name.toLowerCase();\n    const marks = new Uint8Array(name.length);\n    for (const t of terms) {\n      const tl = t.toLowerCase();\n      let idx = lower.indexOf(tl);\n      while (idx !== -1) {\n        for (let i = idx; i < idx + tl.length; i++) marks[i] = 1;\n        idx = lower.indexOf(tl, idx + 1);\n      }\n    }\n\n    const segs = [];\n    let i = 0;\n    while (i < name.length) {\n      const m = marks[i];\n      let j = i + 1;\n      while (j < name.length && marks[j] === m) j++;\n      segs.push({ text: name.slice(i, j), hl: m === 1 });\n      i = j;\n    }\n\n    highlightCache.set(name, segs);\n    return segs;\n  }\n\n  const perFileIconExts = new Set(['exe', 'lnk', 'ico', 'url', 'scr', 'appx']);\n\n  function iconKey(entry) {\n    if (entry.isDir) return '__folder__';\n    const ext = (entry.ext || '').toLowerCase();\n    if (perFileIconExts.has(ext)) return entry.path;\n    return ext || '__file__';\n  }\n\n  function iconFor(entry) {\n    return iconCache.get(iconKey(entry)) || (entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n  }\n\n  async function ensureIcon(entry) {\n    const key = iconKey(entry);\n    if (iconCache.has(key) || iconLoading.has(key)) {\n      return;\n    }\n\n    iconLoading.add(key);\n    try {\n      const bytes = await invoke('get_file_icon', {\n        path: entry.path,\n        ext: entry.isDir ? 'folder' : entry.ext || '',\n      });\n      if (Array.isArray(bytes) && bytes.length > 0) {\n        const image = `data:image/png;base64,${bytesToBase64(Uint8Array.from(bytes))}`;\n        iconCache.set(key, image);\n      } else {\n        iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n      }\n    } catch {\n      iconCache.set(key, entry.isDir ? folderFallbackIcon : fileFallbackIcon);\n    } finally {\n      iconLoading.delete(key);\n    }\n  }\n\n  function syncColumnWidthsToContainer() {\n    const width = tableContainer?.clientWidth || tableAreaEl?.clientWidth;\n    if (!width || lastTableWidth !== 0) {\n      return;\n    }\n\n    const saved = loadColWidths();\n    if (saved) {\n      const total = columnKeys.reduce((s, k) => s + saved[k], 0);\n      if (Math.abs(total - width) > 2) {\n        const scale = (width - saved.modified) / (total - saved.modified);\n        let scaledName = Math.max(minColumnWidth.name, Math.round(saved.name * scale));\n        let scaledSize = Math.max(minColumnWidth.size, Math.round(saved.size * scale));\n        let rawPath = width - saved.modified - scaledName - scaledSize;\n        if (rawPath < minColumnWidth.path) {\n          const shortfall = minColumnWidth.path - rawPath;\n          const nameReduction = Math.min(shortfall, scaledName - minColumnWidth.name);\n          scaledName -= nameReduction;\n          const remaining = shortfall - nameReduction;\n          if (remaining > 0) {\n            scaledSize -= Math.min(remaining, scaledSize - minColumnWidth.size);\n          }\n          rawPath = width - saved.modified - scaledName - scaledSize;\n        }\n        const scaledPath = Math.max(minColumnWidth.path, rawPath);\n        colWidths = { name: scaledName, path: scaledPath, size: scaledSize, modified: saved.modified };\n      } else {\n        colWidths = saved;\n      }\n    } else {\n      const fixedModified = minColumnWidth.modified;\n      const rest = width - fixedModified;\n      const ratioSum = defaultColumnRatios.name + defaultColumnRatios.path + defaultColumnRatios.size;\n      colWidths = {\n        name: Math.max(minColumnWidth.name, Math.round(rest * defaultColumnRatios.name / ratioSum)),\n        path: Math.max(minColumnWidth.path, Math.round(rest * defaultColumnRatios.path / ratioSum)),\n        size: Math.max(minColumnWidth.size, Math.round(rest * defaultColumnRatios.size / ratioSum)),\n        modified: fixedModified\n      };\n    }\n    lastTableWidth = width;\n  }\n\n  function loadColWidths() {\n    try {\n      const raw = localStorage.getItem(COL_WIDTHS_KEY);\n      if (!raw) return null;\n      const parsed = JSON.parse(raw);\n      for (const key of columnKeys) {\n        if (typeof parsed[key] !== 'number' || parsed[key] < (minColumnWidth[key] || 0)) return null;\n      }\n      return parsed;\n    } catch {\n      return null;\n    }\n  }\n\n  function saveColWidths() {\n    localStorage.setItem(COL_WIDTHS_KEY, JSON.stringify(colWidths));\n  }\n\n  function updateViewportHeight() {\n    viewportHeight = tableContainer?.clientHeight || 520;\n    syncColumnWidthsToContainer();\n  }\n\n  function scheduleViewportHeightUpdate() {\n    if (viewportResizeRaf !== null) {\n      return;\n    }\n    viewportResizeRaf = requestAnimationFrame(() => {\n      viewportResizeRaf = null;\n      updateViewportHeight();\n    });\n  }\n\n  function startColumnResize(event, leftKey) {\n    event.preventDefault();\n    event.stopPropagation();\n\n    const index = columnKeys.indexOf(leftKey);\n    if (index < 0 || index >= columnKeys.length - 1) {\n      return;\n    }\n\n    const startX = event.clientX;\n    const startLeft = colWidths[leftKey];\n    const rightKey = columnKeys[index + 1];\n    const startRight = colWidths[rightKey];\n\n    resizeCleanup?.();\n    resizingColumn = leftKey;\n\n    const onMove = (moveEvent) => {\n      const delta = Math.round(moveEvent.clientX - startX);\n      if (leftKey === 'name') {\n        // Two-column trade: name and path swap space, each respects its minimum\n        const nextLeft = Math.max(\n          minColumnWidth[leftKey],\n          Math.min(startLeft + delta, startLeft + startRight - minColumnWidth[rightKey])\n        );\n        const nextRight = startLeft + startRight - nextLeft;\n        colWidths = { ...colWidths, [leftKey]: nextLeft, [rightKey]: nextRight };\n      } else {\n        // path splitter: path grows unconstrained (allows horizontal scroll on right drag)\n        const nextLeft = Math.max(minColumnWidth[leftKey], startLeft + delta);\n        colWidths = { ...colWidths, [leftKey]: nextLeft };\n      }\n    };\n\n    const onUp = () => {\n      cleanup();\n    };\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      document.body.style.cursor = '';\n      document.body.style.userSelect = '';\n      resizingColumn = '';\n      saveColWidths();\n      if (resizeCleanup === cleanup) {\n        resizeCleanup = null;\n      }\n    };\n\n    resizeCleanup = cleanup;\n    document.body.style.cursor = 'col-resize';\n    document.body.style.userSelect = 'none';\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  function selectedPaths() {\n    const sorted = [...selectedIndices].sort((a, b) => a - b);\n    return sorted.map((idx) => results[idx]).filter(Boolean).map((entry) => entry.path);\n  }\n\n  function clearSelection() {\n    selectedIndices = new Set();\n    selectionAnchor = -1;\n    lastSelectedIndex = -1;\n  }\n\n  function selectSingle(index) {\n    selectedIndices = new Set([index]);\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectToggle(index) {\n    const next = new Set(selectedIndices);\n    if (next.has(index)) {\n      next.delete(index);\n    } else {\n      next.add(index);\n    }\n    selectedIndices = next;\n    selectionAnchor = index;\n    lastSelectedIndex = index;\n  }\n\n  function selectRange(index) {\n    const anchor = selectionAnchor >= 0 ? selectionAnchor : index;\n    const [from, to] = [Math.min(anchor, index), Math.max(anchor, index)];\n    const next = new Set();\n    for (let i = from; i <= to; i += 1) {\n      next.add(i);\n    }\n    selectedIndices = next;\n    lastSelectedIndex = index;\n  }\n\n  function primaryEntry() {\n    const idx = lastSelectedIndex >= 0 ? lastSelectedIndex : -1;\n    return idx >= 0 ? results[idx] : null;\n  }\n\n  async function refreshStatus() {\n    if (statusRefreshInFlight) {\n      return;\n    }\n    statusRefreshInFlight = true;\n    try {\n      const status = await invoke('get_index_status');\n      const prevState = indexStatus.state;\n      indexStatus = {\n        state: status.state,\n        entriesCount: status.entriesCount,\n        lastUpdated: status.lastUpdated,\n        permissionErrors: status.permissionErrors ?? 0,\n        message: status.message\n      };\n      if (status.state === 'Indexing' && prevState !== 'Indexing') {\n        startElapsedTimer();\n      } else if (status.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n      if (typeof status.scanned === 'number') {\n        scanned = status.scanned;\n      }\n      if (status.state === 'Ready' && prevState !== 'Ready') {\n        scheduleSearch();\n      }\n    } catch (err) {\n      showToast(`Failed to get status: ${String(err)}`);\n    } finally {\n      statusRefreshInFlight = false;\n    }\n  }\n\n  function scheduleSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const scheduledGen = searchGeneration;\n    clearTimeout(searchTimer);\n\n    const now = performance.now();\n    if (now - lastSearchFiredAt >= 200) {\n      // Leading edge: fire immediately if enough time has passed\n      lastSearchFiredAt = now;\n      void runSearch(preserveScroll);\n    } else {\n      // Trailing edge: debounce\n      searchTimer = setTimeout(() => {\n        if (scheduledGen !== searchGeneration) {\n          return;\n        }\n        lastSearchFiredAt = performance.now();\n        void runSearch(preserveScroll);\n      }, 200);\n    }\n  }\n\n  async function runSearch(preserveScroll = false) {\n    searchGeneration += 1;\n    const gen = searchGeneration;\n    const searchQuery = query;\n    const searchSortBy = sortBy;\n    const searchSortDir = sortDir;\n    const startedAt = performance.now();\n    try {\n      const keepPaths = new Set(selectedPaths());\n      const next = await invoke('search', {\n        query: searchQuery,\n        limit: PAGE_SIZE,\n        offset: 0,\n        sortBy: searchSortBy,\n        sortDir: searchSortDir\n      });\n\n      if (gen !== searchGeneration) return;\n\n      dbLatencyMs = Math.round(performance.now() - startedAt);\n      dbLastQuery = searchQuery;\n      const entries = Array.isArray(next.entries) ? next.entries : [];\n      searchModeLabel = next.modeLabel || '';\n      results = entries;\n      if (next.totalCount > 0) {\n        totalResults = next.totalCount;\n        totalResultsKnown = true;\n      } else {\n        totalResults = entries.length;\n        totalResultsKnown = false;\n      }\n      hasMore = totalResultsKnown ? results.length < totalResults : entries.length >= PAGE_SIZE;\n      if (!preserveScroll && tableContainer) tableContainer.scrollTop = 0;\n\n      const restored = new Set();\n      for (let i = 0; i < results.length; i += 1) {\n        if (keepPaths.has(results[i].path)) {\n          restored.add(i);\n        }\n      }\n      selectedIndices = restored;\n\n      updateViewportHeight();\n    } catch (err) {\n      if (gen !== searchGeneration) return;\n      showToast(`Search failed: ${String(err)}`);\n    }\n  }\n\n  async function loadMore() {\n    if (!hasMore || loadingMore) return;\n    const gen = searchGeneration;\n    loadingMore = true;\n    try {\n      const batch = await invoke('search', {\n        query,\n        limit: PAGE_SIZE,\n        offset: results.length,\n        sortBy: sortBy,\n        sortDir: sortDir\n      });\n      if (gen !== searchGeneration) return;\n      const arr = Array.isArray(batch.entries) ? batch.entries : [];\n      if (arr.length > 0) results = [...results, ...arr];\n      hasMore = totalResultsKnown ? results.length < totalResults : arr.length >= PAGE_SIZE;\n    } catch (err) {\n      showToast(`Failed to load more: ${String(err)}`);\n    } finally {\n      loadingMore = false;\n    }\n  }\n\n  function moveSelection(delta, withRange = false) {\n    if (results.length === 0) {\n      return;\n    }\n\n    const current = lastSelectedIndex >= 0 ? lastSelectedIndex : 0;\n    const next = Math.max(0, Math.min(results.length - 1, current + delta));\n\n    if (withRange) {\n      selectRange(next);\n    } else {\n      selectSingle(next);\n    }\n\n    const top = next * rowHeight;\n    const bottom = top + rowHeight;\n    if (top < scrollTop) {\n      tableContainer.scrollTop = top;\n    } else if (bottom > scrollTop + viewportHeight) {\n      tableContainer.scrollTop = bottom - viewportHeight;\n    }\n  }\n\n  function handleHeaderSort(column) {\n    if (sortBy === column) {\n      sortDir = sortDir === 'asc' ? 'desc' : 'asc';\n    } else {\n      sortBy = column;\n      sortDir = 'asc';\n    }\n    if (tableContainer) tableContainer.scrollTop = 0;\n    void runSearch();\n  }\n\n  function handleRowClick(event, index) {\n    contextMenu.visible = false;\n\n    if (event.shiftKey) {\n      selectRange(index);\n      return;\n    }\n\n    if (event.metaKey || event.ctrlKey) {\n      selectToggle(index);\n      return;\n    }\n\n    selectSingle(index);\n  }\n\n  function handleRowContextMenu(event, index) {\n    event.preventDefault();\n\n    if (!selectedIndices.has(index)) {\n      selectSingle(index);\n    }\n\n    if (platform === 'windows' || platform === 'macos') {\n      contextMenu.visible = false;\n      const paths = selectedPaths();\n      if (paths.length > 0) {\n        invoke('show_context_menu', {\n          paths,\n          x: event.clientX,\n          y: event.clientY,\n          singleSelection: selectedIndices.size === 1\n        });\n      }\n      return;\n    }\n\n    contextMenu = {\n      visible: true,\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n\n  function handleRowA11yKeydown(event, index) {\n    if (event.key === ' ' || event.key === 'Enter') {\n      event.preventDefault();\n      handleRowClick(event, index);\n    }\n  }\n\n  const DRAG_THRESHOLD = 5;\n  let dragCleanup = null;\n  const dragImgCache = new Map();\n\n  function dragPathsForIndex(index) {\n    const entry = results[index];\n    if (!entry) {\n      return [];\n    }\n\n    if (selectedIndices.has(index) && selectedIndices.size > 0) {\n      return selectedPaths();\n    }\n\n    return [entry.path];\n  }\n\n  function getDragIconEl(entry) {\n    const src = iconFor(entry);\n    let img = dragImgCache.get(src);\n    if (!img) {\n      img = new Image();\n      img.src = src;\n      dragImgCache.set(src, img);\n    }\n    return img.complete && img.naturalWidth > 0 ? img : null;\n  }\n\n  function fillRoundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function buildDragPreview(index) {\n    const entry = results[index];\n    if (!entry) return null;\n\n    const count = selectedIndices.has(index) ? selectedIndices.size : 1;\n    const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\n\n    const w = 260;\n    const h = 28;\n    const stackGap = count > 1 ? 4 : 0;\n\n    const canvas = document.createElement('canvas');\n    canvas.width = w;\n    canvas.height = h + stackGap;\n    const ctx = canvas.getContext('2d');\n\n    if (count > 1) {\n      ctx.globalAlpha = 0.35;\n      ctx.fillStyle = isDark ? '#5a6070' : '#b0c4de';\n      fillRoundRect(ctx, 3, 0, w - 3, h, 5);\n      ctx.globalAlpha = 1.0;\n    }\n\n    const ry = stackGap;\n    ctx.fillStyle = isDark ? 'rgba(58, 64, 74, 0.94)' : 'rgba(214, 231, 255, 0.94)';\n    fillRoundRect(ctx, 0, ry, w, h, 5);\n\n    ctx.strokeStyle = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';\n    ctx.lineWidth = 0.5;\n    ctx.beginPath();\n    ctx.moveTo(5, ry);\n    ctx.arcTo(w, ry, w, ry + h, 5);\n    ctx.arcTo(w, ry + h, 0, ry + h, 5);\n    ctx.arcTo(0, ry + h, 0, ry, 5);\n    ctx.arcTo(0, ry, w, ry, 5);\n    ctx.closePath();\n    ctx.stroke();\n\n    const iconEl = getDragIconEl(entry);\n    if (iconEl) {\n      ctx.drawImage(iconEl, 6, ry + 6, 16, 16);\n    } else {\n      ctx.fillStyle = entry.isDir ? '#d9b34f' : '#8d98a5';\n      fillRoundRect(ctx, 6, ry + 6, 16, 16, 2);\n    }\n\n    ctx.fillStyle = isDark ? '#e6e6e8' : '#1a1a1a';\n    ctx.font = '12px -apple-system, \"SF Pro Text\", system-ui, sans-serif';\n    ctx.textBaseline = 'middle';\n\n    let nameMaxW = w - 34;\n    if (count > 1) nameMaxW -= 34;\n\n    let name = entry.name;\n    if (ctx.measureText(name).width > nameMaxW) {\n      while (name.length > 4 && ctx.measureText(name + '\\u2026').width > nameMaxW) {\n        name = name.slice(0, -1);\n      }\n      name += '\\u2026';\n    }\n    ctx.fillText(name, 28, ry + h / 2 + 1);\n\n    if (count > 1) {\n      const badge = String(count);\n      ctx.font = 'bold 10px -apple-system, system-ui, sans-serif';\n      const tw = ctx.measureText(badge).width;\n      const bw = Math.max(20, tw + 10);\n      const bx = w - bw - 6;\n      const by = ry + (h - 18) / 2;\n\n      ctx.fillStyle = isDark ? '#5b8bd9' : '#007aff';\n      fillRoundRect(ctx, bx, by, bw, 18, 9);\n\n      ctx.fillStyle = '#ffffff';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(badge, bx + bw / 2, by + 9);\n    }\n\n    return canvas.toDataURL('image/png');\n  }\n\n  function handleRowMouseDown(event, index) {\n    if (event.button !== 0) return;\n    if (event.metaKey || event.ctrlKey || event.shiftKey) return;\n    if (editing.active) return;\n\n    const startX = event.clientX;\n    const startY = event.clientY;\n    let dragging = false;\n\n    dragCleanup?.();\n\n    const onMove = (e) => {\n      if (dragging) return;\n      const dx = e.clientX - startX;\n      const dy = e.clientY - startY;\n      if (dx * dx + dy * dy < DRAG_THRESHOLD * DRAG_THRESHOLD) return;\n\n      dragging = true;\n      cleanup();\n\n      if (!selectedIndices.has(index)) {\n        selectSingle(index);\n      }\n\n      const paths = dragPathsForIndex(index);\n      if (paths.length > 0) {\n        const icon = buildDragPreview(index);\n        startDrag({ item: paths, icon }).catch(() => {});\n      }\n    };\n\n    const onUp = () => cleanup();\n\n    const cleanup = () => {\n      window.removeEventListener('mousemove', onMove);\n      window.removeEventListener('mouseup', onUp);\n      if (dragCleanup === cleanup) dragCleanup = null;\n    };\n\n    dragCleanup = cleanup;\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  async function handleRowDoubleClick(index) {\n    if (!selectedIndices.has(index) || selectedIndices.size > 1) {\n      selectSingle(index);\n      await tick();\n    }\n    await invoke('open', { paths: [results[index].path] }).catch((err) => {\n      showToast(`Failed to open: ${String(err)}`);\n    });\n  }\n\n  function closeContextMenu() {\n    contextMenu = {\n      ...contextMenu,\n      visible: false\n    };\n  }\n\n  async function openSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('open', { paths });\n    } catch (err) {\n      showToast(`Failed to open: ${String(err)}`);\n    }\n  }\n\n  async function openWithFallback() {\n    const target = primaryEntry();\n    if (!target) {\n      return;\n    }\n\n    try {\n      await invoke('open_with', { path: target.path });\n    } catch (err) {\n      showToast(`Open With failed: ${String(err)}`);\n    }\n  }\n\n  async function revealSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('reveal_in_finder', { paths });\n    } catch (err) {\n      showToast(`Failed to reveal in Finder: ${String(err)}`);\n    }\n  }\n\n  async function copySelectedPaths() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_paths', { paths });\n      showToast(`Copied ${paths.length} path(s)`);\n    } catch (err) {\n      showToast(`Failed to copy path: ${String(err)}`);\n    }\n  }\n\n  async function copyFiles() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    try {\n      await invoke('copy_files', { paths });\n      showToast(`Copied ${paths.length} item(s)`);\n    } catch (err) {\n      showToast(`Failed to copy: ${String(err)}`);\n    }\n  }\n\n  async function trashSelected() {\n    const paths = selectedPaths();\n    if (paths.length === 0) {\n      return;\n    }\n\n    const message =\n      paths.length === 1\n        ? 'Move selected item to Trash?'\n        : `Move ${paths.length} items to Trash?`;\n\n    if (!window.confirm(message)) {\n      return;\n    }\n\n    try {\n      await invoke('move_to_trash', { paths });\n      showToast('Moved to Trash.');\n      clearSelection();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to move to Trash: ${String(err)}`);\n    }\n  }\n\n  async function resetIndex() {\n    if (indexStatus.state === 'Indexing') {\n      showToast('Indexing in progress. Please try again after it completes.');\n      return;\n    }\n\n    results = [];\n    totalResults = 0;\n    totalResultsKnown = false;\n    clearSelection();\n    scanned = 0;\n    dbLatencyMs = null;\n    dbLastQuery = '';\n    indexStatus = { ...indexStatus, state: 'Indexing', entriesCount: 0, message: null };\n    indexingStartTime = Date.now();\n    indexingElapsed = '';\n    indexingFinishedAt = '';\n\n    try {\n      await invoke('reset_index');\n    } catch (err) {\n      showToast(`Failed to reset index: ${String(err)}`);\n      await refreshStatus();\n    }\n  }\n\n  function isMultiSelected() {\n    return selectedIndices.size > 1;\n  }\n\n  function autoResizeRenameInput() {\n    if (!renameInputEl) return;\n    renameInputEl.style.height = '0';\n    renameInputEl.style.height = renameInputEl.scrollHeight + 'px';\n  }\n\n  async function startRename() {\n    if (isMultiSelected()) {\n      return;\n    }\n\n    const idx = lastSelectedIndex;\n    if (idx < 0 || !results[idx]) {\n      return;\n    }\n\n    const entry = results[idx];\n\n    // Calculate overlay position from the row's name cell text span\n    const rowDomIndex = idx - startIndex;\n    const rowEls = tableContainer?.querySelectorAll('.row');\n    const rowEl = rowEls?.[rowDomIndex];\n    const nameCell = rowEl?.querySelector('.cell.name');\n\n    if (nameCell) {\n      const cellRect = nameCell.getBoundingClientRect();\n      const ellipsis = nameCell.querySelector('.ellipsis');\n      const textLeft = ellipsis ? ellipsis.getBoundingClientRect().left : cellRect.left + 38;\n      // Offset left by border(1.5) + padding-left(4) so text inside textarea aligns with row text\n      const pad = 6;\n      renameOverlay = {\n        top: cellRect.top,\n        left: textLeft - pad,\n        width: cellRect.right - textLeft + pad - 4\n      };\n    }\n\n    editing = {\n      active: true,\n      path: entry.path,\n      index: idx,\n      draftName: entry.name\n    };\n\n    await tick();\n\n    if (renameInputEl) {\n      autoResizeRenameInput();\n      renameInputEl.focus();\n      const extPos = !entry.isDir ? entry.name.lastIndexOf('.') : -1;\n      const selectionEnd = extPos > 0 ? extPos : entry.name.length;\n      renameInputEl.setSelectionRange(0, selectionEnd);\n    }\n  }\n\n  function cancelRename() {\n    editing = {\n      active: false,\n      path: '',\n      index: -1,\n      draftName: ''\n    };\n  }\n\n  async function commitRename() {\n    if (!editing.active || editing.index < 0 || !results[editing.index]) {\n      return;\n    }\n\n    const current = results[editing.index];\n    const nextName = editing.draftName;\n\n    try {\n      await invoke('rename', {\n        path: current.path,\n        newName: nextName\n      });\n      cancelRename();\n      await runSearch();\n    } catch (err) {\n      showToast(`Failed to rename: ${String(err)}`);\n      await tick();\n      renameInputEl?.focus();\n    }\n  }\n\n  function onGlobalClick() {\n    closeContextMenu();\n  }\n\n  function onTitleBarMouseDown(event) {\n    if (event.button !== 0) {\n      return;\n    }\n\n    const activeElement = document.activeElement;\n    if (activeElement instanceof HTMLElement && isTextInputTarget(activeElement)) {\n      activeElement.blur();\n    }\n  }\n\n  async function focusSearch() {\n    await getCurrentWindow().show();\n    await getCurrentWindow().setFocus();\n    searchInputEl?.focus();\n    searchInputEl?.select();\n  }\n\n  function isTextInputTarget(target) {\n    return (\n      target instanceof HTMLInputElement ||\n      target instanceof HTMLTextAreaElement ||\n      target?.isContentEditable\n    );\n  }\n\n  async function handleKeydown(event) {\n    const isMetaSelectAll = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'a';\n    const isMetaCopy = (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c';\n    const target = event.target;\n    const isTextInput = isTextInputTarget(target);\n\n    if (isMetaCopy && isTextInput) {\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      if (isTextInput) {\n        event.preventDefault();\n        if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n          target.select();\n        }\n        return;\n      }\n    }\n\n    if (editing.active) {\n      if (event.key === 'Enter') {\n        event.preventDefault();\n        await commitRename();\n        return;\n      }\n\n      if (event.key === 'Escape') {\n        event.preventDefault();\n        cancelRename();\n        searchInputEl?.focus();\n        return;\n      }\n      return;\n    }\n\n    if (event.key === 'Escape') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      return;\n    }\n\n    if (event.key === 'ArrowDown') {\n      event.preventDefault();\n      moveSelection(1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'ArrowUp') {\n      event.preventDefault();\n      moveSelection(-1, event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageDown') {\n      event.preventDefault();\n      moveSelection(Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'PageUp') {\n      event.preventDefault();\n      moveSelection(-Math.floor(viewportHeight / rowHeight), event.shiftKey);\n      return;\n    }\n\n    if (event.key === 'Enter') {\n      event.preventDefault();\n      if (platform === 'windows') {\n        await openSelected();\n      } else {\n        await startRename();\n      }\n      return;\n    }\n\n    if (event.key === 'F2') {\n      event.preventDefault();\n      await startRename();\n      return;\n    }\n\n    if (event.key === ' ' && !isTextInput) {\n      event.preventDefault();\n      const entry = primaryEntry();\n      if (entry) {\n        await invoke('quick_look', { path: entry.path });\n      }\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'f') {\n      event.preventDefault();\n      clearSelection();\n      searchInputEl?.focus();\n      searchInputEl?.select();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'o') {\n      event.preventDefault();\n      await openSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {\n      event.preventDefault();\n      await revealSelected();\n      return;\n    }\n\n    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'c') {\n      event.preventDefault();\n      await copySelectedPaths();\n      return;\n    }\n\n    if (isMetaSelectAll) {\n      event.preventDefault();\n      selectedIndices = new Set(Array.from({ length: results.length }, (_, i) => i));\n      return;\n    }\n\n    if (event.key === 'Delete' || ((event.metaKey || event.ctrlKey) && event.key === 'Backspace')) {\n      if (!isTextInput) {\n        event.preventDefault();\n        await trashSelected();\n      }\n      return;\n    }\n  }\n\n  function formatSize(entry) {\n    if (entry.isDir || entry.size == null) return '';\n    const bytes = entry.size;\n    if (bytes < 1024) return `${bytes} B`;\n    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n    return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n  }\n\n  function formatModified(entry) {\n    if (!entry.mtime) {\n      return '';\n    }\n\n    const d = new Date(entry.mtime * 1000);\n    const pad = (n) => String(n).padStart(2, '0');\n    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;\n  }\n\n  function formatLastUpdated(timestamp) {\n    if (!timestamp) {\n      return '-';\n    }\n\n    return new Date(timestamp * 1000).toLocaleString();\n  }\n\n  function formatElapsed(ms) {\n    const totalSec = Math.floor(ms / 1000);\n    const min = Math.floor(totalSec / 60);\n    const sec = totalSec % 60;\n    return min > 0 ? `${min}m ${sec}s` : `${sec}s`;\n  }\n\n  function updateElapsed() {\n    if (indexingStartTime && indexStatus.state === 'Indexing') {\n      indexingElapsed = formatElapsed(Date.now() - indexingStartTime);\n    }\n  }\n\n  function startElapsedTimer() {\n    clearInterval(elapsedTimer);\n    indexingStartTime = Date.now();\n    indexingElapsed = '0s';\n    indexingFinishedAt = '';\n    elapsedTimer = setInterval(updateElapsed, 1000);\n  }\n\n  function stopElapsedTimer() {\n    clearInterval(elapsedTimer);\n    if (indexingStartTime) {\n      const elapsed = Date.now() - indexingStartTime;\n      indexingFinishedAt = `${formatElapsed(elapsed)}`;\n    }\n    indexingStartTime = null;\n    indexingElapsed = '';\n  }\n\n  function displayPath(path) {\n    if (!path) {\n      return path;\n    }\n\n    if (!homePrefix) {\n      return path;\n    }\n\n    if (path === homePrefix) {\n      return '~';\n    }\n\n    if (path.startsWith(`${homePrefix}/`)) {\n      return `~${path.slice(homePrefix.length)}`;\n    }\n\n    return path;\n  }\n\n  let unlistenFns = [];\n\n  onMount(async () => {\n    const t0 = performance.now();\n    const ms = () => Math.round(performance.now() - t0);\n    const DEBUG_STARTUP = false;\n    const flog = DEBUG_STARTUP ? (msg) => invoke('frontend_log', { msg }).catch(() => {}) : () => {};\n\n    flog(`[startup/fe] onMount entered`);\n\n    updateViewportHeight();\n    flog(`[startup/fe] +${ms()}ms updateViewportHeight done`);\n\n    platform = await invoke('get_platform');\n    flog(`[startup/fe] +${ms()}ms get_platform done`);\n\n    const unlistenProgress = await listen('index_progress', (event) => {\n      scanned = event.payload.scanned;\n      if (indexStatus.state !== 'Indexing') {\n        indexStatus = {\n          ...indexStatus,\n          state: 'Indexing'\n        };\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_progress) registered`);\n\n    const unlistenState = await listen('index_state', (event) => {\n      flog(`[startup/fe] index_state event received: ${event.payload.state} at +${ms()}ms`);\n      const prevState = indexStatus.state;\n      indexStatus = {\n        ...indexStatus,\n        state: event.payload.state,\n        message: event.payload.message ?? null,\n        isCatchup: event.payload.isCatchup ?? false\n      };\n\n      if (event.payload.state === 'Indexing' && prevState !== 'Indexing') {\n        if (prevState === 'Ready') {\n          lastReadyCount = indexStatus.entriesCount;\n        }\n        startElapsedTimer();\n      } else if (event.payload.state !== 'Indexing' && prevState === 'Indexing') {\n        stopElapsedTimer();\n      }\n\n      if (event.payload.state === 'Ready') {\n        scheduleSearch();\n      }\n    });\n    flog(`[startup/fe] +${ms()}ms listen(index_state) registered`);\n\n    const unlistenUpdated = await listen('index_updated', (event) => {\n      indexStatus = {\n        ...indexStatus,\n        entriesCount: event.payload.entriesCount,\n        lastUpdated: event.payload.lastUpdated,\n        permissionErrors: event.payload.permissionErrors ?? indexStatus.permissionErrors\n      };\n\n      scheduleSearch(true);\n    });\n\n    const unlistenFocus = await listen('focus_search', () => {\n      void focusSearch();\n    });\n\n    const unlistenCtxMenuAction = await listen('context_menu_action', (event) => {\n      switch (event.payload) {\n        case 'open': void openSelected(); break;\n        case 'quick_look': {\n          const e = primaryEntry();\n          if (e) void invoke('quick_look', { path: e.path });\n          break;\n        }\n        case 'open_with': void openWithFallback(); break;\n        case 'reveal': void revealSelected(); break;\n        case 'copy_files': void copyFiles(); break;\n        case 'copy_path': void copySelectedPaths(); break;\n        case 'trash': void trashSelected(); break;\n        case 'rename': void startRename(); break;\n      }\n    });\n\n    unlistenFns = [unlistenProgress, unlistenState, unlistenUpdated, unlistenFocus, unlistenCtxMenuAction];\n    flog(`[startup/fe] +${ms()}ms all listeners registered`);\n\n    // Fetch backend state IMMEDIATELY after listeners are registered.\n    // Events emitted before listener registration are lost, so this\n    // is the only reliable way to get the current state.\n    await refreshStatus();\n    flog(`[startup/fe] +${ms()}ms refreshStatus done (state=${indexStatus.state})`);\n\n    // Show Svelte UI: remove skeleton, focus search input.\n    await tick();\n    document.getElementById('skeleton')?.remove();\n    await focusSearch();\n    flog(`[startup/fe] +${ms()}ms WINDOW VISIBLE — skeleton removed`);\n\n    try {\n      homePrefix = await invoke('get_home_dir');\n    } catch {\n      homePrefix = '';\n    }\n    flog(`[startup/fe] +${ms()}ms get_home_dir done`);\n\n    if (!localStorage.getItem('everything-fda-notice-v1')) {\n      showToast('macOS Full Disk Access permission may be required for full disk search.');\n      localStorage.setItem('everything-fda-notice-v1', '1');\n    }\n    flog(`[startup/fe] +${ms()}ms calling runSearch...`);\n    await runSearch();\n    flog(`[startup/fe] +${ms()}ms runSearch done`);\n\n    if (typeof ResizeObserver !== 'undefined') {\n      tableResizeObserver = new ResizeObserver(() => {\n        scheduleViewportHeightUpdate();\n      });\n      if (tableContainer) {\n        tableResizeObserver.observe(tableContainer);\n      } else if (tableAreaEl) {\n        tableResizeObserver.observe(tableAreaEl);\n      }\n    }\n\n    window.addEventListener('resize', scheduleViewportHeightUpdate);\n    window.addEventListener('click', onGlobalClick);\n    statusRefreshTimer = setInterval(() => {\n      if (indexStatus.state === 'Indexing') {\n        void refreshStatus();\n      }\n    }, 1000);\n    console.log(`[startup/fe] +${ms()}ms onMount complete`);\n  });\n\n  onDestroy(async () => {\n    clearTimeout(searchTimer);\n    clearTimeout(toastTimer);\n    clearInterval(statusRefreshTimer);\n    clearInterval(elapsedTimer);\n    resizeCleanup?.();\n\n    for (const unlisten of unlistenFns) {\n      unlisten();\n    }\n\n    tableResizeObserver?.disconnect();\n    tableResizeObserver = null;\n    if (viewportResizeRaf !== null) {\n      cancelAnimationFrame(viewportResizeRaf);\n      viewportResizeRaf = null;\n    }\n    window.removeEventListener('resize', scheduleViewportHeightUpdate);\n    window.removeEventListener('click', onGlobalClick);\n  });\n</script>\n\n<svelte:window on:keydown={handleKeydown} />\n\n<div class=\"app-shell\" data-theme={theme}>\n  <div class=\"title-bar\" role=\"presentation\" data-tauri-drag-region on:mousedown={onTitleBarMouseDown}>\n    <div class=\"title-left\"></div>\n    <div class=\"title-center\">\n      <svg class=\"title-icon\" viewBox=\"0 0 215 205\" fill-rule=\"evenodd\" aria-hidden=\"true\">\n        <path d=\"M85 0c46.9 0 85 38.1 85 85 0 20.1-7.2 38.5-19.2 52.7l40.7 40.8c5.8 5.8 5.8 15.2 0 21-5.8 5.8-15.2 5.8-21 0l-40.7-40.7c-13.6 9.7-30.4 15.2-44.8 15.2-46.9 0-85-42.1-85-89 0-46.9 38.1-85 85-85z m0 32c-29.3 0-53 23.7-53 53 0 29.3 23.7 53 53 53 29.3 0 53-23.7 53-53 0-29.3-23.7-53-53-53z\"/>\n      </svg>\n      <span class=\"title-text\">Everything</span>\n    </div>\n    <div class=\"title-right\"></div>\n  </div>\n\n  <header class=\"search-bar\">\n    <input\n      bind:this={searchInputEl}\n      class=\"search-input\"\n      type=\"text\"\n      bind:value={query}\n      on:input={scheduleSearch}\n      on:focus={clearSelection}\n      placeholder=\"Search file/folder names\"\n      autocomplete=\"off\"\n      spellcheck=\"false\"\n    />\n  </header>\n\n  <section class=\"table-area\" bind:this={tableAreaEl} style={tableGridStyle}>\n    <div class=\"table-header\">\n      <div class=\"table-header-track\">\n        <div class=\"col name\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('name')}>\n            Name{#if sortBy === 'name'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'name'}\n            on:mousedown={(event) => startColumnResize(event, 'name')}\n            aria-label=\"Resize Name column\"\n          />\n        </div>\n\n        <div class=\"col path\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('dir')}>\n            Path{#if sortBy === 'dir'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n          <button\n            type=\"button\"\n            class=\"col-resizer\"\n            class:active={resizingColumn === 'path'}\n            on:mousedown={(event) => startColumnResize(event, 'path')}\n            aria-label=\"Resize Path column\"\n          />\n        </div>\n\n        <div class=\"col size\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('size')}>\n            Size{#if sortBy === 'size'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n\n        <div class=\"col modified\">\n          <button type=\"button\" class=\"col-button\" on:click={() => handleHeaderSort('mtime')}>\n            Modified{#if sortBy === 'mtime'}<svg class=\"sort-icon\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d={sortDir === 'asc' ? 'M2.5 6.5 L5 4 L7.5 6.5' : 'M2.5 3.5 L5 6 L7.5 3.5'}/></svg>{/if}\n          </button>\n        </div>\n      </div>\n    </div>\n\n    <div\n      class=\"table-body\"\n      bind:this={tableContainer}\n      on:scroll={() => {\n        scrollTop = tableContainer.scrollTop;\n        headerScrollLeft = tableContainer.scrollLeft;\n        if (editing.active) cancelRename();\n        const scrollBottom = scrollTop + tableContainer.clientHeight;\n        if (scrollBottom >= totalHeight - rowHeight * 10) {\n          void loadMore();\n        }\n      }}\n    >\n      <div class=\"spacer\" style={`height:${totalHeight}px`}>\n        <div class=\"rows\" style={`transform: translateY(${translateY}px);`}>\n          {#each visibleRows as entry, localIndex}\n            {@const index = startIndex + localIndex}\n            <div\n              class=\"row {selectedIndices.has(index) ? 'selected' : ''}\"\n              on:mousedown={(event) => handleRowMouseDown(event, index)}\n              on:click={(event) => handleRowClick(event, index)}\n              on:keydown={(event) => handleRowA11yKeydown(event, index)}\n              on:dblclick={() => handleRowDoubleClick(index)}\n              on:contextmenu={(event) => handleRowContextMenu(event, index)}\n              role=\"row\"\n              tabindex=\"0\"\n            >\n              <div class=\"cell name\">\n                <img class=\"file-icon\" src={iconFor(entry)} alt=\"\" />\n                <span class=\"ellipsis\" class:name-editing={editing.active && editing.index === index}>{#each highlightSegments(entry.name, query) as seg}{#if seg.hl}<mark class=\"hl\">{seg.text}</mark>{:else}{seg.text}{/if}{/each}</span>\n              </div>\n              <div class=\"cell path\"><span class=\"ellipsis\">{displayPath(entry.dir)}</span></div>\n              <div class=\"cell size\">{formatSize(entry)}</div>\n              <div class=\"cell modified\">{formatModified(entry)}</div>\n            </div>\n          {/each}\n        </div>\n      </div>\n    </div>\n  </section>\n\n  <footer class=\"status-bar\">\n    <div class=\"status-left\">\n      <span class=\"status-state\">\n        <span class=\"state-dot {indexStatus.state === 'Indexing' ? 'indexing' : indexStatus.state === 'Error' ? 'error' : 'ready'}\"></span>\n        {#if indexStatus.state === 'Indexing'}\n          Indexing{#if lastReadyCount > 0} ({Math.min(99, Math.round((scanned / lastReadyCount) * 100))}%){/if}{#if indexingElapsed} · {indexingElapsed}{/if}\n          {#if !indexStatus.isCatchup}\n            · {scanned.toLocaleString()} scanned\n          {/if}\n        {:else}\n          Index: {indexStatus.state}\n        {/if}\n      </span>\n      <span>{indexStatus.entriesCount.toLocaleString()} entries</span>\n      {#if indexingFinishedAt && indexStatus.state !== 'Indexing'}\n        <span>in {indexingFinishedAt}</span>\n      {/if}\n      {#if dbLatencyMs !== null && dbLastQuery}\n        <span>\"{dbLastQuery}\" {dbLatencyMs}ms · {totalResults} results</span>\n      {/if}\n      {#if searchModeLabel === 'spotlight' || searchModeLabel === 'spotlight_timeout'}\n        <span class=\"status-spotlight\">Spotlight fallback{#if searchModeLabel === 'spotlight_timeout'} (partial){/if}</span>\n      {/if}\n      {#if indexStatus.permissionErrors > 0}\n        <span class=\"status-warning\">{indexStatus.permissionErrors.toLocaleString()} permission errors</span>\n      {/if}\n      {#if indexStatus.message}\n        <span class={indexStatus.isCatchup ? 'index-progress' : 'status-error'}>{indexStatus.message}</span>\n      {/if}\n    </div>\n    <div class=\"status-right\">\n      <button class=\"status-btn theme-btn\" on:click={cycleTheme} title=\"Switch theme\">\n        {theme === 'dark' ? '☀ Light' : '◑ Dark'}\n      </button>\n      <button\n        class=\"status-btn rebuild-btn\"\n        on:click={resetIndex}\n        disabled={indexStatus.state === 'Indexing'}\n        title={indexStatus.state === 'Indexing' ? 'Cannot reset while indexing is in progress.' : 'Reset and rebuild the index.'}\n      >\n        <svg class=\"rebuild-icon\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n          <path d=\"M23 4v6h-6\"/><path d=\"M20.49 15a9 9 0 1 1-2.12-9.36L23 10\"/>\n        </svg>\n        Rebuild Index\n      </button>\n    </div>\n  </footer>\n\n  {#if editing.active}\n    <div\n      class=\"rename-overlay\"\n      style=\"top:{renameOverlay.top}px; left:{renameOverlay.left}px; width:{renameOverlay.width}px;\"\n      role=\"presentation\"\n      on:mousedown|stopPropagation\n    >\n      <textarea\n        bind:this={renameInputEl}\n        class=\"rename-textarea\"\n        bind:value={editing.draftName}\n        on:input={autoResizeRenameInput}\n        on:click|stopPropagation\n        on:blur={commitRename}\n      />\n    </div>\n  {/if}\n\n  {#if contextMenu.visible}\n    <div class=\"context-menu\" style={`left:${contextMenu.x}px;top:${contextMenu.y}px;`}>\n      <button on:click={() => (closeContextMenu(), openSelected())}>Open</button>\n      <button on:click={async () => { closeContextMenu(); const e = primaryEntry(); if (e) await invoke('quick_look', { path: e.path }); }}>Quick Look</button>\n      <button on:click={() => (closeContextMenu(), openWithFallback())}>Open With... (Reveal in Finder)</button>\n      <button on:click={() => (closeContextMenu(), revealSelected())}>Reveal in Finder</button>\n      <button on:click={() => (closeContextMenu(), copySelectedPaths())}>Copy Path</button>\n      <button on:click={() => (closeContextMenu(), trashSelected())}>Move to Trash</button>\n      {#if selectedIndices.size === 1}\n        <button on:click={() => (closeContextMenu(), startRename())}>Rename</button>\n      {/if}\n    </div>\n  {/if}\n\n  {#if toast}\n    <div class=\"toast\">{toast}</div>\n  {/if}\n</div>\n\n<style>\n  :global(:root) {\n    color-scheme: light dark;\n    --bg-app: transparent;\n    --text-primary: #0d1826;\n    --text-muted: #48596c;\n    --bar-grad-top: rgba(255, 255, 255, 0.48);\n    --bar-grad-bottom: rgba(248, 250, 253, 0.42);\n    --surface-header: rgba(252, 252, 255, 0.40);\n    --surface: rgba(255, 255, 255, 0.22);\n    --border-soft: rgba(0, 0, 0, 0.07);\n    --border-input: rgba(0, 0, 0, 0.13);\n    --focus-ring: #6f96e6;\n    --row-border: rgba(0, 0, 0, 0.032);\n    --row-hover: rgba(0, 0, 0, 0.06);\n    --row-selected: rgba(0, 0, 0, 0.12);\n    --button-bg: rgba(255, 255, 255, 0.62);\n    --button-border: rgba(0, 0, 0, 0.10);\n    --button-text: #2c3e50;\n    --menu-bg: rgba(240, 241, 248, 0.90);\n    --menu-border: rgba(0, 0, 0, 0.06);\n    --menu-hover: rgba(255, 255, 255, 0.62);\n    --menu-text: #1a2a38;\n    --error-text: #b64545;\n    --warning-text: #8f6500;\n    --toast-bg: rgba(18, 22, 32, 0.90);\n    --toast-text: #ffffff;\n  }\n\n  @media (prefers-color-scheme: dark) {\n    :global(:root) {\n      --bg-app: transparent;\n      --text-primary: #e6e6ea;\n      --text-muted: #9494a4;\n      --bar-grad-top: rgba(38, 38, 46, 0.52);\n      --bar-grad-bottom: rgba(30, 30, 38, 0.46);\n      --surface-header: rgba(32, 32, 40, 0.46);\n      --surface: rgba(18, 18, 26, 0.32);\n      --border-soft: rgba(255, 255, 255, 0.065);\n      --border-input: rgba(255, 255, 255, 0.14);\n      --focus-ring: #5b8bd9;\n      --row-border: rgba(255, 255, 255, 0.026);\n      --row-hover: rgba(255, 255, 255, 0.08);\n      --row-selected: rgba(255, 255, 255, 0.14);\n      --button-bg: rgba(255, 255, 255, 0.072);\n      --button-border: rgba(255, 255, 255, 0.11);\n      --button-text: #d6d6e0;\n      --menu-bg: rgba(36, 36, 46, 0.90);\n      --menu-border: rgba(255, 255, 255, 0.066);\n      --menu-hover: rgba(255, 255, 255, 0.062);\n      --menu-text: #e0e0e8;\n      --error-text: #ff9d9d;\n      --warning-text: #e0c670;\n      --toast-bg: rgba(10, 10, 16, 0.93);\n      --toast-text: #f2f2f6;\n    }\n  }\n\n  /* ── Theme: Dark ──────────────────────────────────────────────── */\n  :global([data-theme=\"dark\"]) {\n    color-scheme: dark;\n    --bg-app: #1E1E21;\n    --text-primary: #E2E8F0;\n    --text-muted: #94A3B8;\n    --bar-grad-top: #1E1E21;\n    --bar-grad-bottom: #1E1E21;\n    --surface-header: #1E1E21;\n    --surface: #1E1E21;\n    --bg-input: #161618;\n    --border-soft: #2A2A2D;\n    --border-input: rgba(255, 255, 255, 0.06);\n    --focus-ring: #4DA8FF;\n    --accent: #4DA8FF;\n    --row-border: rgba(255, 255, 255, 0.02);\n    --row-hover: #282828;\n    --row-selected: rgba(77, 168, 255, 0.10);\n    --button-bg: rgba(255, 255, 255, 0.05);\n    --button-border: #2A2A2D;\n    --button-text: #94A3B8;\n    --menu-bg: #252528;\n    --menu-border: #2A2A2D;\n    --menu-hover: rgba(255, 255, 255, 0.04);\n    --menu-text: #E2E8F0;\n    --error-text: #ff9d9d;\n    --warning-text: #e0c670;\n    --toast-bg: rgba(10, 10, 16, 0.93);\n    --toast-text: #f2f2f6;\n  }\n\n  /* ── Theme: Light ─────────────────────────────────────────────── */\n  :global([data-theme=\"light\"]) {\n    color-scheme: light;\n    --bg-app: #F5F5F7;\n    --text-primary: #1C1C1E;\n    --text-muted: #6E6E7A;\n    --bar-grad-top: #F5F5F7;\n    --bar-grad-bottom: #F5F5F7;\n    --surface-header: #F5F5F7;\n    --surface: #F5F5F7;\n    --bg-input: #FFFFFF;\n    --border-soft: #D1D1D6;\n    --border-input: rgba(0, 0, 0, 0.10);\n    --focus-ring: #3A8BF5;\n    --accent: #3A8BF5;\n    --row-border: rgba(0, 0, 0, 0.04);\n    --row-hover: rgba(0, 0, 0, 0.04);\n    --row-selected: rgba(58, 139, 245, 0.10);\n    --button-bg: #FFFFFF;\n    --button-border: #D1D1D6;\n    --button-text: #3C3C43;\n    --menu-bg: #FFFFFF;\n    --menu-border: #D1D1D6;\n    --menu-hover: rgba(0, 0, 0, 0.05);\n    --menu-text: #1C1C1E;\n    --error-text: #D93025;\n    --warning-text: #B45309;\n    --toast-bg: rgba(255, 255, 255, 0.95);\n    --toast-text: #1C1C1E;\n  }\n\n  /* ── Themed element overrides ─────────────────────────────────── */\n  :global([data-theme]) {\n    background: var(--bg-app);\n  }\n\n  /* Search bar: flat, no gradient, no separator */\n  :global([data-theme]) .search-bar {\n    height: 44px;\n    padding: 0 16px;\n    background: var(--bg-app);\n    border-bottom: none;\n  }\n\n  :global([data-theme]) .search-input {\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n    font-family: 'JetBrains Mono', 'SF Mono', monospace;\n    font-size: 12px;\n    height: 34px;\n    border-radius: 8px;\n  }\n\n  /* Table header: flat bg, 16px edge padding */\n  :global([data-theme]) .table-header {\n    background: var(--bg-app);\n  }\n\n  :global([data-theme]) .col-button {\n    padding: 0 8px;\n  }\n\n  :global([data-theme]) .col.name .col-button {\n    padding-left: 16px;\n  }\n\n  /* Row cells: JetBrains Mono, 16px outer edges */\n  :global([data-theme]) .cell {\n    font-family: 'JetBrains Mono', monospace;\n  }\n\n  :global([data-theme]) .cell.name {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    padding-left: 16px;\n    font-size: 12px;\n    color: var(--text-primary);\n  }\n\n  :global([data-theme]) .cell.path {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.size {\n    font-size: 11px;\n  }\n\n  :global([data-theme]) .cell.modified {\n    padding-right: 16px;\n    font-size: 11px;\n    white-space: nowrap;\n  }\n\n  :global([data-theme]) .row.selected {\n    box-shadow: inset 3px 0 0 var(--accent);\n  }\n\n  /* Dim path/size/date cells in themed mode */\n  :global([data-theme]) .cell.path,\n  :global([data-theme]) .cell.size,\n  :global([data-theme]) .cell.modified {\n    color: var(--text-muted);\n  }\n\n  :global(:root) {\n    background: transparent;\n  }\n\n  :global(html, body) {\n    margin: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    background: transparent;\n    color: var(--text-primary);\n    font-family: Inter, 'SF Pro Text', 'Segoe UI', Helvetica, Arial, sans-serif;\n  }\n\n  :global(#app) {\n    width: 100%;\n    height: 100%;\n  }\n\n  .app-shell {\n    display: grid;\n    grid-template-rows: auto auto 1fr auto;\n    height: 100%;\n    min-width: 0;\n  }\n\n  .title-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 44px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    cursor: default;\n    flex-shrink: 0;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-left {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-center {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-right {\n    width: 72px;\n    pointer-events: none;\n    user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .title-icon {\n    width: 14px;\n    height: 14px;\n    fill: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .title-text {\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 13px;\n    font-weight: 500;\n    color: var(--text-primary);\n    letter-spacing: -0.01em;\n  }\n\n  .search-bar {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding: 8px;\n    background: linear-gradient(180deg, var(--bar-grad-top) 0%, var(--bar-grad-bottom) 100%);\n    border-bottom: 1px solid var(--border-soft);\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .search-input {\n    display: block;\n    box-sizing: border-box;\n    width: 100%;\n    min-width: 0;\n    flex: 1 1 auto;\n    height: 36px;\n    border: 1px solid var(--border-input);\n    border-radius: 14px;\n    padding: 0 10px;\n    font-size: 14px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    backdrop-filter: blur(12px) saturate(160%);\n    -webkit-backdrop-filter: blur(12px) saturate(160%);\n  }\n\n  .search-input::placeholder {\n    color: var(--text-muted);\n    opacity: 0.85;\n    font-size: 12px;\n  }\n\n  .search-input:focus {\n    outline: none;\n    border-color: var(--focus-ring);\n    box-shadow: 0 0 0 2px rgba(125, 169, 255, 0.25);\n  }\n\n  .table-area {\n    display: grid;\n    grid-template-rows: auto 1fr;\n    min-height: 0;\n    min-width: 0;\n  }\n\n  .table-header-track,\n  .row {\n    display: grid;\n    grid-template-columns: var(--col-name) var(--col-path) var(--col-size) var(--col-modified);\n    align-items: center;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .table-header {\n    height: 32px;\n    border-bottom: 1px solid var(--border-soft);\n    background: var(--surface-header);\n    user-select: none;\n    overflow: hidden;\n    flex-shrink: 0;\n  }\n\n  .table-header-track {\n    height: 100%;\n    transform: translateX(var(--header-offset, 0px));\n    will-change: transform;\n  }\n\n  .table-header .col {\n    position: relative;\n    min-width: 0;\n    height: 100%;\n  }\n\n  .col-button {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n    gap: 4px;\n    box-sizing: border-box;\n    padding: 0 8px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 11px;\n    font-weight: 600;\n    line-height: 1;\n    color: var(--text-muted);\n    text-align: left;\n    margin: 0;\n    border: none;\n    background: transparent;\n    cursor: pointer;\n  }\n\n  .sort-icon {\n    width: 10px;\n    height: 10px;\n    flex-shrink: 0;\n    color: var(--accent);\n  }\n\n  .col-resizer {\n    position: absolute;\n    top: 0;\n    right: -4px;\n    width: 8px;\n    height: 100%;\n    border: none;\n    padding: 0;\n    background: transparent;\n    cursor: col-resize;\n    z-index: 30;\n  }\n\n  .col-resizer::after {\n    content: '';\n    position: absolute;\n    top: 7px;\n    bottom: 7px;\n    left: 50%;\n    width: 1px;\n    transform: translateX(-50%);\n    background: var(--border-soft);\n    opacity: 0;\n    transition: opacity 0.15s ease;\n  }\n\n  .table-header .col:hover .col-resizer::after,\n  .col-resizer.active::after {\n    opacity: 1;\n  }\n\n  .table-body {\n    overflow: auto;\n    min-height: 0;\n    min-width: 0;\n    background: var(--surface);\n  }\n\n  .spacer {\n    position: relative;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .rows {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: max(var(--table-min-width, 0px), 100%);\n  }\n\n  .row {\n    height: 30px;\n    border-bottom: 1px solid var(--row-border);\n    cursor: default;\n    -webkit-user-select: none;\n    user-select: none;\n    outline: none;\n  }\n\n  .row:hover {\n    background: var(--row-hover);\n  }\n\n  .row.selected {\n    background: var(--row-selected);\n  }\n\n  .cell {\n    padding: 0 8px;\n    font-size: 12px;\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    min-width: 0;\n  }\n\n  .cell.size {\n    text-align: right;\n    font-variant-numeric: tabular-nums;\n  }\n\n  .ellipsis {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n\n  .hl {\n    background: none;\n    color: inherit;\n    font-weight: 700;\n  }\n\n  .file-icon {\n    width: 16px;\n    height: 16px;\n    flex: 0 0 auto;\n  }\n\n  .rename-input {\n    flex: 1;\n    min-width: 0;\n    height: 22px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 12px;\n    padding: 0 6px;\n    border: 1.5px solid var(--focus-ring);\n    border-radius: 4px;\n    background: var(--bg-input, var(--surface));\n    color: var(--text-primary);\n    outline: none;\n    box-shadow: 0 1px 6px rgba(0, 0, 0, 0.18), 0 0 0 3px rgba(77, 168, 255, 0.12);\n  }\n\n  .status-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 32px;\n    padding: 0 16px;\n    background: var(--surface-header);\n    border-top: 1px solid var(--border-soft);\n    font-family: 'JetBrains Mono', monospace;\n    font-size: 11px;\n    color: var(--text-muted);\n    white-space: nowrap;\n    overflow: hidden;\n    min-width: 0;\n    flex-shrink: 0;\n  }\n\n  .status-left {\n    display: flex;\n    align-items: center;\n    gap: 16px;\n    overflow: hidden;\n    min-width: 0;\n  }\n\n  .status-right {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    flex-shrink: 0;\n  }\n\n  .status-btn {\n    border: 1px solid var(--button-border);\n    border-radius: 5px;\n    background: var(--button-bg);\n    color: var(--button-text);\n    font-size: 11px;\n    height: 22px;\n    padding: 0 8px;\n    cursor: pointer;\n  }\n\n  .status-btn:hover {\n    filter: brightness(1.06);\n  }\n\n  .status-btn:disabled {\n    opacity: 0.55;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .status-state {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n  }\n\n  .state-dot {\n    width: 6px;\n    height: 6px;\n    border-radius: 50%;\n    flex-shrink: 0;\n  }\n\n  .state-dot.ready { background: #28C840; }\n  .state-dot.indexing { background: #FEBC2E; }\n  .state-dot.error { background: #FF5F57; }\n\n  .rebuild-btn {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    font-family: Inter, 'SF Pro Text', sans-serif;\n    font-size: 10px;\n    font-weight: 500;\n    background: var(--button-bg);\n    border: 1px solid var(--button-border);\n    border-radius: 4px;\n    color: var(--button-text);\n    height: 22px;\n    padding: 0 10px;\n    cursor: pointer;\n  }\n\n  .rebuild-btn:hover {\n    filter: brightness(1.1);\n  }\n\n  .rebuild-btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    filter: none;\n  }\n\n  .rebuild-icon {\n    width: 11px;\n    height: 11px;\n    color: var(--accent);\n    flex-shrink: 0;\n  }\n\n  .status-error {\n    color: var(--error-text);\n  }\n\n  .status-warning {\n    color: var(--warning-text);\n  }\n\n  .status-spotlight {\n    color: #f59e0b;\n    font-weight: 600;\n  }\n\n  .context-menu {\n    position: fixed;\n    z-index: 200;\n    width: 220px;\n    border: 1px solid var(--menu-border);\n    border-radius: 10px;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.16), inset 0 0 0 0.5px rgba(255, 255, 255, 0.18);\n    background: var(--menu-bg);\n    backdrop-filter: blur(28px) saturate(180%);\n    -webkit-backdrop-filter: blur(28px) saturate(180%);\n    overflow: hidden;\n  }\n\n  .context-menu button {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    padding: 8px 10px;\n    font-size: 12px;\n    color: var(--menu-text);\n  }\n\n  .context-menu button:hover {\n    background: var(--menu-hover);\n  }\n\n  .toast {\n    position: fixed;\n    right: 14px;\n    bottom: 18px;\n    background: var(--toast-bg);\n    color: var(--toast-text);\n    border-radius: 10px;\n    padding: 9px 12px;\n    font-size: 12px;\n    z-index: 250;\n    backdrop-filter: blur(20px) saturate(180%);\n    -webkit-backdrop-filter: blur(20px) saturate(180%);\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);\n  }\n</style>\n","structuredPatch":[{"oldStart":2085,"oldLines":19,"newStart":2085,"newLines":32,"lines":["     flex: 0 0 auto;","   }"," ","-  .rename-input {","-    flex: 1;","-    min-width: 0;","-    height: 22px;","+  .name-editing {","+    opacity: 0.25;","+  }","+","+  .rename-overlay {","+    position: fixed;","+    z-index: 100;","+    min-width: 120px;","+  }","+","+  .rename-textarea {","+    display: block;","+    width: 100%;","+    box-sizing: border-box;","     font-family: Inter, 'SF Pro Text', sans-serif;","     font-size: 12px;","-    padding: 0 6px;","+    line-height: 18px;","+    padding: 6px 4px;","     border: 1.5px solid var(--focus-ring);","     border-radius: 4px;","     background: var(--bg-input, var(--surface));","     color: var(--text-primary);","     outline: none;","-    box-shadow: 0 1px 6px rgba(0, 0, 0, 0.18), 0 0 0 3px rgba(77, 168, 255, 0.12);","+    resize: none;","+    overflow: hidden;","+    box-shadow: 0 2px 14px rgba(0, 0, 0, 0.22), 0 0 0 3px rgba(77, 168, 255, 0.13);","   }"," ","   .status-bar {"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"80a31df2-827d-44ae-92f7-e66860d72fa1"}
{"parentUuid":"316ca1ac-b882-41e1-bf6c-c113251d509a","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","message":{"model":"claude-sonnet-4-6","id":"msg_01Aqe8jW1py7b2bbCTrF4vbm","type":"message","role":"assistant","content":[{"type":"text","text":"동작을 확인합니다:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":635,"cache_read_input_tokens":82616,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":635},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMN9DrjasbPbLRf5qmTQ","type":"assistant","uuid":"38356c9f-b559-4961-bc20-90558515bc0f","timestamp":"2026-02-21T14:23:21.453Z"}
{"parentUuid":"38356c9f-b559-4961-bc20-90558515bc0f","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","message":{"model":"claude-sonnet-4-6","id":"msg_01Aqe8jW1py7b2bbCTrF4vbm","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Ce5NM154J71sZ9tQqSKamF","name":"Bash","input":{"command":"npm run lint 2>&1 | tail -20","description":"Lint check"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":635,"cache_read_input_tokens":82616,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":635},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYMN9DrjasbPbLRf5qmTQ","type":"assistant","uuid":"b4814465-5df1-4fa2-84e0-eab97be02b81","timestamp":"2026-02-21T14:23:22.169Z"}
{"type":"queue-operation","operation":"enqueue","timestamp":"2026-02-21T14:23:26.414Z","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","content":"{\"task_id\":\"bb9e181\",\"tool_use_id\":\"REDACTED\",\"description\":\"Lint check\",\"task_type\":\"local_bash\"}"}
{"parentUuid":"b4814465-5df1-4fa2-84e0-eab97be02b81","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":3,"totalLines":0,"totalBytes":0,"taskId":"bb9e181"},"toolUseID":"bash-progress-0","parentToolUseID":"toolu_01Ce5NM154J71sZ9tQqSKamF","uuid":"acd4321f-88be-4ec7-886c-6e23c445860d","timestamp":"2026-02-21T14:23:26.414Z"}
{"parentUuid":"acd4321f-88be-4ec7-886c-6e23c445860d","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":4,"totalLines":0,"totalBytes":0,"taskId":"bb9e181"},"toolUseID":"bash-progress-1","parentToolUseID":"toolu_01Ce5NM154J71sZ9tQqSKamF","uuid":"0150ae76-f79a-43c8-b0dc-1d017d818fd9","timestamp":"2026-02-21T14:23:27.413Z"}
{"parentUuid":"b4814465-5df1-4fa2-84e0-eab97be02b81","isSidechain":false,"userType":"external","cwd":"/Users/al02402336/everything","sessionId":"c8695c06-50ed-42a5-8e90-58458e0f8e77","version":"2.1.49","gitBranch":"main","slug":"eager-gliding-squirrel","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Ce5NM154J71sZ9tQqSKamF","type":"tool_result","content":"dist/assets/jetbrains-mono-latin-500-normal-BWZEU5yA.woff2      21.83 kB\ndist/assets/inter-latin-400-normal-C38fXH4l.woff2               23.66 kB\ndist/assets/inter-latin-500-normal-Cerq10X2.woff2               24.27 kB\ndist/assets/inter-latin-600-normal-LgqL8muc.woff2               24.45 kB\ndist/assets/jetbrains-mono-latin-400-normal-6-qcROiO.woff       27.50 kB\ndist/assets/jetbrains-mono-latin-500-normal-CJOVTJB7.woff       28.21 kB\ndist/assets/inter-latin-400-normal-CyCys3Eg.woff                30.70 kB\ndist/assets/inter-latin-600-normal-CiBQ2DWP.woff                31.26 kB\ndist/assets/inter-latin-500-normal-BL9OpVg8.woff                31.28 kB\ndist/assets/inter-latin-ext-400-normal-C1nco2VV.woff2           35.00 kB\ndist/assets/inter-latin-ext-500-normal-CV4jyFjo.woff2           36.02 kB\ndist/assets/inter-latin-ext-600-normal-D2bJ5OIk.woff2           36.26 kB\ndist/assets/inter-latin-ext-400-normal-77YHD8bZ.woff            47.56 kB\ndist/assets/inter-latin-ext-500-normal-BxGbmqWO.woff            48.49 kB\ndist/assets/inter-latin-ext-600-normal-CIVaiw4L.woff            48.67 kB\ndist/assets/index-BdMpkY5p.css                                  42.22 kB │ gzip: 17.72 kB\ndist/assets/index-Cr153GZc.js                                   58.27 kB │ gzip: 19.05 kB\n✓ built in 435ms\n   Compiling everything v0.2.0 (/Users/al02402336/everything/src-tauri)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 2.87s","is_error":false}]},"uuid":"babfc60c-a484-40c3-a453-f3d4ade2fee8","timestamp":"2026-02-21T14:23:27.965Z","toolUseResult":{"stdout":"dist/assets/jetbrains-mono-latin-500-normal-BWZEU5yA.woff2      21.83 kB\ndist/assets/inter-latin-400-normal-C38fXH4l.woff2               23.66 kB\ndist/assets/inter-latin-500-normal-Cerq10X2.woff2               24.27 kB\ndist/assets/inter-latin-600-normal-LgqL8muc.woff2               24.45 kB\ndist/assets/jetbrains-mono-latin-400-normal-6-qcROiO.woff       27.50 kB\ndist/assets/jetbrains-mono-latin-500-normal-CJOVTJB7.woff       28.21 kB\ndist/assets/inter-latin-400-normal-CyCys3Eg.woff                30.70 kB\ndist/assets/inter-latin-600-normal-CiBQ2DWP.woff                31.26 kB\ndist/assets/inter-latin-500-normal-BL9OpVg8.woff                31.28 kB\ndist/assets/inter-latin-ext-400-normal-C1nco2VV.woff2           35.00 kB\ndist/assets/inter-latin-ext-500-normal-CV4jyFjo.woff2           36.02 kB\ndist/assets/inter-latin-ext-600-normal-D2bJ5OIk.woff2           36.26 kB\ndist/assets/inter-latin-ext-400-normal-77YHD8bZ.woff            47.56 kB\ndist/assets/inter-latin-ext-500-normal-BxGbmqWO.woff            48.49 kB\ndist/assets/inter-latin-ext-600-normal-CIVaiw4L.woff            48.67 kB\ndist/assets/index-BdMpkY5p.css                                  42.22 kB │ gzip: 17.72 kB\ndist/assets/index-Cr153GZc.js                                   58.27 kB │ gzip: 19.05 kB\n✓ built in 435ms\n   Compiling everything v0.2.0 (/Users/al02402336/everything/src-tauri)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 2.87s","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"b4814465-5df1-4fa2-84e0-eab97be02b81"}
