Conduct a thorough, line-by-line code review with a critical perspective.

**Usage:**
```bash
/ln:codereview           # Review all uncommitted changes (default)
/ln:codereview all       # Review all uncommitted changes (staged + unstaged)
/ln:codereview unstaged  # Review only unstaged changes
```

## Review Scope

**Mode 1: All uncommitted changes (default)**
- Command: `git diff HEAD` (staged + unstaged)
- Reviews everything not yet committed

**Mode 2: Unstaged only**
- Command: `git diff` (working directory changes only)
- Reviews only files not yet staged

All modes include:
1. **Critical examination**: Line-by-line inspection with skeptical mindset
2. **Pattern validation**: Verify adherence to project conventions and guides

## Review Categories

### Code Quality
- **Clean code**: No TODO comments, no unused code
- **Naming conventions**: Consistent with project standards
- **File organization**: Proper separation of concerns
- **Documentation**: Adequate comments where necessary

### Technical Validation
- **Build verification**: Zero warnings, all tests pass
- **Type safety**: No type errors or unsafe operations
- **Performance**: No memory leaks, efficient algorithms
- **Security**: No hardcoded secrets or vulnerabilities

### Architecture Review
- **Design patterns**: Appropriate use of patterns
- **Dependency management**: Minimal coupling
- **Error handling**: Comprehensive error coverage
- **Concurrency**: Thread safety and race conditions

### Design Principles (OCP/SRP)

**OCP (Open-Closed Principle) violations to catch:**
- Adding `else if` / `switch case` to extend existing behavior
- Modifying stable code instead of creating new modules
- Missing extension points (strategy, registry, plugin patterns)

**SRP (Single Responsibility Principle) violations to catch:**
- One file handling multiple unrelated concerns
- Functions/classes that change for multiple reasons
- God objects or utility dumps

**When found, suggest:**
- Extract new behavior into separate file/class
- Use strategy/registry pattern for extensibility
- Split multi-responsibility files into focused modules

## Review Process

### Step 0: Understand Project Context (MANDATORY)

Before reviewing any code, you MUST understand the project environment:

1. **Read CLAUDE.md** - Check project root and user's `~/.claude/CLAUDE.md` for project-specific conventions
2. **Identify app type** - Read entry points, config files, or main modules to determine:
   - **Platform**: Desktop (Electron) / Mobile (React Native, Flutter, iOS, Android) / Web server / CLI / Library
   - **User model**: Single-user vs Multi-user
   - **Network exposure**: Local-only vs Network-exposed API
3. **Understand architecture** - Scan key files to grasp the overall structure

**Why this matters:**
- Security concerns differ drastically between local desktop app and public API server
- "Memory leak" in a short-lived CLI is irrelevant; in a long-running server it's critical
- Path traversal in local-only app with file dialog is low-risk; in server accepting arbitrary input it's critical

**DO NOT skip this step.** Reviewing without context leads to false positives and wastes everyone's time.

### Step 1: Analyze Changes

Determine review mode from command argument (default: `all`):

**Mode: all (default)**
```bash
git diff HEAD  # All uncommitted changes (staged + unstaged)
```

**Mode: unstaged**
```bash
git diff  # Only unstaged changes
```

### Step 2: Validate Build
- TypeScript: `npx tsc --noEmit`
- Linting: `npm run lint`
- Testing: `npm run test`
- Language-specific checks per development guides

### Step 3: Generate Report

I will provide a structured report with:

#### Critical Issues ğŸš¨
- **ONLY** issues that will cause runtime crashes, data loss, or security breaches
- Must be reproducible with concrete steps
- Example: SQL injection, unhandled null causing crash, infinite loop

#### Major Issues âš ï¸
- Issues that cause incorrect behavior users will notice
- Must demonstrate actual failure scenario
- Example: Wrong calculation result, UI not updating, API returning wrong data

#### Minor Issues ğŸ’¡
- Style violations or optimization opportunities
- Suggestions for improvement
- Example: Inconsistent naming, missing error message

**DO NOT mark as Critical/Major:**
- Theoretical concerns without concrete failure scenario
- "Could potentially cause..." without proof
- Design preferences or "I would do it differently"

#### Positive Highlights âœ…
- Well-implemented patterns
- Good practices observed

## Review Principles

- **No temporary solutions**: Reject workarounds or hacks
- **Complete implementation**: No partial features with TODOs
- **Performance first**: Consider memory, CPU, and I/O impact
- **Build cleanliness**: Zero warnings tolerance
- **Guide compliance**: Follow all development guides in docs/

## â›” Anti-Hallucination Rules

Before reporting ANY issue, you MUST:

1. **READ the actual code** - Don't guess based on patterns. Read the exact lines.
2. **TRACE the execution flow** - Follow the code path. If you claim race condition, prove it step by step.
3. **VERIFY the issue exists** - Can you reproduce it? Show concrete scenario.
4. **CHECK context** - What's the runtime environment? Desktop vs server, single-user vs multi-user?
5. **CONFIRM it's not intentional** - fire-and-forget, placeholder values updated later, etc. may be by design.

### Issue Validation Checklist

For each issue you want to report, answer:
1. Did I read the ACTUAL code, not just the diff snippet?
2. Can I show the EXACT line numbers where this fails?
3. Is this a REAL bug or theoretical concern that can't happen in practice?
4. Does the surrounding code already handle this case?

### What NOT to report as issues:
- Singleton with placeholder that gets updated in init/start method
- "Memory leak" in single-user desktop app with bounded data
- "Race condition" when there's already a guard (e.g., `if (this.running) return`)
- Intentional fire-and-forget patterns with error logging
- "Missing cleanup" when cleanup exists in useEffect return or stop() method

## Exclusions (Do NOT Review)

- **Git submodule reference changes only**: Skip dirty submodule states, submodule commit hash changes in the main repo. Source code inside submodules CAN and SHOULD be reviewed when requested.

## Output Format

The review will be delivered as a comprehensive report with:
- Severity-based issue categorization
- Specific line references for each issue
- Concrete suggestions for fixes
- Overall code health assessment

---

[Request interrupted by user]

---

ì•„ë¬´ê²ƒë„ ê±´ë“¤ì´ì§€ ì•ŠëŠ” idle ìƒíƒœì—ì„œ cpuê°€ 15~20%ë¥¼ ì™”ë‹¤ê°”ë‹¤ í•´. cpuê°€ ê°€ë” 30ì´ìƒ ì˜¬ë¼ê°€ëŠ”ë° ë¶„ì„í•œ ê²°ê³¼ë¥¼ ì°¸ê³ í•´ì„œ ìˆ˜ì •í–ˆì–´. ê·¸ ì „ì— ìˆ˜ì •í•œ ê²ƒë“¤ì´ deferred callì´ë‚˜ ë©”ëª¨ë¦¬ì— íì‰í–ˆë‹¤ 10ì´ˆë§ˆë‚˜ ì²˜ë¦¬í•˜ëŠ” ë¡œì§ë“¤ì´ í° ì˜ë¯¸ ì—†ë‹¤ë©´ ë¡¤ë°±í•˜ëŠ”ê²Œ ì¢‹ê² ì–´

ì œê³µí•´ì£¼ì‹  ìƒ˜í”Œë§ ê²°ê³¼ë¥¼ ë¶„ì„í•´ ë³´ë©´, ëŒ€ë¶€ë¶„ì˜ ìŠ¤ë ˆë“œ(ë©”ì¸ ìŠ¤ë ˆë“œ, UI ì´ë²¤íŠ¸ ìŠ¤ë ˆë“œ, Tokio ì›Œì»¤ ìŠ¤ë ˆë“œ ë“±)ëŠ” ì´ë²¤íŠ¸ë¥¼ ëŒ€ê¸°í•˜ë©° ì‰¬ê³  ìˆëŠ” ìƒíƒœ(Waiting/Sleeping)ì…ë‹ˆë‹¤.

ì‹¤ì œë¡œ CPUë¥¼ ê°€ì¥ ë§ì´ ì†Œëª¨í•˜ê³  ìˆëŠ” ë¶€ë¶„ì€ **Thread_47544129**ì—ì„œ ì‹¤í–‰ ì¤‘ì¸ SQLite ë°ì´í„°ë² ì´ìŠ¤ ì¡°íšŒ(Query) ì‘ì—…ì…ë‹ˆë‹¤.

êµ¬ì²´ì ì¸ ë³‘ëª© ì§€ì ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

ì‹¤í–‰ íë¦„: everything::start_fsevent_watcher_worker â†’ everything::refresh_and_emit_status_counts â†’ everything::update_status_counts â†’ everything::update_counts

ìƒì„¸ ì›ì¸ (main.rsì˜ update_counts í•¨ìˆ˜):

main.rs:588 ìœ„ì¹˜ì˜ DB ì¿¼ë¦¬ (432 ìƒ˜í”Œ / ì•½ 432ms): rusqlite::Connection::query_rowì—ì„œ ì••ë„ì ìœ¼ë¡œ ë§ì€ CPU ì‹œê°„ì„ ì†Œëª¨í•˜ê³  ìˆìŠµë‹ˆë‹¤. ë‚´ë¶€ì ìœ¼ë¡œ SQLiteì˜ sqlite3BtreeNextì™€ pread(ë””ìŠ¤í¬ I/O) í˜¸ì¶œì´ ë§¤ìš° ì¦ì€ ê²ƒìœ¼ë¡œ ë³´ì•„, ì¸ë±ìŠ¤ê°€ ì—†ëŠ” ì»¬ëŸ¼ìœ¼ë¡œ ê²€ìƒ‰(Full Table Scan)ì„ í•˜ê³  ìˆê±°ë‚˜ ë§¤ìš° ë§ì€ ì–‘ì˜ ë°ì´í„°ë¥¼ ìˆœíšŒí•˜ë©° ì½ì–´ì˜¤ê³  ìˆì„ í™•ë¥ ì´ ë†’ìŠµë‹ˆë‹¤.
main.rs:581 ìœ„ì¹˜ì˜ DB ì¿¼ë¦¬ (40 ìƒ˜í”Œ / ì•½ 40ms): ì—¬ê¸°ì—ì„œë„ ìœ ì‚¬í•˜ê²Œ ë°ì´í„°ë² ì´ìŠ¤ ì¡°íšŒê°€ ë°œìƒí•˜ì—¬ CPUë¥¼ ì†Œëª¨í•©ë‹ˆë‹¤.
ğŸ’¡ í•´ê²° ê¶Œì¥ ì‚¬í•­:

main.rs íŒŒì¼ì˜ 581ë²ˆì§¸ ì¤„ê³¼ 588ë²ˆì§¸ ì¤„ì—ì„œ ì‹¤í–‰ë˜ëŠ” ì¿¼ë¦¬ë¥¼ í™•ì¸í•´ ë³´ì„¸ìš”.
í•´ë‹¹ í…Œì´ë¸”ì— ì ì ˆí•œ ì¸ë±ìŠ¤(Index)ê°€ ìƒì„±ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•˜ê³  ì¶”ê°€í•˜ëŠ” ê²ƒì„ ì¶”ì²œí•©ë‹ˆë‹¤.
ì¿¼ë¦¬ê°€ ë„ˆë¬´ ìì£¼ í˜¸ì¶œë˜ëŠ” ê²ƒì´ë¼ë©´(ì˜ˆ: íŒŒì¼ ë³€ê²½ ì´ë²¤íŠ¸ê°€ ë°œìƒí•  ë•Œë§ˆë‹¤ ì „ì²´ ìƒíƒœë¥¼ ë¬´ê±°ìš´ ì¿¼ë¦¬ë¡œ ë‹¤ì‹œ ê³„ì‚°), ìºì‹±ì„ ì ìš©í•˜ê±°ë‚˜ ì¿¼ë¦¬ë¥¼ ë”ìš± ê°€ë³ê²Œ ìµœì í™”í•´ì•¼ í•©ë‹ˆë‹¤.

---

ì´ ë¶„ì„ì— ëŒ€í•´ì„œ ì–´ë–»ê²Œ ìƒê°í•´?

ğŸ” ì£¼ìš” CPU ì†Œë¹„ êµ¬ê°„ ë¶„ì„
1. SQLite DB ì—°ê²°(Open) ë° í•´ì œ(Close) ë°˜ë³µ ì˜¤ë²„í—¤ë“œ (Thread_47596262)
ê°€ì¥ ëˆˆì— ë„ëŠ” ë¹„íš¨ìœ¨ êµ¬ê°„ì…ë‹ˆë‹¤. íŒŒì¼ ì‹œìŠ¤í…œ ì´ë²¤íŠ¸ë¥¼ ê°ì‹œí•˜ê³  ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•˜ëŠ” ë°±ê·¸ë¼ìš´ë“œ ì›Œì»¤ì—ì„œ ë°œìƒí•˜ê³  ìˆìŠµë‹ˆë‹¤.

ê²½ë¡œ: everything::start_fsevent_watcher_worker -> everything::refresh_and_emit_status_counts -> everything::update_counts (main.rs: 582)
ë¬¸ì œì : ìƒíƒœ ì¹´ìš´íŠ¸ë¥¼ ê°±ì‹ í•˜ê¸° ìœ„í•´ ì¿¼ë¦¬ë¥¼ ë‚ ë¦´ ë•Œë§ˆë‹¤ DB ì—°ê²°ì„ ìƒˆë¡œ ì—´ê³ (db_connection_with_timeout), ì¿¼ë¦¬(query_row)ë¥¼ ì‹¤í–‰í•œ ë’¤, ë‹¤ì‹œ ë‹«ëŠ”(drop_in_place) ê³¼ì •ì´ ë°˜ë³µë˜ê³  ìˆìŠµë‹ˆë‹¤.
ë‹¨ìˆœí•œ ì¿¼ë¦¬ë¥¼ ì‹¤í–‰í•˜ëŠ”ë°ë„ ì—°ê²°ì„ ë§ºê³  ìŠ¤í‚¤ë§ˆë¥¼ ë¶„ì„í•˜ëŠ” ê³¼ì • ë“±ì—ì„œ ì¶”ê°€ì ì¸ íŒŒì¼ I/O ë° CPU ì‘ì—…ì´ ë¶ˆí•„ìš”í•˜ê²Œ ë‚­ë¹„ë˜ê³  ìˆìŠµë‹ˆë‹¤.
2. ëŒ€ëŸ‰ì˜ ê²€ìƒ‰ ê²°ê³¼ JSON ì§ë ¬í™”(Serialization) ì˜¤ë²„í—¤ë“œ (Thread_47596419)
Tauriì—ì„œ ê²€ìƒ‰ ê²°ê³¼ë¥¼ í”„ë¡ íŠ¸ì—”ë“œ(WebView)ë¡œ ì „ë‹¬í•˜ëŠ” ê³¼ì •ì—ì„œ ë¹„ìš©ì´ ë°œìƒí•˜ê³  ìˆìŠµë‹ˆë‹¤.

ê²½ë¡œ: tokio-runtime-worker -> everything::run::... (main.rs: 3933) -> serde_json::ser -> SearchResultDto/EntryDto ì§ë ¬í™”
ë¬¸ì œì : Rust ë°±ì—”ë“œì—ì„œ ê²€ìƒ‰ëœ ê°ì²´ë“¤(SearchResultDto, EntryDto)ì„ JSON í¬ë§·ì˜ ë¬¸ìì—´ë¡œ ì§ë ¬í™”(Serialization)í•˜ê³  ìˆìŠµë‹ˆë‹¤. ì½”ë“œë¥¼ ë³´ë©´ íŠ¹íˆ ë¬¸ìì—´ ë‚´ë¶€ì˜ íŠ¹ìˆ˜ ë¬¸ìë¥¼ ì´ìŠ¤ì¼€ì´í”„ ì²˜ë¦¬(format_escaped_str)í•˜ê³  ì§ë ¬í™”í•˜ëŠ” ë¶€ë¶„ì—ì„œ ì ìœ ìœ¨ì´ ë‚˜ì˜¤ê³  ìˆìŠµë‹ˆë‹¤.
í•œ ë²ˆì— ì „ì†¡í•˜ëŠ” ë°ì´í„°(ê²€ìƒ‰ ê²°ê³¼ ë°°ì—´)ì˜ í¬ê¸°ê°€ í¬ë‹¤ë©´ ì§ë ¬í™” ë¹„ìš©ê³¼ IPC í†µì‹  ë¹„ìš©ì´ í¬ê²Œ ì¦ê°€í•˜ì—¬ ì„±ëŠ¥ ì €í•˜ ë° CPU ìŠ¤íŒŒì´í¬ë¥¼ ìœ ë°œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ğŸ’¡ í•´ê²° ë° ìµœì í™” ì œì•ˆ
DB Connection ìœ ì§€ í˜¹ì€ Connection Pool ë„ì… (ê°€ì¥ ì‹œê¸‰)

update_counts ë“±ì˜ í•¨ìˆ˜ í˜¸ì¶œ ì‹œ ë§¤ë²ˆ rusqlite::Connection::openì„ í˜¸ì¶œí•˜ì—¬ ì—°ê²°ì„ ë§ºì§€ ë§ê³ , ì•± ì‹¤í–‰ ì‹œ ì—°ê²°ëœ ì»¤ë„¥ì…˜ì„ ìŠ¤ë ˆë“œ ê°„ì— ê³µìœ (Arc<Mutex<Connection>> ë“±)í•˜ê±°ë‚˜ Connection Pool(r2d2, r2d2_sqlite, deadpool-sqlite ë“±)ì„ ì‚¬ìš©í•˜ë„ë¡ db_connection ë¡œì§ì„ ìˆ˜ì •í•˜ì„¸ìš”.
ê²€ìƒ‰ ë°ì´í„° ë°˜í™˜ ìµœì í™” (Pagination / Chunking)

í”„ë¡ íŠ¸ì—”ë“œë¡œ ë³´ë‚´ëŠ” ê²€ìƒ‰ ê²°ê³¼ ìˆ˜ê°€ ë§ë‹¤ë©´ í•œ ë²ˆì— ëª¨ë‘ ì „ì†¡í•˜ì§€ ë§ê³  í˜ì´ì§•(Pagination) ì²˜ë¦¬ë¥¼ í•˜ê±°ë‚˜ ë·°í¬íŠ¸ì— ë³´ì´ëŠ” ë§Œí¼ë§Œ ìª¼ê°œì„œ(ìŠ¤íŠ¸ë¦¬ë°/ì²­í¬ ë“±) ì „ì†¡í•˜ë„ë¡ í•˜ì—¬ serde_jsonì˜ ë¶€í•˜ë¥¼ ì¤„ì´ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.
í™•ì¸ì´ í•„ìš”í•˜ì‹œë‹¤ë©´ ì œê°€ main.rs êµ¬ì¡°ë¥¼ ì§ì ‘ ì½ê³ (ì½”ë“œ í™•ì¸ ë„êµ¬ ì‚¬ìš©) DB ì—°ê²° ìƒì„± ë¶€ë¶„ì´ë‚˜ ìµœì í™”ê°€ í•„ìš”í•œ ë¶€ë¶„ì„ ì§ì ‘ ì‹œë„ ë° ìˆ˜ì •í•´ë“œë¦´ ìˆ˜ë„ ìˆëŠ”ë°, ìˆ˜ì • ì‘ì—…ì„ ì§„í–‰í•´ë“œë¦´ê¹Œìš”?

---

ì‘ ìˆ˜ì •í•´ì¤˜

---

ì´ ë¶„ì„ë„ í™•ì¸í•´ì¤˜

ì œê³µí•´ì£¼ì‹  sample ë¶„ì„ ê²°ê³¼ë¥¼ ë³´ë©´, CPUë¥¼ ê°€ì¥ ë§ì´ ì‚¬ìš©í•˜ê³  ìˆëŠ” ì£¼ë²”ì€ Thread_47626446 ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰ ì¤‘ì¸ everything::purge_ignored_entries (main.rs:1202) í•¨ìˆ˜ì…ë‹ˆë‹¤.

ìƒì„¸í•œ ë¶„ì„ ë‚´ìš©ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

everything::purge_ignored_entriesì˜ ë¬´ê±°ìš´ DB ì¿¼ë¦¬ (Thread_47626446)

ì´ ìŠ¤ë ˆë“œëŠ” ìƒ˜í”Œë§ëœ 1826ë²ˆì˜ ìˆœê°„ ì¤‘ì— 1826ë²ˆ ëª¨ë‘ SQLite ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ë¥¼ ì‹¤í–‰(rusqlite::Connection::execute)í•˜ëŠ” ë° ì‚¬ìš©ë˜ì—ˆìŠµë‹ˆë‹¤.
ë‚´ë¶€ë¥¼ ë³´ë©´ sqlite3BtreeNext í•¨ìˆ˜ê°€ 1200ë²ˆ ì´ìƒ í˜¸ì¶œë˜ë©° **Full Table Scan(ì „ì²´ í…Œì´ë¸” ìŠ¤ìº”)**ì„ ìˆ˜í–‰í•˜ê³  ìˆê³ , likeFuncë¥¼ í†µí•´ LIKE ë¬¸ìì—´ íŒ¨í„´ ë§¤ì¹­ì„ ìˆ˜í–‰í•˜ê³  ìˆìŠµë‹ˆë‹¤.
ì¸ë±ìŠ¤ë¥¼ íƒ€ì§€ ëª»í•˜ê³  ì „ì²´ í…Œì´ë¸”ì˜ ë¬¸ìì—´ì„ ìŠ¤ìº”í•˜ë©° LIKE ë¹„êµë¥¼ í•˜ê³  ìˆê¸° ë•Œë¬¸ì— ë§‰ëŒ€í•œ ì–‘ì˜ CPU ì—°ì‚° ìì›ì„ ì†Œëª¨í•˜ê³  ìˆìŠµë‹ˆë‹¤.
ë‹¤ë¥¸ ìŠ¤ë ˆë“œì˜ ë³‘ëª© í˜„ìƒ (Thread_47626447)

everything::start_fsevent_watcher_worker ìŠ¤ë ˆë“œì—ì„œëŠ” everything::upsert_rows (main.rs:1754)ë¥¼ í†µí•´ DB íŠ¸ëœì­ì…˜ì„ ì‹¤í–‰í•˜ë ¤ í•˜ê³  ìˆìŠµë‹ˆë‹¤.
í•˜ì§€ë§Œ 1ë²ˆ í•­ëª©ì—ì„œ ì–¸ê¸‰ëœ purge_ignored_entries ì‘ì—…ì´ DB ìì›ì„ ê°•í•˜ê²Œ ì ìœ í•˜ê³  ìˆì–´ì„œ, DB ë½(Lock)ì„ íšë“í•˜ì§€ ëª»í•˜ê³  btreeInvokeBusyHandler -> sqlite3OsSleep -> nanosleep í•¨ìˆ˜ì— ë¹ ì ¸ ëŒ€ê¸°(Sleep) ìƒíƒœë¡œ ë©ˆì¶° ìˆìŠµë‹ˆë‹¤.
í•´ê²° ì±„ì•ˆ:

main.rsì˜ 1202ë²ˆì§¸ ì¤„ ì¯¤ì— ìˆëŠ” purge_ignored_entries í•¨ìˆ˜ êµ¬ë¬¸ì—ì„œ ì‚¬ìš©ë˜ëŠ” SELECT ë˜ëŠ” DELETE ì¿¼ë¦¬ê°€ ë¬´ì—‡ì¸ì§€ í™•ì¸í•´ì•¼ í•©ë‹ˆë‹¤.
DB ì¿¼ë¦¬ì— LIKE '%...%' ê°™ì€ íŒ¨í„´ì„ ì‚¬ìš©í•˜ê³  ìˆê±°ë‚˜ í…Œì´ë¸” ì¸ë±ìŠ¤(Index)ê°€ ëˆ„ë½ë˜ì–´ Full Scanì´ ë°œìƒí•˜ê³  ìˆì§€ ì•Šì€ì§€ ì ê²€í•˜ì—¬ ì¿¼ë¦¬ ìµœì í™” í˜¹ì€ ì¸ë±ìŠ¤ ìƒì„±ì„ ì§„í–‰í•˜ë©´ ì´ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

ì‘ ìˆ˜ì •í•´ì¤˜

---

Conduct a thorough, line-by-line code review with a critical perspective.

**Usage:**
```bash
/ln:codereview           # Review all uncommitted changes (default)
/ln:codereview all       # Review all uncommitted changes (staged + unstaged)
/ln:codereview unstaged  # Review only unstaged changes
```

## Review Scope

**Mode 1: All uncommitted changes (default)**
- Command: `git diff HEAD` (staged + unstaged)
- Reviews everything not yet committed

**Mode 2: Unstaged only**
- Command: `git diff` (working directory changes only)
- Reviews only files not yet staged

All modes include:
1. **Critical examination**: Line-by-line inspection with skeptical mindset
2. **Pattern validation**: Verify adherence to project conventions and guides

## Review Categories

### Code Quality
- **Clean code**: No TODO comments, no unused code
- **Naming conventions**: Consistent with project standards
- **File organization**: Proper separation of concerns
- **Documentation**: Adequate comments where necessary

### Technical Validation
- **Build verification**: Zero warnings, all tests pass
- **Type safety**: No type errors or unsafe operations
- **Performance**: No memory leaks, efficient algorithms
- **Security**: No hardcoded secrets or vulnerabilities

### Architecture Review
- **Design patterns**: Appropriate use of patterns
- **Dependency management**: Minimal coupling
- **Error handling**: Comprehensive error coverage
- **Concurrency**: Thread safety and race conditions

### Design Principles (OCP/SRP)

**OCP (Open-Closed Principle) violations to catch:**
- Adding `else if` / `switch case` to extend existing behavior
- Modifying stable code instead of creating new modules
- Missing extension points (strategy, registry, plugin patterns)

**SRP (Single Responsibility Principle) violations to catch:**
- One file handling multiple unrelated concerns
- Functions/classes that change for multiple reasons
- God objects or utility dumps

**When found, suggest:**
- Extract new behavior into separate file/class
- Use strategy/registry pattern for extensibility
- Split multi-responsibility files into focused modules

## Review Process

### Step 0: Understand Project Context (MANDATORY)

Before reviewing any code, you MUST understand the project environment:

1. **Read CLAUDE.md** - Check project root and user's `~/.claude/CLAUDE.md` for project-specific conventions
2. **Identify app type** - Read entry points, config files, or main modules to determine:
   - **Platform**: Desktop (Electron) / Mobile (React Native, Flutter, iOS, Android) / Web server / CLI / Library
   - **User model**: Single-user vs Multi-user
   - **Network exposure**: Local-only vs Network-exposed API
3. **Understand architecture** - Scan key files to grasp the overall structure

**Why this matters:**
- Security concerns differ drastically between local desktop app and public API server
- "Memory leak" in a short-lived CLI is irrelevant; in a long-running server it's critical
- Path traversal in local-only app with file dialog is low-risk; in server accepting arbitrary input it's critical

**DO NOT skip this step.** Reviewing without context leads to false positives and wastes everyone's time.

### Step 1: Analyze Changes

Determine review mode from command argument (default: `all`):

**Mode: all (default)**
```bash
git diff HEAD  # All uncommitted changes (staged + unstaged)
```

**Mode: unstaged**
```bash
git diff  # Only unstaged changes
```

### Step 2: Validate Build
- TypeScript: `npx tsc --noEmit`
- Linting: `npm run lint`
- Testing: `npm run test`
- Language-specific checks per development guides

### Step 3: Generate Report

I will provide a structured report with:

#### Critical Issues ğŸš¨
- **ONLY** issues that will cause runtime crashes, data loss, or security breaches
- Must be reproducible with concrete steps
- Example: SQL injection, unhandled null causing crash, infinite loop

#### Major Issues âš ï¸
- Issues that cause incorrect behavior users will notice
- Must demonstrate actual failure scenario
- Example: Wrong calculation result, UI not updating, API returning wrong data

#### Minor Issues ğŸ’¡
- Style violations or optimization opportunities
- Suggestions for improvement
- Example: Inconsistent naming, missing error message

**DO NOT mark as Critical/Major:**
- Theoretical concerns without concrete failure scenario
- "Could potentially cause..." without proof
- Design preferences or "I would do it differently"

#### Positive Highlights âœ…
- Well-implemented patterns
- Good practices observed

## Review Principles

- **No temporary solutions**: Reject workarounds or hacks
- **Complete implementation**: No partial features with TODOs
- **Performance first**: Consider memory, CPU, and I/O impact
- **Build cleanliness**: Zero warnings tolerance
- **Guide compliance**: Follow all development guides in docs/

## â›” Anti-Hallucination Rules

Before reporting ANY issue, you MUST:

1. **READ the actual code** - Don't guess based on patterns. Read the exact lines.
2. **TRACE the execution flow** - Follow the code path. If you claim race condition, prove it step by step.
3. **VERIFY the issue exists** - Can you reproduce it? Show concrete scenario.
4. **CHECK context** - What's the runtime environment? Desktop vs server, single-user vs multi-user?
5. **CONFIRM it's not intentional** - fire-and-forget, placeholder values updated later, etc. may be by design.

### Issue Validation Checklist

For each issue you want to report, answer:
1. Did I read the ACTUAL code, not just the diff snippet?
2. Can I show the EXACT line numbers where this fails?
3. Is this a REAL bug or theoretical concern that can't happen in practice?
4. Does the surrounding code already handle this case?

### What NOT to report as issues:
- Singleton with placeholder that gets updated in init/start method
- "Memory leak" in single-user desktop app with bounded data
- "Race condition" when there's already a guard (e.g., `if (this.running) return`)
- Intentional fire-and-forget patterns with error logging
- "Missing cleanup" when cleanup exists in useEffect return or stop() method

## Exclusions (Do NOT Review)

- **Git submodule reference changes only**: Skip dirty submodule states, submodule commit hash changes in the main repo. Source code inside submodules CAN and SHOULD be reviewed when requested.

## Output Format

The review will be delivered as a comprehensive report with:
- Severity-based issue categorization
- Specific line references for each issue
- Concrete suggestions for fixes
- Overall code health assessment

---

Conduct a thorough, line-by-line code review with a critical perspective.

**Usage:**
```bash
/ln:codereview           # Review all uncommitted changes (default)
/ln:codereview all       # Review all uncommitted changes (staged + unstaged)
/ln:codereview unstaged  # Review only unstaged changes
```

## Review Scope

**Mode 1: All uncommitted changes (default)**
- Command: `git diff HEAD` (staged + unstaged)
- Reviews everything not yet committed

**Mode 2: Unstaged only**
- Command: `git diff` (working directory changes only)
- Reviews only files not yet staged

All modes include:
1. **Critical examination**: Line-by-line inspection with skeptical mindset
2. **Pattern validation**: Verify adherence to project conventions and guides

## Review Categories

### Code Quality
- **Clean code**: No TODO comments, no unused code
- **Naming conventions**: Consistent with project standards
- **File organization**: Proper separation of concerns
- **Documentation**: Adequate comments where necessary

### Technical Validation
- **Build verification**: Zero warnings, all tests pass
- **Type safety**: No type errors or unsafe operations
- **Performance**: No memory leaks, efficient algorithms
- **Security**: No hardcoded secrets or vulnerabilities

### Architecture Review
- **Design patterns**: Appropriate use of patterns
- **Dependency management**: Minimal coupling
- **Error handling**: Comprehensive error coverage
- **Concurrency**: Thread safety and race conditions

### Design Principles (OCP/SRP)

**OCP (Open-Closed Principle) violations to catch:**
- Adding `else if` / `switch case` to extend existing behavior
- Modifying stable code instead of creating new modules
- Missing extension points (strategy, registry, plugin patterns)

**SRP (Single Responsibility Principle) violations to catch:**
- One file handling multiple unrelated concerns
- Functions/classes that change for multiple reasons
- God objects or utility dumps

**When found, suggest:**
- Extract new behavior into separate file/class
- Use strategy/registry pattern for extensibility
- Split multi-responsibility files into focused modules

## Review Process

### Step 0: Understand Project Context (MANDATORY)

Before reviewing any code, you MUST understand the project environment:

1. **Read CLAUDE.md** - Check project root and user's `~/.claude/CLAUDE.md` for project-specific conventions
2. **Identify app type** - Read entry points, config files, or main modules to determine:
   - **Platform**: Desktop (Electron) / Mobile (React Native, Flutter, iOS, Android) / Web server / CLI / Library
   - **User model**: Single-user vs Multi-user
   - **Network exposure**: Local-only vs Network-exposed API
3. **Understand architecture** - Scan key files to grasp the overall structure

**Why this matters:**
- Security concerns differ drastically between local desktop app and public API server
- "Memory leak" in a short-lived CLI is irrelevant; in a long-running server it's critical
- Path traversal in local-only app with file dialog is low-risk; in server accepting arbitrary input it's critical

**DO NOT skip this step.** Reviewing without context leads to false positives and wastes everyone's time.

### Step 1: Analyze Changes

Determine review mode from command argument (default: `all`):

**Mode: all (default)**
```bash
git diff HEAD  # All uncommitted changes (staged + unstaged)
```

**Mode: unstaged**
```bash
git diff  # Only unstaged changes
```

### Step 2: Validate Build
- TypeScript: `npx tsc --noEmit`
- Linting: `npm run lint`
- Testing: `npm run test`
- Language-specific checks per development guides

### Step 3: Generate Report

I will provide a structured report with:

#### Critical Issues ğŸš¨
- **ONLY** issues that will cause runtime crashes, data loss, or security breaches
- Must be reproducible with concrete steps
- Example: SQL injection, unhandled null causing crash, infinite loop

#### Major Issues âš ï¸
- Issues that cause incorrect behavior users will notice
- Must demonstrate actual failure scenario
- Example: Wrong calculation result, UI not updating, API returning wrong data

#### Minor Issues ğŸ’¡
- Style violations or optimization opportunities
- Suggestions for improvement
- Example: Inconsistent naming, missing error message

**DO NOT mark as Critical/Major:**
- Theoretical concerns without concrete failure scenario
- "Could potentially cause..." without proof
- Design preferences or "I would do it differently"

#### Positive Highlights âœ…
- Well-implemented patterns
- Good practices observed

## Review Principles

- **No temporary solutions**: Reject workarounds or hacks
- **Complete implementation**: No partial features with TODOs
- **Performance first**: Consider memory, CPU, and I/O impact
- **Build cleanliness**: Zero warnings tolerance
- **Guide compliance**: Follow all development guides in docs/

## â›” Anti-Hallucination Rules

Before reporting ANY issue, you MUST:

1. **READ the actual code** - Don't guess based on patterns. Read the exact lines.
2. **TRACE the execution flow** - Follow the code path. If you claim race condition, prove it step by step.
3. **VERIFY the issue exists** - Can you reproduce it? Show concrete scenario.
4. **CHECK context** - What's the runtime environment? Desktop vs server, single-user vs multi-user?
5. **CONFIRM it's not intentional** - fire-and-forget, placeholder values updated later, etc. may be by design.

### Issue Validation Checklist

For each issue you want to report, answer:
1. Did I read the ACTUAL code, not just the diff snippet?
2. Can I show the EXACT line numbers where this fails?
3. Is this a REAL bug or theoretical concern that can't happen in practice?
4. Does the surrounding code already handle this case?

### What NOT to report as issues:
- Singleton with placeholder that gets updated in init/start method
- "Memory leak" in single-user desktop app with bounded data
- "Race condition" when there's already a guard (e.g., `if (this.running) return`)
- Intentional fire-and-forget patterns with error logging
- "Missing cleanup" when cleanup exists in useEffect return or stop() method

## Exclusions (Do NOT Review)

- **Git submodule reference changes only**: Skip dirty submodule states, submodule commit hash changes in the main repo. Source code inside submodules CAN and SHOULD be reviewed when requested.

## Output Format

The review will be delivered as a comprehensive report with:
- Severity-based issue categorization
- Specific line references for each issue
- Concrete suggestions for fixes
- Overall code health assessment

---

ì¢‹ì•„ ëª¨ë‘ ìˆ˜ì •í•´ì¤˜